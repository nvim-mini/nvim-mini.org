<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>mini.doc documentation – MINI</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../..//assets/logo-mini_180x180.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-0ed1a58f1961f20e100ea025a42ebf64.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-fdc1b2fd0a2d1e1fd2f41bfe1f0ec5c1.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-eae15776b4993c730e8acf4e0a84d3b5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-4919b8c1fb8c9d7fd240973183da8612.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": "tree",
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<style> .quarto-title > h1.title { display: none } </style>


<meta property="og:title" content="mini.doc documentation – MINI">
<meta property="og:description" content="Modular Independent Neovim Improvements">
<meta property="og:image" content="https://nvim-mini.org/assets/logo-mini_social.png">
<meta property="og:site_name" content="MINI">
<meta property="og:image:height" content="630">
<meta property="og:image:width" content="1200">
<meta name="twitter:title" content="mini.doc documentation – MINI">
<meta name="twitter:description" content="Modular Independent Neovim Improvements">
<meta name="twitter:image" content="https://nvim-mini.org/assets/logo-mini_social.png">
<meta name="twitter:image-height" content="630">
<meta name="twitter:image-width" content="1200">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-dark"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = true;
    const queryPrefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    const darkModeDefault = queryPrefersDark.matches;
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    queryPrefersDark.addEventListener("change", e => {
      if(window.localStorage.getItem("quarto-color-scheme") !== null)
        return;
      const alternate = e.matches
      toggleColorMode(alternate);
      localAlternateSentinel = e.matches ? 'alternate' : 'default'; // this is used alongside local storage!
      toggleGiscusIfUsed(alternate, darkModeDefault);
    });
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">MINI</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../mini.nvim/index.html"> 
<span class="menu-text">mini.nvim</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../MiniMax/index.html"> 
<span class="menu-text">MiniMax</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/nvim-mini"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../blog/index.xml"> <i class="bi bi-rss-fill" role="img" aria-label="RSS">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#module" id="toc-module" class="nav-link active" data-scroll-target="#module">Module</a>
  <ul>
  <li><a href="#module-setup" id="toc-module-setup" class="nav-link" data-scroll-target="#module-setup">Setup</a></li>
  <li><a href="#module-tips" id="toc-module-tips" class="nav-link" data-scroll-target="#module-tips">Tips</a></li>
  <li><a href="#module-comparisons" id="toc-module-comparisons" class="nav-link" data-scroll-target="#module-comparisons">Comparisons</a></li>
  </ul></li>
  <li><a href="#minidoc-data-structures" id="toc-minidoc-data-structures" class="nav-link" data-scroll-target="#minidoc-data-structures">Data structures</a></li>
  <li><a href="#minidoc.setup" id="toc-minidoc.setup" class="nav-link" data-scroll-target="#minidoc.setup">setup()</a>
  <ul>
  <li><a href="#minidoc.setup-parameters" id="toc-minidoc.setup-parameters" class="nav-link" data-scroll-target="#minidoc.setup-parameters">Parameters</a></li>
  <li><a href="#minidoc.setup-usage" id="toc-minidoc.setup-usage" class="nav-link" data-scroll-target="#minidoc.setup-usage">Usage</a></li>
  </ul></li>
  <li><a href="#minidoc.config" id="toc-minidoc.config" class="nav-link" data-scroll-target="#minidoc.config">config</a>
  <ul>
  <li><a href="#minidoc.config-defaults" id="toc-minidoc.config-defaults" class="nav-link" data-scroll-target="#minidoc.config-defaults">Defaults</a></li>
  <li><a href="#minidoc.config-notes" id="toc-minidoc.config-notes" class="nav-link" data-scroll-target="#minidoc.config-notes">Notes</a></li>
  </ul></li>
  <li><a href="#minidoc.current" id="toc-minidoc.current" class="nav-link" data-scroll-target="#minidoc.current">current</a></li>
  <li><a href="#minidoc.default_hooks" id="toc-minidoc.default_hooks" class="nav-link" data-scroll-target="#minidoc.default_hooks">default_hooks</a></li>
  <li><a href="#minidoc.generate" id="toc-minidoc.generate" class="nav-link" data-scroll-target="#minidoc.generate">generate()</a>
  <ul>
  <li><a href="#minidoc.generate-algorithm" id="toc-minidoc.generate-algorithm" class="nav-link" data-scroll-target="#minidoc.generate-algorithm">Algorithm</a></li>
  <li><a href="#minidoc.generate-projectspecificscript" id="toc-minidoc.generate-projectspecificscript" class="nav-link" data-scroll-target="#minidoc.generate-projectspecificscript">Project specific script</a></li>
  <li><a href="#minidoc.generate-parameters" id="toc-minidoc.generate-parameters" class="nav-link" data-scroll-target="#minidoc.generate-parameters">Parameters</a></li>
  <li><a href="#minidoc.generate-return" id="toc-minidoc.generate-return" class="nav-link" data-scroll-target="#minidoc.generate-return">Return</a></li>
  </ul></li>
  <li><a href="#minidoc.afterlines_to_code" id="toc-minidoc.afterlines_to_code" class="nav-link" data-scroll-target="#minidoc.afterlines_to_code">afterlines_to_code()</a>
  <ul>
  <li><a href="#minidoc.afterlines_to_code-directives" id="toc-minidoc.afterlines_to_code-directives" class="nav-link" data-scroll-target="#minidoc.afterlines_to_code-directives">Directives</a></li>
  <li><a href="#minidoc.afterlines_to_code-parameters" id="toc-minidoc.afterlines_to_code-parameters" class="nav-link" data-scroll-target="#minidoc.afterlines_to_code-parameters">Parameters</a></li>
  <li><a href="#minidoc.afterlines_to_code-return" id="toc-minidoc.afterlines_to_code-return" class="nav-link" data-scroll-target="#minidoc.afterlines_to_code-return">Return</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">mini.doc documentation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>Generated from the <code>main</code> branch of ‘mini.nvim’</em></p>
<p><a name="mini.doc" href="../../mini.nvim/doc/mini-doc.html#mini.doc"><b>mini.doc</b></a> Generate Neovim help files</p>
<p>MIT License Copyright (c) 2022 Evgeni Chasnovski</p>
<hr>
<section id="module" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="module">Module</h3>
<p>Key design ideas:</p>
<ul>
<li><p>Keep documentation next to code by writing EmmyLua-like annotation comments. They will be parsed as is, so formatting should follow built-in guide in <a href="https://neovim.io/doc/user/helptag.html?tag=help-writing">help-writing</a>. However, custom hooks are allowed at many generation stages for more granular management of output help file.</p></li>
<li><p>Generation is done by processing a set of ordered files line by line. Each line can either be considered as a part of documentation block (if it matches certain configurable pattern) or not (considered to be an “afterline” of documentation block). See <a href="../../mini.nvim/doc/mini-doc.html#minidoc.generate">MiniDoc.generate()</a> for more details.</p></li>
<li><p>Processing is done by using nested data structures (section, block, file, doc) describing certain parts of help file. See <a href="../../mini.nvim/doc/mini-doc.html#minidoc-data-structures">MiniDoc-data-structures</a> for more details.</p></li>
<li><p>Project specific script can be written as plain Lua file with configuratble path. See <a href="../../mini.nvim/doc/mini-doc.html#minidoc.generate">MiniDoc.generate()</a> for more details.</p></li>
</ul>
<p>What it doesn’t do:</p>
<ul>
<li><p>It doesn’t support markdown or other markup language inside annotations.</p></li>
<li><p>It doesn’t use treesitter in favor of Lua string manipulation for basic tasks (parsing annotations, formatting, auto-generating tags, etc.). This is done to manage complexity and be dependency free.</p></li>
</ul>
<section id="module-setup" class="level4">
<h4 class="anchored" data-anchor-id="module-setup">Setup</h4>
<p>This module needs a setup with <code>require('mini.doc').setup({})</code> (replace <code>{}</code> with your <code>config</code> table). It will create global Lua table <code>MiniDoc</code> which you can use for scripting or manually (with <code>:lua MiniDoc.*</code>).</p>
<p>See <a href="../../mini.nvim/doc/mini-doc.html#minidoc.config">MiniDoc.config</a> for available config settings.</p>
<p>You can override runtime config settings locally to buffer inside <code>vim.b.minidoc_config</code> which should have same structure as <code>MiniDoc.config</code>. See <a href="../../mini.nvim/doc/mini-nvim.html#mini.nvim-buffer-local-config">mini.nvim-buffer-local-config</a> for more details.</p>
<p>To stop module from showing non-error feedback, set <code>config.silent = true</code>.</p>
</section>
<section id="module-tips" class="level4">
<h4 class="anchored" data-anchor-id="module-tips">Tips</h4>
<ul>
<li><p>Some settings tips that might make writing annotation comments easier:</p>
<ul>
<li><p>Set up appropriate ‘comments’ for <code>lua</code> file type to respect EmmyLua-like’s <code>---</code> comment leader. Value <code>:---,:--</code> seems to work.</p></li>
<li><p>Set up appropriate ‘formatoptions’ (see also <a href="https://neovim.io/doc/user/helptag.html?tag=fo-table">fo-table</a>). Consider adding <code>j</code>, <code>n</code>, <code>q</code>, and <code>r</code> flags.</p></li>
<li><p>Set up appropriate ‘formatlistpat’ to help auto-formatting lists (if <code>n</code> flag is added to ‘formatoptions’). One suggestion (not entirely ideal) is a value <code>^\s*[0-9\-\+\*]\+[\.\)]*\s\+</code>. This reads as ‘at least one special character (digit, <code>-</code>, <code>+</code>, <code>*</code>) possibly followed by some punctuation (<code>.</code> or <code>)</code>) followed by at least one space is a start of list item’.</p></li>
</ul></li>
<li><p>Probably one of the most reliable resources for what is considered to be best practice when using this module is this whole plugin. Look at source code for the reference.</p></li>
</ul>
</section>
<section id="module-comparisons" class="level4">
<h4 class="anchored" data-anchor-id="module-comparisons">Comparisons</h4>
<ul>
<li><p><a href="https://github.com/tjdevries/tree-sitter-lua">tjdevries/tree-sitter-lua</a>:</p>
<ul>
<li><p>Its key design is to use treesitter grammar to parse both Lua code and annotation comments. This makes it not easy to install, customize, and support.</p></li>
<li><p>It takes more care about automating output formatting (like auto indentation and line width fit). This plugin leans more to manual formatting with option to supply customized post-processing hooks.</p></li>
</ul></li>
</ul>
<hr>
</section>
</section>
<section id="minidoc-data-structures" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc-data-structures">Data structures</h3>
<p>Data structures</p>
<p>Data structures are basically arrays of other structures accompanied with some fields (keys with data values) and methods (keys with function values):</p>
<ul>
<li><p><code>Section structure</code> is an array of string lines describing one aspect (determined by section id like ‘<span class="citation" data-cites="param">@param</span>’, ‘<span class="citation" data-cites="return">@return</span>’, ‘<span class="citation" data-cites="text">@text</span>’) of an annotation subject. All lines will be used directly in help file.</p></li>
<li><p><code>Block structure</code> is an array of sections describing one annotation subject like function, table, concept.</p></li>
<li><p><code>File structure</code> is an array of blocks describing certain file on disk. Basically, file is split into consecutive blocks: annotation lines go inside block, non-annotation - inside <code>block_afterlines</code> element of info.</p></li>
<li><p><code>Doc structure</code> is an array of files describing a final help file. Each string line from section (when traversed in depth-first fashion) goes directly into output file.</p></li>
</ul>
<p>All structures have these keys:</p>
<ul>
<li><p>Fields:</p>
<ul>
<li><p><code>info</code> - contains additional information about current structure. For more details see next section.</p></li>
<li><p><code>parent</code> - table of parent structure (if exists).</p></li>
<li><p><code>parent_index</code> - index of this structure in its parent’s array. Useful for adding to parent another structure near current one.</p></li>
<li><p><code>type</code> - string with structure type (section, block, file, doc).</p></li>
</ul></li>
<li><p>Methods (use them as <code>x:method(args)</code>):</p>
<ul>
<li><p><code>insert(self, [index,] child)</code> - insert <code>child</code> to <code>self</code> at position <code>index</code> (optional; if not supplied, child will be appended to end). Basically, a <code>table.insert()</code>, but adds <code>parent</code> and <code>parent_index</code> fields to <code>child</code> while properly updating <code>self</code>.</p></li>
<li><p><code>remove(self [,index])</code> - remove from <code>self</code> element at position <code>index</code>. Basically, a <code>table.remove()</code>, but properly updates <code>self</code>.</p></li>
<li><p><code>has_descendant(self, predicate)</code> - whether there is a descendant (structure or string) for which <code>predicate</code> returns <code>true</code>. In case of success also returns the first such descendant as second value.</p></li>
<li><p><code>has_lines(self)</code> - whether structure has any lines (even empty ones) to be put in output file. For section structures this is equivalent to <code>#self</code>, but more useful for higher order structures.</p></li>
<li><p><code>clear_lines(self)</code> - remove all lines from structure. As a result, this structure won’t contribute to output help file.</p></li>
</ul></li>
</ul>
<p>Description of <code>info</code> fields per structure type:</p>
<ul>
<li><p><code>Section</code>:</p>
<ul>
<li><p><code>id</code> - captured section identifier. Can be empty string meaning no identifier is captured.</p></li>
<li><p><code>line_begin</code> - line number inside file at which section begins (-1 if not generated from file).</p></li>
<li><p><code>line_end</code> - line number inside file at which section ends (-1 if not generated from file).</p></li>
</ul></li>
<li><p><code>Block</code>:</p>
<ul>
<li><p><code>afterlines</code> - array of strings which were parsed from file after this annotation block (up until the next block or end of file). Useful for making automated decisions about what is being documented.</p></li>
<li><p><code>line_begin</code> - line number inside file at which block begins (-1 if not generated from file).</p></li>
<li><p><code>line_end</code> - line number inside file at which block ends (-1 if not generated from file).</p></li>
</ul></li>
<li><p><code>File</code>:</p>
<ul>
<li><code>path</code> - absolute path to a file (<code>''</code> if not generated from file).</li>
</ul></li>
<li><p><code>Doc</code>:</p>
<ul>
<li><p><code>input</code> - array of input file paths (as in <a href="../../mini.nvim/doc/mini-doc.html#minidoc.generate">MiniDoc.generate()</a>).</p></li>
<li><p><code>output</code> - output path (as in <a href="../../mini.nvim/doc/mini-doc.html#minidoc.generate">MiniDoc.generate()</a>).</p></li>
<li><p><code>config</code> - configuration used (as in <a href="../../mini.nvim/doc/mini-doc.html#minidoc.generate">MiniDoc.generate()</a>).</p></li>
</ul></li>
</ul>
<hr>
</section>
<section id="minidoc.setup" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc.setup">setup()</h3>
<p align="center">
<code>MiniDoc.setup</code>(<span class="help-syntax-special">{config}</span>)
</p>
<p>Module setup</p>
<section id="minidoc.setup-parameters" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.setup-parameters">Parameters</h4>
<p><span class="help-syntax-special">{config}</span> <code>(table|nil)</code> Module config table. See <a href="../../mini.nvim/doc/mini-doc.html#minidoc.config">MiniDoc.config</a>.</p>
</section>
<section id="minidoc.setup-usage" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.setup-usage">Usage</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb1"><pre class="sourceCode lua code-with-copy"><code class="sourceCode lua"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span><span class="op">(</span><span class="st">'mini.doc'</span><span class="op">).</span>setup<span class="op">()</span> <span class="co">-- use default config</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- OR</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span><span class="op">(</span><span class="st">'mini.doc'</span><span class="op">).</span>setup<span class="op">({})</span> <span class="co">-- replace {} with your config table</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<hr>
</section>
</section>
<section id="minidoc.config" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc.config">config</h3>
<p align="center">
<code>MiniDoc.config</code>
</p>
<section id="minidoc.config-defaults" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.config-defaults">Defaults</h4>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb2"><pre class="sourceCode lua code-with-copy"><code class="sourceCode lua"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="va">MiniDoc</span><span class="op">.</span><span class="va">config</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Function which extracts part of line used to denote annotation.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- For more information see 'Notes' in |MiniDoc.config|.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">annotation_extractor</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">l</span><span class="op">)</span> <span class="cf">return</span> <span class="fu">string.find</span><span class="op">(</span><span class="va">l</span><span class="op">,</span> <span class="st">'^%-%-%-(%S*) ?'</span><span class="op">)</span> <span class="kw">end</span><span class="op">,</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Identifier of block annotation lines until first captured identifier</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="va">default_section_id</span> <span class="op">=</span> <span class="st">'@text'</span><span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Hooks to be applied at certain stage of document life cycle. Should</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- modify its input in place (and not return new one).</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="va">hooks</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied to block before anything else</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="va">block_pre</span> <span class="op">=</span> <span class="co">--&lt;function: infers header sections (tag and/or signature)&gt;,</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied to section before anything else</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="va">section_pre</span> <span class="op">=</span> <span class="co">--&lt;function: replaces current aliases&gt;,</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied if section has specified captured id</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="va">sections</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@alias'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: registers alias in MiniDoc.current.aliases&gt;,</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@class'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@diagnostic'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: ignores any section content&gt;,</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- For most typical usage see |MiniDoc.afterlines_to_code|</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@eval'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: evaluates lines; replaces with their return&gt;,</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@field'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@overload'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@param'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@private'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: registers block for removal&gt;,</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@return'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@seealso'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@signature'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: formats signature of documented object&gt;,</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@tag'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: turns its line in proper tag lines&gt;,</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@text'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: purposefully does nothing&gt;,</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@toc'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: clears all section lines&gt;,</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@toc_entry'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function: registers lines for table of contents&gt;,</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@type'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>      <span class="op">[</span><span class="st">'@usage'</span><span class="op">]</span> <span class="op">=</span> <span class="co">--&lt;function&gt;,</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">},</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied to section after all previous steps</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    <span class="va">section_post</span> <span class="op">=</span> <span class="co">--&lt;function: currently does nothing&gt;,</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied to block after all previous steps</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="va">block_post</span> <span class="op">=</span> <span class="co">--&lt;function: does many things&gt;,</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied to file after all previous steps</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>    <span class="va">file</span> <span class="op">=</span> <span class="co">--&lt;function: adds separator&gt;,</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied to doc after all previous steps</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="va">doc</span> <span class="op">=</span> <span class="co">--&lt;function: adds modeline&gt;,</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied before output file is written. Takes lines array as argument.</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>    <span class="va">write_pre</span> <span class="op">=</span> <span class="co">--&lt;function: currently returns its input&gt;,</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Applied after output help file is written. Takes doc as argument.</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="va">write_post</span> <span class="op">=</span> <span class="co">--&lt;function: various convenience actions&gt;,</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>  <span class="op">},</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Path (relative to current directory) to script which handles project</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- specific help file generation (like custom input files, hooks, etc.).</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>  <span class="va">script_path</span> <span class="op">=</span> <span class="st">'scripts/minidoc.lua'</span><span class="op">,</span></span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Whether to disable showing non-error feedback</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>  <span class="va">silent</span> <span class="op">=</span> <span class="kw">false</span><span class="op">,</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
</section>
<section id="minidoc.config-notes" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.config-notes">Notes</h4>
<ul>
<li><p><code>annotation_extractor</code> takes single string line as input. Output describes what makes an input to be an annotation (if anything). It should be similar to <code>string.find</code> with one capture group: start and end of annotation indicator (whole part will be removed from help line) with third value being string of section id (if input describes first line of section; <code>nil</code> or empty string otherwise). Output should be <code>nil</code> if line is not part of annotation. Default value means that annotation line should:</p>
<ul>
<li><p>Start with <code>---</code> at first column.</p></li>
<li><p>Any non-whitespace after <code>---</code> will be treated as new section id.</p></li>
<li><p>Single whitespace at the start of main text will be ignored.</p></li>
</ul></li>
<li><p>Hooks are expected to be functions. Their default values might do many things which might change over time, so for more information please look at source code. Some more information can be found in <a href="../../mini.nvim/doc/mini-doc.html#minidoc.default_hooks">MiniDoc.default_hooks</a>.</p></li>
</ul>
<hr>
</section>
</section>
<section id="minidoc.current" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc.current">current</h3>
<p align="center">
<code>MiniDoc.current</code>
</p>
<p>Table with information about current state of auto-generation</p>
<p>It is reset at the beginning and end of <code>MiniDoc.generate()</code>.</p>
<p>At least these keys are supported:</p>
<ul>
<li><p><span class="help-syntax-special">{aliases}</span> - table with keys being alias name and values - alias description and single string (using <code>\n</code> to separate lines).</p></li>
<li><p><span class="help-syntax-special">{eval_section}</span> - input section of <code>@eval</code> section hook. Can be used for information about current block, etc.</p></li>
<li><p><span class="help-syntax-special">{toc}</span> - array with table of contents entries. Each entry is a whole <code>@toc_entry</code> section.</p></li>
</ul>
<hr>
</section>
<section id="minidoc.default_hooks" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc.default_hooks">default_hooks</h3>
<p align="center">
<code>MiniDoc.default_hooks</code>
</p>
<p>Default hooks</p>
<p>This is default value of <code>MiniDoc.config.hooks</code>. Use it if only a little tweak is needed.</p>
<p>Some more insight about their behavior:</p>
<ul>
<li><p>Default inference of documented object metadata (tag and object signature at the moment) is done in <code>block_pre</code>. Inference is based on string pattern matching, so can lead to false results, although works in most cases. It intentionally works only if first line after block has no indentation and contains all necessary information to determine if inference should happen.</p></li>
<li><p>Hooks for sections describing some “variable-like” object (‘<span class="citation" data-cites="class">@class</span>’, ‘<span class="citation" data-cites="field">@field</span>’, ‘<span class="citation" data-cites="param">@param</span>’) automatically enclose first word in ‘<span class="help-syntax-special">{}</span>’.</p></li>
<li><p>Hooks for sections which supposed to have “type-like” data (‘<span class="citation" data-cites="field">@field</span>’, ‘<span class="citation" data-cites="param">@param</span>’, ‘<span class="citation" data-cites="return">@return</span>’, ‘<span class="citation" data-cites="type">@type</span>’) automatically enclose <em>first found</em> “type-like” word and its neighbor characters in ‘<code>(&lt;type&gt;)</code>’ (expect false positives). Algorithm is far from being 100% correct, but seems to work with present allowed type annotation. For allowed types see https://github.com/sumneko/lua-language-server/wiki/EmmyLua-Annotations#types-and-type or, better yet, look in source code of this module.</p></li>
<li><p>Automated creation of table of contents (TOC) is done in the following way:</p>
<ul>
<li><p>Put section with <code>@toc_entry</code> id in the annotation block. Section’s lines will be registered as TOC entry.</p></li>
<li><p>Put <code>@toc</code> section where you want to insert rendered table of contents. TOC entries will be inserted on the left, references for their respective tag section (only first, if present) on the right. Render is done in default <code>doc</code> hook (because it should be done after processing all files).</p></li>
</ul></li>
<li><p>The <code>write_post</code> hook executes some actions convenient for iterative annotations writing:</p>
<ul>
<li><p>Generate <code>:helptags</code> for directory containing output file.</p></li>
<li><p>Silently reload buffer containing output file (if such exists).</p></li>
<li><p>Display notification message about result.</p></li>
</ul></li>
</ul>
<hr>
</section>
<section id="minidoc.generate" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc.generate">generate()</h3>
<p align="center">
<code>MiniDoc.generate</code>(<span class="help-syntax-special">{input}</span>, <span class="help-syntax-special">{output}</span>, <span class="help-syntax-special">{config}</span>)
</p>
<p>Generate help file</p>
<section id="minidoc.generate-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.generate-algorithm">Algorithm</h4>
<ul>
<li><p>Main parameters for help generation are an array of input file paths and path to output help file.</p></li>
<li><p>Parse all inputs:</p>
<ul>
<li><p>For each file, lines are processed top to bottom in order to create an array of documentation blocks. Each line is tested whether it is an annotation by applying <code>MiniDoc.config.annotation_extractor</code>: if anything is extracted, it is considered to be an annotation. Annotation line goes to “current block” after removing extracted annotation indicator, otherwise - to afterlines of “current block”.</p></li>
<li><p>Each block’s annotation lines are processed top to bottom. If line had captured section id, it is a first line of “current section” (first block lines are allowed to not specify section id; by default it is <code>@text</code>). All subsequent lines without captured section id go into “current section”.</p></li>
</ul></li>
<li><p>Apply structure hooks (they should modify its input in place, which is possible due to ‘table nature’ of all inputs):</p>
<ul>
<li><p>Each block is processed by <code>MiniDoc.config.hooks.block_pre</code>. This is a designated step for auto-generation of sections from described annotation subject (like sections with id <code>@tag</code>, <code>@type</code>).</p></li>
<li><p>Each section is processed by <code>MiniDoc.config.hooks.section_pre</code>.</p></li>
<li><p>Each section is processed by corresponding <code>MiniDoc.config.hooks.sections</code> function (table key equals to section id). This is a step where most of formatting should happen (like wrap first word of <code>@param</code> section with <code>{</code> and <code>}</code>, append empty line to section, etc.).</p></li>
<li><p>Each section is processed by <code>MiniDoc.config.hooks.section_post</code>.</p></li>
<li><p>Each block is processed by <code>MiniDoc.config.hooks.block_post</code>. This is a step for processing block after formatting is done (like add first line with <code>----</code> delimiter).</p></li>
<li><p>Each file is processed by <code>MiniDoc.config.hooks.file</code>. This is a step for adding any file-related data (like add first line with <code>====</code> delimiter).</p></li>
<li><p>Doc is processed by <code>MiniDoc.config.hooks.doc</code>. This is a step for adding any helpfile-related data (maybe like table of contents).</p></li>
</ul></li>
<li><p>Collect all strings from sections in depth-first fashion (equivalent to nested “for all files -&gt; for all blocks -&gt; for all sections -&gt; for all strings -&gt; add string to output”). Strings can have <code>\n</code> character indicating start of new line.</p></li>
<li><p>Modify collected strings with <code>MiniDoc.config.write_pre</code>. Takes strings from previous step as input and should return array of strings.</p></li>
<li><p>Write modified strings to output file.</p></li>
<li><p>Execute <code>MiniDoc.config.write_post</code> hook. This is useful for showing some feedback and making actions involving newly updated help file (like generate tags, etc.).</p></li>
</ul>
</section>
<section id="minidoc.generate-projectspecificscript" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.generate-projectspecificscript">Project specific script</h4>
<p>If all arguments have default <code>nil</code> values, first there is an attempt to source project specific script. This is basically a <code>luafile &lt;MiniDoc.config.script_path&gt;</code> with current Lua runtime while caching and restoring current <code>MiniDoc.config</code>. Its successful execution stops any further generation actions while error means proceeding generation as if no script was found.</p>
<p>Typical script content might include definition of custom hooks, input and output files with eventual call to <code>require('mini.doc').generate()</code> (with or without arguments).</p>
</section>
<section id="minidoc.generate-parameters" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.generate-parameters">Parameters</h4>
<p><span class="help-syntax-special">{input}</span> <code>(table|nil)</code> Array of file paths which will be processed in supplied order. Default: all ‘.lua’ files from current directory following by all such files in these subdirectories: ‘lua/’, ‘after/’, ‘colors/’. Note: any ‘init.lua’ file is placed before other files from the same directory.</p>
<p><span class="help-syntax-special">{output}</span> <code>(string|nil)</code> Path for output help file. Default: <code>doc/&lt;current_directory&gt;.txt</code> (designed to be used for generating help file for plugin).</p>
<p><span class="help-syntax-special">{config}</span> <code>(table|nil)</code> Configuration overriding parts of <a href="../../mini.nvim/doc/mini-doc.html#minidoc.config">MiniDoc.config</a>.</p>
</section>
<section id="minidoc.generate-return" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.generate-return">Return</h4>
<p><code>(table)</code> Document structure which was generated and used for output help file. In case <code>MiniDoc.config.script_path</code> was successfully used, this is a return from the latest call of this function.</p>
<hr>
</section>
</section>
<section id="minidoc.afterlines_to_code" class="level3 help-syntax-right-anchor">
<h3 class="help-syntax-right-anchor anchored" data-anchor-id="minidoc.afterlines_to_code">afterlines_to_code()</h3>
<p align="center">
<code>MiniDoc.afterlines_to_code</code>(<span class="help-syntax-special">{struct}</span>)
</p>
<p>Convert afterlines to code</p>
<p>This function is designed to be used together with <code>@eval</code> section to automate documentation of certain values (notably default values of a table). It processes afterlines based on certain directives and makes output look like a Lua code block.</p>
<p>Most common usage is by adding the following section in your annotation:</p>
<pre><code>---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)</code></pre>
<section id="minidoc.afterlines_to_code-directives" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.afterlines_to_code-directives">Directives</h4>
<p>Directives are special comments that are processed using Lua string pattern capabilities (so beware of false positives). Each directive should be put on its separate line. Supported directives:</p>
<ul>
<li><p><code>--minidoc_afterlines_end</code> denotes a line at afterlines end. Only all lines before it will be considered as afterlines. Useful if there is extra code in afterlines which shouldn’t be used.</p></li>
<li><p><code>--minidoc_replace_start &lt;replacement&gt;</code> and <code>--minidoc_replace_end</code> denote lines between them which should be replaced with <code>&lt;replacement&gt;</code>. Useful for manually changing what should be placed in output like in case of replacing function body with something else.</p></li>
</ul>
<p>Here is an example. Suppose having these afterlines:</p>
<div class="code-copy-outer-scaffold"><div class="sourceCode" id="cb4"><pre class="sourceCode lua code-with-copy"><code class="sourceCode lua"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">--minidoc_replace_start {</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cn">M</span><span class="op">.</span><span class="va">config</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">--minidoc_replace_end</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="va">param_one</span> <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">--minidoc_replace_start param_fun = --&lt;function&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="va">param_fun</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">x</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">--minidoc_replace_end</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="co">--minidoc_afterlines_end</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="cn">M</span></span></code></pre></div><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></div>
<p>After adding <code>@eval</code> section those will be formatted as:</p>
<pre><code>{
  param_one = 1,
  param_fun = --&lt;function&gt;
}</code></pre>
</section>
<section id="minidoc.afterlines_to_code-parameters" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.afterlines_to_code-parameters">Parameters</h4>
<p><span class="help-syntax-special">{struct}</span> <code>(table)</code> Block or section structure which after lines will be converted to code.</p>
</section>
<section id="minidoc.afterlines_to_code-return" class="level4">
<h4 class="anchored" data-anchor-id="minidoc.afterlines_to_code-return">Return</h4>
<p><code>(string|nil)</code> Single string (using <code>\n</code> to separate lines) describing afterlines as Lua code block in help file. If <code>nil</code>, input is not valid.</p>


</section>
</section>

</main> <!-- /main -->
<!-- Original source: https://gc.zgo.at/count.js -->
<!-- Inlined for security reasons (less supply chain attack possibility) -->
<script data-goatcounter="https://nvim-mini.goatcounter.com/count">
// GoatCounter: https://www.goatcounter.com
// This file is released under the ISC license: https://opensource.org/licenses/ISC
;(function() {
	'use strict';

	window.goatcounter = window.goatcounter || {}

	// Load settings from data-goatcounter-settings.
	var s = document.querySelector('script[data-goatcounter]')
	if (s && s.dataset.goatcounterSettings) {
		try         { var set = JSON.parse(s.dataset.goatcounterSettings) }
		catch (err) { console.error('invalid JSON in data-goatcounter-settings: ' + err) }
		for (var k in set)
			if (['no_onload', 'no_events', 'allow_local', 'allow_frame', 'path', 'title', 'referrer', 'event'].indexOf(k) > -1)
				window.goatcounter[k] = set[k]
	}

	var enc = encodeURIComponent

	// Get all data we're going to send off to the counter endpoint.
	window.goatcounter.get_data = function(vars) {
		vars = vars || {}
		var data = {
			p: (vars.path     === undefined ? goatcounter.path     : vars.path),
			r: (vars.referrer === undefined ? goatcounter.referrer : vars.referrer),
			t: (vars.title    === undefined ? goatcounter.title    : vars.title),
			e: !!(vars.event || goatcounter.event),
			s: window.screen.width,
			b: is_bot(),
			q: location.search,
		}

		var rcb, pcb, tcb  // Save callbacks to apply later.
		if (typeof(data.r) === 'function') rcb = data.r
		if (typeof(data.t) === 'function') tcb = data.t
		if (typeof(data.p) === 'function') pcb = data.p

		if (is_empty(data.r)) data.r = document.referrer
		if (is_empty(data.t)) data.t = document.title
		if (is_empty(data.p)) data.p = get_path()

		if (rcb) data.r = rcb(data.r)
		if (tcb) data.t = tcb(data.t)
		if (pcb) data.p = pcb(data.p)
		return data
	}

	// Check if a value is "empty" for the purpose of get_data().
	var is_empty = function(v) { return v === null || v === undefined || typeof(v) === 'function' }

	// See if this looks like a bot; there is some additional filtering on the
	// backend, but these properties can't be fetched from there.
	var is_bot = function() {
		// Headless browsers are probably a bot.
		var w = window, d = document
		if (w.callPhantom || w._phantom || w.phantom)
			return 150
		if (w.__nightmare)
			return 151
		if (d.__selenium_unwrapped || d.__webdriver_evaluate || d.__driver_evaluate)
			return 152
		if (navigator.webdriver)
			return 153
		return 0
	}

	// Object to urlencoded string, starting with a ?.
	var urlencode = function(obj) {
		var p = []
		for (var k in obj)
			if (obj[k] !== '' && obj[k] !== null && obj[k] !== undefined && obj[k] !== false)
				p.push(enc(k) + '=' + enc(obj[k]))
		return '?' + p.join('&')
	}

	// Show a warning in the console.
	var warn = function(msg) {
		if (console && 'warn' in console)
			console.warn('goatcounter: ' + msg)
	}

	// Get the endpoint to send requests to.
	var get_endpoint = function() {
		var s = document.querySelector('script[data-goatcounter]')
		return (s && s.dataset.goatcounter) ? s.dataset.goatcounter : goatcounter.endpoint
	}

	// Get current path.
	var get_path = function() {
		var loc = location,
			c = document.querySelector('link[rel="canonical"][href]')
		if (c) {  // May be relative or point to different domain.
			var a = document.createElement('a')
			a.href = c.href
			if (a.hostname.replace(/^www\./, '') === location.hostname.replace(/^www\./, ''))
				loc = a
		}
		return (loc.pathname + loc.search) || '/'
	}

	// Run function after DOM is loaded.
	var on_load = function(f) {
		if (document.body === null)
			document.addEventListener('DOMContentLoaded', function() { f() }, false)
		else
			f()
	}

	// Filter some requests that we (probably) don't want to count.
	window.goatcounter.filter = function() {
		if ('visibilityState' in document && document.visibilityState === 'prerender')
			return 'visibilityState'
		if (!goatcounter.allow_frame && location !== parent.location)
			return 'frame'
		if (!goatcounter.allow_local && location.hostname.match(/(localhost$|^127\.|^10\.|^172\.(1[6-9]|2[0-9]|3[0-1])\.|^192\.168\.|^0\.0\.0\.0$)/))
			return 'localhost'
		if (!goatcounter.allow_local && location.protocol === 'file:')
			return 'localfile'
		if (localStorage && localStorage.getItem('skipgc') === 't')
			return 'disabled with #toggle-goatcounter'
		return false
	}

	// Get URL to send to GoatCounter.
	window.goatcounter.url = function(vars) {
		var data = window.goatcounter.get_data(vars || {})
		if (data.p === null)  // null from user callback.
			return
		data.rnd = Math.random().toString(36).substr(2, 5)  // Browsers don't always listen to Cache-Control.

		var endpoint = get_endpoint()
		if (!endpoint)
			return warn('no endpoint found')

		return endpoint + urlencode(data)
	}

	// Count a hit.
	window.goatcounter.count = function(vars) {
		var f = goatcounter.filter()
		if (f)
			return warn('not counting because of: ' + f)
		var url = goatcounter.url(vars)
		if (!url)
			return warn('not counting because path callback returned null')

		if (!navigator.sendBeacon(url)) {
			// This mostly fails due to being blocked by CSP; try again with an
			// image-based fallback.
			var img = document.createElement('img')
			img.src = url
			img.style.position = 'absolute'  // Affect layout less.
			img.style.bottom = '0px'
			img.style.width = '1px'
			img.style.height = '1px'
			img.loading = 'eager'
			img.setAttribute('alt', '')
			img.setAttribute('aria-hidden', 'true')

			var rm = function() { if (img && img.parentNode) img.parentNode.removeChild(img) }
			img.addEventListener('load', rm, false)
			document.body.appendChild(img)
		}
	}

	// Get a query parameter.
	window.goatcounter.get_query = function(name) {
		var s = location.search.substr(1).split('&')
		for (var i = 0; i < s.length; i++)
			if (s[i].toLowerCase().indexOf(name.toLowerCase() + '=') === 0)
				return s[i].substr(name.length + 1)
	}

	// Track click events.
	window.goatcounter.bind_events = function() {
		if (!document.querySelectorAll)  // Just in case someone uses an ancient browser.
			return

		var send = function(elem) {
			return function() {
				goatcounter.count({
					event:    true,
					path:     (elem.dataset.goatcounterClick || elem.name || elem.id || ''),
					title:    (elem.dataset.goatcounterTitle || elem.title || (elem.innerHTML || '').substr(0, 200) || ''),
					referrer: (elem.dataset.goatcounterReferrer || elem.dataset.goatcounterReferral || ''),
				})
			}
		}

		Array.prototype.slice.call(document.querySelectorAll("*[data-goatcounter-click]")).forEach(function(elem) {
			if (elem.dataset.goatcounterBound)
				return
			var f = send(elem)
			elem.addEventListener('click', f, false)
			elem.addEventListener('auxclick', f, false)  // Middle click.
			elem.dataset.goatcounterBound = 'true'
		})
	}

	// Add a "visitor counter" frame or image.
	window.goatcounter.visit_count = function(opt) {
		on_load(function() {
			opt        = opt        || {}
			opt.type   = opt.type   || 'html'
			opt.append = opt.append || 'body'
			opt.path   = opt.path   || get_path()
			opt.attr   = opt.attr   || {width: '200', height: (opt.no_branding ? '60' : '80')}

			opt.attr['src'] = get_endpoint() + 'er/' + enc(opt.path) + '.' + enc(opt.type) + '?'
			if (opt.no_branding) opt.attr['src'] += '&no_branding=1'
			if (opt.style)       opt.attr['src'] += '&style=' + enc(opt.style)
			if (opt.start)       opt.attr['src'] += '&start=' + enc(opt.start)
			if (opt.end)         opt.attr['src'] += '&end='   + enc(opt.end)

			var tag = {png: 'img', svg: 'img', html: 'iframe'}[opt.type]
			if (!tag)
				return warn('visit_count: unknown type: ' + opt.type)

			if (opt.type === 'html') {
				opt.attr['frameborder'] = '0'
				opt.attr['scrolling']   = 'no'
			}

			var d = document.createElement(tag)
			for (var k in opt.attr)
				d.setAttribute(k, opt.attr[k])

			var p = document.querySelector(opt.append)
			if (!p)
				return warn('visit_count: element to append to not found: ' + opt.append)
			p.appendChild(d)
		})
	}

	// Make it easy to skip your own views.
	if (location.hash === '#toggle-goatcounter') {
		if (localStorage.getItem('skipgc') === 't') {
			localStorage.removeItem('skipgc', 't')
			alert('GoatCounter tracking is now ENABLED in this browser.')
		}
		else {
			localStorage.setItem('skipgc', 't')
			alert('GoatCounter tracking is now DISABLED in this browser until ' + location + ' is loaded again.')
		}
	}

	if (!goatcounter.no_onload)
		on_load(function() {
			// 1. Page is visible, count request.
			// 2. Page is not yet visible; wait until it switches to 'visible' and count.
			// See #487
			if (!('visibilityState' in document) || document.visibilityState === 'visible')
				goatcounter.count()
			else {
				var f = function(e) {
					if (document.visibilityState !== 'visible')
						return
					document.removeEventListener('visibilitychange', f)
					goatcounter.count()
				}
				document.addEventListener('visibilitychange', f)
			}

			if (!goatcounter.no_events)
				goatcounter.bind_events()
		})
})();
</script>
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/nvim-mini\.org");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© Evgeni Chasnovski, <a href="https://choosealicense.com/licenses/mit/">MIT</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>