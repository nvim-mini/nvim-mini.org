[
  {
    "objectID": "MiniMax/index.html",
    "href": "MiniMax/index.html",
    "title": "MiniMax",
    "section": "",
    "text": "Generated from the main branch of ‘MiniMax’"
  },
  {
    "objectID": "MiniMax/index.html#neovim-with-maximum-mini",
    "href": "MiniMax/index.html#neovim-with-maximum-mini",
    "title": "MiniMax",
    "section": "Neovim with maximum MINI",
    "text": "Neovim with maximum MINI\nMiniMax is a collection of fully working self-contained Neovim configs. All of the them:\n\nUse mostly MINI to showcase its capabilities.\nProvide out of the box a stable, polished, and feature rich Neovim experience.\nShare minimal structure with potential to build upon.\nContain extensively commented config files meant to be read.\n\nIt can be automatically set up, which uses the best suited config from available ones.\nSee change log for a history of changes.\nIf you find this project useful, please consider leaving a Github star.\n\nHow it looks\n     \n     \n\n\nWhat it is not\nIt is not a “Neovim distribution”, i.e. there are no automatic config updates. After your config is set up, it is yours to improve and update (which makes this approach more stable). You can still see how MiniMax itself gets updated (see Updating and Change log) and adjust the config accordingly.\nIt is not a comprehensive guide on how to set up and use every Neovim feature and plugin. Most of the config parts are carefully chosen in order to reach a balance between stability and features.\n\n\nRequirements\n\nSoftware\n\nNeovim executable. Assumed to be named nvim.\nGit executable. Assumed to be named git.\nOperating system: any OS supported by Neovim.\nInternet connection for downloading plugins.\n(Optional, but recommended) ripgrep.\n(Optional, but recommended) Terminal emulator (or GUI) with true colors and Nerd Font icons support. No need for a full Nerd font, using NerdFontsSymbolsOnly as a fallback is usually enough.\n(Optional, but recommended) System requirements for main branch of ‘nvim-treesitter/nvim-treesitter’ plugin.\n\n\n\nKnowledge\nBasic level of understanding of how to:\n\nUse CLI (command line): open, navigate file system, execute commands, close.\nUse Neovim: open, modal editing, reading help, close. If inside Neovim, type :h help.txt (or click it if it is a link) followed by &lt;Enter&gt; and it should guide you through understanding basics.\nSeveral personal recommendations (no need to read in full; be aware of their content): :h notation, :h key-notation, :h vim-modes, :h mode-switching, :h windows-intro, :h vimtutor\nRead help files from inside Neovim: notion of help tags, key notations, navigation.\n\n\n\n\n\n\nTip\n\n\n\nIf already inside MiniMax config, press &lt;Space&gt; + f + h to fuzzy search across all help tags.\n\n\nRead Lua language: variables, tables, function calls, iterations. See also :h lua-concepts and :h lua-guide.\n\n\n\nMotivation\n\nIt will be really helpful if you are mentally ready to read documentation and practice. If you are new to Neovim and/or MINI, it might feel like a lot. It gets easier the more you learn and practice. Without this you likely won’t enjoy Neovim and MiniMax as much.\n\n\n\n\nSetting up\nThis sets up temporary ‘nvim-minimax’ config and doesn’t affect your regular config. To set up a full time config, remove all instances of NVIM_APPNAME=nvim-minimax.\n# Download\ngit clone --filter=blob:none https://github.com/nvim-mini/MiniMax ./MiniMax\n\n# Set up config (copies config files and possibly initiates Git repository)\nNVIM_APPNAME=nvim-minimax nvim -l ./MiniMax/setup.lua\n\n# Start Neovim\nNVIM_APPNAME=nvim-minimax nvim\n\n# Wait for plugins to install (there should be no new notifications)\n\n# Enjoy your new config!\n# Start with reading its files. Type `&lt;Space&gt;`+`e`+`i` to open 'init.lua'.\nNotes:\n\nMiniMax project can be downloaded manually (like via GitHub UI).\nWith NVIM_APPNAME=nvim-minimax config directory is ‘~/.config/nvim-minimax’ on Unix and ‘~/AppData/Local/nvim-minimax’ on Windows.\nA full-time config directory is ‘~/.config/nvim’ on Unix and ‘~/AppData/Local/nvim’ on Windows.\nIf there are messages about backed up files during setup, it means the target config directory already contained files that are meant to come from MiniMax. Previous files were moved to MiniMax-backup directory. Review/restore them and delete the whole backup directory.\nYou can explore MiniMax manually to find which (parts of) config examples suit you best. Read through the relevant config example (starting at ‘init.lua’) and use interesting parts in your already existing config.\n\n\n\nUpdating\nMiniMax doesn’t provide fully automatic updates of an already set up config. The recommended approach is to manually explore configs and change log to see the changes.\nThe closest approach to automatic updating is:\n# Pull updates of MiniMax itself\ngit -C ./MiniMax pull\n\n# Run setup script again. Remove `NVIM_APPNAME=nvim-minimax` for full-time config\nNVIM_APPNAME=nvim-minimax nvim -l ./MiniMax/setup.lua\n\n# There probably be messages about backed up files:\n# 1. Examine 'MiniMax-backup' directory with conflicting files.\n# 2. Recover the ones you need.\n# 3. Delete the backup directory.\n\n\nSimilar projects\n\nnvim-lua/kickstart.nvim\nMore automated approaches (“Neovim distributions”):\n\nLazyVim/LazyVim\nNvChad/NvChad\nAstroNvim/AstroNvim"
  },
  {
    "objectID": "MiniMax/configs/nvim-0.11/index.html",
    "href": "MiniMax/configs/nvim-0.11/index.html",
    "title": "MiniMax config nvim-0.11",
    "section": "",
    "text": "Generated from the main branch of ‘MiniMax’\n\nMiniMax config nvim-0.11\n\ninit.lua\n\n\nCode\n\n-- ┌────────────────────┐\n-- │ Welcome to MiniMax │\n-- └────────────────────┘\n--\n-- This is a config designed to mostly use MINI. It provides out of the box\n-- a stable, polished, and feature rich Neovim experience. Its structure:\n--\n-- ├ init.lua          Initial (this) file executed during startup\n-- ├ plugin/           Files automatically sourced during startup\n-- ├── 10_options.lua  Built-in Neovim behavior\n-- ├── 20_keymaps.lua  Custom mappings\n-- ├── 30_mini.lua     MINI configuration\n-- ├── 40_plugins.lua  Plugins outside of MINI\n-- ├ snippets/         User defined snippets (has demo file)\n-- ├ after/            Files to override behavior added by plugins\n-- ├── ftplugin/       Files for filetype behavior (has demo file)\n-- ├── lsp/            Language server configurations (has demo file)\n-- ├── snippets/       Higher priority snippet files (has demo file)\n--\n-- Config files are meant to be read, preferably inside a Neovim instance running\n-- this config and opened at its root. This will help you better understand your\n-- setup. Start with this file. Any order is possible, prefer the one listed above.\n-- Ways of navigating your config:\n-- - `&lt;Space&gt;` + `e` + (one of) `iokmp` - edit 'init.lua' or 'plugin/' files.\n-- - Inside config directory: `&lt;Space&gt;ff` (picker) or `&lt;Space&gt;ed` (explorer)\n-- - Navigate existing buffers with `[b`, `]b`, or `&lt;Space&gt;fb`.\n--\n-- Config files are also meant to be customized. Initially it is a baseline of\n-- a working config based on MINI. Modify it to make it yours. Some approaches:\n-- - Modify already existing files in a way that keeps them consistent.\n-- - Add new files in a way that keeps config consistent.\n--   Usually inside 'plugin/' or 'after/'.\n--\n-- Documentation comments like this can be found throughout the config.\n-- Common conventions:\n--\n-- - See `:h key-notation` for key notation used.\n-- - `:h xxx` means \"documentation of helptag xxx\". Either type text directly\n--   followed by Enter or type `&lt;Space&gt;fh` to open a helptag fuzzy picker.\n-- - \"Type `&lt;Space&gt;fh`\" means \"press &lt;Space&gt;, followed by f, followed by h\".\n--   Unless said otherwise, it assumes that Normal mode is current.\n-- - \"See 'path/to/file'\" means see open file at described path and read it.\n-- - `:SomeCommand ...` or `:lua ...` means execute mentioned command.\n\n-- Bootstrap 'mini.nvim' manually in a way that it gets managed by 'mini.deps'\nlocal mini_path = vim.fn.stdpath('data') .. '/site/pack/deps/start/mini.nvim'\nif not vim.loop.fs_stat(mini_path) then\n  vim.cmd('echo \"Installing `mini.nvim`\" | redraw')\n  local origin = 'https://github.com/nvim-mini/mini.nvim'\n  local clone_cmd = { 'git', 'clone', '--filter=blob:none', origin, mini_path }\n  vim.fn.system(clone_cmd)\n  vim.cmd('packadd mini.nvim | helptags ALL')\n  vim.cmd('echo \"Installed `mini.nvim`\" | redraw')\nend\n\n-- Plugin manager. Set up immediately for `now()`/`later()` helpers.\n-- Example usage:\n-- - `MiniDeps.add('...')` - use inside config to add a plugin\n-- - `:DepsUpdate` - update all plugins\n-- - `:DepsSnapSave` - save a snapshot of currently active plugins\n--\n-- See also:\n-- - `:h MiniDeps-overview` - how to use it\n-- - `:h MiniDeps-commands` - all available commands\n-- - 'plugin/30_mini.lua' - more details about 'mini.nvim' in general\nrequire('mini.deps').setup()\n\n-- Define config table to be able to pass data between scripts\n_G.Config = {}\n\n-- Define custom autocommand group and helper to create an autocommand.\n-- Autocommands are Neovim's way to define actions that are executed on events\n-- (like creating a buffer, setting an option, etc.).\n--\n-- See also:\n-- - `:h autocommand`\n-- - `:h nvim_create_augroup()`\n-- - `:h nvim_create_autocmd()`\nlocal gr = vim.api.nvim_create_augroup('custom-config', {})\n_G.Config.new_autocmd = function(event, pattern, callback, desc)\n  local opts = { group = gr, pattern = pattern, callback = callback, desc = desc }\n  vim.api.nvim_create_autocmd(event, opts)\nend\n\n-- Some plugins and 'mini.nvim' modules only need setup during startup if Neovim\n-- is started like `nvim -- path/to/file`, otherwise delaying setup is fine\n_G.Config.now_if_args = vim.fn.argc(-1) &gt; 0 and MiniDeps.now or MiniDeps.later\n\n\n\nplugin/10_options.lua\n\n\nCode\n\n-- ┌──────────────────────────┐\n-- │ Built-in Neovim behavior │\n-- └──────────────────────────┘\n--\n-- This file defines Neovim's built-in behavior. The goal is to improve overall\n-- usability in a way that works best with MINI.\n--\n-- Here `vim.o.xxx = value` sets default value of option `xxx` to `value`.\n-- See `:h 'xxx'` (replace `xxx` with actual option name).\n--\n-- Option values can be customized on per buffer or window basis.\n-- See 'after/ftplugin/' for common example.\n\n-- stylua: ignore start\n-- The next part (until `-- stylua: ignore end`) is aligned manually for easier\n-- reading. Consider preserving this or remove `-- stylua` lines to autoformat.\n\n-- General ====================================================================\nvim.g.mapleader = ' ' -- Use `&lt;Space&gt;` as &lt;Leader&gt; key\n\nvim.o.mouse       = 'a'            -- Enable mouse\nvim.o.mousescroll = 'ver:25,hor:6' -- Customize mouse scroll\nvim.o.switchbuf   = 'usetab'       -- Use already opened buffers when switching\nvim.o.undofile    = true           -- Enable persistent undo\n\nvim.o.shada = \"'100,&lt;50,s10,:1000,/100,@100,h\" -- Limit ShaDa file (for startup)\n\n-- Enable all filetype plugins and syntax (if not enabled, for better startup)\nvim.cmd('filetype plugin indent on')\nif vim.fn.exists('syntax_on') ~= 1 then vim.cmd('syntax enable') end\n\n-- UI =========================================================================\nvim.o.breakindent    = true       -- Indent wrapped lines to match line start\nvim.o.breakindentopt = 'list:-1'  -- Add padding for lists (if 'wrap' is set)\nvim.o.colorcolumn    = '+1'       -- Draw column on the right of maximum width\nvim.o.cursorline     = true       -- Enable current line highlighting\nvim.o.linebreak      = true       -- Wrap lines at 'breakat' (if 'wrap' is set)\nvim.o.list           = true       -- Show helpful text indicators\nvim.o.number         = true       -- Show line numbers\nvim.o.pumheight      = 10         -- Make popup menu smaller\nvim.o.ruler          = false      -- Don't show cursor coordinates\nvim.o.shortmess      = 'CFOSWaco' -- Disable some built-in completion messages\nvim.o.showmode       = false      -- Don't show mode in command line\nvim.o.signcolumn     = 'yes'      -- Always show signcolumn (less flicker)\nvim.o.splitbelow     = true       -- Horizontal splits will be below\nvim.o.splitkeep      = 'screen'   -- Reduce scroll during window split\nvim.o.splitright     = true       -- Vertical splits will be to the right\nvim.o.winborder      = 'single'   -- Use border in floating windows\nvim.o.wrap           = false      -- Don't visually wrap lines (toggle with \\w)\n\nvim.o.cursorlineopt  = 'screenline,number' -- Show cursor line per screen line\n\n-- Special UI symbols. More is set via 'mini.basics' later.\nvim.o.fillchars = 'eob: ,fold:╌'\nvim.o.listchars = 'extends:…,nbsp:␣,precedes:…,tab:&gt; '\n\n-- Folds (see `:h fold-commands`, `:h zM`, `:h zR`, `:h zA`, `:h zj`)\nvim.o.foldlevel   = 10       -- Fold nothing by default; set to 0 or 1 to fold\nvim.o.foldmethod  = 'indent' -- Fold based on indent level\nvim.o.foldnestmax = 10       -- Limit number of fold levels\nvim.o.foldtext    = ''       -- Show text under fold with its highlighting\n\n-- Editing ====================================================================\nvim.o.autoindent    = true    -- Use auto indent\nvim.o.expandtab     = true    -- Convert tabs to spaces\nvim.o.formatoptions = 'rqnl1j'-- Improve comment editing\nvim.o.ignorecase    = true    -- Ignore case during search\nvim.o.incsearch     = true    -- Show search matches while typing\nvim.o.infercase     = true    -- Infer case in built-in completion\nvim.o.shiftwidth    = 2       -- Use this number of spaces for indentation\nvim.o.smartcase     = true    -- Respect case if search pattern has upper case\nvim.o.smartindent   = true    -- Make indenting smart\nvim.o.spelloptions  = 'camel' -- Treat camelCase word parts as separate words\nvim.o.tabstop       = 2       -- Show tab as this number of spaces\nvim.o.virtualedit   = 'block' -- Allow going past end of line in blockwise mode\n\nvim.o.iskeyword = '@,48-57,_,192-255,-' -- Treat dash as `word` textobject part\n\n-- Pattern for a start of numbered list (used in `gw`). This reads as\n-- \"Start of list item is: at least one special character (digit, -, +, *)\n-- possibly followed by punctuation (. or `)`) followed by at least one space\".\nvim.o.formatlistpat = [[^\\s*[0-9\\-\\+\\*]\\+[\\.\\)]*\\s\\+]]\n\n-- Built-in completion\nvim.o.complete    = '.,w,b,kspell'                  -- Use less sources\nvim.o.completeopt = 'menuone,noselect,fuzzy,nosort' -- Use custom behavior\n\n-- Autocommands ===============================================================\n\n-- Don't auto-wrap comments and don't insert comment leader after hitting 'o'.\n-- Do on `FileType` to always override these changes from filetype plugins.\nlocal f = function() vim.cmd('setlocal formatoptions-=c formatoptions-=o') end\n_G.Config.new_autocmd('FileType', nil, f, \"Proper 'formatoptions'\")\n\n-- There are other autocommands created by 'mini.basics'. See 'plugin/30_mini.lua'.\n\n-- Diagnostics ================================================================\n\n-- Neovim has built-in support for showing diagnostic messages. This configures\n-- a more conservative display while still being useful.\n-- See `:h vim.diagnostic` and `:h vim.diagnostic.config()`.\nlocal diagnostic_opts = {\n  -- Show signs on top of any other sign, but only for warnings and errors\n  signs = { priority = 9999, severity = { min = 'WARN', max = 'ERROR' } },\n\n  -- Show all diagnostics as underline (for their messages type `&lt;Leader&gt;ld`)\n  underline = { severity = { min = 'HINT', max = 'ERROR' } },\n\n  -- Show more details immediately for errors on the current line\n  virtual_lines = false,\n  virtual_text = {\n    current_line = true,\n    severity = { min = 'ERROR', max = 'ERROR' },\n  },\n\n  -- Don't update diagnostics when typing\n  update_in_insert = false,\n}\n\n-- Use `later()` to avoid sourcing `vim.diagnostic` on startup\nMiniDeps.later(function() vim.diagnostic.config(diagnostic_opts) end)\n-- stylua: ignore end\n\n\n\nplugin/20_keymaps.lua\n\n\nCode\n\n-- ┌─────────────────┐\n-- │ Custom mappings │\n-- └─────────────────┘\n--\n-- This file contains definitions of custom general and Leader mappings.\n\n-- General mappings ===========================================================\n\n-- Use this section to add custom general mappings. See `:h vim.keymap.set()`.\n\n-- An example helper to create a Normal mode mapping\nlocal nmap = function(lhs, rhs, desc)\n  -- See `:h vim.keymap.set()`\n  vim.keymap.set('n', lhs, rhs, { desc = desc })\nend\n\n-- Paste linewise before/after current line\n-- Usage: `yiw` to yank a word and `]p` to put it on the next line.\nnmap('[p', '&lt;Cmd&gt;exe \"put! \" . v:register&lt;CR&gt;', 'Paste Above')\nnmap(']p', '&lt;Cmd&gt;exe \"put \"  . v:register&lt;CR&gt;', 'Paste Below')\n\n-- Many general mappings are created by 'mini.basics'. See 'plugin/30_mini.lua'\n\n-- stylua: ignore start\n-- The next part (until `-- stylua: ignore end`) is aligned manually for easier\n-- reading. Consider preserving this or remove `-- stylua` lines to autoformat.\n\n-- Leader mappings ============================================================\n\n-- Neovim has the concept of a Leader key (see `:h &lt;Leader&gt;`). It is a configurable\n-- key that is primarily used for \"workflow\" mappings (opposed to text editing).\n-- Like \"open file explorer\", \"create scratch buffer\", \"pick from buffers\".\n--\n-- In 'plugin/10_options.lua' &lt;Leader&gt; is set to &lt;Space&gt;, i.e. press &lt;Space&gt;\n-- whenever there is a suggestion to press &lt;Leader&gt;.\n--\n-- This config uses a \"two key Leader mappings\" approach: first key describes\n-- semantic group, second key executes an action. Both keys are usually chosen\n-- to create some kind of mnemonic.\n-- Example: `&lt;Leader&gt;f` groups \"find\" type of actions; `&lt;Leader&gt;ff` - find files.\n-- Use this section to add Leader mappings in a structural manner.\n--\n-- Usually if there are global and local kinds of actions, lowercase second key\n-- denotes global and uppercase - local.\n-- Example: `&lt;Leader&gt;fs` / `&lt;Leader&gt;fS` - find workspace/document LSP symbols.\n--\n-- Many of the mappings use 'mini.nvim' modules set up in 'plugin/30_mini.lua'.\n\n-- Create a global table with information about Leader groups in certain modes.\n-- This is used to provide 'mini.clue' with extra clues.\n-- Add an entry if you create a new group.\n_G.Config.leader_group_clues = {\n  { mode = 'n', keys = '&lt;Leader&gt;b', desc = '+Buffer' },\n  { mode = 'n', keys = '&lt;Leader&gt;e', desc = '+Explore/Edit' },\n  { mode = 'n', keys = '&lt;Leader&gt;f', desc = '+Find' },\n  { mode = 'n', keys = '&lt;Leader&gt;g', desc = '+Git' },\n  { mode = 'n', keys = '&lt;Leader&gt;l', desc = '+Language' },\n  { mode = 'n', keys = '&lt;Leader&gt;m', desc = '+Map' },\n  { mode = 'n', keys = '&lt;Leader&gt;o', desc = '+Other' },\n  { mode = 'n', keys = '&lt;Leader&gt;s', desc = '+Session' },\n  { mode = 'n', keys = '&lt;Leader&gt;t', desc = '+Terminal' },\n  { mode = 'n', keys = '&lt;Leader&gt;v', desc = '+Visits' },\n\n  { mode = 'x', keys = '&lt;Leader&gt;g', desc = '+Git' },\n  { mode = 'x', keys = '&lt;Leader&gt;l', desc = '+Language' },\n}\n\n-- Helpers for a more concise `&lt;Leader&gt;` mappings.\n-- Most of the mappings use `&lt;Cmd&gt;...&lt;CR&gt;` string as a right hand side (RHS) in\n-- an attempt to be more concise yet descriptive. See `:h &lt;Cmd&gt;`.\n-- This approach also doesn't require the underlying commands/functions to exist\n-- during mapping creation: a \"lazy loading\" approach to improve startup time.\nlocal nmap_leader = function(suffix, rhs, desc)\n  vim.keymap.set('n', '&lt;Leader&gt;' .. suffix, rhs, { desc = desc })\nend\nlocal xmap_leader = function(suffix, rhs, desc)\n  vim.keymap.set('x', '&lt;Leader&gt;' .. suffix, rhs, { desc = desc })\nend\n\n-- b is for 'Buffer'. Common usage:\n-- - `&lt;Leader&gt;bs` - create scratch (temporary) buffer\n-- - `&lt;Leader&gt;ba` - navigate to the alternative buffer\n-- - `&lt;Leader&gt;bw` - wipeout (fully delete) current buffer\nlocal new_scratch_buffer = function()\n  vim.api.nvim_win_set_buf(0, vim.api.nvim_create_buf(true, true))\nend\n\nnmap_leader('ba', '&lt;Cmd&gt;b#&lt;CR&gt;',                                 'Alternate')\nnmap_leader('bd', '&lt;Cmd&gt;lua MiniBufremove.delete()&lt;CR&gt;',         'Delete')\nnmap_leader('bD', '&lt;Cmd&gt;lua MiniBufremove.delete(0, true)&lt;CR&gt;',  'Delete!')\nnmap_leader('bs', new_scratch_buffer,                            'Scratch')\nnmap_leader('bw', '&lt;Cmd&gt;lua MiniBufremove.wipeout()&lt;CR&gt;',        'Wipeout')\nnmap_leader('bW', '&lt;Cmd&gt;lua MiniBufremove.wipeout(0, true)&lt;CR&gt;', 'Wipeout!')\n\n-- e is for 'Explore' and 'Edit'. Common usage:\n-- - `&lt;Leader&gt;ed` - open explorer at current working directory\n-- - `&lt;Leader&gt;ef` - open directory of current file (needs to be present on disk)\n-- - `&lt;Leader&gt;ei` - edit 'init.lua'\n-- - All mappings that use `edit_plugin_file` - edit 'plugin/' config files\nlocal edit_plugin_file = function(filename)\n  return string.format('&lt;Cmd&gt;edit %s/plugin/%s&lt;CR&gt;', vim.fn.stdpath('config'), filename)\nend\nlocal explore_at_file = '&lt;Cmd&gt;lua MiniFiles.open(vim.api.nvim_buf_get_name(0))&lt;CR&gt;'\nlocal explore_quickfix = function()\n  for _, win_id in ipairs(vim.api.nvim_tabpage_list_wins(0)) do\n    if vim.fn.getwininfo(win_id)[1].quickfix == 1 then return vim.cmd('cclose') end\n  end\n  vim.cmd('copen')\nend\n\nnmap_leader('ed', '&lt;Cmd&gt;lua MiniFiles.open()&lt;CR&gt;',          'Directory')\nnmap_leader('ef', explore_at_file,                          'File directory')\nnmap_leader('ei', '&lt;Cmd&gt;edit $MYVIMRC&lt;CR&gt;',                 'init.lua')\nnmap_leader('ek', edit_plugin_file('20_keymaps.lua'),       'Keymaps config')\nnmap_leader('em', edit_plugin_file('30_mini.lua'),          'MINI config')\nnmap_leader('en', '&lt;Cmd&gt;lua MiniNotify.show_history()&lt;CR&gt;', 'Notifications')\nnmap_leader('eo', edit_plugin_file('10_options.lua'),       'Options config')\nnmap_leader('ep', edit_plugin_file('40_plugins.lua'),       'Plugins config')\nnmap_leader('eq', explore_quickfix,                         'Quickfix')\n\n-- f is for 'Fuzzy Find'. Common usage:\n-- - `&lt;Leader&gt;ff` - find files; for best performance requires `ripgrep`\n-- - `&lt;Leader&gt;fg` - find inside files; requires `ripgrep`\n-- - `&lt;Leader&gt;fh` - find help tag\n-- - `&lt;Leader&gt;fr` - resume latest picker\n-- - `&lt;Leader&gt;fv` - all visited paths; requires 'mini.visits'\n--\n-- All these use 'mini.pick'. See `:h MiniPick-overview` for an overview.\nlocal pick_added_hunks_buf = '&lt;Cmd&gt;Pick git_hunks path=\"%\" scope=\"staged\"&lt;CR&gt;'\nlocal pick_workspace_symbols_live = '&lt;Cmd&gt;Pick lsp scope=\"workspace_symbol_live\"&lt;CR&gt;'\n\nnmap_leader('f/', '&lt;Cmd&gt;Pick history scope=\"/\"&lt;CR&gt;',            '\"/\" history')\nnmap_leader('f:', '&lt;Cmd&gt;Pick history scope=\":\"&lt;CR&gt;',            '\":\" history')\nnmap_leader('fa', '&lt;Cmd&gt;Pick git_hunks scope=\"staged\"&lt;CR&gt;',     'Added hunks (all)')\nnmap_leader('fA', pick_added_hunks_buf,                         'Added hunks (buf)')\nnmap_leader('fb', '&lt;Cmd&gt;Pick buffers&lt;CR&gt;',                      'Buffers')\nnmap_leader('fc', '&lt;Cmd&gt;Pick git_commits&lt;CR&gt;',                  'Commits (all)')\nnmap_leader('fC', '&lt;Cmd&gt;Pick git_commits path=\"%\"&lt;CR&gt;',         'Commits (buf)')\nnmap_leader('fd', '&lt;Cmd&gt;Pick diagnostic scope=\"all\"&lt;CR&gt;',       'Diagnostic workspace')\nnmap_leader('fD', '&lt;Cmd&gt;Pick diagnostic scope=\"current\"&lt;CR&gt;',   'Diagnostic buffer')\nnmap_leader('ff', '&lt;Cmd&gt;Pick files&lt;CR&gt;',                        'Files')\nnmap_leader('fg', '&lt;Cmd&gt;Pick grep_live&lt;CR&gt;',                    'Grep live')\nnmap_leader('fG', '&lt;Cmd&gt;Pick grep pattern=\"&lt;cword&gt;\"&lt;CR&gt;',       'Grep current word')\nnmap_leader('fh', '&lt;Cmd&gt;Pick help&lt;CR&gt;',                         'Help tags')\nnmap_leader('fH', '&lt;Cmd&gt;Pick hl_groups&lt;CR&gt;',                    'Highlight groups')\nnmap_leader('fl', '&lt;Cmd&gt;Pick buf_lines scope=\"all\"&lt;CR&gt;',        'Lines (all)')\nnmap_leader('fL', '&lt;Cmd&gt;Pick buf_lines scope=\"current\"&lt;CR&gt;',    'Lines (buf)')\nnmap_leader('fm', '&lt;Cmd&gt;Pick git_hunks&lt;CR&gt;',                    'Modified hunks (all)')\nnmap_leader('fM', '&lt;Cmd&gt;Pick git_hunks path=\"%\"&lt;CR&gt;',           'Modified hunks (buf)')\nnmap_leader('fr', '&lt;Cmd&gt;Pick resume&lt;CR&gt;',                       'Resume')\nnmap_leader('fR', '&lt;Cmd&gt;Pick lsp scope=\"references\"&lt;CR&gt;',       'References (LSP)')\nnmap_leader('fs', pick_workspace_symbols_live,                  'Symbols workspace (live)')\nnmap_leader('fS', '&lt;Cmd&gt;Pick lsp scope=\"document_symbol\"&lt;CR&gt;',  'Symbols document')\nnmap_leader('fv', '&lt;Cmd&gt;Pick visit_paths cwd=\"\"&lt;CR&gt;',           'Visit paths (all)')\nnmap_leader('fV', '&lt;Cmd&gt;Pick visit_paths&lt;CR&gt;',                  'Visit paths (cwd)')\n\n-- g is for 'Git'. Common usage:\n-- - `&lt;Leader&gt;gs` - show information at cursor\n-- - `&lt;Leader&gt;go` - toggle 'mini.diff' overlay to show in-buffer unstaged changes\n-- - `&lt;Leader&gt;gd` - show unstaged changes as a patch in separate tabpage\n-- - `&lt;Leader&gt;gL` - show Git log of current file\nlocal git_log_cmd = [[Git log --pretty=format:\\%h\\ \\%as\\ │\\ \\%s --topo-order]]\nlocal git_log_buf_cmd = git_log_cmd .. ' --follow -- %'\n\nnmap_leader('ga', '&lt;Cmd&gt;Git diff --cached&lt;CR&gt;',             'Added diff')\nnmap_leader('gA', '&lt;Cmd&gt;Git diff --cached -- %&lt;CR&gt;',        'Added diff buffer')\nnmap_leader('gc', '&lt;Cmd&gt;Git commit&lt;CR&gt;',                    'Commit')\nnmap_leader('gC', '&lt;Cmd&gt;Git commit --amend&lt;CR&gt;',            'Commit amend')\nnmap_leader('gd', '&lt;Cmd&gt;Git diff&lt;CR&gt;',                      'Diff')\nnmap_leader('gD', '&lt;Cmd&gt;Git diff -- %&lt;CR&gt;',                 'Diff buffer')\nnmap_leader('gl', '&lt;Cmd&gt;' .. git_log_cmd .. '&lt;CR&gt;',         'Log')\nnmap_leader('gL', '&lt;Cmd&gt;' .. git_log_buf_cmd .. '&lt;CR&gt;',     'Log buffer')\nnmap_leader('go', '&lt;Cmd&gt;lua MiniDiff.toggle_overlay()&lt;CR&gt;', 'Toggle overlay')\nnmap_leader('gs', '&lt;Cmd&gt;lua MiniGit.show_at_cursor()&lt;CR&gt;',  'Show at cursor')\n\nxmap_leader('gs', '&lt;Cmd&gt;lua MiniGit.show_at_cursor()&lt;CR&gt;', 'Show at selection')\n\n-- l is for 'Language'. Common usage:\n-- - `&lt;Leader&gt;ld` - show more diagnostic details in a floating window\n-- - `&lt;Leader&gt;lr` - perform rename via LSP\n-- - `&lt;Leader&gt;ls` - navigate to source definition of symbol under cursor\n--\n-- NOTE: most LSP mappings represent a more structured way of replacing built-in\n-- LSP mappings (like `:h gra` and others). This is needed because `gr` is mapped\n-- by an \"replace\" operator in 'mini.operators' (which is more commonly used).\nlocal formatting_cmd = '&lt;Cmd&gt;lua require(\"conform\").format({lsp_fallback=true})&lt;CR&gt;'\n\nnmap_leader('la', '&lt;Cmd&gt;lua vim.lsp.buf.code_action()&lt;CR&gt;',     'Actions')\nnmap_leader('ld', '&lt;Cmd&gt;lua vim.diagnostic.open_float()&lt;CR&gt;',   'Diagnostic popup')\nnmap_leader('lf', formatting_cmd,                               'Format')\nnmap_leader('li', '&lt;Cmd&gt;lua vim.lsp.buf.implementation()&lt;CR&gt;',  'Implementation')\nnmap_leader('lh', '&lt;Cmd&gt;lua vim.lsp.buf.hover()&lt;CR&gt;',           'Hover')\nnmap_leader('lr', '&lt;Cmd&gt;lua vim.lsp.buf.rename()&lt;CR&gt;',          'Rename')\nnmap_leader('lR', '&lt;Cmd&gt;lua vim.lsp.buf.references()&lt;CR&gt;',      'References')\nnmap_leader('ls', '&lt;Cmd&gt;lua vim.lsp.buf.definition()&lt;CR&gt;',      'Source definition')\nnmap_leader('lt', '&lt;Cmd&gt;lua vim.lsp.buf.type_definition()&lt;CR&gt;', 'Type definition')\n\nxmap_leader('lf', formatting_cmd, 'Format selection')\n\n-- m is for 'Map'. Common usage:\n-- - `&lt;Leader&gt;mt` - toggle map from 'mini.map' (closed by default)\n-- - `&lt;Leader&gt;mf` - focus on the map for fast navigation\n-- - `&lt;Leader&gt;ms` - change map's side (if it covers something underneath)\nnmap_leader('mf', '&lt;Cmd&gt;lua MiniMap.toggle_focus()&lt;CR&gt;', 'Focus (toggle)')\nnmap_leader('mr', '&lt;Cmd&gt;lua MiniMap.refresh()&lt;CR&gt;',      'Refresh')\nnmap_leader('ms', '&lt;Cmd&gt;lua MiniMap.toggle_side()&lt;CR&gt;',  'Side (toggle)')\nnmap_leader('mt', '&lt;Cmd&gt;lua MiniMap.toggle()&lt;CR&gt;',       'Toggle')\n\n-- o is for 'Other'. Common usage:\n-- - `&lt;Leader&gt;oz` - toggle between \"zoomed\" and regular view of current buffer\nnmap_leader('or', '&lt;Cmd&gt;lua MiniMisc.resize_window()&lt;CR&gt;', 'Resize to default width')\nnmap_leader('ot', '&lt;Cmd&gt;lua MiniTrailspace.trim()&lt;CR&gt;',    'Trim trailspace')\nnmap_leader('oz', '&lt;Cmd&gt;lua MiniMisc.zoom()&lt;CR&gt;',          'Zoom toggle')\n\n-- s is for 'Session'. Common usage:\n-- - `&lt;Leader&gt;sn` - start new session\n-- - `&lt;Leader&gt;sr` - read previously started session\n-- - `&lt;Leader&gt;sd` - delete previously started session\nlocal session_new = 'MiniSessions.write(vim.fn.input(\"Session name: \"))'\n\nnmap_leader('sd', '&lt;Cmd&gt;lua MiniSessions.select(\"delete\")&lt;CR&gt;', 'Delete')\nnmap_leader('sn', '&lt;Cmd&gt;lua ' .. session_new .. '&lt;CR&gt;',         'New')\nnmap_leader('sr', '&lt;Cmd&gt;lua MiniSessions.select(\"read\")&lt;CR&gt;',   'Read')\nnmap_leader('sw', '&lt;Cmd&gt;lua MiniSessions.write()&lt;CR&gt;',          'Write current')\n\n-- t is for 'Terminal'\nnmap_leader('tT', '&lt;Cmd&gt;horizontal term&lt;CR&gt;', 'Terminal (horizontal)')\nnmap_leader('tt', '&lt;Cmd&gt;vertical term&lt;CR&gt;',   'Terminal (vertical)')\n\n-- v is for 'Visits'. Common usage:\n-- - `&lt;Leader&gt;vv` - add    \"core\" label to current file.\n-- - `&lt;Leader&gt;vV` - remove \"core\" label to current file.\n-- - `&lt;Leader&gt;vc` - pick among all files with \"core\" label.\nlocal make_pick_core = function(cwd, desc)\n  return function()\n    local sort_latest = MiniVisits.gen_sort.default({ recency_weight = 1 })\n    local local_opts = { cwd = cwd, filter = 'core', sort = sort_latest }\n    MiniExtra.pickers.visit_paths(local_opts, { source = { name = desc } })\n  end\nend\n\nnmap_leader('vc', make_pick_core('',  'Core visits (all)'),       'Core visits (all)')\nnmap_leader('vC', make_pick_core(nil, 'Core visits (cwd)'),       'Core visits (cwd)')\nnmap_leader('vv', '&lt;Cmd&gt;lua MiniVisits.add_label(\"core\")&lt;CR&gt;',    'Add \"core\" label')\nnmap_leader('vV', '&lt;Cmd&gt;lua MiniVisits.remove_label(\"core\")&lt;CR&gt;', 'Remove \"core\" label')\nnmap_leader('vl', '&lt;Cmd&gt;lua MiniVisits.add_label()&lt;CR&gt;',          'Add label')\nnmap_leader('vL', '&lt;Cmd&gt;lua MiniVisits.remove_label()&lt;CR&gt;',       'Remove label')\n-- stylua: ignore end\n\n\n\nplugin/30_mini.lua\n\n\nCode\n\n-- ┌────────────────────┐\n-- │ MINI configuration │\n-- └────────────────────┘\n--\n-- This file contains configuration of the MINI parts of the config.\n-- It contains only configs for the 'mini.nvim' plugin (installed in 'init.lua').\n--\n-- 'mini.nvim' is a library of modules. Each is enabled independently via\n-- `require('mini.xxx').setup()` convention. It creates all intended side effects:\n-- mappings, autocommands, highlight groups, etc. It also creates a global\n-- `MiniXxx` table that can be later used to access module's features.\n--\n-- Every module's `setup()` function accepts an optional `config` table to\n-- adjust its behavior. See the structure of this table at `:h MiniXxx.config`.\n--\n-- See `:h mini.nvim-general-principles` for more general principles.\n--\n-- Here each module's `setup()` has a brief explanation of what the module is for,\n-- its usage examples (uses Leader mappings from 'plugin/20_keymaps.lua'), and\n-- possible directions for more info.\n-- For more info about a module see its help page (`:h mini.xxx` for 'mini.xxx').\n\n-- To minimize the time until first screen draw, modules are enabled in two steps:\n-- - Step one enables everything that is needed for first draw with `now()`.\n--   Sometimes is needed only if Neovim is started as `nvim -- path/to/file`.\n-- - Everything else is delayed until the first draw with `later()`.\nlocal now, later = MiniDeps.now, MiniDeps.later\nlocal now_if_args = _G.Config.now_if_args\n\n-- Step one ===================================================================\n-- Enable 'miniwinter' color scheme. It comes with 'mini.nvim' and uses 'mini.hues'.\n--\n-- See also:\n-- - `:h mini.nvim-color-schemes` - list of other color schemes\n-- - `:h MiniHues-examples` - how to define highlighting with 'mini.hues'\n-- - 'plugin/40_plugins.lua' honorable mentions - other good color schemes\nnow(function() vim.cmd('colorscheme miniwinter') end)\n\n-- You can try these other 'mini.hues'-based color schemes (uncomment with `gcc`):\n-- now(function() vim.cmd('colorscheme minispring') end)\n-- now(function() vim.cmd('colorscheme minisummer') end)\n-- now(function() vim.cmd('colorscheme miniautumn') end)\n-- now(function() vim.cmd('colorscheme randomhue') end)\n\n-- Common configuration presets. Example usage:\n-- - `&lt;C-s&gt;` in Insert mode - save and go to Normal mode\n-- - `go` / `gO` - insert empty line before/after in Normal mode\n-- - `gy` / `gp` - copy / paste from system clipboard\n-- - `\\` + key - toggle common options. Like `\\h` toggles highlighting search.\n-- - `&lt;C-hjkl&gt;` (four combos) - navigate between windows.\n-- - `&lt;M-hjkl&gt;` in Insert/Command mode - navigate in that mode.\n--\n-- See also:\n-- - `:h MiniBasics.config.options` - list of adjusted options\n-- - `:h MiniBasics.config.mappings` - list of created mappings\n-- - `:h MiniBasics.config.autocommands` - list of created autocommands\nnow(function()\n  require('mini.basics').setup({\n    -- Manage options in 'plugin/10_options.lua' for didactic purposes\n    options = { basic = false },\n    mappings = {\n      -- Create `&lt;C-hjkl&gt;` mappings for window navigation\n      windows = true,\n      -- Create `&lt;M-hjkl&gt;` mappings for navigation in Insert and Command modes\n      move_with_alt = true,\n    },\n  })\nend)\n\n-- Icon provider. Usually no need to use manually. It is used by plugins like\n-- 'mini.pick', 'mini.files', 'mini.statusline', and others.\nnow(function()\n  -- Set up to not prefer extension-based icon for some extensions\n  local ext3_blocklist = { scm = true, txt = true, yml = true }\n  local ext4_blocklist = { json = true, yaml = true }\n  require('mini.icons').setup({\n    use_file_extension = function(ext, _)\n      return not (ext3_blocklist[ext:sub(-3)] or ext4_blocklist[ext:sub(-4)])\n    end,\n  })\n\n  -- Mock 'nvim-tree/nvim-web-devicons' for plugins without 'mini.icons' support.\n  -- Not needed for 'mini.nvim' or MiniMax, but might be useful for others.\n  later(MiniIcons.mock_nvim_web_devicons)\n\n  -- Add LSP kind icons. Useful for 'mini.completion'.\n  later(MiniIcons.tweak_lsp_kind)\nend)\n\n-- Miscellaneous small but useful functions. Example usage:\n-- - `&lt;Leader&gt;oz` - toggle between \"zoomed\" and regular view of current buffer\n-- - `&lt;Leader&gt;or` - resize window to its \"editable width\"\n-- - `:lua put_text(vim.lsp.get_clients())` - put output of a function below\n--   cursor in current buffer. Useful for a detailed exploration.\n-- - `:lua put(MiniMisc.stat_summary(MiniMisc.bench_time(f, 100)))` - run\n--   function `f` 100 times and report statistical summary of execution times\n--\n-- Uses `now()` for `setup_xxx()` to work when started like `nvim -- path/to/file`\nnow_if_args(function()\n  -- Makes `:h MiniMisc.put()` and `:h MiniMisc.put_text()` public\n  require('mini.misc').setup()\n\n  -- Change current working directory based on the current file path. It\n  -- searches up the file tree until the first root marker ('.git' or 'Makefile')\n  -- and sets their parent directory as a current directory.\n  -- This is helpful when simultaneously dealing with files from several projects.\n  MiniMisc.setup_auto_root()\n\n  -- Restore latest cursor position on file open\n  MiniMisc.setup_restore_cursor()\n\n  -- Synchronize terminal emulator background with Neovim's background to remove\n  -- possibly different color padding around Neovim instance\n  MiniMisc.setup_termbg_sync()\nend)\n\n-- Notifications provider. Shows all kinds of notifications in the upper right\n-- corner (by default). Example usage:\n-- - `:h vim.notify()` - show notification (hides automatically)\n-- - `&lt;Leader&gt;en` - show notification history\n--\n-- See also:\n-- - `:h MiniNotify.config` for some of common configuration examples.\nnow(function() require('mini.notify').setup() end)\n\n-- Session management. A thin wrapper around `:h mksession` that consistently\n-- manages session files. Example usage:\n-- - `&lt;Leader&gt;sn` - start new session\n-- - `&lt;Leader&gt;sr` - read previously started session\n-- - `&lt;Leader&gt;sd` - delete previously started session\nnow(function() require('mini.sessions').setup() end)\n\n-- Start screen. This is what is shown when you open Neovim like `nvim`.\n-- Example usage:\n-- - Type prefix keys to limit available candidates\n-- - Navigate down/up with `&lt;C-n&gt;` and `&lt;C-p&gt;`\n-- - Press `&lt;CR&gt;` to select an entry\n--\n-- See also:\n-- - `:h MiniStarter-example-config` - non-default config examples\n-- - `:h MiniStarter-lifecycle` - how to work with Starter buffer\nnow(function() require('mini.starter').setup() end)\n\n-- Statusline. Sets `:h 'statusline'` to show more info in a line below window.\n-- Example usage:\n-- - Left most section indicates current mode (text + highlighting).\n-- - Second from left section shows \"developer info\": Git, diff, diagnostics, LSP.\n-- - Center section shows the name of displayed buffer.\n-- - Second to right section shows more buffer info.\n-- - Right most section shows current cursor coordinates and search results.\n--\n-- See also:\n-- - `:h MiniStatusline-example-content` - example of default content. Use it to\n--   configure a custom statusline by setting `config.content.active` function.\nnow(function() require('mini.statusline').setup() end)\n\n-- Tabline. Sets `:h 'tabline'` to show all listed buffers in a line at the top.\n-- Buffers are ordered as they were created. Navigate with `[b` and `]b`.\nnow(function() require('mini.tabline').setup() end)\n\n-- Step two ===================================================================\n\n-- Extra 'mini.nvim' functionality.\n--\n-- See also:\n-- - `:h MiniExtra.pickers` - pickers. Most are mapped in `&lt;Leader&gt;f` group.\n--   Calling `setup()` makes 'mini.pick' respect 'mini.extra' pickers.\n-- - `:h MiniExtra.gen_ai_spec` - 'mini.ai' textobject specifications\n-- - `:h MiniExtra.gen_highlighter` - 'mini.hipatterns' highlighters\nlater(function() require('mini.extra').setup() end)\n\n-- Extend and create a/i textobjects, like `:h a(`, `:h a'`, and more).\n-- Contains not only `a` and `i` type of textobjects, but also their \"next\" and\n-- \"last\" variants that will explicitly search for textobjects after and before\n-- cursor. Example usage:\n-- - `ci)` - *c*hange *i*inside parenthesis (`)`)\n-- - `di(` - *d*elete *i*inside padded parenthesis (`(`)\n-- - `yaq` - *y*ank *a*round *q*uote (any of \"\", '', or ``)\n-- - `vif` - *v*isually select *i*inside *f*unction call\n-- - `cina` - *c*hange *i*nside *n*ext *a*rgument\n-- - `valaala` - *v*isually select *a*round *l*ast (i.e. previous) *a*rgument\n--   and then again reselect *a*round new *l*ast *a*rgument\n--\n-- See also:\n-- - `:h text-objects` - general info about what textobjects are\n-- - `:h MiniAi-builtin-textobjects` - list of all supported textobjects\n-- - `:h MiniAi-textobject-specification` - examples of custom textobjects\nlater(function()\n  local ai = require('mini.ai')\n  ai.setup({\n    -- 'mini.ai' can be extended with custom textobjects\n    custom_textobjects = {\n      -- Make `aB` / `iB` act on around/inside whole *b*uffer\n      B = MiniExtra.gen_ai_spec.buffer(),\n      -- For more complicated textobjects that require structural awareness,\n      -- use tree-sitter. This example makes `aF`/`iF` mean around/inside function\n      -- definition (not call). See `:h MiniAi.gen_spec.treesitter()` for details.\n      F = ai.gen_spec.treesitter({ a = '@function.outer', i = '@function.inner' }),\n    },\n\n    -- 'mini.ai' by default mostly mimics built-in search behavior: first try\n    -- to find textobject covering cursor, then try to find to the right.\n    -- Although this works in most cases, some are confusing. It is more robust to\n    -- always try to search only covering textobject and explicitly ask to search\n    -- for next (`an`/`in`) or last (`al`/`il`).\n    -- Try this. If you don't like it - delete next line and this comment.\n    search_method = 'cover',\n  })\nend)\n\n-- Align text interactively. Example usage:\n-- - `gaip,` - `ga` (align operator) *i*nside *p*aragraph by comma\n-- - `gAip` - start interactive alignment on the paragraph. Choose how to\n--   split, justify, and merge string parts. Press `&lt;CR&gt;` to make it permanent,\n--   press `&lt;Esc&gt;` to go back to initial state.\n--\n-- See also:\n-- - `:h MiniAlign-example` - hands-on list of examples to practice aligning\n-- - `:h MiniAlign.gen_step` - list of support step customizations\n-- - `:h MiniAlign-algorithm` - how alignment is done on algorithmic level\nlater(function() require('mini.align').setup() end)\n\n-- Animate common Neovim actions. Like cursor movement, scroll, window resize,\n-- window open, window close. Animations are done based on Neovim events and\n-- don't require custom mappings.\n--\n-- It is not enabled by default because its effects are a matter of taste.\n-- Also scroll and resize have some unwanted side effects (see `:h mini.animate`).\n-- Uncomment next line (use `gcc`) to enable.\n-- later(function() require('mini.animate').setup() end)\n\n-- Go forward/backward with square brackets. Implements consistent sets of mappings\n-- for selected targets (like buffers, diagnostic, quickfix list entries, etc.).\n-- Example usage:\n-- - `]b` - go to next buffer\n-- - `[j` - go to previous jump inside current buffer\n-- - `[Q` - go to first entry of quickfix list\n-- - `]X` - go to last conflict marker in a buffer\n--\n-- See also:\n-- - `:h MiniBracketed` - overall mapping design and list of targets\nlater(function() require('mini.bracketed').setup() end)\n\n-- Remove buffers. Opened files occupy space in tabline and buffer picker.\n-- When not needed, they can be removed. Example usage:\n-- - `&lt;Leader&gt;bw` - completely wipeout current buffer (see `:h :bwipeout`)\n-- - `&lt;Leader&gt;bW` - completely wipeout current buffer even if it has changes\n-- - `&lt;Leader&gt;bd` - delete current buffer (see `:h :bdelete`)\nlater(function() require('mini.bufremove').setup() end)\n\n-- Show next key clues in a bottom right window. Requires explicit opt-in for\n-- keys that act as clue trigger. Example usage:\n-- - Press `&lt;Leader&gt;` and wait for 1 second. A window with information about\n--   next available keys should appear.\n-- - Press one of the listed keys. Window updates immediately to show information\n--   about new next available keys. You can press `&lt;BS&gt;` to go back in key sequence.\n-- - Press keys until they resolve into some mapping.\n--\n-- Note: it is designed to work in buffers for normal files. It doesn't work in\n-- special buffers (like for 'mini.starter' or 'mini.files') to not conflict\n-- with its local mappings.\n--\n-- See also:\n-- - `:h MiniClue-examples` - examples of common setups\n-- - `:h MiniClue.ensure_buf_triggers()` - use it to enable triggers in buffer\n-- - `:h MiniClue.set_mapping_desc()` - change mapping description not from config\nlater(function()\n  local miniclue = require('mini.clue')\n  -- stylua: ignore\n  miniclue.setup({\n    -- Define which clues to show. By default shows only clues for custom mappings\n    -- (uses `desc` field from the mapping; takes precedence over custom clue).\n    clues = {\n      -- This is defined in 'plugin/20_keymaps.lua' with Leader group descriptions\n      Config.leader_group_clues,\n      miniclue.gen_clues.builtin_completion(),\n      miniclue.gen_clues.g(),\n      miniclue.gen_clues.marks(),\n      miniclue.gen_clues.registers(),\n      -- This creates a submode for window resize mappings. Try the following:\n      -- - Press `&lt;C-w&gt;s` to make a window split.\n      -- - Press `&lt;C-w&gt;+` to increase height. Clue window still shows clues as if\n      --   `&lt;C-w&gt;` is pressed again. Keep pressing just `+` to increase height.\n      --   Try pressing `-` to decrease height.\n      -- - Stop submode either by `&lt;Esc&gt;` or by any key that is not in submode.\n      miniclue.gen_clues.windows({ submode_resize = true }),\n      miniclue.gen_clues.z(),\n    },\n    -- Explicitly opt-in for set of common keys to trigger clue window\n    triggers = {\n      { mode = 'n', keys = '&lt;Leader&gt;' }, -- Leader triggers\n      { mode = 'x', keys = '&lt;Leader&gt;' },\n      { mode = 'n', keys = '\\\\' },       -- mini.basics\n      { mode = 'n', keys = '[' },        -- mini.bracketed\n      { mode = 'n', keys = ']' },\n      { mode = 'x', keys = '[' },\n      { mode = 'x', keys = ']' },\n      { mode = 'i', keys = '&lt;C-x&gt;' },    -- Built-in completion\n      { mode = 'n', keys = 'g' },        -- `g` key\n      { mode = 'x', keys = 'g' },\n      { mode = 'n', keys = \"'\" },        -- Marks\n      { mode = 'n', keys = '`' },\n      { mode = 'x', keys = \"'\" },\n      { mode = 'x', keys = '`' },\n      { mode = 'n', keys = '\"' },        -- Registers\n      { mode = 'x', keys = '\"' },\n      { mode = 'i', keys = '&lt;C-r&gt;' },\n      { mode = 'c', keys = '&lt;C-r&gt;' },\n      { mode = 'n', keys = '&lt;C-w&gt;' },    -- Window commands\n      { mode = 'n', keys = 'z' },        -- `z` key\n      { mode = 'x', keys = 'z' },\n    },\n  })\nend)\n\n-- Tweak and save any color scheme. Contains utility functions to work with\n-- color spaces and color schemes. Example usage:\n-- - `:Colorscheme default` - switch with animation to the default color scheme\n--\n-- See also:\n-- - `:h MiniColors.interactive()` - interactively tweak color scheme\n-- - `:h MiniColors-recipes` - common recipes to use during interactive tweaking\n-- - `:h MiniColors.convert()` - convert between color spaces\n-- - `:h MiniColors-color-spaces` - list of supported color sapces\n--\n-- It is not enabled by default because it is not really needed on a daily basis.\n-- Uncomment next line (use `gcc`) to enable.\n-- later(function() require('mini.colors').setup() end)\n\n-- Comment lines. Provides functionality to work with commented lines.\n-- Uses `:h 'commentstring'` option to infer comment structure.\n-- Example usage:\n-- - `gcip` - toggle comment (`gc`) *i*inside *p*aragraph\n-- - `vapgc` - *v*isually select *a*round *p*aragraph and toggle comment (`gc`)\n-- - `gcgc` - uncomment (`gc`, operator) comment block at cursor (`gc`, textobject)\n--\n-- The built-in `:h commenting` is based on 'mini.comment'. Yet this module is\n-- still enabled as it provides more customization opportunities.\nlater(function() require('mini.comment').setup() end)\n\n-- Completion and signature help. Implements async \"two stage\" autocompletion:\n-- - Based on attached LSP servers that support completion.\n-- - Fallback (based on built-in keyword completion) if there is no LSP candidates.\n--\n-- Example usage in Insert mode with attached LSP:\n-- - Start typing text that should be recognized by LSP (like variable name).\n-- - After 100ms a popup menu with candidates appears.\n-- - Press `&lt;Tab&gt;` / `&lt;S-Tab&gt;` to navigate down/up the list. These are set up\n--   in 'mini.keymap'. You can also use `&lt;C-n&gt;` / `&lt;C-p&gt;`.\n-- - During navigation there is an info window to the right showing extra info\n--   that the LSP server can provide about the candidate. It appears after the\n--   candidate stays selected for 100ms. Use `&lt;C-f&gt;` / `&lt;C-b&gt;` to scroll it.\n-- - Navigating to an entry also changes buffer text. If you are happy with it,\n--   keep typing after it. To discard completion completely, press `&lt;C-e&gt;`.\n-- - After pressing special trigger(s), usually `(`, a window appears that shows\n--   the signature of the current function/method. It gets updated as you type\n--   showing the currently active parameter.\n--\n-- Example usage in Insert mode without an attached LSP or in places not\n-- supported by the LSP (like comments):\n-- - Start typing a word that is present in current or opened buffers.\n-- - After 100ms popup menu with candidates appears.\n-- - Navigate with `&lt;Tab&gt;` / `&lt;S-Tab&gt;` or `&lt;C-n&gt;` / `&lt;C-p&gt;`. This also updates\n--   buffer text. If happy with choice, keep typing. Stop with `&lt;C-e&gt;`.\n--\n-- It also works with snippet candidates provided by LSP server. Best experience\n-- when paired with 'mini.snippets' (which is set up in this file).\nlater(function()\n  -- Customize post-processing of LSP responses for a better user experience.\n  -- Don't show 'Text' suggestions (usually noisy) and show snippets last.\n  local process_items_opts = { kind_priority = { Text = -1, Snippet = 99 } }\n  local process_items = function(items, base)\n    return MiniCompletion.default_process_items(items, base, process_items_opts)\n  end\n  require('mini.completion').setup({\n    lsp_completion = {\n      -- Without this config autocompletion is set up through `:h 'completefunc'`.\n      -- Although not needed, setting up through `:h 'omnifunc'` is cleaner\n      -- (sets up only when needed) and makes it possible to use `&lt;C-u&gt;`.\n      source_func = 'omnifunc',\n      auto_setup = false,\n      process_items = process_items,\n    },\n  })\n\n  -- Set 'omnifunc' for LSP completion only when needed.\n  local on_attach = function(ev)\n    vim.bo[ev.buf].omnifunc = 'v:lua.MiniCompletion.completefunc_lsp'\n  end\n  _G.Config.new_autocmd('LspAttach', nil, on_attach, \"Set 'omnifunc'\")\n\n  -- Advertise to servers that Neovim now supports certain set of completion and\n  -- signature features through 'mini.completion'.\n  vim.lsp.config('*', { capabilities = MiniCompletion.get_lsp_capabilities() })\nend)\n\n-- Autohighlight word under cursor with a customizable delay.\n-- Word boundaries are defined based on `:h 'iskeyword'` option.\n--\n-- It is not enabled by default because its effects are a matter of taste.\n-- Uncomment next line (use `gcc`) to enable.\n-- later(function() require('mini.cursorword').setup() end)\n\n-- Work with diff hunks that represent the difference between the buffer text and\n-- some reference text set by a source. Default source uses text from Git index.\n-- Also provides summary info used in developer section of 'mini.statusline'.\n-- Example usage:\n-- - `ghip` - apply hunks (`gh`) within *i*nside *p*aragraph\n-- - `gHG` - reset hunks (`gH`) from cursor until end of buffer (`G`)\n-- - `ghgh` - apply (`gh`) hunk at cursor (`gh`)\n-- - `gHgh` - reset (`gH`) hunk at cursor (`gh`)\n-- - `&lt;Leader&gt;go` - toggle overlay\n--\n-- See also:\n-- - `:h MiniDiff-overview` - overview of how module works\n-- - `:h MiniDiff-diff-summary` - available summary information\n-- - `:h MiniDiff.gen_source` - available built-in sources\nlater(function() require('mini.diff').setup() end)\n\n-- Navigate and manipulate file system\n--\n-- Navigation is done using column view (Miller columns) to display nested\n-- directories, they are displayed in floating windows in top left corner.\n--\n-- Manipulate files and directories by editing text as regular buffers.\n--\n-- Example usage:\n-- - `&lt;Leader&gt;ed` - open current working directory\n-- - `&lt;Leader&gt;ef` - open directory of current file (needs to be present on disk)\n--\n-- Basic navigation:\n-- - `l` - go in entry at cursor: navigate into directory or open file\n-- - `h` - go out of focused directory\n-- - Navigate window as any regular buffer\n-- - Press `g?` inside explorer to see more mappings\n--\n-- Basic manipulation:\n-- - After any following action, press `=` in Normal mode to synchronize, read\n--   carefully about actions, press `y` or `&lt;CR&gt;` to confirm\n-- - New entry: press `o` and type its name; end with `/` to create directory\n-- - Rename: press `C` and type new name\n-- - Delete: type `dd`\n-- - Move/copy: type `dd`/`yy`, navigate to target directory, press `p`\n--\n-- See also:\n-- - `:h MiniFiles-navigation` - more details about how to navigate\n-- - `:h MiniFiles-manipulation` - more details about how to manipulate\n-- - `:h MiniFiles-examples` - examples of common setups\nlater(function()\n  -- Enable directory/file preview\n  require('mini.files').setup({ windows = { preview = true } })\n\n  -- Add common bookmarks for every explorer. Example usage inside explorer:\n  -- - `'c` to navigate into your config directory\n  -- - `g?` to see available bookmarks\n  local add_marks = function()\n    MiniFiles.set_bookmark('c', vim.fn.stdpath('config'), { desc = 'Config' })\n    local minideps_plugins = vim.fn.stdpath('data') .. '/site/pack/deps/opt'\n    MiniFiles.set_bookmark('p', minideps_plugins, { desc = 'Plugins' })\n    MiniFiles.set_bookmark('w', vim.fn.getcwd, { desc = 'Working directory' })\n  end\n  _G.Config.new_autocmd('User', 'MiniFilesExplorerOpen', add_marks, 'Add bookmarks')\nend)\n\n-- Git integration for more straightforward Git actions based on Neovim's state.\n-- It is not meant as a fully featured Git client, only to provide helpers that\n-- integrate better with Neovim. Example usage:\n-- - `&lt;Leader&gt;gs` - show information at cursor\n-- - `&lt;Leader&gt;gd` - show unstaged changes as a patch in separate tabpage\n-- - `&lt;Leader&gt;gL` - show Git log of current file\n-- - `:Git help git` - show output of `git help git` inside Neovim\n--\n-- See also:\n-- - `:h MiniGit-examples` - examples of common setups\n-- - `:h :Git` - more details about `:Git` user command\n-- - `:h MiniGit.show_at_cursor()` - what information at cursor is shown\nlater(function() require('mini.git').setup() end)\n\n-- Highlight patterns in text. Like `TODO`/`NOTE` or color hex codes.\n-- Example usage:\n-- - `:Pick hipatterns` - pick among all highlighted patterns\n--\n-- See also:\n-- - `:h MiniHipatterns-examples` - examples of common setups\nlater(function()\n  local hipatterns = require('mini.hipatterns')\n  local hi_words = MiniExtra.gen_highlighter.words\n  hipatterns.setup({\n    highlighters = {\n      -- Highlight a fixed set of common words. Will be highlighted in any place,\n      -- not like \"only in comments\".\n      fixme = hi_words({ 'FIXME', 'Fixme', 'fixme' }, 'MiniHipatternsFixme'),\n      hack = hi_words({ 'HACK', 'Hack', 'hack' }, 'MiniHipatternsHack'),\n      todo = hi_words({ 'TODO', 'Todo', 'todo' }, 'MiniHipatternsTodo'),\n      note = hi_words({ 'NOTE', 'Note', 'note' }, 'MiniHipatternsNote'),\n\n      -- Highlight hex color string (#aabbcc) with that color as a background\n      hex_color = hipatterns.gen_highlighter.hex_color(),\n    },\n  })\nend)\n\n-- Visualize and work with indent scope. It visualizes indent scope \"at cursor\"\n-- with animated vertical line. Provides relevant motions and textobjects.\n-- Example usage:\n-- - `cii` - *c*hange *i*nside *i*ndent scope\n-- - `Vaiai` - *V*isually select *a*round *i*ndent scope and then again\n--   reselect *a*round new *i*indent scope\n-- - `[i` / `]i` - navigate to scope's top / bottom\n--\n-- See also:\n-- - `:h MiniIndentscope.gen_animation` - available animation rules\nlater(function() require('mini.indentscope').setup() end)\n\n-- Jump to next/previous single character. It implements \"smarter `fFtT` keys\"\n-- (see `:h f`) that work across multiple lines, start \"jumping mode\", and\n-- highlight all target matches. Example usage:\n-- - `fxff` - move *f*orward onto next character \"x\", then next, and next again\n-- - `dt)` - *d*elete *t*ill next closing parenthesis (`)`)\nlater(function() require('mini.jump').setup() end)\n\n-- Jump within visible lines to pre-defined spots via iterative label filtering.\n-- Spots are computed by a configurable spotter function. Example usage:\n-- - Lock eyes on desired location to jump\n-- - `&lt;CR&gt;` - start jumping; this shows character labels over target spots\n-- - Type character that appears over desired location; number of target spots\n--   should be reduced\n-- - Keep typing labels until target spot is unique to perform the jump\n--\n-- See also:\n-- - `:h MiniJump2d.gen_spotter` - list of available spotters\nlater(function() require('mini.jump2d').setup() end)\n\n-- Special key mappings. Provides helpers to map:\n-- - Multi-step actions. Apply action 1 if condition is met; else apply\n--   action 2 if condition is met; etc.\n-- - Combos. Sequence of keys where each acts immediately plus execute extra\n--   action if all are typed fast enough. Useful for Insert mode mappings to not\n--   introduce delay when typing mapping keys without intention to execute action.\n--\n-- See also:\n-- - `:h MiniKeymap-examples` - examples of common setups\n-- - `:h MiniKeymap.map_multistep()` - map multi-step action\n-- - `:h MiniKeymap.map_combo()` - map combo\nlater(function()\n  require('mini.keymap').setup()\n  -- Navigate 'mini.completion' menu with `&lt;Tab&gt;` /  `&lt;S-Tab&gt;`\n  MiniKeymap.map_multistep('i', '&lt;Tab&gt;', { 'pmenu_next' })\n  MiniKeymap.map_multistep('i', '&lt;S-Tab&gt;', { 'pmenu_prev' })\n  -- On `&lt;CR&gt;` try to accept current completion item, fall back to accounting\n  -- for pairs from 'mini.pairs'\n  MiniKeymap.map_multistep('i', '&lt;CR&gt;', { 'pmenu_accept', 'minipairs_cr' })\n  -- On `&lt;BS&gt;` just try to account for pairs from 'mini.pairs'\n  MiniKeymap.map_multistep('i', '&lt;BS&gt;', { 'minipairs_bs' })\nend)\n\n-- Window with text overview. It is displayed on the right hand side. Can be used\n-- for quick overview and navigation. Hidden by default. Example usage:\n-- - `&lt;Leader&gt;mt` - toggle map window\n-- - `&lt;Leader&gt;mf` - focus on the map for fast navigation\n-- - `&lt;Leader&gt;ms` - change map's side (if it covers something underneath)\n--\n-- See also:\n-- - `:h MiniMap.gen_encode_symbols` - list of symbols to use for text encoding\n-- - `:h MiniMap.gen_integration` - list of integrations to show in the map\n--\n-- NOTE: Might introduce lag on very big buffers (10000+ lines)\nlater(function()\n  local map = require('mini.map')\n  map.setup({\n    -- Use Braille dots to encode text\n    symbols = { encode = map.gen_encode_symbols.dot('4x2') },\n    -- Show built-in search matches, 'mini.diff' hunks, and diagnostic entries\n    integrations = {\n      map.gen_integration.builtin_search(),\n      map.gen_integration.diff(),\n      map.gen_integration.diagnostic(),\n    },\n  })\n\n  -- Map built-in navigation characters to force map refresh\n  for _, key in ipairs({ 'n', 'N', '*', '#' }) do\n    local rhs = key\n      -- Also open enough folds when jumping to the next match\n      .. 'zv'\n      .. '&lt;Cmd&gt;lua MiniMap.refresh({}, { lines = false, scrollbar = false })&lt;CR&gt;'\n    vim.keymap.set('n', key, rhs)\n  end\nend)\n\n-- Move any selection in any direction. Example usage in Normal mode:\n-- - `&lt;M-j&gt;`/`&lt;M-k&gt;` - move current line down / up\n-- - `&lt;M-h&gt;`/`&lt;M-l&gt;` - decrease / increase indent of current line\n--\n-- Example usage in Visual mode:\n-- - `&lt;M-h&gt;`/`&lt;M-j&gt;`/`&lt;M-k&gt;`/`&lt;M-l&gt;` - move selection left/down/up/right\nlater(function() require('mini.move').setup() end)\n\n-- Text edit operators. All operators have mappings for:\n-- - Regular operator (waits for motion/textobject to use)\n-- - Current line action (repeat second character of operator to activate)\n-- - Act on visual selection (type operator in Visual mode)\n--\n-- Example usage:\n-- - `griw` - replace (`gr`) *i*inside *w*ord\n-- - `gmm` - multiple/duplicate (`gm`) current line (extra `m`)\n-- - `vipgs` - *v*isually select *i*nside *p*aragraph and sort it (`gs`)\n-- - `gxiww.` - exchange (`gx`) *i*nside *w*ord with next word (`w` to navigate\n--   to it and `.` to repeat exchange operator)\n-- - `g==` - execute current line as Lua code and replace with its output.\n--   For example, typing `g==` over line `vim.lsp.get_clients()` shows\n--   information about all available LSP clients.\n--\n-- See also:\n-- - `:h MiniOperators-mappings` - overview of how mappings are created\n-- - `:h MiniOperators-overview` - overview of present operators\nlater(function()\n  require('mini.operators').setup()\n\n  -- Create mappings for swapping adjacent arguments. Notes:\n  -- - Relies on `a` argument textobject from 'mini.ai'.\n  -- - It is not 100% reliable, but mostly works.\n  -- - It overrides `:h (` and `:h )`.\n  -- Explanation: `gx`-`ia`-`gx`-`ila` &lt;=&gt; exchange current and last argument\n  -- Usage: when on `a` in `(aa, bb)` press `)` followed by `(`.\n  vim.keymap.set('n', '(', 'gxiagxila', { remap = true, desc = 'Swap arg left' })\n  vim.keymap.set('n', ')', 'gxiagxina', { remap = true, desc = 'Swap arg right' })\nend)\n\n-- Autopairs functionality. Insert pair when typing opening character and go over\n-- right character if it is already to cursor's right. Also provides mappings for\n-- `&lt;CR&gt;` and `&lt;BS&gt;` to perform extra actions when inside pair.\n-- Example usage in Insert mode:\n-- - `(` - insert \"()\" and put cursor between them\n-- - `)` when there is \")\" to the right - jump over \")\" without inserting new one\n-- - `&lt;C-v&gt;(` - always insert a single \"(\" literally. This is useful since\n--   'mini.pairs' doesn't provide particularly smart behavior, like auto balancing\nlater(function()\n  -- Create pairs not only in Insert, but also in Command line mode\n  require('mini.pairs').setup({ modes = { command = true } })\nend)\n\n-- Pick anything with single window layout and fast matching. This is one of\n-- the main usability improvements as it powers a lot of \"find things quickly\"\n-- workflows. How to use a picker:\n-- - Start picker, usually with `:Pick &lt;picker-name&gt;` command. Like `:Pick files`.\n--   It shows a single window in the bottom left corner filled with possible items\n--   to choose from. Current item has special full line highlighting.\n--   At the top there is a current query used to filter+sort items.\n-- - Type characters (appear at top) to narrow down items. There is fuzzy matching:\n--   characters may not match one-by-one, but they should be in correct order.\n-- - Navigate down/up with `&lt;C-n&gt;`/`&lt;C-p&gt;`.\n-- - Press `&lt;Tab&gt;` to show item's preview. `&lt;Tab&gt;` again goes back to items.\n-- - Press `&lt;S-Tab&gt;` to show picker's info. `&lt;S-Tab&gt;` again goes back to items.\n-- - Press `&lt;CR&gt;` to choose an item. The exact action depends on the picker: `files`\n--   picker opens a selected file, `help` picker opens help page on selected tag.\n--   To close picker without choosing an item, press `&lt;Esc&gt;`.\n--\n-- Example usage:\n-- - `&lt;Leader&gt;ff` - *f*ind *f*iles; for best performance requires `ripgrep`\n-- - `&lt;Leader&gt;fg` - *f*ind inside files (a.k.a. \"to *g*rep\"); requires `ripgrep`\n-- - `&lt;Leader&gt;fh` - *f*ind *h*elp tag\n-- - `&lt;Leader&gt;fr` - *r*esume latest picker\n-- - `:h vim.ui.select()` - implemented with 'mini.pick'\n--\n-- See also:\n-- - `:h MiniPick-overview` - overview of picker functionality\n-- - `:h MiniPick-examples` - examples of common setups\n-- - `:h MiniPick.builtin` and `:h MiniExtra.pickers` - available pickers;\n--   Execute one either with Lua function, `:Pick &lt;picker-name&gt;` command, or\n--   one of `&lt;Leader&gt;f` mappings defined in 'plugin/20_keymaps.lua'\nlater(function() require('mini.pick').setup() end)\n\n-- Manage and expand snippets (templates for a frequently used text).\n-- Typical workflow is to type snippet's (configurable) prefix and expand it\n-- into a snippet session.\n--\n-- How to manage snippets:\n-- - 'mini.snippets' itself doesn't come with preconfigured snippets. Instead there\n--   is a flexible system of how snippets are prepared before expanding.\n--   They can come from pre-defined path on disk, 'snippets/' directories inside\n--   config or plugins, defined inside `setup()` call directly.\n-- - This config, however, does come with snippet configuration:\n--     - 'snippets/global.json' is a file with global snippets that will be\n--       available in any buffer\n--     - 'after/snippets/lua.json' defines personal snippets for Lua language\n--     - 'friendly-snippets' plugin configured in 'plugin/40_plugins.lua' provides\n--       a collection of language snippets\n--\n-- How to expand a snippet in Insert mode:\n-- - If you know snippet's prefix, type it as a word and press `&lt;C-j&gt;`. Snippet's\n--   body should be inserted instead of the prefix.\n-- - If you don't remember snippet's prefix, type only part of it (or none at all)\n--   and press `&lt;C-j&gt;`. It should show picker with all snippets that have prefixes\n--   matching typed characters (or all snippets if none was typed).\n--   Choose one and its body should be inserted instead of previously typed text.\n--\n-- How to navigate during snippet session:\n-- - Snippets can contain tabstops - places for user to interactively adjust text.\n--   Each tabstop is highlighted depending on session progression - whether tabstop\n--   is current, was or was not visited. If tabstop doesn't yet have text, it is\n--   visualized with special \"ghost\" inline text: • and ∎ by default.\n-- - Type necessary text at current tabstop and navigate to next/previous one\n--   by pressing `&lt;C-l&gt;` / `&lt;C-h&gt;`.\n-- - Repeat previous step until you reach special final tabstop, usually denoted\n--   by ∎ symbol. If you spotted a mistake in an earlier tabstop, navigate to it\n--   and return back to the final tabstop.\n-- - To end a snippet session when at final tabstop, keep typing or go into\n--   Normal mode. To force end snippet session, press `&lt;C-c&gt;`.\n--\n-- See also:\n-- - `:h MiniSnippets-overview` - overview of how module works\n-- - `:h MiniSnippets-examples` - examples of common setups\n-- - `:h MiniSnippets-session` - details about snippet session\n-- - `:h MiniSnippets.gen_loader` - list of available loaders\nlater(function()\n  -- Define language patterns to work better with 'friendly-snippets'\n  local latex_patterns = { 'latex/**/*.json', '**/latex.json' }\n  local lang_patterns = {\n    tex = latex_patterns,\n    plaintex = latex_patterns,\n    -- Recognize special injected language of markdown tree-sitter parser\n    markdown_inline = { 'markdown.json' },\n  }\n\n  local snippets = require('mini.snippets')\n  local config_path = vim.fn.stdpath('config')\n  snippets.setup({\n    snippets = {\n      -- Always load 'snippets/global.json' from config directory\n      snippets.gen_loader.from_file(config_path .. '/snippets/global.json'),\n      -- Load from 'snippets/' directory of plugins, like 'friendly-snippets'\n      snippets.gen_loader.from_lang({ lang_patterns = lang_patterns }),\n    },\n  })\n\n  -- By default snippets available at cursor are not shown as candidates in\n  -- 'mini.completion' menu. This requires a dedicated in-process LSP server\n  -- that will provide them. To have that, uncomment next line (use `gcc`).\n  -- MiniSnippets.start_lsp_server()\nend)\n\n-- Split and join arguments (regions inside brackets between allowed separators).\n-- It uses Lua patterns to find arguments, which means it works in comments and\n-- strings but can be not as accurate as tree-sitter based solutions.\n-- Each action can be configured with hooks (like add/remove trailing comma).\n-- Example usage:\n-- - `gS` - toggle between joined (all in one line) and split (each on a separate\n--   line and indented) arguments. It is dot-repeatable (see `:h .`).\n--\n-- See also:\n-- - `:h MiniSplitjoin.gen_hook` - list of available hooks\nlater(function() require('mini.splitjoin').setup() end)\n\n-- Surround actions: add/delete/replace/find/highlight. Working with surroundings\n-- is surprisingly common: surround word with quotes, replace `)` with `]`, etc.\n-- This module comes with many built-in surroundings, each identified by a single\n-- character. It searches only for surrounding that covers cursor and comes with\n-- a special \"next\" / \"last\" versions of actions to search forward or backward\n-- (just like 'mini.ai'). All text editing actions are dot-repeatable (see `:h .`).\n--\n-- Example usage (this may feel intimidating at first, but after practice it\n-- becomes second nature during text editing):\n-- - `saiw)` - *s*urround *a*dd for *i*nside *w*ord parenthesis (`)`)\n-- - `sdf`   - *s*urround *d*elete *f*unction call (like `f(var)` -&gt; `var`)\n-- - `srb[`  - *s*urround *r*eplace *b*racket (any of [], (), {}) with padded `[`\n-- - `sf*`   - *s*urround *f*ind right part of `*` pair (like bold in markdown)\n-- - `shf`   - *s*urround *h*ighlight current *f*unction call\n-- - `srn{{` - *s*urround *r*eplace *n*ext curly bracket `{` with padded `{`\n-- - `sdl'`  - *s*urround *d*elete *l*ast quote pair (`'`)\n-- - `vaWsa&lt;Space&gt;` - *v*isually select *a*round *W*ORD and *s*urround *a*dd\n--                    spaces (`&lt;Space&gt;`)\n--\n-- See also:\n-- - `:h MiniSurround-builtin-surroundings` - list of all supported surroundings\n-- - `:h MiniSurround-surrounding-specification` - examples of custom surroundings\n-- - `:h MiniSurround-vim-surround-config` - alternative set of action mappings\nlater(function() require('mini.surround').setup() end)\n\n-- Highlight and remove trailspace. Temporarily stops highlighting in Insert mode\n-- to reduce noise when typing. Example usage:\n-- - `&lt;Leader&gt;ot` - trim all trailing whitespace in a buffer\nlater(function() require('mini.trailspace').setup() end)\n\n-- Track and reuse file system visits. Every file/directory visit is persistently\n-- tracked on disk to later reuse: show in special frecency order, etc. It also\n-- supports adding labels to visited paths to quickly navigate between them.\n-- Example usage:\n-- - `&lt;Leader&gt;fv` - find across all visits\n-- - `&lt;Leader&gt;vv` / `&lt;Leader&gt;vV` - add/remove special \"core\" label to current file\n-- - `&lt;Leader&gt;vc` / `&lt;Leader&gt;vC` - show files with \"core\" label; all or added within\n--   current working directory\n--\n-- See also:\n-- - `:h MiniVisits-overview` - overview of how module works\n-- - `:h MiniVisits-examples` - examples of common setups\nlater(function() require('mini.visits').setup() end)\n\n-- Not mentioned here, but can be useful:\n-- - 'mini.doc' - needed only for plugin developers.\n-- - 'mini.fuzzy' - not really needed on a daily basis.\n-- - 'mini.test' - needed only for plugin developers.\n\n\n\nplugin/40_plugins.lua\n\n\nCode\n\n-- ┌─────────────────────────┐\n-- │ Plugins outside of MINI │\n-- └─────────────────────────┘\n--\n-- This file contains installation and configuration of plugins outside of MINI.\n-- They significantly improve user experience in a way not yet possible with MINI.\n-- These are mostly plugins that provide programming language specific behavior.\n--\n-- Use this file to install and configure other such plugins.\n\n-- Make concise helpers for installing/adding plugins in two stages\nlocal add, later = MiniDeps.add, MiniDeps.later\nlocal now_if_args = _G.Config.now_if_args\n\n-- Tree-sitter ================================================================\n\n-- Tree-sitter is a tool for fast incremental parsing. It converts text into\n-- a hierarchical structure (called tree) that can be used to implement advanced\n-- and/or more precise actions: syntax highlighting, textobjects, indent, etc.\n--\n-- Tree-sitter support is built into Neovim (see `:h treesitter`). However, it\n-- requires two extra pieces that don't come with Neovim directly:\n-- - Language parsers: programs that convert text into trees. Some are built-in\n--   (like for Lua), 'nvim-treesitter' provides many others.\n--   NOTE: It requires third party software to build and install parsers.\n--   See the link for more info in \"Requirements\" section of the MiniMax README.\n-- - Query files: definitions of how to extract information from trees in\n--   a useful manner (see `:h treesitter-query`). 'nvim-treesitter' also provides\n--   these, while 'nvim-treesitter-textobjects' provides the ones for Neovim\n--   textobjects (see `:h text-objects`, `:h MiniAi.gen_spec.treesitter()`).\n--\n-- Add these plugins now if file (and not 'mini.starter') is shown after startup.\nnow_if_args(function()\n  add({\n    source = 'nvim-treesitter/nvim-treesitter',\n    -- Update tree-sitter parser after plugin is updated\n    hooks = { post_checkout = function() vim.cmd('TSUpdate') end },\n  })\n  add({\n    source = 'nvim-treesitter/nvim-treesitter-textobjects',\n    -- Use `main` branch since `master` branch is frozen, yet still default\n    -- It is needed for compatibility with 'nvim-treesitter' `main` branch\n    checkout = 'main',\n  })\n\n  -- Define languages which will have parsers installed and auto enabled\n  local languages = {\n    -- These are already pre-installed with Neovim. Used as an example.\n    'lua',\n    'vimdoc',\n    'markdown',\n    -- Add here more languages with which you want to use tree-sitter\n    -- To see available languages:\n    -- - Execute `:=require('nvim-treesitter').get_available()`\n    -- - Visit 'SUPPORTED_LANGUAGES.md' file at\n    --   https://github.com/nvim-treesitter/nvim-treesitter/blob/main\n  }\n  local isnt_installed = function(lang)\n    return #vim.api.nvim_get_runtime_file('parser/' .. lang .. '.*', false) == 0\n  end\n  local to_install = vim.tbl_filter(isnt_installed, languages)\n  if #to_install &gt; 0 then require('nvim-treesitter').install(to_install) end\n\n  -- Enable tree-sitter after opening a file for a target language\n  local filetypes = {}\n  for _, lang in ipairs(languages) do\n    for _, ft in ipairs(vim.treesitter.language.get_filetypes(lang)) do\n      table.insert(filetypes, ft)\n    end\n  end\n  local ts_start = function(ev) vim.treesitter.start(ev.buf) end\n  _G.Config.new_autocmd('FileType', filetypes, ts_start, 'Start tree-sitter')\nend)\n\n-- Language servers ===========================================================\n\n-- Language Server Protocol (LSP) is a set of conventions that power creation of\n-- language specific tools. It requires two parts:\n-- - Server - program that performs language specific computations.\n-- - Client - program that asks server for computations and shows results.\n--\n-- Here Neovim itself is a client (see `:h vim.lsp`). Language servers need to\n-- be installed separately based on your OS, CLI tools, and preferences.\n-- See note about 'mason.nvim' at the bottom of the file.\n--\n-- Neovim's team collects commonly used configurations for most language servers\n-- inside 'neovim/nvim-lspconfig' plugin.\n--\n-- Add it now if file (and not 'mini.starter') is shown after startup.\nnow_if_args(function()\n  add('neovim/nvim-lspconfig')\n\n  -- Use `:h vim.lsp.enable()` to automatically enable language server based on\n  -- the rules provided by 'nvim-lspconfig'.\n  -- Use `:h vim.lsp.config()` or 'after/lsp/' directory to configure servers.\n  -- Uncomment and tweak the following `vim.lsp.enable()` call to enable servers.\n  -- vim.lsp.enable({\n  --   -- For example, if `lua-language-server` is installed, use `'lua_ls'` entry\n  -- })\nend)\n\n-- Formatting =================================================================\n\n-- Programs dedicated to text formatting (a.k.a. formatters) are very useful.\n-- Neovim has built-in tools for text formatting (see `:h gq` and `:h 'formatprg'`).\n-- They can be used to configure external programs, but it might become tedious.\n--\n-- The 'stevearc/conform.nvim' plugin is a good and maintained solution for easier\n-- formatting setup.\nlater(function()\n  add('stevearc/conform.nvim')\n\n  -- See also:\n  -- - `:h Conform`\n  -- - `:h conform-options`\n  -- - `:h conform-formatters`\n  require('conform').setup({\n    -- Map of filetype to formatters\n    -- Make sure that necessary CLI tool is available\n    -- formatters_by_ft = { lua = { 'stylua' } },\n  })\nend)\n\n-- Snippets ===================================================================\n\n-- Although 'mini.snippets' provides functionality to manage snippet files, it\n-- deliberately doesn't come with those.\n--\n-- The 'rafamadriz/friendly-snippets' is currently the largest collection of\n-- snippet files. They are organized in 'snippets/' directory (mostly) per language.\n-- 'mini.snippets' is designed to work with it as seamlessly as possible.\n-- See `:h MiniSnippets.gen_loader.from_lang()`.\nlater(function() add('rafamadriz/friendly-snippets') end)\n\n-- Honorable mentions =========================================================\n\n-- 'mason-org/mason.nvim' (a.k.a. \"Mason\") is a great tool (package manager) for\n-- installing external language servers, formatters, and linters. It provides\n-- a unified interface for installing, updating, and deleting such programs.\n--\n-- The caveat is that these programs will be set up to be mostly used inside Neovim.\n-- If you need them to work elsewhere, consider using other package managers.\n--\n-- You can use it like so:\n-- now_if_args(function()\n--   add('mason-org/mason.nvim')\n--   require('mason').setup()\n-- end)\n\n-- Beautiful, usable, well maintained color schemes outside of 'mini.nvim' and\n-- have full support of its highlight groups. Use if you don't like 'miniwinter'\n-- enabled in 'plugin/30_mini.lua' or other suggested 'mini.hues' based ones.\n-- MiniDeps.now(function()\n--   -- Install only those that you need\n--   add('sainnhe/everforest')\n--   add('Shatur/neovim-ayu')\n--   add('ellisonleao/gruvbox.nvim')\n--\n--   -- Enable only one\n--   vim.cmd('color everforest')\n-- end)\n\n\n\nsnippets/global.json\n\n\nCode\n\n{\n  \"Current datetime\": {\n    \"prefix\": \"cdtm\",\n    \"body\": \"$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\",\n    \"description\": \"Insert current datetime (YYYY-mm-dd HH:MM:SS)\"\n  },\n  \"Current date\": {\n    \"prefix\": \"cdate\",\n    \"body\": \"$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE\",\n    \"description\": \"Insert current date (YYYY-mm-dd)\"\n  },\n  \"Current time\": {\n    \"prefix\": \"ctime\",\n    \"body\": \"$CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\",\n    \"description\": \"Insert current time (HH:MM:SS)\"\n  }\n}\n\n\n\nafter/ftplugin/markdown.lua\n\n\nCode\n\n-- ┌─────────────────────────┐\n-- │ Filetype config example │\n-- └─────────────────────────┘\n--\n-- This is an example of a configuration that will apply only to a particular\n-- filetype, which is the same as file's basename ('markdown' in this example;\n-- which is for '*.md' files).\n--\n-- It can contain any code which will be usually executed when the file is opened\n-- (strictly speaking, on every 'filetype' option value change to target value).\n-- Usually it needs to define buffer/window local options and variables.\n-- So instead of `vim.o` to set options, use `vim.bo` for buffer-local options and\n-- `vim.cmd('setlocal ...')` for window-local options (currently more robust).\n--\n-- This is also a good place to set buffer-local 'mini.nvim' variables.\n-- See `:h mini.nvim-buffer-local-config` and `:h mini.nvim-disabling-recipes`.\n\n-- Enable spelling and wrap for window\nvim.cmd('setlocal spell wrap')\n\n-- Fold with tree-sitter\nvim.cmd('setlocal foldmethod=expr foldexpr=v:lua.vim.treesitter.foldexpr()')\n\n-- Disable built-in `gO` mapping in favor of 'mini.basics'\nvim.keymap.del('n', 'gO', { buffer = 0 })\n\n-- Set markdown-specific surrounding in 'mini.surround'\nvim.b.minisurround_config = {\n  custom_surroundings = {\n    -- Markdown link. Common usage:\n    -- `saiwL` + [type/paste link] + &lt;CR&gt; - add link\n    -- `sdL` - delete link\n    -- `srLL` + [type/paste link] + &lt;CR&gt; - replace link\n    L = {\n      input = { '%[().-()%]%(.-%)' },\n      output = function()\n        local link = require('mini.surround').user_input('Link: ')\n        return { left = '[', right = '](' .. link .. ')' }\n      end,\n    },\n  },\n}\n\n\n\nafter/lsp/lua_ls.lua\n\n\nCode\n\n-- ┌────────────────────┐\n-- │ LSP config example │\n-- └────────────────────┘\n--\n-- This file contains configuration of 'lua_ls' language server.\n-- Source: https://github.com/LuaLS/lua-language-server\n--\n-- It is used by `:h vim.lsp.enable()` and `:h vim.lsp.config()`.\n-- See `:h vim.lsp.Config` and `:h vim.lsp.ClientConfig` for all available fields.\n--\n-- This config is designed for Lua's activity around Neovim. It provides only\n-- basic config and can be further improved.\nreturn {\n  on_attach = function(client, buf_id)\n    -- Reduce very long list of triggers for better 'mini.completion' experience\n    client.server_capabilities.completionProvider.triggerCharacters =\n      { '.', ':', '#', '(' }\n\n    -- Use this function to define buffer-local mappings and behavior that depend\n    -- on attached client or only makes sense if there is language server attached.\n  end,\n  -- LuaLS Structure of these settings comes from LuaLS, not Neovim\n  settings = {\n    Lua = {\n      -- Define runtime properties. Use 'LuaJIT', as it is built into Neovim.\n      runtime = { version = 'LuaJIT', path = vim.split(package.path, ';') },\n      workspace = {\n        -- Don't analyze code from submodules\n        ignoreSubmodules = true,\n        -- Add Neovim's methods for easier code writing\n        library = { vim.env.VIMRUNTIME },\n      },\n    },\n  },\n}\n\n\n\nafter/snippets/lua.json\n\n\nCode\n\n{\n  \"local\": { \"prefix\": \"l\", \"body\": \"local $1 = $0\" },\n  \"Remove prefixes\": { \"prefix\": [\"lfu\", \"ll\", \"lpca\"] }\n}"
  },
  {
    "objectID": "blog/2023-06-08-release-090.html",
    "href": "blog/2023-06-08-release-090.html",
    "title": "Release 0.9.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nI am once again greatly pleased to share the news about the release of mini.nvim version 0.9.0. It is mostly about three new modules related to colors, exciting new features of ‘mini.comment’, and some maintenance work.\nHere is a full release description if you are curious.\n\nThree new modules came out of beta-testing (all related to colors):\n\nmini.colors - Tweak and save any color scheme. This is my deep dive into color theory and Neovim color schemes in order to help other users solve common problems like “I generally like this color scheme but want it to be lighter / darker / more saturated / less saturated/ have transparent background / support cterm attributes / and more”.\nmini.hues - Generate configurable color scheme. After gaining more insight into color theory, I was confident enough to attempt and make my own color scheme generator (not following some pre-defined standards, like mini.base16). And I like the result. Especially the randomhue color scheme which is my daily driver now.\nmini.hipatterns (module number 30) - Highlight patterns in text. Think about it as a more flexible middle ground between folke/todo-comments.nvim and NvChad/nvim-colorizer.lua with slightly more possibilities.\n\n\nmini.comment got substantial update following new features in Neovim 0.9.0:\n\nTree-sitter aware local commenting out of the box which uses tree-sitter information about locally active language to infer ‘commentstring’ option value. Works in most cases and usually ‘JoosepAlviste/nvim-ts-context-commentstring’ is not needed anymore. Unfortunately, not in all cases, as some (overly) complex cases, like TSX, still need it.\nNew options.custom_commentstring option for a more granular customization of comment structure. This is where ‘JoosepAlviste/nvim-ts-context-commentstring’ can be used now.\nNew get_commentstring() function representing built-in logic of computing relevant ‘commentstring’.\n\n\nThere were a lot of maintenance work related to long awaited deprecation of Neovim&lt;=0.6 support. This means that ‘mini.nvim’ can finally use Lua API for common tasks like autocommands, mappings, and default highlight group creation. This also results into less exported functions (which were mostly there to work with autocommands and mappings) reducing tests and documentation.\n\nIf you feel adventurous to try new color scheme, tweak your own, add highlights to some patterns, or start using tree-sitter aware comments out of the box, this is a good opportunity to do it!\nThanks for reading! Hope to see you in the next module release!"
  },
  {
    "objectID": "blog/2023-08-01-announce-mini-clue.html",
    "href": "blog/2023-08-01-announce-mini-clue.html",
    "title": "Announcing ‘mini.clue’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am relieved to finally make the release of mini.clue - new module of mini.nvim to show next key clues. It can also be installed using separate GitHub repository.\n\n‘mini.clue’ is basically a folke/which-key.nvim but with different implementation of how user input is processed. This allows it to have ‘hydra’-like submodes and be independent from ‘timeoutlen’ (built-in duration after which currently typed keys are forced to execute).\nOne important distinction from ‘folke/which-key.nvim’ is that ‘mini.clue’ can’t create mappings during its setup. It needs to be done separately, mostly because I believe that this (separation of mapping creation and showing setup) leads to a cleaner user config.\nI love how this module turned out. Originally, I thought that it would be not hard to implement, but it became a really painful process to try to mitigate all Neovim’s built-in quirks (especially for Operator-pending mode). It is a huge relief to finally release this.\nOn a slightly sad note, this will replace the last Folke’s plugin in my config :(\n\nHere are main features of ‘mini.clue’:\n\nImplement custom key query process to reach target key combination:\n\nStarts after customizable opt-in triggers (mode + keys).\nEach key press narrows down set of possible targets.\nPressing &lt;BS&gt; removes previous user entry.\nPressing &lt;Esc&gt; or &lt;C-c&gt; leads to an early stop.\nDoesn’t depend on ‘timeoutlen’ and has basic support for ‘langmap’.\nEnds when there is at most one target left or user pressed &lt;CR&gt;. Results into emulating pressing all query keys plus possible postkeys.\n\nShow window (after configurable delay) with clues. It lists available next keys along with their descriptions (auto generated from descriptions present keymaps and user-supplied clues).\nConfigurable “postkeys” for key combinations - keys which will be emulated after combination is reached during key query process.\nProvide customizable sets of clues for common built-in keys/concepts:\n\ng key.\nz key.\nWindow commands.\nBuilt-in completion.\nMarks.\nRegisters.\n\nLua functions to disable/enable triggers globally or per buffer.\n\nFor more details see these tags in help:\n\nMiniClue-key-query-process\nMiniClue-examples\nMiniClue.config\nMiniClue.gen_clues\n\nFor more information, see help file.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2023-10-13-announce-mini-pick.html",
    "href": "blog/2023-10-13-announce-mini-pick.html",
    "title": "Announcing ‘mini.pick’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI would like to invite you to celebrate a special day with a massive release of mini.pick - new module of mini.nvim. It can also be installed using separate GitHub repository.\n\nFirst things first. Today is a special day because it marks two years since the first public release of ‘mini.nvim’. It was a nerve wracking to make, but your continuous support for the past two years made it worth it.\n\nNow about ‘mini.pick’. It has a long (and still not full) list of features, but for a blog post I’ll compress it a bit. From a bird’s eye view, it is an ‘nvim-telescope/telescope.nvim’ with completely different UI/UX, fast and slightly different default matching, and only a handful of built-in pickers. Considerably more pickers will be released in a next ‘mini.nvim’ module (‘mini.extra’ with some extra configurations for other modules). If you are completely happy with Telescope, there is not much reasons to switch (besides mentioned earlier). All I can say is that I am now Telescope-free for about a month and loving it.\nThis is definitely the most ambitious module in ‘mini.nvim’: 3000+ lines, around 5000 lines of tests with almost 300 cases. But this is the price to pay for flexibility and comfortable out of the box experience.\nIf you want to learn more, see overview.\nFor full documentation see help file.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2024-01-04-announce-mini-notify.html",
    "href": "blog/2024-01-04-announce-mini-notify.html",
    "title": "Announcing ‘mini.notify’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nPlease join me in welcoming 2024 with announce of mini.notify - new module of mini.nvim with functionality to show one or more highlighted notifications in a floating window. It can also be installed using separate GitHub repository.\n\nI personally didn’t use fancy notifications before ‘mini.notify’ but it was on my TODO list. Recently it occurred to me that a demo of at least one upcoming module will look more interesting if several notifications can be shown at once. Thus I decided to move this new functionality up in list and here we are.\n\nFeatures:\n\nShow one or more highlighted notifications in a single floating window.\nManage notifications (add, update, remove, clear).\nvim.notify() wrapper generator (see MiniNotify.make_notify()).\nAutomated show of LSP progress report.\nTrack history which can be accessed with MiniNotify.get_all() and shown with MiniNotify.show_history().\n\nFor full documentation see help file.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2023-01-29-announce-mini-basics.html",
    "href": "blog/2023-01-29-announce-mini-basics.html",
    "title": "Announcing ‘mini.basics’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nIt is me again, posting this time about mini.basics - a module of mini.nvim with common configuration presets for options, mappings, and autocommands. You can also install from a standalone Git repository.\nA while back I did a public Neovim options survey (here are the results). One of the goals was to gather a commonly used option values to create a “crowd-sourced” moderate version of tpope/vim-sensible. Well, this is it.\nIt has the following features:\n\nPresets for common options (like ‘termguicolors’, ‘number’, ‘ignorecase’, etc.). It will only change option if it wasn’t manually set before. For more info see this portion of help file and/or this part of source code.\nPresets for common mappings (like j/k to move by visible lines, &lt;C-s&gt; to save, toggle common options, and much more). For more info see this portion of help file and/or this part of source code.\nPresets for common autocommands (like highlight on yank, start Insert mode when opening terminal, etc.). For more info see this portion of help file and/or this part of source code.\n\nMain goal of ‘mini.basics’ is to provide a relatively easier way for new-ish Neovim users to have a better “works out of the box” experience while having documented relevant options/mappings/autocommands to study. But more seasoned users almost surely will find something useful. Browsing source code and copying only some options/mappings/autocommands is ok, of course.\nAmusingly, development of this “basic” module led to creation of two other “less basic” modules: mini.move (here is a the announcement) and one more that needs polishing. Initially I planned to incorporate most of tpope/vim-unimpaired in ‘mini.basics’, but decided to use here only option toggling mappings (with default \\ prefix; can be configured); “next/previous” functionality will be in separate module. Stay tuned!\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2023-03-09-announce-mini-splitjoin.html",
    "href": "blog/2023-03-09-announce-mini-splitjoin.html",
    "title": "Announcing ‘mini.splitjoin’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI would like to announce the release of mini.splitjoin - new module of mini.nvim to split and join arguments. It can also be installed using separate GitHub repository.\nMain features:\n\nMappings and Lua functions that modify arguments (regions inside brackets between allowed separators) under cursor.\nSupported actions:\n\nToggle - split if arguments are on single line, join otherwise. Main supported function of the module.\nSplit - make every argument separator be on end of separate line.\nJoin - make all arguments be on single line.\n\nMappings are dot-repeatable in Normal mode and work in Visual mode.\nCustomizable argument detection (see MiniSplitjoin.config.detect in help file):\n\nWhich brackets can contain arguments.\nWhich strings can separate arguments.\nWhich regions exclude when looking for separators (like inside nested brackets or quotes).\n\nCustomizable pre and post hooks for both split and join.\nWorks inside comments by using modified notion of indent.\nProvides low-level Lua functions for split and join at positions.\n\nNotes:\n\nSearch for arguments is done using Lua patterns (regex-like approach). Certain amount of false positives is to be expected.\nThis module is mostly designed around MiniSplitjoin.toggle(). If initial split positions are on different lines, join first and then split.\n\nFor more information, see help file.\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-12-22-announce-mini-animate.html",
    "href": "blog/2022-12-22-announce-mini-animate.html",
    "title": "Announcing ‘mini.animate’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nAfter a lot of struggle, I am happy to announce mini.animate - new module of mini.nvim which adds animation to some common Neovim actions. Following dual distribution model, it can also be installed using separate GitHub repository.\nThis module aims to enhance visual user experience with as little setup and config intrusion as possible. Granted, not everyone likes animations in their editor, and that is OK. I myself didn’t use this kind of plugins, but recently found that animation helps in various subtle ways to more precisely target my focus.\nMain features:\n\nWorks out of the box with a single require('mini.animate').setup(). No extra mappings or commands needed.\nAnimate cursor movement inside same buffer by showing customizable path.\nAnimate scrolling with a series of subscrolls (“smooth scrolling”).\nAnimate window resize by gradually changing sizes of all windows.\nAnimate window open/close with visually updating floating window.\nTimings for all actions can be customized independently.\nAction animations can be enabled/disabled independently.\nAll animations are asynchronous/non-blocking and trigger a targeted event which can be used to perform actions after animation is done.\nMiniAnimate.animate() function which can be used to perform own animations.\n\nFor more information, see help file.\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2024-02-29-release-0120.html",
    "href": "blog/2024-02-29-release-0120.html",
    "title": "Release 0.12.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nLet’s celebrate the leap year day by making a long overdue 0.12.0 release of mini.nvim. It includes three major plugins coming out of beta-testing and quite a few small updates to other modules.\nHere is a full release description if you are curious.\n\nThree new modules coming out of beta-testing:\n\nmini.visits - module to track and reuse file system visits. This is a ‘mini.nvim’ version of ‘nvim-telescope/telescope-frecency.nvim’ (persistently track file visits and select from them) partially combined with ‘ThePrimeagen/harpoon’ (persistently add/remove labels to paths and select based on them).\nmini.notify - module to show notifications. It provides custom ‘vim.notify’ maker so that users can have pretty and less intrusive plugin notifications. Also by default it sets up notifications for LSP progress updates (feature I didn’t know I needed until I tried it).\nmini.deps - plugin manager module. Although ‘mini.nvim’ already includes most of the necessary editor functionality, there are other great plugins out there. ‘mini.deps’ helps installing/updating/cleaning/snapshotting other plugins with minimal yet sufficient user experience (in my opinion it ended up somewhere near ‘junegunn/vim-plug’ in that regard).\n\n\nAlready present modules got their fair share of updates:\n\n‘mini.comment’ now calls hooks with data about commenting action.\n‘mini.hues’ now implements support for the new tree-sitter captures introduced in ‘nvim-treesitter’ and Neovim&gt;=0.10.\n‘mini.statusline’ now has search_count section in default content.\nAnd more…\n\n\nThanks for reading! Hope to see you soon in the next module release!"
  },
  {
    "objectID": "blog/2023-07-04-update-mini-files-file-preview.html",
    "href": "blog/2023-07-04-update-mini-files-file-preview.html",
    "title": "Updates of ‘mini.files’: file preview",
    "section": "",
    "text": "Originally posted on Reddit\n\n\n\nExplorer with preview\n\n\nHello, Neovim users!\nAround two weeks ago I’ve announced the release of mini.files - a file explorer module of mini.nvim with column view navigation and “edit text to manipulate file system” design. This resulted into a great feedback from the community, much of which turned into new features.\nI don’t really do a follow up post with plugin updates, as it is usually fairly complete before release. This time is an exception.\nHere is a list of new additions to ‘mini.files’:\n\nFile preview (with highlighting): set windows.preview = true and navigate over file. Initially I was skeptical about adding this due to code design. However, having preview visible for directories and not visible for files resulted into some uncomfortable behavior during deeply nested exploration, so I changed my mind. Big thanks to /u/folke for the help on how to efficiently add text highlighting in file previews!\nCustomizable preview width via windows.width_preview. Following previous change, this seemed necessary for a better file preview.\nPrefix (icon) customization via content.prefix, including no icons at all (see examples in help). Again, initially skeptical about adding due to code design, but I figured out a way to make even a better choices to enable customizable prefix.\nNon-permanent delete via options.permanent_delete = false. This is a module-specific “move to trash” approach which will move file/directory into ‘mini.files/trash’ directory of ‘data’ standard path. Didn’t use regular trash mostly due to it being OS dependent.\nAbility to set new target window from inside explorer. Here is an example of creating mappings for vertical/horizontal split of target window (should be followed by explicit file open afterwards).\nEvents after successful file system action (see this list). This was one of the first questions/requests I’ve got after the release, as it makes possible to utilize didCreateFiles/didRenameFiles/didDeleteFiles LSP notifications.\nVarious small tweaks, like support [count] for go_in/go_out keys, make non-delete file system actions to never override existing data, etc.\n\nAnd that’s about it. ‘mini.files’ will still be in beta-testing for a while until ‘mini.nvim’ 0.10.0 release, but I consider its features to be mostly complete.\nIf you didn’t try it yet, give it a shot and tell me what you think! Either here in comments or in a (already pretty crowded, though) dedicated beta-testing issue. Thanks!"
  },
  {
    "objectID": "blog/2023-09-05-release-0100.html",
    "href": "blog/2023-09-05-release-0100.html",
    "title": "Release 0.10.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nI would like to offer you to join me in saying late greetings to this autumn with a release of mini.nvim version 0.10.0. It is mostly about introducing three (quite feature full, dare I say) modules and minor updates of existing ones.\nHere is a full release description if you are curious.\n\nThree new modules came out of beta-testing:\n\nmini.files - Navigate and manipulate file system. A file explorer with column view capable of manipulating file system by editing text. Can create/delete/rename/copy/move files/directories inside and across directories.\nmini.clue - Show next key clues. Think about it as somewhat of a cross between ‘which-key’ and ‘hydra’. Implements custom key query process with customizable opt-in triggers, next key descriptions (clues), hydra-like submodes, window delay/config. Provides clue sets for some built-in concepts: g/z keys, window commands, etc.\nmini.operators - Various text edit operators: replace, exchange, multiply, sort, evaluate. Creates mappings to operate on textobject, line, and visual selection. Supports count and dot-repeat.\n\n\nThe most prominent update of existing modules comes from ‘mini.surround’: its add (sa) now can replicate left and right parts by respecting [count]. In Normal mode two kinds of [count] is respected: one for operator (replicates left and right parts) and one for textobject/motion. In Visual mode [count] replicates parts.\n\nAll of new modules pack a lot of functionality in a small container and (at least I hope) user-friendly design. If you haven’t already, please do check them out.\nThanks for reading! Hope to see you in the next module release!"
  },
  {
    "objectID": "blog/2025-05-03-announce-mini-keymap.html",
    "href": "blog/2025-05-03-announce-mini-keymap.html",
    "title": "Announcing ‘mini.keymap’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI invite you to break a long pause between new mini.nvim module releases together with ‘mini.keymap’. It can also be installed using separate GitHub repository.\n\nThis module is aimed to solve three pressing issues:\n\nProvide a way to tie together different modules/plugins which can use &lt;Tab&gt; / &lt;S-Tab&gt; / &lt;CR&gt; / &lt;BS&gt; keys in Insert mode. These are usually known as “smart” keys, but ‘mini.keymap’ offers a more general and customizable alternative of “multi-step actions”.\nResolve the oldest open feature request for adding “better escape” like functionality into ‘mini.nvim’. I personally prefer exiting into Normal mode with &lt;C-S&gt; (which also saves), but I can see the appeal of jk. Maybe I’ll try to get used to it. Besides, the end result in ‘mini.keymap’ (called “combo”) is more versatile.\nThe upcoming ‘mini.nvim’ release 0.16.0 will be mostly about new ‘mini.completion’ features and many new features in other modules. But I’d like for every stable release to provide at least one new module. So here we are.\n\n\nFeatures of ‘mini.keymap’:\n\nMap keys to perform configurable multi-step actions: if condition for step one is true - execute step one action, else check step two, and so on until falling back to executing original keys. This is usually referred to as “smart” keys (like “smart tab”).\nThere are many built-in steps targeted for Insert mode mappings of special keys like &lt;Tab&gt;, &lt;S-Tab&gt;, &lt;CR&gt;, and &lt;BS&gt;. Here is the full list and some common examples. More plugin might support in the future (like for accepting inline completion and “next text edit”), but having as much coverage as possible is not the goal.\nMap keys as “combo”: each key acts immediately plus execute extra action if all are typed within configurable delay between each other. Some of the common use cases include:\n\nMap insertable keys to exit into Normal mode (as this won’t have side effects like inoremap jk &lt;Esc&gt;).\nShow a notification if there are too many same navigation keys pressed (to break bad habits).\n\nHere are more examples.\n\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue. I’d also like to collect ideas about useful combos that are not convenient to be done as a regular mapping.\nThanks!"
  },
  {
    "objectID": "blog/2023-02-12-release-070.html",
    "href": "blog/2023-02-12-release-070.html",
    "title": "Release 0.7.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nI am glad to finally announce that mini.nvim had a release of version 0.7.0.\nIf you are following main branch (on ‘mini.nvim’ itself or any of its standalone repositories) or Reddit posts, there is not much news for you (apart from new modules are now out of beta-testing phase).\nIf you are following stable branch or latest tag (like with ‘folke/lazy.nvim’), there are some new modules, features, and breaking changes.\nHere is a relevant part of changelog. A quick summary:\n\nThere are three new modules (main part of release):\n\nmini.animate - Animate common Neovim actions.\nmini.basics - Common configuration presets.\nmini.move - Move any selection in any direction.\n\nThere are four breaking changes (most previous behavior still works but will be removed soon in main branch):\n\nIn ‘mini.ai’ the separators option for argument specification is deprecated in favor of separator. See here about migration.\nIn ‘mini.completion’ the window_dimensions option is renamed to window to handle more general configuration.\nIn ‘mini.indentscope’ the gen_animation is now a table with methods instead of a function. See here about migration.\nIn ‘mini.indentscope’ the MiniIndentscopePrefix highlighting group is deprecated as it is no longer needed.\n\nThere are five new features:\n\n‘mini.misc’ got setup_auto_root() and find_root() functions for root finding functionality (a.k.a “simplified vim-rooter”).\n‘mini.misc’ got setup_restore_cursor() function to automatically restore latest cursor position on file reopen. Thanks @cryptomilk for most part of the work!\n‘mini.completion’ can now customize borders of info and signature windows.\n‘mini.indentscope’ now doesn’t obscure region to the left of vertical line. Specifically, it means that it works with ‘lukas-reineke/indent-blankline.nvim’.\n‘mini.ai’ can now define separator for argument textobject via Lua pattern instead of an array of single characters.\n\nSupport for Neovim 0.6 is now soft deprecated. All versions prior Neovim 0.7.0 will stop working some time after Neovim 0.9.0 release.\n\nIf you were waiting for new modules to come out of beta-testing, this is the time to try them out!\nThanks for reading!"
  },
  {
    "objectID": "blog/2024-09-03-update-mini-files-bookmarks.html",
    "href": "blog/2024-09-03-update-mini-files-bookmarks.html",
    "title": "Updates of ‘mini.files’: bookmarks",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nTL;DR: here is a full list of changes since last release. I’d be grateful if you could test them and give your feedback before the next ‘mini.nvim’ release.\n\nDuring the current version iteration of ‘mini.nvim’ I decided to spread my attention to already existing modules for overall maintenance and backlog cleanup. ‘mini.files’ got the most attention among those, so I’d like to ask its users to test new changes before the next ‘mini.nvim’ release. The full list of changes is at the beginning of the post, but here are important highlights of recent activity:\n\n‘mini.files’ now implements bookmarks, which act similar to built-in marks:\n\nm&lt;char&gt; sets directory path of focused window as bookmark with id &lt;char&gt;.\n'&lt;char&gt; makes bookmark path focused.\nset_bookmark() can set custom bookmarks from script. Here is an example.\n\nThe main motivation for this was that move/copy files across different directories was tricky without quick way to switch between them. Now they are a single 'a / 'b away from each other (needs conscious decision of creating them, though).\nComplex cases of file manipulation (like delete ‘file-a’ and copy ‘file-b’ as ‘file-a’ in a single synchronization) are now properly resolved. It is not 100% full proof (intentionally), so I’d still suggest splitting tasks into independent steps.\nConfirmation info now uses relative paths inside action description as much as possible. It is also now intentionally aligned.\nget_target_window() is now soft deprecated (works for now, but will be removed after the next ‘mini.nvim’ release) in favor of a get_explorer_state().target_window. This was an oversight because I didn’t want to fix the whole explorer data structure (and later realised that I didn’t have to). Sorry about that.\n\nYou can leave your feedback/issues/suggestions here, create a question (if it wasn’t already asked before), or create an issue (if it wasn’t already create before).\nThanks!\nEdit: if you are curious to read about my journey to implementing bookmarks, this issue contains some thought process for possible future reference."
  },
  {
    "objectID": "blog/2024-06-13-release-0130.html",
    "href": "blog/2024-06-13-release-0130.html",
    "title": "Release 0.13.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nToday is the release day of mini.nvim version 0.13.0. It includes two new quite feature-rich modules coming out of beta-testing, some breaking features for existing modules, and a few small updates for other modules.\nThis release marks the crossing of curiously aligned milestones. The ‘mini.nvim’ project now has: - 40+ modules. - 4000+ GitHub stars (thank you all for your support ❤️). - 4000+ test cases.\nHere is a full release description if you are curious.\n\nTwo new modules coming out of beta-testing:\n\nmini.diff - module to interactively visualize difference between buffer text and its reference. This is basically a ‘mini.nvim’ version of ‘lewis6991/gitsigns.nvim’, but with more general design towards reference text (not only from Git index) and a bit different way to show inline difference (called “overlay”).\nmini.git - module for a tighter Git integration. Its primary goal is to track per buffer Git related data to be shown in statusline. However, it also includes two other big sets of features: :Git command for a more direct use of Git within current Neovim session and helper functions for a more interactive Git history exploration. It is not intended as ‘tpope/vim-fugitive’ or full featured Git client replacement.\n\n\nTwo plugins got visible breaking updates:\n\n‘mini.comment’ now treats whitespace more coherently (updated during the preparation for its essentially upstreaming to core):\n\nBlank lines are ignored when deciding whether to comment or uncomment. In practice it means that region with commented and blank lines will be uncommented rather than commented.\nWhitespace in ‘commentstring’ is now treated more explicitly. With default config this is rarely noticeable, but might matter for people using options.pad_comment_parts = false.\n\n‘mini.statusline’ got several big updates:\n\nThe new ‘mini.diff’ and ‘mini.git’ modules now take precedence over ‘lewis6991/gitsigns.nvim’. Meaning the latter now is not required for ‘mini.statusline’ to show its full potential.\nsection_diagnostics() now does not depend on whether there is an LSP server attached to the buffer (which is more aligned with section’s purpose).\nThere are two new sections added and immediately are now used in default active statusline content: section_diff() and section_lsp(). For users with default ‘mini.statusline’ config this mostly means that diff is shown with extra icon and there is an indicator for the number of attached LSP servers.\n\n\n\nSeveral plugins got small-ish but useful updates:\n\n‘mini.deps’ now highlights commit messages which indicate breaking change in a conventional commit style (which ‘mini.nvim’ itself now uses and I am very happy with it).\n‘mini.map’ got gen_integration.diff() integration to highlight hunks from ‘mini.diff’.\n‘mini.tabline’ got an option to format tab labels.\nAnd more…\n\n\nThanks for reading and showing interest in ‘mini.nvim’ project!\nHope to see you soon in the next module release (there are some really nice things planned)!"
  },
  {
    "objectID": "blog/2025-03-07-update-mini-completion-snippet-support.html",
    "href": "blog/2025-03-07-update-mini-completion-snippet-support.html",
    "title": "Updates of ‘mini.completion’: snippet support (finally)",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nThe ‘mini.completion’ module of ‘mini.nvim’ plugin has accumulated visible number of changes on latest main branch. As some of them were requested fairly often, I decided to make a separate post about it.\nThe main improvement is (finally) added snippet support. That is, ‘mini.completion’ now can properly insert snippet completion entries. The main attention has gone into making it work with enabled ‘mini.snippets’ module, but there is automated fallback to vim.snippet (on Neovim&gt;=0.10).\nOther updates include:\n\nDefault mappings for scrolling down/up in both info/signature windows. Those are &lt;C-f&gt; and &lt;C-b&gt;, but can be configured (be careful with &lt;C-d&gt; and &lt;C-u&gt;, as they have special meaning during active built-in completion popup).\nSignificantly better highlighting in info/signature windows.\nSupport for isIncomplete, which means there will be automated update of completion list on the next key press if initial response from LSP server did not contain all possible items.\nBetter handling of label details and documentation, i.e. which goes into initial popup and which goes into info window.\nSlightly different default UI for info and signature window: with border and title.\n\nHere is a CHANGELOG entry with more details thus far and here is an updated demo (done in Neovim=0.11 which soon-ish should be released as stable).\n\nThese updates took a lot longer than I would have liked. Ignoring non-development related issues, this seems to be a result of my personal mental block when working with LSP related things. I think this is due to multiplied complexity from 1) LSP specification; 2) having to deal with different servers implementing it slightly differently; and 3) sometimes Neovim itself (mostly by having to deal with Vim’s legacy part).\nDoing one small step at a time definitely helped me here and I am happy this part is over. There are still plans for LSP related functionality (making in-process LSP server for snippets loaded with ‘mini.snippets’ and adding create/rename/delete LSP support in ‘mini.files’), so time to relax will not be long :)\n\nThanks for taking interest in ‘mini.nvim’ project and ‘mini.completion’ in particular! If you experience issues after these updates (and I imagine there will be), please create an issue/discussion and we can look into it.\nHope to see you soon with new and exciting updates!"
  },
  {
    "objectID": "blog/2023-05-07-announce-mini-hues.html",
    "href": "blog/2023-05-07-announce-mini-hues.html",
    "title": "Announcing ‘mini.hues’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am really happy to tell you about the release of mini.hues - new color scheme module of mini.nvim to generate configurable color scheme. It can also be installed using separate GitHub repository.\n\nThis is an attempt to create my own color scheme leveraging the knowledge I got from writing ‘mini.colors’ and learning about Oklab/Oklch color space. But this is not just a color scheme, but a color scheme generator - it creates and applies palette based on (mandatory) background and foreground colors.\nI put quite a lot of thought into how this palette is applied to highlight groups. There are many small details that make reading code and text easier (at least for me), like bold keywords, orange delimiters, red return, etc.\nHere are some configuration examples for you to try (basically what is showcased in video demo).\n\nAlong with ‘mini.hues’ comes ‘randomhue’. This is a good old configuration-free color scheme, but with a twist: each call to :colorscheme randomhue will result into random yet coherent colors. Generation is somewhat smart: it adapts to dark/light 'background' option while base colors always have same lightness and chroma.\nFirst eight examples from the video can be a result of ‘randomhue’. For examples of light background see demo in README.\nI’ve been daily driving ‘randomhue’ for about a week and I must say that it is quite a bit of fun. Small amount of randomness adds something special to user experience.\n\nHere are the features of ‘mini.hues’:\n\nRequired to set two base colors: background and foreground. Their shades and other non-base colors are computed to be as much perceptually different as reasonably possible.\nConfigurable:\n\nNumber of hues used for non-base colors (from 0 to 8).\nSaturation level (‘low’, ‘medium’, ‘high’).\nAccent color used for some selected UI elements.\nPlugin integration (can be selectively enabled for faster startup).\n\nRandom generator for base colors. Powers randomhue color scheme.\nLua function to compute palette used in color scheme.\n\nSupported highlight groups:\n\nAll built-in UI and syntax groups.\nBuilt-in Neovim LSP and diagnostic.\nTree-sitter.\nLSP semantic tokens.\n30+ modern Neovim plugins.\n\nFor more information, see help file.\n\nPlease, check it out and tell me what you think! I am also very curious about user experience with plugins (to be honest, not all of them were checked with an actual working plugin). You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2025-10-03-announce-site.html",
    "href": "blog/2025-10-03-announce-site.html",
    "title": "MINI now has its own site",
    "section": "",
    "text": "Hello, Neovim users!\nFor the entirety of the ‘mini.nvim’/MINI project its main place of documentation was GitHub. It means that “official” links to module READMEs and help files were something like https://github.com/nvim-mini/mini.nvim/blob/main/readmes/mini-ai.md and https://github.com/nvim-mini/mini.nvim/blob/126ce3328c78399dcff58272f6f540a373b62a75/doc/mini-ai.txt#L1. But not any more!\nPlease welcome nvim-mini.org! It is a long-time-in-the-works project that is finally public. It required a careful work of updating ‘mini.nvim’ documentation to be usable in both built-in :help and in this auto-generated site (it uses Quarto and custom Lua scripts).\nHere are the improvements a dedicated site brings (apart form adding a bit more credibility to the project):\n\nOwn blog which is already populated with posts I made on Reddit for nearly four years. The main benefit is that it makes it harder to take those posts away from the web, which was a real issue for me, unfortunately. Plus it opens possibilities to create posts that can be freely linked on different blog post aggregation sites.\nGenerated ‘mini.nvim’ documentation: both READMEs, change log, and help files. The latter is much more readable and usable than linking to a “*.txt” file on GitHub:\n\nIt has :help like highlighting.\nIt auto-links tag links (like the one on which you can press &lt;C-]&gt; and navigate to its target), making reading and navigation much better. And not only it links within ‘mini.nvim’ tags, it also links to neovim.io documentation for built-in tags as well!\nIt creates more robust links to help sections (like ‘mini.pick’ overview) and change log entries (like ‘mini.completion’ changes in v0.16.0). The latter is not possible on GitHub because it doesn’t handle duplicating headings very well for this task.\n\nThere are still downsides to this approach, of course. Links to documentation are not “immutable” (like GitHub’s links to a specific commit) and now only display documentation of the ‘main’ branch. I’ll see what I can do here (like maybe provide snapshots of documentations for releases), but this is not the highest priority right now.\nA more suitable place to document things outside of ‘mini.nvim’ plugin but within MINI project. Which are planned and should be coming soon-ish (I hope)!\n\nAll in all, I am very happy to finally have a dedicated website for the project.\nThank you all for reading this post and supporting MINI. Hope to meet you soon!"
  },
  {
    "objectID": "blog/2022-02-10-announce-mini-indentscope.html",
    "href": "blog/2022-02-10-announce-mini-indentscope.html",
    "title": "Announcing ‘mini.indentscope’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am happy to announce new module of mini.nvim - mini.indentscope. It is built around a notion of “indent scope” - minimal set of lines containing reference one (usually cursor line) and every line having indent not less than a reference (usually computed using indent of cursor line). Core functionalities:\n\nInteractively visualize current indent scope. It is done in non-blocking way with customizable animation (there are some popular easing functions built in; of course no animation is also possible) and debounce delay.\nCustomizable way of computing scope. Like:\n\nWhat is considered a scope border (useful for certain filetypes, like Python).\nWhether to incorporate cursor column in computing reference indent (like behavior in animation).\nWhether to try and recognize line as border first (useful to place cursor on function header and visualize its body).\n\nMove cursor to either side of scope.\nUse scope textobject, both without and with border.\n\nHow it compares to ‘lukas-reineke/indent-blankline.nvim’:\n\nMain purpose of ‘indent-blankline.nvim’ is to show static indent guides. This module is intended to show what is a current indent scope (yes, ‘indent-blankline.nvim’ has similar functionality also, but not that general).\nThey both use Neovim’s extmarks for visualization (in fact, I used ‘indent-blankline.nvim’ source code for some reference solutions). This doesn’t cause big conflict, but one of visualizations will be placed on top of another (at the moment, it is a ’mini.indentscope’s one).\n\nTry it out! Feedback is greatly appreciated. Feel free to drop a comment here or use a dedicated issue."
  },
  {
    "objectID": "blog/2022-08-28-update-mini-surround-tree-sitter.html",
    "href": "blog/2022-08-28-update-mini-surround-tree-sitter.html",
    "title": "Updates of ‘mini.surround’: tree-sitter support and more",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am happy to announce new features of ‘mini.surround’ - module of ‘mini.nvim’ for surrounding actions (add, delete, replace, find, highlight surrounding characters). All actions are dot-repeatable out of the box and operate on highly customizable set of surrounding identifiers. By default it defines mappings with common s prefix (sa for add, sd for delete, sr for replace, sf for find, sh for highlight), but setup similar to ‘tpope/vim-surround’ is, of course, also possible.\nThis update was prompted after the release of ‘mini.ai’ which can create custom textobjects. Its initial implementation was based on ‘mini.surround’ but in the process it got transformed into much more powerful design (at cost of some code and documentation complexity). Ironically, ‘mini.surround’ is now updated to share as much with ‘mini.ai’ as possible, which provides more integrated experience.\nNew features:\n\nNew surrounding specification format for updated, more powerful search logic. This allows creating more flexible surroundings based on Lua patterns and functions. This also enables creating aliases (like new builtin b for brackets and qfor quotes). This is a breaking change for those who defined custom input surroundings. Previous format will work until next release and transition to new one is pretty straightforward.\nTree-sitter support. Thanks to new specification format you can now use tree-sitter based surroundings. More information is in the help file. Note, that for full experience with function call surrounding, better update ‘nvim-treesitter/nvim-treesitter-textobjects’ to at least include changes from this PR (merged around 3 days ago).\n“Last”/“next” extended mappings. With the same idea as in ‘mini.ai’, you can now use mappings with special suffixes (l for “last”, n for “next”) to operate on previous or next surrounding. This can be done for actions involving searching surrounding (delete, replace, find, highlight) but proved to be especially useful for finding next surrounding (as shown in demo).\nSupport of v:count for input surrounding. Now, for example, you can type 2sdf to delete second (based on search method) function call.\nFor ‘tpope/vim-surround’ lovers, open bracket identifiers ((, [, {, &lt;) now include padding: for input it will use all edge whitespace, for output - single space.\n\nCheck it out and tell me what you think. Thanks!"
  },
  {
    "objectID": "blog/2022-05-06-announce-mini-jump2d.html",
    "href": "blog/2022-05-06-announce-mini-jump2d.html",
    "title": "Announcing ‘mini.jump2d’",
    "section": "",
    "text": "Originally posted on Reddit\n\nImmediate note: demo gif is made on a very slow laptop which resulted in a frame loss. In reality any reaction to typed key is instantaneous.\nHello, Neovim users!\nI am happy to release mini.jump2d - yet another module of mini.nvim plugin. Unlike ‘mini.jump’, it is about jumping within visible lines in both directions (not only forward/backward). Idea is very similar to phaazon/hop.nvim: lock eyes on where you want to place cursor, start jumping (shows all possible jump spots labeled with single character), type labels appearing over target place until it is unambiguously filtered (usually takes about 2-3 keystrokes).\nFeatures:\n\nCustomizable:\n\nWay of computing possible jump spots with opinionated default (here is its description).\nCharacters used to label jump spots during iterative filtering.\nAction hooks to be executed at certain events during jump.\nAllowed windows: current and/or not current.\nAllowed lines: whether to process blank or folded lines, lines before/at/after cursor line, etc. Example: user can configure to look for word starts only inside current window at or after cursor line with ‘j’ and ‘k’ labels performing some action after jump.\n\nPreconfigured ways of computing jump spots: line start, word start, to single or multiple characters (typed by user).\nWorks in Visual and Operator-pending modes with same command.\nWorks with multibyte characters.\n\nMain differences from ‘phaazon/hop.nvim’:\n\n‘hop.nvim’ computes labels (called “hints”) based on current cursor position, while ‘mini.jump2d’ deliberately does not take cursor into account.\n‘hop.nvim’ visualizes labels differently. It is designed to show whole sequences at once, while ‘mini.jump2d’ intentionally shows only current one at a time.\n‘hop.nvim’ exports many targeted commands for builtin jump types, while ‘mini.jump2d’ has preconfigured basic options leaving others to customization with Lua code.\n‘mini.jump2d’ has opinionated default algorithm of computing jump spots.\n\nPlease try it out and share your thoughts (here in comments or in dedicated beta-testing issue). Thanks!"
  },
  {
    "objectID": "blog/2022-08-19-update-mini-nvim-colors-minicyan.html",
    "href": "blog/2022-08-19-update-mini-nvim-colors-minicyan.html",
    "title": "Update of ‘mini.base16’ and a new minicyan color scheme",
    "section": "",
    "text": "Originally posted on Reddit\n \nHello, Neovim users!\nI’d like to make a post about color updates in ‘mini.nvim’ (collection of 20+ independent Lua plugins improving Neovim&gt;=0.5 experience with minimal effort):\n\n‘mini.base16’ got new 25 plugin integrations along with option to granularly control what highlight groups are created (to squeeze precious milliseconds of startup time). Here is a full list of available integrations and how they can be controlled. Full disclosure: not all integrations are explicit (i.e. have new highlight groups created); some have very nice defaults which I chose not to override (like ‘nvim-lualine/lualine.nvim’). Nevertheless, they will be monitored from time to time to see if any adjustment should be done.\nThere is a new ‘minicyan’ color scheme (shown in these screenshots). It is created with ‘mini.base16’ via its own palette generator: it just needs foreground, background and accent chroma values to generate readable and coherent base16 palette (I am really proud of it somehow, to be honest). It has cyan and grey main colors which resulted into moderate contrast and saturation palette. Base cyan color came as inspiration from my contribution to popular Neovim color schemes journey.\n\nIf you are looking for fast and fully featured color scheme, try ‘mini.base16’ with its palette generator and tell me what you think. Thanks!\n(Side note: I was really impressed with UI of mason.nvim; check it out if you haven’t already)"
  },
  {
    "objectID": "blog/2024-05-21-announce-mini-git.html",
    "href": "blog/2024-05-21-announce-mini-git.html",
    "title": "Announcing ‘mini.git’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nLet’s together celebrate the release of mini.git - new module of mini.nvim for better Git integration. It can also be installed using separate GitHub repository.\n\nFirst things first. This release marks ‘mini.nvim’ reaching two important milestones: - It is already module number 40. They grow up so fast. - The project recently reached 4000 GitHub stars. Thank you for your support and trust!\n\nBriefly about module itself. This is not intended as a one-to-one ‘tpope/vim-fugitive’ or full featured Git client replacement!\nGit related functionality was one of the oldest module requests dating back to October 2022. After some thoughts, I have finally come up with a scope that I feel strikes an important balance between features and maintainability.\nIts initial goal was to track Git related data in a way that can be used in statusline (can be seen used inside statusline in demo). This should pair nicely with what ‘mini.diff’ already does for diff hunks. The ‘mini.statusline’ module now uses ‘mini.git’ and ‘mini.diff’ by default for Git-diff-related sections (with fallback to ‘lewis6991/gitsigns.nvim’, so no major breaking).\nAfter some thinking, I’ve also decided to add Fugitive-style :Git command and helpers for history navigation. Demo video showcases them both nicely.\n\nFeatures:\n\nAutomated tracking of Git related data: root path, status, HEAD, etc. Exposes buffer-local variables for convenient use in statusline.\n:Git command for executing any git call inside file’s repository root with deeper current instance integration (show output as notification/buffer, use to edit commit messages, etc.).\nHelper functions to inspect Git history:\n\nMiniGit.show_range_history() shows how certain line range evolved.\nMiniGit.show_diff_source() shows file state as it was at diff entry.\nMiniGit.show_at_cursor() shows Git related data depending on context.\n\n\nWhat it doesn’t do:\n\nReplace fully featured Git client. Rule of thumb: if feature does not rely on a state of current Neovim (opened buffers, etc.), it is out of scope. For more functionality, use either ‘mini.diff’ or fully featured Git client.\n\nTo read more information, see these tags in help file:\n\n*:Git*\n*MiniGit-examples*\n*MiniGit.enable()*\n*MiniGit.get_buf_data()*\n\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-01-20-announce-mini-doc.html",
    "href": "blog/2022-01-20-announce-mini-doc.html",
    "title": "Announcing ‘mini.doc’",
    "section": "",
    "text": "Originally posted on Reddit\nHello people!\nI am happy to announce mini.doc - module of mini.nvim for generating help files (what you read when using :help) from EmmyLua-like annotations (not fully complying with this standard but very close). The basic idea is to keep documentation close to Lua implementation and generate help files automatically. It was written mainly to document ‘mini.nvim’ (instead of previous great but not that flexible tjdevries/tree-sitter-lua), but other people can also benefit from this. And not only plugin authors: general user can also document their Neovim Lua setup!\nBasically, it works like this:\n\nParse every input file line by line from top to bottom to separate annotations from what is annotated (“afterlines”).\nParse every consecutive annotation lines from top to bottom to determine for every line to which ‘section’ it belongs.\nConstruct hierarchical data structure that describes parsing result. Every hierarchy level is an enhanced Lua array of objects one level lower. Levels are ‘section’ (array of consecutive parsed annotation lines) &lt; ‘block’ &lt; ‘file’ &lt; ‘doc’.\nIteratively apply extensive (but fully configurable!) hooks to modify output. This is where everything essential happens: infer tag and signature from “afterlines”, add new lines, format existing ones, and many more.\nCollect lines and put them in output path.\n\nTo give an example, this Lua code …\n--- My very first Lua function\n---\n---@param x number First number.\n---@param y number Second number.\n---\n---@return number Sum of `x` and `y`.\nModule.my_fun = function(x, y)\n  return x + y\nend\n… will be converted into these lines (in actual help file they are a bit more colorful):\n                                                               *Module.my_fun()*\n                           `Module.my_fun`({x}, {y})\nMy very first Lua function\n\nParameters~\n{x} `(number)` First number.\n{y} `(number)` Second number.\n\nReturn~\n`(number)` Sum of `x` and `y`.\nWhat extra features I consider to be very useful:\n\nHaving a way of automatically generate help lines based on what is documented (use @eval section with executable Lua code). It was a relief to be able to automatically generate default config values for all ‘mini.nvim’ modules.\nSupporting @alias sections to avoid annotation duplication.\nSupporting local configuration by creating a plain Lua script at configurable path. This is a currently proposed way of controlling which Lua files are parsed, where and how output is created, etc.\n\nFor full disclosure, what features are not that great but probably will stay in order to manage complexity:\n\nNot supporting markdown in comments in favor of Vim’s help syntax.\nUsing Lua string manipulation by default for basic tasks: what lines are recognized as annotations, how they are modified, how tag and signature are automatically created, etc.\nNot having rich auto-formatting capabilities (like wrapping for target width, auto-indenting, etc.).\n\nGive it a try! Feedback is highly welcome (either here or in this dedicated issue). I consider general design to be stable enough with only default behavior subject to change (based on your feedback) before next ‘mini.nvim’ stable release."
  },
  {
    "objectID": "blog/2025-12-07-announce-mini-cmdline.html",
    "href": "blog/2025-12-07-announce-mini-cmdline.html",
    "title": "Announcing ‘mini.cmdline’",
    "section": "",
    "text": "Video\nHello, Neovim users!\nAfter what feels like an eternity, there is now a new module: ‘mini.cmdline’.\nThe ‘mini.nvim’ is long overdue a new 0.17 release. After contemplating a “just do it” approach, I decided that keeping the “every release has at least one new module” streak is worth it.\nSo after looking for which module would be the most beneficial while taking not-so-long to write, the choice fell on implementing various Neovim command line tweaks.\n\nFeatures of ‘mini.cmdline’:\n\nAutocomplete with customizable delay. This is basically an automated pressing of 'wildchar' (&lt;Tab&gt; by default) with some extra configuration possibilities. Proved to be more useful than I anticipated.\nRequires Neovim&gt;=0.11, though Neovim&gt;=0.12 is recommended.\nAutocorrect words as-you-type. Only words that must come from a fixed set of candidates (like commands and options) are autocorrected by default.\nAutopeek command range as-you-type. Shows a floating window with range lines along with customizable context lines. Looks really cool!\n\nWhat it doesn’t do:\n\nCustomization of command line UI. Hopefully :h vim._extui will be enough for that (on Neovim&gt;=0.12).\nCustomization of autocompletion candidates. They are computed via :h cmdline-completion based on how current command defines its completion.\n\n\nPlease, check it out and tell me what you think! For the time being (until there are comments on the site) leave a comment in a dedicated beta-testing issue.\nI’d like to make 0.17 release relatively soon, so extensive public beta-testing will help a lot.\nThanks!"
  },
  {
    "objectID": "blog/2025-12-18-release-0170.html",
    "href": "blog/2025-12-18-release-0170.html",
    "title": "Release 0.17.0",
    "section": "",
    "text": "Hello, Neovim users!\nThe ‘mini.nvim’ plugin has released a new 0.17.0 version. The previous release was a whopping 7 months and 235 commits ago. The new one is long overdue, to say the least.\nHere is a full release description if you are curious.\n\nThere is only one new module in this release:\n\n‘mini.cmdline’ - Command line tweaks. It enables autocomplete (requires Neovim&gt;=0.11), autocorrect, and autopeek range when using command line. You can read more in this release post.\n\n\nOne of the big reasons why this release took so much more time than previous ones is that there was a lot of adjacent work:\n\nThe whole project was rebranded to be MINI: Modular Independent Neovim Improvements.\nThere is now a website. It took a lot of time to plan and execute.\nHosting moved from echasnovski personal GitHub account to a dedicated nvim-mini organization. This change is made to improve long term project stability. See more details here.\nThere is now an amazing team that helps me with MINI. Improving bus factor of the project is very important for its longevity.\nThere is an “official” Neovim config example based on ‘mini.nvim’: MiniMax. In fact, it is designed as a collection of examples, each independent and tailored to specific Neovim version. It is not a lot now, but with time it might be a valuable resource about how Neovim config can change with time.\n\nThe other big reason for a long release delay is that in July my initial PR for the Neovim’s built-in plugin manager (vim.pack) got merged. Its core ideas come from ‘mini.deps’ with some adjustments and overall improvements. It required a lot of time and effort to address initial issues and discussions.\n\nThe full changelog for 0.17 is here. Noticeable changes include:\n\nThere is now a set of static ‘mini.hues’ based color schemes to complete randomhue. They are inspired by four seasons: miniwinter, minispring, minisummer, miniautumn.\n‘mini.ai’ and ‘mini.surround’ tree-sitter integrations now don’t use ‘nvim-treesitter’ functions by default in favor of built-in vim.treesitter approaches.\n‘mini.extra’ got colorschemes picker and workspace_symbol_live scope to lsp picker.\n‘mini.files’ now:\n\nNever hides a preview window, even if cursor is on something that can not be previewed. This should reduce flickering in various situations.\nTreats appending / to a file name as “delete it and create a directory with the same name”. Useful when earlier you wanted to create a directory but forgot to append “/”.\nHas config.content.highlight to adjust highlighting of file system entries.\n\n‘mini.hues’ has several groups autoadjust their highlighting based on certain events. Like Pmenu adjusts based on the value of ‘pumborder’ option (on Neovim&gt;=0.12).\n‘mini.jump2d’ moved gen_xxx_spotter functions into a separate gen_spotter table to follow the pattern from other modules.\n‘mini.misc’ got logging related functions (log_add, log_show, etc.). I use them very frequently during ‘mini.nvim’ development.\n‘mini.pick’ now:\n\nHas grep and grep_live pickers with rg tool respect Neovim’s ‘ignorecase’ and ‘smartcase’ options when matching.\n“Paste” action supports some special registers. Like &lt;C-r&gt;&lt;C-w&gt; will paste word at cursor.\n\n‘mini.surround’ doesn’t create update_n_lines to save “mapping real estate”. This will be useful later.\n‘mini.test’ screenshot testing now ignores text and highlighting attributes separately via ignore_text and ignore_attr.\n\n\nHuge thank you for the continued support of ‘mini.nvim’ project! We are past 8.4K stars now 🙏\nThere is a lot more planned for ‘mini.nvim’ and MINI. So let’s keep in touch :)"
  },
  {
    "objectID": "blog/2024-02-11-announce-mini-deps.html",
    "href": "blog/2024-02-11-announce-mini-deps.html",
    "title": "Announcing ‘mini.deps’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am happy to share with you a release of mini.deps - new module of mini.nvim which acts as a plugin manager to install and manage other plugins. It can also be installed using separate GitHub repository.\n\nThis was one of the toughest modules to write as of yet. Although overall goal of managing plugins seems more or less straightforward, actually designing the balance between simplicity and usability has proved to be not as trivial. I ended up redesigning the overall approach three times. Combined with slow iteration process of simulating plugin updates, not trivial testing, and some real life issues, this took waaaay longer than I would’ve liked. Despite all this, it is now fully designed, implemented, tested, and documented.\nOverall, it uses Git and built-in packages to install, update, clean, and snapshot plugins. It is far less feature-rich than ‘folke/lazy.nvim’ and slightly more user-friendly than ‘savq/paq-nvim’. In my opinion it ended up somewhere near ‘junegunn/vim-plug’ when talking about user experience.\n\nFeatures:\n\nManage plugins utilizing Git and built-in packages with these actions:\n\nAdd plugin to current session, download if absent.\nUpdate with/without confirm, with/without parallel download of new data.\nDelete unused plugins with/without confirm.\nGet / set / save / load snapshot.\n\nMinimal yet flexible plugin specification:\n\nPlugin source.\nName of target plugin directory.\nCheckout target: branch, commit, tag, etc.\nMonitor branch to track updates without checking out.\nDependencies to be set up prior to the target plugin.\nHooks to call before/after plugin is created/changed.\n\nHelpers implementing two-stage startup: now() and later().\n\nFor slightly more details, see overview in README.\nFor even more information, see these tags in help file: - *MiniDeps-plugin-specification* - *MiniDeps-commands*\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nI do want to point out that it is a good idea to first try this without affecting your main config. Here is one example with two quick steps of how to do this.\nThanks!"
  },
  {
    "objectID": "blog/2025-10-13-announce-minimax.html",
    "href": "blog/2025-10-13-announce-minimax.html",
    "title": "MiniMax - Neovim with maximum MINI",
    "section": "",
    "text": "Hello, Neovim users!\nIt is a huge joy and relief to be able to announce this: there is now an “official” MINI config example. It is called MiniMax.\nThis release makes today a triple MINI birthday:\n\nThe ‘mini.nvim’ plugin itself was released four years ago.\nThe ‘mini.pick’ module was released two years ago.\nAnd MiniMax now also has today as its birthday.\n\n\nMiniMax is designed to be more than a single config. It is a collection of configs, each specially crafted for specific conditions. Currently it is planned to have a dedicated config for each stable Neovim release, but other conditions are possible (but probably not in the near future). As far as I know, this type of arrangement is pretty unique among existing “preconfigured configurations”. It would make MiniMax useful beyond just configs: with time it might become a good reference for which changes are worth having when changing Neovim versions.\nConfigs themselves are fairly minimal in structure: small ‘init.lua’ and four ‘plugin/’ files that are loaded at startup. Their structure and contents are based on my own config that I’ve been daily driving for a very long time.\nIn today’s terms, MiniMax is similar to ‘nvim-lua/kickstart.nvim’ in its style. Config files contain a lot of documentation comments and are meant to be read. Once you set up MiniMax, it is also up to you to tweak and update it. It is not a distro and not a comprehensive guide for everything Neovim\nPlease check it out and tell me what you think. I’d like to focus on making the current state as usable, polished, and typo free as possible. For the time being, suggestions about adding new specific option and/or plugin will not be considered.\n\nI would also like to thank Pete Kazmier for all the helpful feedback during MiniMax development.\nAnd thank you all for your continuous support! Let’s hope to meet again for many more such birthdays to come!"
  },
  {
    "objectID": "mini.nvim/index.html",
    "href": "mini.nvim/index.html",
    "title": "mini.nvim",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/index.html#table-of-contents",
    "href": "mini.nvim/index.html#table-of-contents",
    "title": "mini.nvim",
    "section": "Table of contents",
    "text": "Table of contents\n\nInstallation\nModules\nGeneral principles\nPlugin color schemes\nPlanned modules"
  },
  {
    "objectID": "mini.nvim/index.html#installation",
    "href": "mini.nvim/index.html#installation",
    "title": "mini.nvim",
    "section": "Installation",
    "text": "Installation\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods:\n\nManually with git clone (compatible with mini.deps):\n\n-- Put this at the top of 'init.lua'\nlocal path_package = vim.fn.stdpath('data') .. '/site'\nlocal mini_path = path_package .. '/pack/deps/start/mini.nvim'\nif not vim.loop.fs_stat(mini_path) then\n  vim.cmd('echo \"Installing `mini.nvim`\" | redraw')\n  local clone_cmd = {\n    'git', 'clone', '--filter=blob:none',\n    -- Uncomment next line to use 'stable' branch\n    -- '--branch', 'stable',\n    'https://github.com/nvim-mini/mini.nvim', mini_path\n  }\n  vim.fn.system(clone_cmd)\n  vim.cmd('packadd mini.nvim | helptags ALL')\n  vim.cmd('echo \"Installed `mini.nvim`\" | redraw')\nend\n\nWith folke/lazy.nvim:\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\n\nWith junegunn/vim-plug:\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\n\nEvery module is also distributed as a standalone Git repository. Check out module’s information for more details.\n\nImportant: don’t forget to call module’s setup() (if required) to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/index.html#modules",
    "href": "mini.nvim/index.html#modules",
    "title": "mini.nvim",
    "section": "Modules",
    "text": "Modules\n‘mini.nvim’ contains many modules which is slightly daunting at first. All of them can be used independently, one at a time.\nFor easier exploration, here they are presented in groups based on module’s primary functionality (although some modules can fit in several groups). See more detailed listing here.\n\nText editing\nThese modules improve your text editing experience. Start with ‘mini.ai’, ‘mini.operators’, and ‘mini.surround’.\n\n\n\nModule\nDescription\nOverview\nDetails\n\n\n\n\nmini.ai\nExtend and create a/i textobjects\nREADME\nDocumentation\n\n\nmini.align\nAlign text interactively\nREADME\nDocumentation\n\n\nmini.comment\nComment lines\nREADME\nDocumentation\n\n\nmini.completion\nCompletion and signature help\nREADME\nDocumentation\n\n\nmini.keymap\nSpecial key mappings\nREADME\nDocumentation\n\n\nmini.move\nMove any selection in any direction\nREADME\nDocumentation\n\n\nmini.operators\nText edit operators\nREADME\nDocumentation\n\n\nmini.pairs\nAutopairs\nREADME\nDocumentation\n\n\nmini.snippets\nManage and expand snippets\nREADME\nDocumentation\n\n\nmini.splitjoin\nSplit and join arguments\nREADME\nDocumentation\n\n\nmini.surround\nSurround actions\nREADME\nDocumentation\n\n\n\n\n\nGeneral workflow\nThese modules improve your general workflow. Start with ‘mini.bracketed’, ‘mini.files’, and ‘mini.pick’.\n\n\n\nModule\nDescription\nOverview\nDetails\n\n\n\n\nmini.basics\nCommon configuration presets\nREADME\nDocumentation\n\n\nmini.bracketed\nGo forward/backward with square brackets\nREADME\nDocumentation\n\n\nmini.bufremove\nRemove buffers\nREADME\nDocumentation\n\n\nmini.clue\nShow next key clues\nREADME\nDocumentation\n\n\nmini.cmdline\nCommand line tweaks\nREADME\nDocumentation\n\n\nmini.deps\nPlugin manager\nREADME\nDocumentation\n\n\nmini.diff\nWork with diff hunks\nREADME\nDocumentation\n\n\nmini.extra\nExtra ‘mini.nvim’ functionality\nREADME\nDocumentation\n\n\nmini.files\nNavigate and manipulate file system\nREADME\nDocumentation\n\n\nmini.git\nGit integration\nREADME\nDocumentation\n\n\nmini.jump\nJump to next/previous single character\nREADME\nDocumentation\n\n\nmini.jump2d\nJump within visible lines\nREADME\nDocumentation\n\n\nmini.misc\nMiscellaneous functions\nREADME\nDocumentation\n\n\nmini.pick\nPick anything\nREADME\nDocumentation\n\n\nmini.sessions\nSession management\nREADME\nDocumentation\n\n\nmini.visits\nTrack and reuse file system visits\nREADME\nDocumentation\n\n\n\n\n\nAppearance\nThese modules improve your Neovim appearance. Start with ‘mini.hues’, ‘mini.icons’, and ‘mini.statusline’.\n\n\n\nModule\nDescription\nOverview\nDetails\n\n\n\n\nmini.animate\nAnimate common Neovim actions\nREADME\nDocumentation\n\n\nmini.base16\nBase16 colorscheme creation\nREADME\nDocumentation\n\n\nmini.colors\nTweak and save any color scheme\nREADME\nDocumentation\n\n\nmini.cursorword\nAutohighlight word under cursor\nREADME\nDocumentation\n\n\nmini.hipatterns\nHighlight patterns in text\nREADME\nDocumentation\n\n\nmini.hues\nGenerate configurable color scheme\nREADME\nDocumentation\n\n\nmini.icons\nIcon provider\nREADME\nDocumentation\n\n\nmini.indentscope\nVisualize and work with indent scope\nREADME\nDocumentation\n\n\nmini.map\nWindow with buffer text overview\nREADME\nDocumentation\n\n\nmini.notify\nShow notifications\nREADME\nDocumentation\n\n\nmini.starter\nStart screen\nREADME\nDocumentation\n\n\nmini.statusline\nStatusline\nREADME\nDocumentation\n\n\nmini.tabline\nTabline\nREADME\nDocumentation\n\n\nmini.trailspace\nTrailspace (highlight and remove)\nREADME\nDocumentation\n\n\n\n\n\nOther\nThese modules don’t quite fit in any of the previous categories.\n\n\n\nModule\nDescription\nOverview\nDetails\n\n\n\n\nmini.doc\nGenerate Neovim help files\nREADME\nDocumentation\n\n\nmini.fuzzy\nFuzzy matching\nREADME\nDocumentation\n\n\nmini.test\nTest Neovim plugins\nREADME\nDocumentation"
  },
  {
    "objectID": "mini.nvim/index.html#general-principles",
    "href": "mini.nvim/index.html#general-principles",
    "title": "mini.nvim",
    "section": "General principles",
    "text": "General principles\n\nDesign\nEach module is designed to solve a particular problem targeting balance between feature-richness (handling as many edge-cases as possible) and simplicity of implementation/support. Granted, not all of them ended up with the same balance, but it is the goal nevertheless.\n\n\nIndependence\nModules are independent of each other and can be run without external dependencies. Although some of them may need dependencies for full experience.\n\n\nStructure\nEach module is a submodule for a placeholder “mini” module. So, for example, “surround” module should be referred to as “mini.surround”. As later will be explained, this plugin can also be referred to as “MiniSurround”.\n\n\nSetup\n\nEach module you want to use should be enabled separately with require(&lt;name of module&gt;).setup({}). Possibly replace {} with your config table or omit altogether to use defaults. You can supply only parts of config, the rest will be inferred from defaults.\nCall to module’s setup() always creates a global Lua object with coherent camel-case name: require('mini.surround').setup() creates _G.MiniSurround. This allows for a simpler usage of plugin functionality: instead of require('mini.surround') use MiniSurround (or manually :lua MiniSurround.* in command line); available from v:lua like v:lua.MiniSurround. Considering this, “module” and “Lua object” names can be used interchangeably: ‘mini.surround’ and ‘MiniSurround’ will mean the same thing.\nEach supplied config table is stored in config field of global object. Like MiniSurround.config.\nValues of config which affect runtime activity can be changed on the fly to have effect. For example, MiniSurround.config.n_lines can be changed during runtime; but changing MiniSurround.config.mappings won’t have any effect (as mappings are created once during setup()).\nIf module works best with some specific non-default option value, it is set during setup(). If the value is not essential to module’s functionality, it is done only if user or another plugin hasn’t set it beforehand (no matter the value).\n\n\n\nBuffer local configuration\nEach module can be additionally configured to use certain runtime config settings locally to buffer. See mini.nvim-buffer-local-config section in help file for more information.\n\n\nBuffer names\nAll module-related buffers are named according to the following format: mini&lt;module-name&gt;://&lt;buffer-number&gt;/&lt;useful-info&gt; (forward slashes are used on any platform; &lt;useful-info&gt; may be empty). This structure allows creating identifiable, reasonably unique, and useful buffer names. For example, ‘mini.files’ buffers are created per displayed directory/file with names like minifiles://10/path/to/displayed/directory.\n\n\nDisabling\nEach module’s core functionality can be disabled globally or locally to buffer. See “Disabling” section in module’s help page for more details. See mini.nvim-disabling-recipes section in main help file for common recipes.\n\n\nSilencing\nEach module providing non-error feedback can be configured to not do that by setting config.silent = true (either inside setup() call or on the fly).\n\n\nHighlighting\nAppearance of module’s output is controlled by certain set of highlight groups (see :h highlight-groups). By default they usually link to some semantically close built-in highlight group and are ensured to be defined after any color scheme takes effect. Use :highlight command or vim.api.nvim_set_hl() Lua function to customize highlighting. To see a more calibrated look, use ‘mini.hues’, ‘mini.base16’, or plugin’s color scheme.\n\n\nStability\nEach module upon release is considered to be relatively stable: both in terms of setup and functionality. Any non-bugfix backward-incompatible change will be released gradually as much as possible.\n\n\nNot filetype and language specific\nIncluding functionality which needs several filetype/language specific implementations is an explicit no-goal of this project. This is mostly due to the potential increase in maintenance to keep implementation up to date. However, any part which might need filetype/language specific tuning should be designed to allow it by letting user set proper buffer options and/or local configuration."
  },
  {
    "objectID": "mini.nvim/index.html#plugin-color-schemes",
    "href": "mini.nvim/index.html#plugin-color-schemes",
    "title": "mini.nvim",
    "section": "Plugin color schemes",
    "text": "Plugin color schemes\nThis plugin comes with several color schemes (all have both dark and light variants). Activate any of them as a regular colorscheme (like :colorscheme miniwinter or vim.cmd.colorscheme('miniwinter')).\n\nBased on ‘mini.hues’ (recommended):\n\nminiwinter: “icy winter” palette with azure background.\nminispring: “blooming spring” palette with green background.\nminisummer: “hot summer” palette with brown/yellow background.\nminiautumn: “cooling autumn” palette with purple background.\nrandomhue: random background and foreground of the same hue with medium saturation.\n\nYou can see how they look in ‘mini.hues’ README.\nBased on ‘mini.base16’:\n\nminicyan: cyan and grey main colors with medium contrast and saturation palette.\nminischeme: blue and yellow main colors with high contrast and saturation palette.\n\nYou can see how they look in ‘mini.base16’ README."
  },
  {
    "objectID": "mini.nvim/index.html#planned-modules",
    "href": "mini.nvim/index.html#planned-modules",
    "title": "mini.nvim",
    "section": "Planned modules",
    "text": "Planned modules\nThis is the list of modules I currently intend to implement eventually (as my free time and dedication will allow), in alphabetical order:\n\n‘mini.abbrev’ - helper to manage/setup Insert mode abbreviations.\n‘mini.cycle’ - cycle through alternatives with pre-defined rules. Something like monaqa/dial.nvim and AndrewRadev/switch.vim\n‘mini.folds’ - more capable and user-friendly folds.\n‘mini.repl’ - extendable wrapper for REPLs with built-in support for R, Python, Julia, and maybe (just maybe) some AI tools.\n‘mini.sendtext’ - send text between buffers. In particular between regular and built-in terminal buffers.\n‘mini.statuscolumn’ - customizable ‘statuscolumn’.\n‘mini.terminals’ - coherently manage interactive terminal buffers. Something like kassio/neoterm. Might also incorporate functionality to asynchronously run code in shell with post-processed results.\n‘mini.quickfix’ - more capable and user-friendly quickfix list. Possibly with preview and inline editing for search-and-replace workflow.\n‘mini.windows’ - window manager. Interactive picker, layout organizer, and maybe more."
  },
  {
    "objectID": "mini.nvim/readmes/mini-animate.html",
    "href": "mini.nvim/readmes/mini-animate.html",
    "title": "mini.animate",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-animate.html#demo",
    "href": "mini.nvim/readmes/mini-animate.html#demo",
    "title": "mini.animate",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-animate.html#features",
    "href": "mini.nvim/readmes/mini-animate.html#features",
    "title": "mini.animate",
    "section": "Features",
    "text": "Features\n\nWorks out of the box with a single require('mini.animate').setup(). No extra mappings or commands needed.\nAnimate cursor movement inside same buffer by showing customizable path.\nAnimate scrolling with a series of subscrolls (“smooth scrolling”).\nAnimate window resize by gradually changing sizes of all windows.\nAnimate window open/close with visually updating floating window.\nTimings for all actions can be customized independently.\nAction animations can be enabled/disabled independently.\nAll animations are asynchronous/non-blocking and trigger a targeted event which can be used to perform actions after animation is done.\nMiniAnimate.animate() function which can be used to perform own animations.\n\nNotes:\n\nScroll and resize animations actually change Neovim state to achieve their effects and are asynchronous. This can cause following issues:\n\nIf you have remapped any movement operation to center after it is done (like with nzvzz or &lt;C-d&gt;zz), you need to change those mappings. Either remove them or update to use MiniAnimate.execute_after() (see :h MiniAnimate.config.scroll)\nUsing mouse wheel to scroll can appear slower or can have visual jitter. This usually happens due to high number of wheel turns per second: each turn is taking over previous one to start new animation. To mitigate this, you can either modify ‘mousescroll’ option (set vertical scroll to 1 and use high turn speed or set to high value and use one turn at a time) or config.scroll to fine tune when/how scroll animation is done."
  },
  {
    "objectID": "mini.nvim/readmes/mini-animate.html#installation",
    "href": "mini.nvim/readmes/mini-animate.html#installation",
    "title": "mini.animate",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.animate’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.animate’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.animate', version = false },\n\n\nStable\n{ 'nvim-mini/mini.animate', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.animate'\n\n\nStable\nPlug 'nvim-mini/mini.animate', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.animate').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-animate.html#default-config",
    "href": "mini.nvim/readmes/mini-animate.html#default-config",
    "title": "mini.animate",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Cursor path\n  cursor = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: implements linear total 250ms animation duration&gt;,\n\n    -- Path generator for visualized cursor movement\n    path = --&lt;function: implements shortest line path no longer than 1000&gt;,\n  },\n\n  -- Vertical scroll\n  scroll = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: implements linear total 250ms animation duration&gt;,\n\n    -- Subscroll generator based on total scroll\n    subscroll = --&lt;function: implements equal scroll with at most 60 steps&gt;,\n  },\n\n  -- Window resize\n  resize = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: implements linear total 250ms animation duration&gt;,\n\n    -- Subresize generator for all steps of resize animations\n    subresize = --&lt;function: implements equal linear steps&gt;,\n  },\n\n  -- Window open\n  open = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: implements linear total 250ms animation duration&gt;,\n\n    -- Floating window config generator visualizing specific window\n    winconfig = --&lt;function: implements static window for 25 steps&gt;,\n\n    -- 'winblend' (window transparency) generator for floating window\n    winblend = --&lt;function: implements equal linear steps from 80 to 100&gt;,\n  },\n\n  -- Window close\n  close = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: implements linear total 250ms animation duration&gt;,\n\n    -- Floating window config generator visualizing specific window\n    winconfig = --&lt;function: implements static window for 25 steps&gt;,\n\n    -- 'winblend' (window transparency) generator for floating window\n    winblend = --&lt;function: implements equal linear steps from 80 to 100&gt;,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-animate.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-animate.html#similar-plugins",
    "title": "mini.animate",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nNeovide (Neovim GUI, not a plugin)\nedluffy/specs.nvim\nkarb94/neoscroll.nvim\nanuvyklack/windows.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html",
    "href": "mini.nvim/readmes/mini-diff.html",
    "title": "mini.diff",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html#demo",
    "href": "mini.nvim/readmes/mini-diff.html#demo",
    "title": "mini.diff",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html#features",
    "href": "mini.nvim/readmes/mini-diff.html#features",
    "title": "mini.diff",
    "section": "Features",
    "text": "Features\n\nVisualize difference between buffer text and its configurable reference interactively (updates as you type). This is done per line showing whether it is inside added, changed, or deleted part of difference (called hunk). Visualization can be with customizable colored signs or line numbers.\nSpecial toggleable overlay view with more hunk details inside text area.\nCompletely configurable per buffer source(s) of reference text used to keep it up to date and define interactions with it. Can be array of sources which are attempted to attach in order. By default uses Git source (buffer’s file text from Git index as reference).\nConfigurable mappings to manage diff hunks:\n\nApply and reset hunks inside region (selected visually or with a dot-repeatable operator).\n“Hunk range under cursor” textobject to be used as operator target.\nNavigate to first/previous/next/last hunk.\n\n\nWhat it doesn’t do:\n\nProvide functionality to work directly with Git outside of visualizing and staging (applying) hunks with (default) Git source. In particular, unstaging hunks is not supported.\n\nFor more information see these parts of help:\n\n:h MiniDiff-overview\n:h MiniDiff-source-specification\n:h MiniDiff-hunk-specification\n:h MiniDiff-diff-summary"
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html#overview",
    "href": "mini.nvim/readmes/mini-diff.html#overview",
    "title": "mini.diff",
    "section": "Overview",
    "text": "Overview\n\nDiffs and hunks\nThe “diff” (short for “difference”) is a result of computing how two text strings differ from one another. This is done on per line basis, i.e. the goal is to compute sequences of lines common to both files, interspersed with groups of differing lines (called “hunks”).\nAlthough computing diff is a general concept (used on its own, in Git, etc.), this module computes difference between current text in a buffer and some reference text which is kept up to date specifically for that buffer. For example, default reference text is computed as file content in Git index. This can be customized in config.source.\n\n\nLife cycle\n\nWhen entering proper (not already enabled, valid, showing text) buffer, it is attempted to be enabled for diff processing.\nDuring enabling, attempt attaching the source. This should set up how reference text is kept up to date.\nOn every text change, diff computation is scheduled in debounced fashion after customizable delay (200 ms by default).\nAfter the diff is computed, do the following:\n\nUpdate visualization based on configurable style: either by placing colored text in sign column or coloring line numbers. Colors for both styles are defined per hunk type in corresponding MiniDiffSign* highlight group and sign text for “sign” style can be configured in config.view.signs.\nUpdate overlay view (if it is enabled).\nUpdate vim.b.minidiff_summary and vim.b.minidiff_summary_string buffer-local variables. These can be used, for example, in statusline.\nTrigger MiniDiffUpdated User event. See :h MiniDiff-diff-summary for example of how to use it.\n\n\nNotes:\n\nUse :edit to reset (disable and re-enable) current buffer.\n\n\n\nOverlay\nAlong with basic visualization, there is a special view called “overlay”. Although it is meant for temporary overview of diff details and can be manually toggled via MiniDiff.toggle_overlay(), text can be changed with overlay reacting accordingly.\nIt shows more diff details inside text area:\n\nAdded buffer lines are highlighted with MiniDiffOverAdd highlight group.\nDeleted reference lines are shown as virtual text and highlighted with MiniDiffOverDelete highlight group.\nChanged reference lines are shown as virtual text and highlighted with MiniDiffOverChange highlight group.\n“Change” hunks with equal number of buffer and reference lines have special treatment and show “word diff”. Reference line is shown next to its buffer counterpart and only changed parts of both lines are highlighted with MiniDiffOverChange. The rest of reference line has MiniDiffOverContext highlighting.\nThis usually is the case when config.options.linematch is enabled.\n\n\n\nMappings\nThis module provides mappings for common actions with diffs, like:\n\nApply and reset hunks.\n“Hunk range under cursor” textobject.\nGo to first/previous/next/last hunk range.\n\nExamples:\n\nvip followed by gh / gH applies/resets hunks inside current paragraph. Same can be achieved in operator form ghip / gHip, which has the advantage of being dot-repeatable.\ngh_ / gH_ applies/resets current line (even if it is not a full hunk).\nghgh / gHgh applies/resets hunk range under cursor.\ndgh deletes hunk range under cursor.\n[H / [h / ]h / ]H navigate cursor to the first / previous / next / last hunk range of the current buffer.\n\nMappings for some functionality are assumed to be done manually. See :h MiniDiff.operator().\n\n\nBuffer-local variables\nEach enabled buffer has the following buffer-local variables which can be used in custom statusline to show an overview of hunks in current buffer:\n\nvim.b.minidiff_summary is a table with the following fields:\n\nsource_name - name of the source.\nn_ranges - number of hunk ranges (sequences of contiguous hunks).\nadd - number of added lines.\nchange - number of changed lines.\ndelete - number of deleted lines.\n\nvim.b.minidiff_summary_string is a string representation of summary with a fixed format. It is expected to be used as is. To achieve different formatting, use vim.b.minidiff_summary to construct one. The best way to do this is by overriding vim.b.minidiff_summary_string in the callback for MiniDiffUpdated event:\nlocal format_summary = function(data)\n  local summary = vim.b[data.buf].minidiff_summary\n  local t = {}\n  if summary.add &gt; 0 then table.insert(t, '+' .. summary.add) end\n  if summary.change &gt; 0 then table.insert(t, '~' .. summary.change) end\n  if summary.delete &gt; 0 then table.insert(t, '-' .. summary.delete) end\n  vim.b[data.buf].minidiff_summary_string = table.concat(t, ' ')\nend\nlocal au_opts = { pattern = 'MiniDiffUpdated', callback = format_summary }\nvim.api.nvim_create_autocmd('User', au_opts)"
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html#installation",
    "href": "mini.nvim/readmes/mini-diff.html#installation",
    "title": "mini.diff",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.diff’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.diff’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.diff', version = false },\n\n\nStable\n{ 'nvim-mini/mini.diff', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.diff'\n\n\nStable\nPlug 'nvim-mini/mini.diff', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.diff').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html#default-config",
    "href": "mini.nvim/readmes/mini-diff.html#default-config",
    "title": "mini.diff",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Options for how hunks are visualized\n  view = {\n    -- Visualization style. Possible values are 'sign' and 'number'.\n    -- Default: 'number' if line numbers are enabled, 'sign' otherwise.\n    style = vim.go.number and 'number' or 'sign',\n\n    -- Signs used for hunks with 'sign' view\n    signs = { add = '▒', change = '▒', delete = '▒' },\n\n    -- Priority of used visualization extmarks\n    priority = 199,\n  },\n\n  -- Source(s) for how reference text is computed/updated/etc\n  -- Uses content from Git index by default\n  source = nil,\n\n  -- Delays (in ms) defining asynchronous processes\n  delay = {\n    -- How much to wait before update following every text change\n    text_change = 200,\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Apply hunks inside a visual/operator region\n    apply = 'gh',\n\n    -- Reset hunks inside a visual/operator region\n    reset = 'gH',\n\n    -- Hunk range textobject to be used inside operator\n    -- Works also in Visual mode if mapping differs from apply and reset\n    textobject = 'gh',\n\n    -- Go to hunk range in corresponding direction\n    goto_first = '[H',\n    goto_prev = '[h',\n    goto_next = ']h',\n    goto_last = ']H',\n  },\n\n  -- Various options\n  options = {\n    -- Diff algorithm. See `:h vim.diff()`.\n    algorithm = 'histogram',\n\n    -- Whether to use \"indent heuristic\". See `:h vim.diff()`.\n    indent_heuristic = true,\n\n    -- The amount of second-stage diff to align lines\n    linematch = 60,\n\n    -- Whether to wrap around edges during hunk navigation\n    wrap_goto = false,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-diff.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-diff.html#similar-plugins",
    "title": "mini.diff",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nlewis6991/gitsigns.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html",
    "href": "mini.nvim/readmes/mini-icons.html",
    "title": "mini.icons",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html#demo",
    "href": "mini.nvim/readmes/mini-icons.html#demo",
    "title": "mini.icons",
    "section": "Demo",
    "text": "Demo\n\n\n\ndemo-icons_glyph-dark\n\n\n\n\n\ndemo-icons_ascii\n\n\n\n\n\ndemo-icons_glyph-light"
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html#features",
    "href": "mini.nvim/readmes/mini-icons.html#features",
    "title": "mini.icons",
    "section": "Features",
    "text": "Features\n\nProvide icons with their highlighting via a single MiniIcons.get() for various categories: filetype, file/directory path, extension, operating system, LSP kind values. Icons and category defaults can be overridden.\nConfigurable styles: “glyph” (icon glyphs) or “ascii” (non-glyph fallback).\nFixed set of highlight groups (linked to built-in groups by default) for better blend with color scheme.\nCaching for maximum performance.\nIntegration with vim.filetype.add() and vim.filetype.match().\nMocking methods of ‘nvim-tree/nvim-web-devicons’ for better integrations with plugins outside ‘mini.nvim’. See :h MiniIcons.mock_nvim_web_devicons().\nTweaking built-in maps for “LSP kind” to include icons. In particular, this makes ‘mini.completion’ use icons in LSP step. See :h MiniIcons.tweak_lsp_kind().\n\nNotes:\n\nIt is not a goal to become a collection of icons for as much use cases as possible. There are specific criteria for icon data to be included as built-in in each category (see :h MiniIcons.get()). The main supported category is “filetype”.\n\nRecommendations for plugin authors using ‘mini.icons’ as a dependency:\n\nCheck if _G.MiniIcons table is present (which means that user explicitly enabled ‘mini.icons’) and provide icons only if it is.\nUse MiniIcons.get() function to get icon string and more data about it.\nFor file icons prefer using full path instead of relative or only basename. It makes a difference if path matches pattern that uses parent directories. The :h MiniIcons.config has an example of that."
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html#dependencies",
    "href": "mini.nvim/readmes/mini-icons.html#dependencies",
    "title": "mini.icons",
    "section": "Dependencies",
    "text": "Dependencies\nSuggested dependencies:\n\nTerminal emulator that supports showing special utf8 glyphs, possibly with “overflow” view (displaying is done not in one but two visual cells). Most modern feature-rich terminal emulators support this out of the box: WezTerm, Kitty, Alacritty, iTerm2, Ghostty.\nNot having “overflow” feature only results into smaller icons. Not having support for special utf8 glyphs will result into seemingly random symbols (or question mark squares) instead of icon glyphs.\nFont that supports Nerd Fonts icons from version 3.0.0+ (in particular nf-md-* class). This should be configured on terminal emulator level either by using font patched with Nerd Fonts icons or using NerdFontsSymbolsOnly font as a fallback for glyphs that are not supported in main font.\n\nIf using terminal emulator and/or font with icon support is impossible, use config.style = 'ascii'. It will use a (less visually appealing) set of non-glyph icons."
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html#installation",
    "href": "mini.nvim/readmes/mini-icons.html#installation",
    "title": "mini.icons",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.icons’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.icons’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.icons', version = false },\n\n\nStable\n{ 'nvim-mini/mini.icons', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.icons'\n\n\nStable\nPlug 'nvim-mini/mini.icons', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.icons').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html#default-config",
    "href": "mini.nvim/readmes/mini-icons.html#default-config",
    "title": "mini.icons",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Icon style: 'glyph' or 'ascii'\n  style = 'glyph',\n\n  -- Customize per category. See [`:h MiniIcons.config`](../doc/mini-icons.qmd#miniicons.config) for details.\n  default   = {},\n  directory = {},\n  extension = {},\n  file      = {},\n  filetype  = {},\n  lsp       = {},\n  os        = {},\n\n  -- Control which extensions will be considered during \"file\" resolution\n  use_file_extension = function(ext, file) return true end,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-icons.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-icons.html#similar-plugins",
    "title": "mini.icons",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-tree/nvim-web-devicons\nonsails/lspkind.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-misc.html",
    "href": "mini.nvim/readmes/mini-misc.html",
    "title": "mini.misc",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-misc.html#demo",
    "href": "mini.nvim/readmes/mini-misc.html#demo",
    "title": "mini.misc",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-misc.html#features",
    "href": "mini.nvim/readmes/mini-misc.html#features",
    "title": "mini.misc",
    "section": "Features",
    "text": "Features\n\nbench_time() executes function several times and timing how long it took.\nlog_add() / log_show() and other helper functions to work with a special in-memory log array. Useful when debugging Lua code (instead of print()).\nput() and put_text() print Lua objects in command line and current buffer respectively.\nresize_window() resizes current window to its editable width.\nsetup_auto_root() sets up automated change of current directory.\nsetup_termbg_sync() to set up terminal background synchronization (removes possible “frame” around current Neovim instance).\nsetup_restore_cursor() sets up automated restoration of cursor position on file reopen.\nstat_summary() computes summary statistics of numerical array.\ntbl_head() and tbl_tail() return first and last elements of table.\nzoom() makes current buffer full screen in a floating window.\nAnd more."
  },
  {
    "objectID": "mini.nvim/readmes/mini-misc.html#installation",
    "href": "mini.nvim/readmes/mini-misc.html#installation",
    "title": "mini.misc",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.misc’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.misc’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.misc', version = false },\n\n\nStable\n{ 'nvim-mini/mini.misc', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.misc'\n\n\nStable\nPlug 'nvim-mini/mini.misc', { 'branch': 'stable' }\n\n\n\n\n\nImportant: no need to call require('mini.misc').setup(), but it can be done to improve usability.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-misc.html#default-config",
    "href": "mini.nvim/readmes/mini-misc.html#default-config",
    "title": "mini.misc",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Array of fields to make global (to be used as independent variables)\n  make_global = { 'put', 'put_text' },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-misc.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-misc.html#similar-plugins",
    "title": "mini.misc",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-lua/plenary.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-git.html",
    "href": "mini.nvim/readmes/mini-git.html",
    "title": "mini.git",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-git.html#demo",
    "href": "mini.nvim/readmes/mini-git.html#demo",
    "title": "mini.git",
    "section": "Demo",
    "text": "Demo\nVideo\nNote: This demo uses custom vim.notify() from mini.notify and diff line number highlighting from mini.diff."
  },
  {
    "objectID": "mini.nvim/readmes/mini-git.html#features",
    "href": "mini.nvim/readmes/mini-git.html#features",
    "title": "mini.git",
    "section": "Features",
    "text": "Features\n\nAutomated tracking of Git related data: root path, status, HEAD, etc. Exposes buffer-local variables for convenient use in statusline.\n:Git command for executing any git call inside file’s repository root with deeper current instance integration (show output as notification/buffer, use to edit commit messages, etc.).\nHelper functions to inspect Git history:\n\nMiniGit.show_range_history() shows how certain line range evolved.\nMiniGit.show_diff_source() shows file state as it was at diff entry.\nMiniGit.show_at_cursor() shows Git related data depending on context.\n\n\nWhat it doesn’t do:\n\nReplace fully featured Git client. Rule of thumb: if feature does not rely on a state of current Neovim (opened buffers, etc.), it is out of scope. For more functionality, use either ‘mini.diff’ or fully featured Git client.\n\nFor more information see these parts of help:\n\n:h :Git\n:h MiniGit-examples\n:h MiniGit.enable()\n:h MiniGit.get_buf_data()"
  },
  {
    "objectID": "mini.nvim/readmes/mini-git.html#installation",
    "href": "mini.nvim/readmes/mini-git.html#installation",
    "title": "mini.git",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini-git’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini-git’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini-git', version = false },\n\n\nStable\n{ 'nvim-mini/mini-git', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini-git'\n\n\nStable\nPlug 'nvim-mini/mini-git', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.git').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-git.html#default-config",
    "href": "mini.nvim/readmes/mini-git.html#default-config",
    "title": "mini.git",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- General CLI execution\n  job = {\n    -- Path to Git executable\n    git_executable = 'git',\n\n    -- Timeout (in ms) for each job before force quit\n    timeout = 30000,\n  },\n\n  -- Options for [`:Git`](../doc/mini-git.qmd#git) command\n  command = {\n    -- Default split direction\n    split = 'auto',\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-git.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-git.html#similar-plugins",
    "title": "mini.git",
    "section": "Similar plugins",
    "text": "Similar plugins\n\ntpope/vim-fugitive\nNeogitOrg/neogit\nlewis6991/gitsigns.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-align.html",
    "href": "mini.nvim/readmes/mini-align.html",
    "title": "mini.align",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-align.html#demo",
    "href": "mini.nvim/readmes/mini-align.html#demo",
    "title": "mini.align",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-align.html#features",
    "href": "mini.nvim/readmes/mini-align.html#features",
    "title": "mini.align",
    "section": "Features",
    "text": "Features\n\nAlignment is done in three main steps:\n\nSplit lines into parts based on Lua pattern(s) or user-supplied rule.\nJustify parts for certain side(s) to be same width inside columns.\nMerge parts to be lines, with customizable delimiter(s).\n\nEach main step can be preceded by other steps (pre-steps) to achieve highly customizable outcome. See steps value in :h MiniAlign.config. For more details, see :h MiniAlign-glossary and :h MiniAlign-algorithm.\nUser can control alignment interactively by pressing customizable modifiers (single keys representing how alignment steps and/or options should change). Some of default modifiers:\n\nPress s to enter split Lua pattern.\nPress j to choose justification side from available ones (“left”, “center”, “right”, “none”).\nPress m to enter merge delimiter.\nPress f to enter filter Lua expression to configure which parts will be affected (like “align only first column”).\nPress i to ignore some commonly unwanted split matches.\nPress p to pair neighboring parts so they be aligned together.\nPress t to trim whitespace from parts.\nPress &lt;BS&gt; (backspace) to delete some last pre-step.\n\nFor more details, see :h MiniAlign-modifiers-builtin and :h MiniAlign-examples.\nAlignment can be done with instant preview (result is updated after each modifier) or without it (result is shown and accepted after non-default split pattern is set).\nEvery user interaction is accompanied with helper status message showing relevant information about current alignment process."
  },
  {
    "objectID": "mini.nvim/readmes/mini-align.html#installation",
    "href": "mini.nvim/readmes/mini-align.html#installation",
    "title": "mini.align",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.align’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.align’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.align', version = false },\n\n\nStable\n{ 'nvim-mini/mini.align', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.align'\n\n\nStable\nPlug 'nvim-mini/mini.align', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.align').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-align.html#default-config",
    "href": "mini.nvim/readmes/mini-align.html#default-config",
    "title": "mini.align",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    start = 'ga',\n    start_with_preview = 'gA',\n  },\n\n  -- Modifiers changing alignment steps and/or options\n  modifiers = {\n    -- Main option modifiers\n    ['s'] = --&lt;function: enter split pattern&gt;,\n    ['j'] = --&lt;function: choose justify side&gt;,\n    ['m'] = --&lt;function: enter merge delimiter&gt;,\n\n    -- Modifiers adding pre-steps\n    ['f'] = --&lt;function: filter parts by entering Lua expression&gt;,\n    ['i'] = --&lt;function: ignore some split matches&gt;,\n    ['p'] = --&lt;function: pair parts&gt;,\n    ['t'] = --&lt;function: trim parts&gt;,\n\n    -- Delete some last pre-step\n    ['&lt;BS&gt;'] = --&lt;function: delete some last pre-step&gt;,\n\n    -- Special configurations for common splits\n    ['='] = --&lt;function: enhanced setup for '='&gt;,\n    [','] = --&lt;function: enhanced setup for ','&gt;,\n    ['|'] = --&lt;function: enhanced setup for '|'&gt;,\n    [' '] = --&lt;function: enhanced setup for ' '&gt;,\n  },\n\n  -- Default options controlling alignment process\n  options = {\n    split_pattern = '',\n    justify_side = 'left',\n    merge_delimiter = '',\n  },\n\n  -- Default steps performing alignment (if `nil`, default is used)\n  steps = {\n    pre_split = {},\n    split = nil,\n    pre_justify = {},\n    justify = nil,\n    pre_merge = {},\n    merge = nil,\n  },\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-align.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-align.html#similar-plugins",
    "title": "mini.align",
    "section": "Similar plugins",
    "text": "Similar plugins\n\njunegunn/vim-easy-align\ngodlygeek/tabular\ntommcdo/vim-lion\nVonr/align.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-splitjoin.html",
    "href": "mini.nvim/readmes/mini-splitjoin.html",
    "title": "mini.splitjoin",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-splitjoin.html#demo",
    "href": "mini.nvim/readmes/mini-splitjoin.html#demo",
    "title": "mini.splitjoin",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-splitjoin.html#features",
    "href": "mini.nvim/readmes/mini-splitjoin.html#features",
    "title": "mini.splitjoin",
    "section": "Features",
    "text": "Features\n\nMappings and Lua functions that modify arguments (regions inside brackets between allowed separators) under cursor.\nSupported actions:\n\nToggle - split if arguments are on single line, join otherwise. Main supported function of the module. See MiniSplitjoin.toggle() in help file.\nSplit - make every argument separator be on end of separate line. See MiniSplitjoin.split() in help file.\nJoin - make all arguments be on single line. See MiniSplitjoin.join() in help file.\n\nMappings are dot-repeatable in Normal mode and work in Visual mode.\nCustomizable argument detection (see MiniSplitjoin.config.detect in help file):\n\nWhich brackets can contain arguments.\nWhich strings can separate arguments.\nWhich regions exclude when looking for separators (like inside nested brackets or quotes).\n\nCustomizable pre and post hooks for both split and join. See split and join of MiniSplitjoin.config in help file.\nWorks inside comments by using modified notion of indent. See MiniSplitjoin.get_indent_part() in help file.\nProvides low-level Lua functions for split and join at positions. See MiniSplitjoin.split_at() and MiniSplitjoin.join_at() in help file.\n\nNotes:\n\nSearch for arguments is done using Lua patterns (regex-like approach). Certain amount of false positives is to be expected.\nThis module is mostly designed around MiniSplitjoin.toggle(). If initial split positions are on different lines, join first and then split.\nActions can be done on Visual mode selection, which mostly present as a safety route in case of incorrect detection of initial region. It uses MiniSplitjoin.get_visual_region() which treats selection as full brackets (use va) and not vi))."
  },
  {
    "objectID": "mini.nvim/readmes/mini-splitjoin.html#installation",
    "href": "mini.nvim/readmes/mini-splitjoin.html#installation",
    "title": "mini.splitjoin",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.splitjoin’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.splitjoin’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.splitjoin', version = false },\n\n\nStable\n{ 'nvim-mini/mini.splitjoin', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.splitjoin'\n\n\nStable\nPlug 'nvim-mini/mini.splitjoin', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.splitjoin').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-splitjoin.html#default-config",
    "href": "mini.nvim/readmes/mini-splitjoin.html#default-config",
    "title": "mini.splitjoin",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Module mappings. Use `''` (empty string) to disable one.\n  -- Created for both Normal and Visual modes.\n  mappings = {\n    toggle = 'gS',\n    split = '',\n    join = '',\n  },\n\n  -- Detection options: where split/join should be done\n  detect = {\n    -- Array of Lua patterns to detect region with arguments.\n    -- Default: { '%b()', '%b[]', '%b{}' }\n    brackets = nil,\n\n    -- String Lua pattern defining argument separator\n    separator = ',',\n\n    -- Array of Lua patterns for sub-regions to exclude separators from.\n    -- Enables correct detection in presence of nested brackets and quotes.\n    -- Default: { '%b()', '%b[]', '%b{}', '%b\"\"', \"%b''\" }\n    exclude_regions = nil,\n  },\n\n  -- Split options\n  split = {\n    hooks_pre = {},\n    hooks_post = {},\n  },\n\n  -- Join options\n  join = {\n    hooks_pre = {},\n    hooks_post = {},\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-splitjoin.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-splitjoin.html#similar-plugins",
    "title": "mini.splitjoin",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nFooSoft/vim-argwrap\nAndrewRadev/splitjoin.vim\nWansmer/treesj"
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html",
    "href": "mini.nvim/readmes/mini-files.html",
    "title": "mini.files",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#demo",
    "href": "mini.nvim/readmes/mini-files.html#demo",
    "title": "mini.files",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#features",
    "href": "mini.nvim/readmes/mini-files.html#features",
    "title": "mini.files",
    "section": "Features",
    "text": "Features\n\nNavigate file system using column view (Miller columns) to display nested directories. See :h MiniFiles-navigation for overview.\nOpt-in preview of file or directory under cursor.\nManipulate files and directories by editing text buffers: create, delete, copy, rename, move. See :h MiniFiles-manipulation for overview.\nUse as default file explorer instead of netrw.\nConfigurable:\n\nFilter/prefix/sort of file system entries.\nMappings used for common explorer actions.\nUI options: whether to show preview of file/directory under cursor, etc.\nBookmarks for quicker navigation.\n\n\nSee :h MiniFiles-examples for some common configuration examples.\nNotes:\n\nThis module is written and thoroughly tested on Linux. Support for other platform/OS (like Windows or MacOS) is a goal, but there is no guarantee.\nThis module silently reacts to not enough permissions:\n\nIn case of missing file, check its or its parent read permissions.\nIn case of no manipulation result, check write permissions."
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#dependencies",
    "href": "mini.nvim/readmes/mini-files.html#dependencies",
    "title": "mini.files",
    "section": "Dependencies",
    "text": "Dependencies\nFor full experience needs (still works without any of suggestions):\n\nEnabled ‘mini.icons’ module to show icons near file/directory names. Can fall back to using nvim-tree/nvim-web-devicons plugin."
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#quick-start",
    "href": "mini.nvim/readmes/mini-files.html#quick-start",
    "title": "mini.files",
    "section": "Quick start",
    "text": "Quick start\n\nNavigation\n\nRun :lua MiniFiles.open().\nNavigate:\n\nPress j/k to navigate down/up.\nPress l to expand entry under cursor: show directory or open file in the most recent window.\nPress h to go to parent directory.\nType m&lt;char&gt; to set directory path of focused window as bookmark &lt;char&gt;. Jump to it with '&lt;char&gt;. Go back to before the latest jump with ''.\nType g? for more information about other available mappings and bookmarks.\nMove as in any other buffer ($, G, f/t, etc.).\n\n\nFor deeper overview, see :h MiniFiles-navigation.\n\n\nManipulation\n\nNavigate to the directory in which manipulation should be done.\nEdit buffer in the way representing file system action:\n\nCreate file/directory: create new line like file or dir/.\nCreate file/directory in the descendant directory: create new line like dir/file or dir/nested/.\nDelete file/directory: delete whole line representing that entry.\nRename file/directory: change text to the right of that entry’s icon.\nCopy file/directory: copy whole line and paste it in target directory.\nMove file/directory: cut whole line and paste it in target directory.\n\nPress =; read confirmation dialog; confirm with y/&lt;CR&gt; or not confirm with n/&lt;Esc&gt;.\n\nFor deeper overview, see :h MiniFiles-manipulation."
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#installation",
    "href": "mini.nvim/readmes/mini-files.html#installation",
    "title": "mini.files",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.files’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.files’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.files', version = false },\n\n\nStable\n{ 'nvim-mini/mini.files', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.files'\n\n\nStable\nPlug 'nvim-mini/mini.files', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.files').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#default-config",
    "href": "mini.nvim/readmes/mini-files.html#default-config",
    "title": "mini.files",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Customization of shown content\n  content = {\n    -- Predicate for which file system entries to show\n    filter = nil,\n    -- Highlight group to use for a file system entry\n    highlight = nil,\n    -- Prefix text and highlight to show to the left of file system entry\n    prefix = nil,\n    -- Order in which to show file system entries\n    sort = nil,\n  },\n\n  -- Module mappings created only inside explorer.\n  -- Use `''` (empty string) to not create one.\n  mappings = {\n    close       = 'q',\n    go_in       = 'l',\n    go_in_plus  = 'L',\n    go_out      = 'h',\n    go_out_plus = 'H',\n    mark_goto   = \"'\",\n    mark_set    = 'm',\n    reset       = '&lt;BS&gt;',\n    reveal_cwd  = '@',\n    show_help   = 'g?',\n    synchronize = '=',\n    trim_left   = '&lt;',\n    trim_right  = '&gt;',\n  },\n\n  -- General options\n  options = {\n    -- Whether to delete permanently or move into module-specific trash\n    permanent_delete = true,\n    -- Whether to use for editing directories\n    use_as_default_explorer = true,\n  },\n\n  -- Customization of explorer windows\n  windows = {\n    -- Maximum number of windows to show side by side\n    max_number = math.huge,\n    -- Whether to show preview of file/directory under cursor\n    preview = false,\n    -- Width of focused window\n    width_focus = 50,\n    -- Width of non-focused window\n    width_nofocus = 15,\n    -- Width of preview window\n    width_preview = 25,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-files.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-files.html#similar-plugins",
    "title": "mini.files",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-tree/nvim-tree.lua\nstevearc/oil.nvim\nnvim-neo-tree/neo-tree.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump.html",
    "href": "mini.nvim/readmes/mini-jump.html",
    "title": "mini.jump",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump.html#demo",
    "href": "mini.nvim/readmes/mini-jump.html#demo",
    "title": "mini.jump",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump.html#features",
    "href": "mini.nvim/readmes/mini-jump.html#features",
    "title": "mini.jump",
    "section": "Features",
    "text": "Features\n\nExtend f, F, t, T to work on multiple lines.\nRepeat jump by pressing f, F, t, T again. It is reset when cursor moved as a result of not jumping or timeout after idle time (duration customizable).\nHighlight (after customizable delay) all possible target characters and stop it after some (customizable) idle time.\nNormal, Visual, and Operator-pending (with full dot-repeat) modes are supported."
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump.html#installation",
    "href": "mini.nvim/readmes/mini-jump.html#installation",
    "title": "mini.jump",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.jump’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.jump’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.jump', version = false },\n\n\nStable\n{ 'nvim-mini/mini.jump', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.jump'\n\n\nStable\nPlug 'nvim-mini/mini.jump', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.jump').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump.html#default-config",
    "href": "mini.nvim/readmes/mini-jump.html#default-config",
    "title": "mini.jump",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    forward = 'f',\n    backward = 'F',\n    forward_till = 't',\n    backward_till = 'T',\n    repeat_jump = ';',\n  },\n\n  -- Delay values (in ms) for different functionalities. Set any of them to\n  -- a very big number (like 10^7) to virtually disable.\n  delay = {\n    -- Delay between jump and highlighting all possible jumps\n    highlight = 250,\n\n    -- Delay between jump and automatic stop if idle (no jump is done)\n    idle_stop = 10000000,\n  },\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-jump.html#similar-plugins",
    "title": "mini.jump",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nrhysd/clever-f.vim\njustinmk/vim-sneak"
  },
  {
    "objectID": "mini.nvim/readmes/mini-comment.html",
    "href": "mini.nvim/readmes/mini-comment.html",
    "title": "mini.comment",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-comment.html#demo",
    "href": "mini.nvim/readmes/mini-comment.html#demo",
    "title": "mini.comment",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-comment.html#features",
    "href": "mini.nvim/readmes/mini-comment.html#features",
    "title": "mini.comment",
    "section": "Features",
    "text": "Features\n\nCommenting in Normal mode respects v:count and is dot-repeatable.\nComment structure is inferred from ‘commentstring’: either from current buffer or from locally active tree-sitter language. It can be customized via options.custom_commentstring.\nHandles both tab and space indenting (but not when they are mixed).\nAllows custom hooks before and after successful commenting.\nConfigurable options for some nuanced behavior.\n\nNotes:\n\nTo use tree-sitter aware commenting, global value of ‘commentstring’ should be '' (empty string). This is the default value, so make sure to not set it manually to a different value."
  },
  {
    "objectID": "mini.nvim/readmes/mini-comment.html#installation",
    "href": "mini.nvim/readmes/mini-comment.html#installation",
    "title": "mini.comment",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.comment’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.comment’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.comment', version = false },\n\n\nStable\n{ 'nvim-mini/mini.comment', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.comment'\n\n\nStable\nPlug 'nvim-mini/mini.comment', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.comment').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-comment.html#default-config",
    "href": "mini.nvim/readmes/mini-comment.html#default-config",
    "title": "mini.comment",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Options which control module behavior\n  options = {\n    -- Function to compute custom 'commentstring' (optional)\n    custom_commentstring = nil,\n\n    -- Whether to ignore blank lines when commenting\n    ignore_blank_line = false,\n\n    -- Whether to ignore blank lines in actions and textobject\n    start_of_line = false,\n\n    -- Whether to force single space inner padding for comment parts\n    pad_comment_parts = true,\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Toggle comment (like `gcip` - comment inner paragraph) for both\n    -- Normal and Visual modes\n    comment = 'gc',\n\n    -- Toggle comment on current line\n    comment_line = 'gcc',\n\n    -- Toggle comment on visual selection\n    comment_visual = 'gc',\n\n    -- Define 'comment' textobject (like `dgc` - delete whole comment block)\n    -- Works also in Visual mode if mapping differs from `comment_visual`\n    textobject = 'gc',\n  },\n\n  -- Hook functions to be executed at certain stage of commenting\n  hooks = {\n    -- Before successful commenting. Does nothing by default.\n    pre = function() end,\n    -- After successful commenting. Does nothing by default.\n    post = function() end,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-comment.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-comment.html#similar-plugins",
    "title": "mini.comment",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nBuilt-in commenting in Neovim&gt;=0.10, see :h commenting (implemented with ‘mini.comment’ as reference)\nnumToStr/Comment.nvim\ntpope/vim-commentary\npreservim/nerdcommenter\nb3nj5m1n/kommentary"
  },
  {
    "objectID": "mini.nvim/readmes/mini-fuzzy.html",
    "href": "mini.nvim/readmes/mini-fuzzy.html",
    "title": "mini.fuzzy",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-fuzzy.html#demo",
    "href": "mini.nvim/readmes/mini-fuzzy.html#demo",
    "title": "mini.fuzzy",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-fuzzy.html#features",
    "href": "mini.nvim/readmes/mini-fuzzy.html#features",
    "title": "mini.fuzzy",
    "section": "Features",
    "text": "Features\n\nFunction to perform fuzzy matching of one string to others.\nSorter for nvim-telescope/telescope.nvim."
  },
  {
    "objectID": "mini.nvim/readmes/mini-fuzzy.html#installation",
    "href": "mini.nvim/readmes/mini-fuzzy.html#installation",
    "title": "mini.fuzzy",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.fuzzy’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.fuzzy’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.fuzzy', version = false },\n\n\nStable\n{ 'nvim-mini/mini.fuzzy', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.fuzzy'\n\n\nStable\nPlug 'nvim-mini/mini.fuzzy', { 'branch': 'stable' }\n\n\n\n\n\nImportant: no need to call require('mini.fuzzy').setup(), but it can be done to improve usability.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-fuzzy.html#default-config",
    "href": "mini.nvim/readmes/mini-fuzzy.html#default-config",
    "title": "mini.fuzzy",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Maximum allowed value of match features (width and first match). All\n  -- feature values greater than cutoff can be considered \"equally bad\".\n  cutoff = 100,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-fuzzy.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-fuzzy.html#similar-plugins",
    "title": "mini.fuzzy",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-telescope/telescope-fzy-native.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-operators.html",
    "href": "mini.nvim/readmes/mini-operators.html",
    "title": "mini.operators",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-operators.html#demo",
    "href": "mini.nvim/readmes/mini-operators.html#demo",
    "title": "mini.operators",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-operators.html#features",
    "href": "mini.nvim/readmes/mini-operators.html#features",
    "title": "mini.operators",
    "section": "Features",
    "text": "Features\n\nOperators:\n\nEvaluate text and replace with output.\nExchange text regions.\nMultiply (duplicate) text.\nReplace text with register.\nSort text.\n\nAutomated configurable mappings to operate on textobject, line, selection. Can be disabled in favor of more control with MiniOperators.make_mappings().\nAll operators support [count] and dot-repeat.\n\nFor more information see theses parts of help: - :h MiniOperators-overview - :h MiniOperators.config"
  },
  {
    "objectID": "mini.nvim/readmes/mini-operators.html#installation",
    "href": "mini.nvim/readmes/mini-operators.html#installation",
    "title": "mini.operators",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.operators’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.operators’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.operators', version = false },\n\n\nStable\n{ 'nvim-mini/mini.operators', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.operators'\n\n\nStable\nPlug 'nvim-mini/mini.operators', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.operators').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-operators.html#default-config",
    "href": "mini.nvim/readmes/mini-operators.html#default-config",
    "title": "mini.operators",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Each entry configures one operator.\n  -- `prefix` defines keys mapped during `setup()`: in Normal mode\n  -- to operate on textobject and line, in Visual - on selection.\n\n  -- Evaluate text and replace with output\n  evaluate = {\n    prefix = 'g=',\n\n    -- Function which does the evaluation\n    func = nil,\n  },\n\n  -- Exchange text regions\n  exchange = {\n    -- NOTE: Default `gx` is remapped to `gX`\n    prefix = 'gx',\n\n    -- Whether to reindent new text to match previous indent\n    reindent_linewise = true,\n  },\n\n  -- Multiply (duplicate) text\n  multiply = {\n    prefix = 'gm',\n\n    -- Function which can modify text before multiplying\n    func = nil,\n  },\n\n  -- Replace text with register\n  replace = {\n    -- NOTE: Default `gr*` LSP mappings are removed\n    prefix = 'gr',\n\n    -- Whether to reindent new text to match previous indent\n    reindent_linewise = true,\n  },\n\n  -- Sort text\n  sort = {\n    prefix = 'gs',\n\n    -- Function which does the sort\n    func = nil,\n  }\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-operators.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-operators.html#similar-plugins",
    "title": "mini.operators",
    "section": "Similar plugins",
    "text": "Similar plugins\n\ngbprod/substitute.nvim\nsvermeulen/vim-subversive\ntommcdo/vim-exchange\nchristoomey/vim-sort-motion"
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html",
    "href": "mini.nvim/readmes/mini-tabline.html",
    "title": "mini.tabline",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html#demo",
    "href": "mini.nvim/readmes/mini-tabline.html#demo",
    "title": "mini.tabline",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html#features",
    "href": "mini.nvim/readmes/mini-tabline.html#features",
    "title": "mini.tabline",
    "section": "Features",
    "text": "Features\n\nBuffers are listed in the order of their identifier.\nDifferent highlight groups for “states” of buffer affecting ‘buffer tabs’.\nBuffer names are made unique by extending paths to files or appending unique identifier to buffers without name.\nCurrent buffer is displayed “optimally centered” (in center of screen while maximizing the total number of buffers shown) when there are many buffers open.\n‘Buffer tabs’ are clickable if Neovim allows it.\nExtra information section in case of multiple Neovim tabpages.\nTruncation symbols which show if there are tabs to the left and/or right. Exact characters are taken from ‘listchars’ option (precedes and extends fields) and are shown only if ‘list’ option is enabled."
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html#dependencies",
    "href": "mini.nvim/readmes/mini-tabline.html#dependencies",
    "title": "mini.tabline",
    "section": "Dependencies",
    "text": "Dependencies\nFor full experience needs (still works without any of suggestions):\n\nEnabled ‘mini.icons’ module to show icons near file names. Can fall back to using nvim-tree/nvim-web-devicons plugin."
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html#installation",
    "href": "mini.nvim/readmes/mini-tabline.html#installation",
    "title": "mini.tabline",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.tabline’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.tabline’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.tabline', version = false },\n\n\nStable\n{ 'nvim-mini/mini.tabline', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.tabline'\n\n\nStable\nPlug 'nvim-mini/mini.tabline', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.tabline').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html#default-config",
    "href": "mini.nvim/readmes/mini-tabline.html#default-config",
    "title": "mini.tabline",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Whether to show file icons (requires 'mini.icons')\n  show_icons = true,\n\n  -- Function which formats the tab label\n  -- By default surrounds with space and possibly prepends with icon\n  format = nil,\n\n  -- Where to show tabpage section in case of multiple vim tabpages.\n  -- One of 'left', 'right', 'none'.\n  tabpage_section = 'left',\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-tabline.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-tabline.html#similar-plugins",
    "title": "mini.tabline",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nakinsho/bufferline.nvim\nromgrk/barbar.nvim\nap/vim-buftabline"
  },
  {
    "objectID": "mini.nvim/readmes/mini-indentscope.html",
    "href": "mini.nvim/readmes/mini-indentscope.html",
    "title": "mini.indentscope",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-indentscope.html#demo",
    "href": "mini.nvim/readmes/mini-indentscope.html#demo",
    "title": "mini.indentscope",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-indentscope.html#features",
    "href": "mini.nvim/readmes/mini-indentscope.html#features",
    "title": "mini.indentscope",
    "section": "Features",
    "text": "Features\n\nVisualize scope with animated vertical line. It is very fast and done automatically in a non-blocking way (other operations can be performed, like moving cursor). You can customize debounce delay and animation rule.\nCustomization of scope computation options can be done on global level (in MiniIndentscope.config), for a certain buffer (using vim.b.miniindentscope_config buffer variable), or within a call (using opts variable in MiniIndentscope.get_scope()).\nCustomizable notion of a border: which adjacent lines with strictly lower indent are recognized as such. This is useful for a certain filetypes (for example, Python or plain text).\nCustomizable way of line to be considered “border first”. This is useful if you want to place cursor on function header and get scope of its body.\nThere are textobjects and motions to operate on scope. Support v:count and dot-repeat (in operator pending mode)."
  },
  {
    "objectID": "mini.nvim/readmes/mini-indentscope.html#installation",
    "href": "mini.nvim/readmes/mini-indentscope.html#installation",
    "title": "mini.indentscope",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.indentscope’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.indentscope’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.indentscope', version = false },\n\n\nStable\n{ 'nvim-mini/mini.indentscope', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.indentscope'\n\n\nStable\nPlug 'nvim-mini/mini.indentscope', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.indentscope').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-indentscope.html#default-config",
    "href": "mini.nvim/readmes/mini-indentscope.html#default-config",
    "title": "mini.indentscope",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Draw options\n  draw = {\n    -- Delay (in ms) between event and start of drawing scope indicator\n    delay = 100,\n\n    -- Animation rule for scope's first drawing. A function which, given\n    -- next and total step numbers, returns wait time (in ms). See\n    -- |MiniIndentscope.gen_animation| for builtin options. To disable\n    -- animation, use `require('mini.indentscope').gen_animation.none()`.\n    animation = --&lt;function: implements constant 20ms between steps&gt;,\n\n    -- Whether to auto draw scope: return `true` to draw, `false` otherwise.\n    -- Default draws only fully computed scope (see `options.n_lines`).\n    predicate = function(scope) return not scope.body.is_incomplete end,\n\n    -- Symbol priority. Increase to display on top of more symbols.\n    priority = 2,\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Textobjects\n    object_scope = 'ii',\n    object_scope_with_border = 'ai',\n\n    -- Motions (jump to respective border line; if not present - body line)\n    goto_top = '[i',\n    goto_bottom = ']i',\n  },\n\n  -- Options which control scope computation\n  options = {\n    -- Type of scope's border: which line(s) with smaller indent to\n    -- categorize as border. Can be one of: 'both', 'top', 'bottom', 'none'.\n    border = 'both',\n\n    -- Whether to use cursor column when computing reference indent.\n    -- Useful to see incremental scopes with horizontal cursor movements.\n    indent_at_cursor = true,\n\n    -- Maximum number of lines above or below within which scope is computed\n    n_lines = 10000,\n\n    -- Whether to first check input line to be a border of adjacent scope.\n    -- Use it if you want to place cursor on function header to get scope of\n    -- its body.\n    try_as_border = false,\n  },\n\n  -- Which character to use for drawing scope indicator\n  symbol = '╎',\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-indentscope.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-indentscope.html#similar-plugins",
    "title": "mini.indentscope",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nlukas-reineke/indent-blankline.nvim\nmichaeljsmith/vim-indent-object"
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html",
    "href": "mini.nvim/readmes/mini-clue.html",
    "title": "mini.clue",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html#demo",
    "href": "mini.nvim/readmes/mini-clue.html#demo",
    "title": "mini.clue",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html#features",
    "href": "mini.nvim/readmes/mini-clue.html#features",
    "title": "mini.clue",
    "section": "Features",
    "text": "Features\n\nImplement custom key query process to reach target key combination:\n\nStarts after customizable opt-in triggers (mode + keys).\nEach key press narrows down set of possible targets.\nPressing &lt;BS&gt; removes previous user entry.\nPressing &lt;Esc&gt; or &lt;C-c&gt; leads to an early stop.\nDoesn’t depend on ‘timeoutlen’ and has basic support for ‘langmap’.\nEnds when there is at most one target left or user pressed &lt;CR&gt;. Results into emulating pressing all query keys plus possible postkeys.\n\nShow window (after configurable delay) with clues. It lists available next keys along with their descriptions (auto generated from descriptions present keymaps and user-supplied clues; preferring the former).\nConfigurable “postkeys” for key combinations - keys which will be emulated after combination is reached during key query process.\nProvide customizable sets of clues for common built-in keys/concepts:\n\ng key.\nz key.\nWindow commands.\nBuilt-in completion.\nMarks.\nRegisters.\n\nLua functions to disable/enable triggers globally or per buffer.\n\nFor more information see these parts of help:\n\n:h MiniClue-key-query-process\n:h MiniClue-examples\n:h MiniClue.config\n:h MiniClue.gen_clues\n\nNotes:\n\nThere is no functionality to create mappings in order to clearly separate two different tasks.\nThe best suggested practice is to manually create mappings with descriptions (desc field in options), as they will be automatically used inside clue window.\nTriggers are implemented as special buffer-local mappings. This leads to several caveats:\n\nThey will override same regular buffer-local mappings and have precedence over global one.\nExample: having set &lt;C-w&gt; as Normal mode trigger means that there should not be another &lt;C-w&gt; mapping.\nThey need to be the latest created buffer-local mappings or they will not function properly. Most common indicator of this is that some mapping starts to work only after clue window is shown.\nExample: g is set as Normal mode trigger, but gcc from ‘mini.comment’ doesn’t work right away. This is probably because there are some other buffer-local mappings starting with g which were created after mapping for g trigger. Most common places for this are in LSP server’s on_attach or during tree-sitter start in buffer.\nTo check if trigger is the most recent buffer-local mapping, execute :&lt;mode-char&gt;map &lt;trigger-keys&gt; (like :nmap g for previous example). Mapping for trigger should be the first listed.\nThis module makes the best effort to work out of the box and cover most common cases, but it is not foolproof. The solution here is to ensure that triggers are created after making all buffer-local mappings: run either MiniClue.setup() or MiniClue.ensure_buf_triggers().\n\nDescriptions from existing mappings take precedence over user-supplied clues. This is to ensure that information shown in clue window is as relevant as possible. To add/customize description of an already existing mapping, use MiniClue.set_mapping_desc().\nDue to technical difficulties, there is no foolproof support for Operator-pending mode triggers (like a/i from ‘mini.ai’):\n\nDoesn’t work as part of a command in “temporary Normal mode” (like after &lt;C-o&gt; in Insert mode) due to implementation difficulties.\nCan have unexpected behavior with custom operators.\n\nHas (mostly solved) issues with macros:\n\nAll triggers are disabled during macro recording due to technical reasons.\nThe @ and Q keys are specially mapped inside MiniClue.setup() to temporarily disable triggers."
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html#config-quick-start",
    "href": "mini.nvim/readmes/mini-clue.html#config-quick-start",
    "title": "mini.clue",
    "section": "Config quick start",
    "text": "Config quick start\nlocal miniclue = require('mini.clue')\nminiclue.setup({\n  triggers = {\n    -- Leader triggers\n    { mode = 'n', keys = '&lt;Leader&gt;' },\n    { mode = 'x', keys = '&lt;Leader&gt;' },\n\n    -- Built-in completion\n    { mode = 'i', keys = '&lt;C-x&gt;' },\n\n    -- `g` key\n    { mode = 'n', keys = 'g' },\n    { mode = 'x', keys = 'g' },\n\n    -- Marks\n    { mode = 'n', keys = \"'\" },\n    { mode = 'n', keys = '`' },\n    { mode = 'x', keys = \"'\" },\n    { mode = 'x', keys = '`' },\n\n    -- Registers\n    { mode = 'n', keys = '\"' },\n    { mode = 'x', keys = '\"' },\n    { mode = 'i', keys = '&lt;C-r&gt;' },\n    { mode = 'c', keys = '&lt;C-r&gt;' },\n\n    -- Window commands\n    { mode = 'n', keys = '&lt;C-w&gt;' },\n\n    -- `z` key\n    { mode = 'n', keys = 'z' },\n    { mode = 'x', keys = 'z' },\n  },\n\n  clues = {\n    -- Enhance this by adding descriptions for &lt;Leader&gt; mapping groups\n    miniclue.gen_clues.builtin_completion(),\n    miniclue.gen_clues.g(),\n    miniclue.gen_clues.marks(),\n    miniclue.gen_clues.registers(),\n    miniclue.gen_clues.windows(),\n    miniclue.gen_clues.z(),\n  },\n})"
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html#installation",
    "href": "mini.nvim/readmes/mini-clue.html#installation",
    "title": "mini.clue",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.clue’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.clue’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.clue', version = false },\n\n\nStable\n{ 'nvim-mini/mini.clue', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.clue'\n\n\nStable\nPlug 'nvim-mini/mini.clue', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.clue').setup() to enable its functionality. Needs to have triggers configured.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html#default-config",
    "href": "mini.nvim/readmes/mini-clue.html#default-config",
    "title": "mini.clue",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Array of extra clues to show\n  clues = {},\n\n  -- Array of opt-in triggers which start custom key query process.\n  -- **Needs to have something in order to show clues**.\n  triggers = {},\n\n  -- Clue window settings\n  window = {\n    -- Floating window config\n    config = {},\n\n    -- Delay before showing clue window\n    delay = 1000,\n\n    -- Keys to scroll inside the clue window\n    scroll_down = '&lt;C-d&gt;',\n    scroll_up = '&lt;C-u&gt;',\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-clue.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-clue.html#similar-plugins",
    "title": "mini.clue",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nfolke/which-key.nvim\nanuvyklack/hydra.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-map.html",
    "href": "mini.nvim/readmes/mini-map.html",
    "title": "mini.map",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-map.html#demo",
    "href": "mini.nvim/readmes/mini-map.html#demo",
    "title": "mini.map",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-map.html#features",
    "href": "mini.nvim/readmes/mini-map.html#features",
    "title": "mini.map",
    "section": "Features",
    "text": "Features\n\nShow and manage special floating window displaying automatically updated overview of current buffer text. Window takes up whole height of Neovim instance and is fixed to a left/right side. Map content is computed by taking all current lines, converting it to binary whitespace/non-whitespace mask, rescaling to appropriate dimensions, and converting back to strings consisting from special encoding symbols. All this is done very fast and asynchronously.\nSee :h MiniMap.open(), :h MiniMap.refresh(), :h MiniMap.close(), :h MiniMap.toggle(), :h MiniMap.toggle_side().\nFor a general overview and tips, see :h mini.map-usage.\nShow scrollbar next to map content. It represents current line and view (top and bottom visible lines). Can be the only thing shown, making map window a “pure scrollbar”.\nHighlight map lines representing certain data in current buffer. This is done via extensible set of callables, called integrations. There are pre-built generators for common integrations:\n\nBuiltin search.\nBuiltin diagnostic.\nGeneral diff hunks provided by ‘mini.diff’.\nHunks provided by ‘lewis6991/gitsigns.nvim’. For more details see :h MiniMap.gen_integration.\n\nFocus on map window to quickly browse current (source) buffer. Moving inside map window updates cursor position in source window enabling fast and targeted buffer exploration. To focus back, hit &lt;CR&gt; to accept current explored position or &lt;Esc&gt; to go back to original position. See :h MiniMap.toggle_focus().\nCustomizable:\n\nEncoding symbols used to display binary information of different resolution (default is 3x2). There are pre-built generators for different basic character families and resolutions. See :h MiniMap.gen_encode_symbols.\nScrollbar symbols, separate for line and view. Can have any width (even zero, which virtually disables scrollbar).\nIntegrations producing map line highlights.\nWindow options: side (left/right), width, ‘winblend’, and more."
  },
  {
    "objectID": "mini.nvim/readmes/mini-map.html#installation",
    "href": "mini.nvim/readmes/mini-map.html#installation",
    "title": "mini.map",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.map’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.map’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.map', version = false },\n\n\nStable\n{ 'nvim-mini/mini.map', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.map'\n\n\nStable\nPlug 'nvim-mini/mini.map', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.map').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-map.html#default-config",
    "href": "mini.nvim/readmes/mini-map.html#default-config",
    "title": "mini.map",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Highlight integrations (none by default)\n  integrations = nil,\n\n  -- Symbols used to display data\n  symbols = {\n    -- Encode symbols. See [`:h MiniMap.config`](../doc/mini-map.qmd#minimap.config) for specification and\n    -- [`:h MiniMap.gen_encode_symbols`](../doc/mini-map.qmd#minimap.gen_encode_symbols) for pre-built ones.\n    -- Default: solid blocks with 3x2 resolution.\n    encode = nil,\n\n    -- Scrollbar parts for view and line. Use empty string to disable any.\n    scroll_line = '█',\n    scroll_view = '┃',\n  },\n\n  -- Window options\n  window = {\n    -- Whether window is focusable in normal way (with `wincmd` or mouse)\n    focusable = false,\n\n    -- Side to stick ('left' or 'right')\n    side = 'right',\n\n    -- Whether to show count of multiple integration highlights\n    show_integration_count = true,\n\n    -- Total width\n    width = 10,\n\n    -- Value of 'winblend' option\n    winblend = 25,\n\n    -- Z-index\n    zindex = 10,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-map.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-map.html#similar-plugins",
    "title": "mini.map",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nwfxr/minimap.vim\ndstein64/nvim-scrollview\npetertriho/nvim-scrollbar\nlewis6991/satellite.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html",
    "href": "mini.nvim/readmes/mini-completion.html",
    "title": "mini.completion",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#demo",
    "href": "mini.nvim/readmes/mini-completion.html#demo",
    "title": "mini.completion",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#features",
    "href": "mini.nvim/readmes/mini-completion.html#features",
    "title": "mini.completion",
    "section": "Features",
    "text": "Features\n\nTwo-stage chain completion:\n\nFirst stage is an LSP completion. Supports additionalTextEdits (like auto-import, etc.) and snippets (see “Snippets”) (best results require ‘mini.snippets’ dependency).\nIf first stage is not set up or resulted into no candidates, fallback action is executed. The most tested actions are Neovim’s built-in insert completion.\n\nAutomatic display in floating window of completion item info (via ‘completionItem/resolve’ request) and signature help (with highlighting of active parameter if LSP server provides such information). Scrolling is possible in both info/signature window (&lt;C-f&gt; / &lt;C-b&gt; by default).\nAutomatic actions are done after some configurable amount of delay. This reduces computational load and allows fast typing (completion and signature help) and item selection (item info)\nUser can force two-stage/fallback completion (&lt;C-Space&gt; / &lt;A-Space&gt; by default).\nCustomizable highlighting of LSP items. Requires Neovim&gt;=0.11. Supported:\n\nItem label. By default only checks if item is marked as deprecated and sets MiniCompletionDeprecated highlight group.\nLSP kind (like “Function”, “Keyword”, etc.). Requires enabled ‘mini.icons’ (uses its “lsp” category)"
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#dependencies",
    "href": "mini.nvim/readmes/mini-completion.html#dependencies",
    "title": "mini.completion",
    "section": "Dependencies",
    "text": "Dependencies\nFor full experience needs (still works without any of suggestions):\n\nEnabled ‘mini.icons’ module to highlight LSP kind (requires Neovim&gt;=0.11). If absent, MiniCompletion.default_process_items() does not add highlighting. Also take a look at MiniIcons.tweak_lsp_kind().\nEnabled ‘mini.snippets’ module for better snippet handling (much recommended). If absent and custom snippet insert is not configured, vim.snippet.expand() is used on Neovim&gt;=0.10 (nothing extra is done on earlier versions). See :h MiniCompletion.default_snippet_insert()."
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#snippets",
    "href": "mini.nvim/readmes/mini-completion.html#snippets",
    "title": "mini.completion",
    "section": "Snippets",
    "text": "Snippets\nAs per LSP specification, some completion items can be supplied in the form of snippet - a template with both pre-defined text and places (called “tabstops”) for user to interactively change/add text during snippet session.\nIn ‘mini.completion’ items that will insert snippet have “S” symbol shown in the popup. To actually insert a snippet:\n\nSelect an item via &lt;C-n&gt; / &lt;C-p&gt;. This will insert item’s label (usually not full snippet) first to reduce visual flicker. The full snippet text will be shown in info window if LSP server doesn’t provide its own info for an item.\nPress &lt;C-y&gt; or attempt inserting a non-keyword character (like &lt;CR&gt;; new character will be removed). It will clear text from previous step, set cursor, and call lsp_completion.snippet_insert with snippet text.\nPress &lt;C-e&gt; to cancel snippet insert and properly end completion.\n\nSee :h MiniCompletion.default_snippet_insert() for overview of how to work with inserted snippets."
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#installation",
    "href": "mini.nvim/readmes/mini-completion.html#installation",
    "title": "mini.completion",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.completion’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.completion’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.completion', version = false },\n\n\nStable\n{ 'nvim-mini/mini.completion', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.completion'\n\n\nStable\nPlug 'nvim-mini/mini.completion', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.completion').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#default-config",
    "href": "mini.nvim/readmes/mini-completion.html#default-config",
    "title": "mini.completion",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Delay (debounce type, in ms) between certain Neovim event and action.\n  -- This can be used to (virtually) disable certain automatic actions by\n  -- setting very high delay time (like 10^7).\n  delay = { completion = 100, info = 100, signature = 50 },\n\n  -- Configuration for action windows:\n  -- - `height` and `width` are maximum dimensions.\n  -- - `border` defines border (as in `nvim_open_win()`; default \"single\").\n  window = {\n    info = { height = 25, width = 80, border = nil },\n    signature = { height = 25, width = 80, border = nil },\n  },\n\n  -- Way of how module does LSP completion\n  lsp_completion = {\n    -- `source_func` should be one of 'completefunc' or 'omnifunc'.\n    source_func = 'completefunc',\n\n    -- `auto_setup` should be boolean indicating if LSP completion is set up\n    -- on every `BufEnter` event.\n    auto_setup = true,\n\n    -- A function which takes LSP 'textDocument/completion' response items\n    -- (each with `client_id` field for item's server) and word to complete.\n    -- Output should be a table of the same nature as input. Common use case\n    -- is custom filter/sort. Default: `default_process_items`\n    process_items = nil,\n\n    -- A function which takes a snippet as string and inserts it at cursor.\n    -- Default: `default_snippet_insert` which tries to use 'mini.snippets'\n    -- and falls back to `vim.snippet.expand` (on Neovim&gt;=0.10).\n    snippet_insert = nil,\n  },\n\n  -- Fallback action as function/string. Executed in Insert mode.\n  -- To use built-in completion (`:h ins-completion`), set its mapping as\n  -- string. Example: set '&lt;C-x&gt;&lt;C-l&gt;' for 'whole lines' completion.\n  fallback_action = '&lt;C-n&gt;',\n\n  -- Module mappings. Use `''` (empty string) to disable one. Some of them\n  -- might conflict with system mappings.\n  mappings = {\n    -- Force two-step/fallback completions\n    force_twostep = '&lt;C-Space&gt;',\n    force_fallback = '&lt;A-Space&gt;',\n\n    -- Scroll info/signature window down/up. When overriding, check for\n    -- conflicts with built-in keys for popup menu (like `&lt;C-u&gt;`/`&lt;C-o&gt;`\n    -- for 'completefunc'/'omnifunc' source function; or `&lt;C-n&gt;`/`&lt;C-p&gt;`).\n    scroll_down = '&lt;C-f&gt;',\n    scroll_up = '&lt;C-b&gt;',\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-completion.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-completion.html#similar-plugins",
    "title": "mini.completion",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nhrsh7th/nvim-cmp\nShougo/ddc.vim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html",
    "href": "mini.nvim/readmes/mini-pick.html",
    "title": "mini.pick",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#demo",
    "href": "mini.nvim/readmes/mini-pick.html#demo",
    "title": "mini.pick",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#features",
    "href": "mini.nvim/readmes/mini-pick.html#features",
    "title": "mini.pick",
    "section": "Features",
    "text": "Features\n\nSingle window general purpose interface for picking element from any array.\nOn demand toggleable preview and info views.\nInteractive query matching (filter+sort) with fast non-blocking default which does fuzzy matching and allows other modes.\nBuilt-in pickers:\n\nFiles.\nPattern match (for fixed pattern or with live feedback; both allow file filtering via glob patterns).\nBuffers.\nHelp tags.\nCLI output.\nResume latest picker.\n\n:Pick command to work with extensible MiniPick.registry.\nvim.ui.select() implementation. To adjust, use MiniPick.ui_select() or save-restore vim.ui.select manually after calling MiniPick.setup().\nRich and customizable built-in actions when picker is active:\n\nManually change currently focused item.\nScroll vertically and horizontally.\nToggle preview or info view.\nMark/unmark items to choose later.\nRefine current matches (make them part of a new picker).\nAnd many more.\n\nMinimal yet flexible source specification with:\n\nItems (array, callable, or manually set later).\nSource name.\nWorking directory.\nMatching algorithm.\nWay matches are shown in main window.\nItem preview.\n“On choice” action for current and marked items.\n\nCustom actions/keys can be configured globally, per buffer, or per picker.\nOut of the box support for ‘ignorecase’ and ‘smartcase’.\nMatch caching to increase responsiveness on repeated prompts.\n\nNotes:\n\nWorks on all supported versions but Neovim&gt;=0.10 will give more visual feedback in floating window footer.\nFor more pickers see ‘mini.extra’.\nCLI tools are called only with basic arguments needed to get items. To customize the output, use their respective configuration approaches. Here are some examples of where to start:\n\nripgrep\nfd\ngit\n\n\nFor more information see these parts of help:\n\n:h MiniPick-overview\n:h MiniPick-source\n:h MiniPick-actions\n:h MiniPick-examples\n:h MiniPick.builtin"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#dependencies",
    "href": "mini.nvim/readmes/mini-pick.html#dependencies",
    "title": "mini.pick",
    "section": "Dependencies",
    "text": "Dependencies\nFor full experience needs (still works without any of suggestions):\n\nEnabled ‘mini.icons’ module for icons near the items representing actual paths. Can fall back to using nvim-tree/nvim-web-devicons plugin.\nExecutable BurntSushi/ripgrep CLI tool for faster file and pattern search on disk."
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#overview",
    "href": "mini.nvim/readmes/mini-pick.html#overview",
    "title": "mini.pick",
    "section": "Overview",
    "text": "Overview\nGeneral idea is to take array of objects, display them with interactive filter/sort/navigate/preview, and allow to choose one or more items.\n\nHow to start a picker\n\nUse MiniPick.start() with opts.source defining source.\nExample: MiniPick.start({ source = { items = vim.fn.readdir('.') } })\nUse any of MiniPick.builtin pickers directly.\nExample: MiniPick.builtin.files({ tool = 'git' })\nUse :Pick command which uses customizable pickers from MiniPick.registry.\nExample: :Pick files tool='git'\n\n\n\nUser interface\nUI consists from a single window capable of displaying three different views:\n\n“Main” - where current query matches are shown.\n“Preview” - preview of current item (toggle with &lt;Tab&gt;).\n“Info” - general info about picker and its state (toggle with &lt;S-Tab&gt;).\n\nCurrent prompt is displayed at the top left of the window border with vertical line indicating caret (current input position).\nBottom part of window border displays (in Neovim&gt;=0.10) extra visual feedback:\n\nLeft part is a picker name.\nRight part contains information in the format:\n&lt;current index in matches&gt; | &lt;match count&gt; | &lt;marked count&gt; / &lt;total count&gt;\n\nWhen picker is busy (like if there are no items yet set or matching is active) window border changes color to be MiniPickBorderBusy after config.delay.busy milliseconds of idle time.\n\n\nLife cycle\n\nType characters to filter and sort matches. It uses MiniPick.default_match() with query being an array of pressed characters. Overview of how it matches:\n\nIf query starts with ', the match is exact.\nIf query starts with ^, the match is exact at start.\nIf query ends with $, the match is exact at end.\nIf query starts with *, the match is forced to be fuzzy.\nOtherwise match is fuzzy.\nSorting is done to first minimize match width and then match start. Nothing more: no favoring certain places in string, etc.\n\nType special keys to perform actions. Here are some basic ones:\n\n&lt;C-n&gt; / &lt;Down&gt; moves down; &lt;C-p&gt; / &lt;Up&gt; moves up.\n&lt;Left&gt; / &lt;Right&gt; moves prompt caret left / right.\n&lt;S-Tab&gt; toggles information window with all available mappings.\n&lt;Tab&gt; toggles preview.\n&lt;C-x&gt; / &lt;C-a&gt; toggles current / all item(s) as (un)marked.\n&lt;C-Space&gt; / &lt;M-Space&gt; makes all matches or marked items as new picker.\n&lt;CR&gt; / &lt;M-CR&gt; chooses current/marked item(s).\n&lt;Esc&gt; / &lt;C-c&gt; stops picker."
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#installation",
    "href": "mini.nvim/readmes/mini-pick.html#installation",
    "title": "mini.pick",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.pick’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.pick’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.pick', version = false },\n\n\nStable\n{ 'nvim-mini/mini.pick', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.pick'\n\n\nStable\nPlug 'nvim-mini/mini.pick', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.pick').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#default-config",
    "href": "mini.nvim/readmes/mini-pick.html#default-config",
    "title": "mini.pick",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Delays (in ms; should be at least 1)\n  delay = {\n    -- Delay between forcing asynchronous behavior\n    async = 10,\n\n    -- Delay between computation start and visual feedback about it\n    busy = 50,\n  },\n\n  -- Keys for performing actions. See [`:h MiniPick-actions`](../doc/mini-pick.qmd#minipick-actions).\n  mappings = {\n    caret_left  = '&lt;Left&gt;',\n    caret_right = '&lt;Right&gt;',\n\n    choose            = '&lt;CR&gt;',\n    choose_in_split   = '&lt;C-s&gt;',\n    choose_in_tabpage = '&lt;C-t&gt;',\n    choose_in_vsplit  = '&lt;C-v&gt;',\n    choose_marked     = '&lt;M-CR&gt;',\n\n    delete_char       = '&lt;BS&gt;',\n    delete_char_right = '&lt;Del&gt;',\n    delete_left       = '&lt;C-u&gt;',\n    delete_word       = '&lt;C-w&gt;',\n\n    mark     = '&lt;C-x&gt;',\n    mark_all = '&lt;C-a&gt;',\n\n    move_down  = '&lt;C-n&gt;',\n    move_start = '&lt;C-g&gt;',\n    move_up    = '&lt;C-p&gt;',\n\n    paste = '&lt;C-r&gt;',\n\n    refine        = '&lt;C-Space&gt;',\n    refine_marked = '&lt;M-Space&gt;',\n\n    scroll_down  = '&lt;C-f&gt;',\n    scroll_left  = '&lt;C-h&gt;',\n    scroll_right = '&lt;C-l&gt;',\n    scroll_up    = '&lt;C-b&gt;',\n\n    stop = '&lt;Esc&gt;',\n\n    toggle_info    = '&lt;S-Tab&gt;',\n    toggle_preview = '&lt;Tab&gt;',\n  },\n\n  -- General options\n  options = {\n    -- Whether to show content from bottom to top\n    content_from_bottom = false,\n\n    -- Whether to cache matches (more speed and memory on repeated prompts)\n    use_cache = false,\n  },\n\n  -- Source definition. See [`:h MiniPick-source`](../doc/mini-pick.qmd#minipick-source).\n  source = {\n    items = nil,\n    name  = nil,\n    cwd   = nil,\n\n    match   = nil,\n    show    = nil,\n    preview = nil,\n\n    choose        = nil,\n    choose_marked = nil,\n  },\n\n  -- Window related options\n  window = {\n    -- Float window config (table or callable returning it)\n    config = nil,\n\n    -- String to use as caret in prompt\n    prompt_caret = '▏',\n\n    -- String to use as prefix in prompt\n    prompt_prefix = '&gt; ',\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pick.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-pick.html#similar-plugins",
    "title": "mini.pick",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-telescope/telescope.nvim\nibhagwan/fzf-lua"
  },
  {
    "objectID": "mini.nvim/readmes/mini-ai.html",
    "href": "mini.nvim/readmes/mini-ai.html",
    "title": "mini.ai",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-ai.html#demo",
    "href": "mini.nvim/readmes/mini-ai.html#demo",
    "title": "mini.ai",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-ai.html#features",
    "href": "mini.nvim/readmes/mini-ai.html#features",
    "title": "mini.ai",
    "section": "Features",
    "text": "Features\n\nCustomizable creation of a/i textobjects using Lua patterns and functions. Supports:\n\nDot-repeat.\nv:count.\nDifferent search methods (see :h MiniAi.config).\nConsecutive application (update selection without leaving Visual mode).\nAliases for multiple textobjects.\n\nComprehensive builtin textobjects (see more at :h MiniAi-builtin-textobjects):\n\nBalanced brackets (with and without whitespace) plus alias.\nBalanced quotes plus alias.\nFunction call.\nArgument.\nTag.\nDerived from user prompt.\nDefault for anything but Latin letters (to fall back to :h text-objects).\n\nMotions for jumping to left/right edge of textobject.\nSet of specification generators to tweak some builtin textobjects (see help for MiniAi.gen_spec).\nTreesitter textobjects (through MiniAi.gen_spec.treesitter() helper)."
  },
  {
    "objectID": "mini.nvim/readmes/mini-ai.html#installation",
    "href": "mini.nvim/readmes/mini-ai.html#installation",
    "title": "mini.ai",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.ai’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.ai’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.ai', version = false },\n\n\nStable\n{ 'nvim-mini/mini.ai', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.ai'\n\n\nStable\nPlug 'nvim-mini/mini.ai', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.ai').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-ai.html#default-config",
    "href": "mini.nvim/readmes/mini-ai.html#default-config",
    "title": "mini.ai",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Table with textobject id as fields, textobject specification as values.\n  -- Also use this to disable builtin textobjects. See |MiniAi.config|.\n  custom_textobjects = nil,\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Main textobject prefixes\n    around = 'a',\n    inside = 'i',\n\n    -- Next/last variants\n    -- NOTE: These override built-in LSP selection mappings on Neovim&gt;=0.12\n    -- Map LSP selection manually to use it (see [`:h MiniAi.config`](../doc/mini-ai.qmd#miniai.config))\n    around_next = 'an',\n    inside_next = 'in',\n    around_last = 'al',\n    inside_last = 'il',\n\n    -- Move cursor to corresponding edge of `a` textobject\n    goto_left = 'g[',\n    goto_right = 'g]',\n  },\n\n  -- Number of lines within which textobject is searched\n  n_lines = 50,\n\n  -- How to search for object (first inside current line, then inside\n  -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',\n  -- 'cover_or_nearest', 'next', 'previous', 'nearest'.\n  search_method = 'cover_or_next',\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-ai.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-ai.html#similar-plugins",
    "title": "mini.ai",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nwellle/targets.vim\nnvim-treesitter/nvim-treesitter-textobjects\nkana/vim-textobj-user"
  },
  {
    "objectID": "mini.nvim/readmes/mini-base16.html",
    "href": "mini.nvim/readmes/mini-base16.html",
    "title": "mini.base16",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-base16.html#demo",
    "href": "mini.nvim/readmes/mini-base16.html#demo",
    "title": "mini.base16",
    "section": "Demo",
    "text": "Demo\nUsing minischeme color scheme:\n     \nUsing minicyan color scheme:"
  },
  {
    "objectID": "mini.nvim/readmes/mini-base16.html#features",
    "href": "mini.nvim/readmes/mini-base16.html#features",
    "title": "mini.base16",
    "section": "Features",
    "text": "Features\nSupported highlight groups:\n\nBuilt-in Neovim LSP and diagnostic.\nPlugins (either with explicit definition or by verification that default highlighting works appropriately):\n\nnvim-mini/mini.nvim\nakinsho/bufferline.nvim\nanuvyklack/hydra.nvim\nDanilaMihailov/beacon.nvim\nfolke/lazy.nvim\nfolke/noice.nvim\nfolke/todo-comments.nvim\nfolke/trouble.nvim\nfolke/which-key.nvim\nggandor/leap.nvim\nggandor/lightspeed.nvim\nglepnir/dashboard-nvim\nglepnir/lspsaga.nvim\nHiPhish/rainbow-delimiters.nvim\nhrsh7th/nvim-cmp\nibhagwan/fzf-lua\njustinmk/vim-sneak\nkevinhwang91/nvim-bqf\nkevinhwang91/nvim-ufo\nlewis6991/gitsigns.nvim\nlukas-reineke/indent-blankline.nvim\nMeanderingProgrammer/render-markdown.nvim\nneoclide/coc.nvim\nNeogitOrg/neogit\nnvim-lualine/lualine.nvim\nnvim-neo-tree/neo-tree.nvim\nnvim-telescope/telescope.nvim\nnvim-tree/nvim-tree.lua\nOXY2DEV/helpview.nvim\nOXY2DEV/markview.nvim\nphaazon/hop.nvim\nrcarriga/nvim-dap-ui\nrcarriga/nvim-notify\nrlane/pounce.nvim\nromgrk/barbar.nvim\nstevearc/aerial.nvim\nwilliamboman/mason.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-base16.html#installation",
    "href": "mini.nvim/readmes/mini-base16.html#installation",
    "title": "mini.base16",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.base16’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.base16’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.base16', version = false },\n\n\nStable\n{ 'nvim-mini/mini.base16', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.base16'\n\n\nStable\nPlug 'nvim-mini/mini.base16', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.base16').setup() with appropriate palette to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-base16.html#default-config",
    "href": "mini.nvim/readmes/mini-base16.html#default-config",
    "title": "mini.base16",
    "section": "Default config",
    "text": "Default config\n{\n  -- Table with names from `base00` to `base0F` and values being strings of\n  -- HEX colors with format \"#RRGGBB\". NOTE: this should be explicitly\n  -- supplied in `setup()`.\n  palette = nil,\n\n  -- Whether to support cterm colors. Can be boolean, `nil` (same as\n  -- `false`), or table with cterm colors. See `setup()` documentation for\n  -- more information.\n  use_cterm = nil,\n\n  -- Plugin integrations. Use `default = false` to disable all integrations.\n  -- Also can be set per plugin (see |MiniBase16.config|).\n  plugins = { default = true },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-base16.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-base16.html#similar-plugins",
    "title": "mini.base16",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nchriskempson/base16-vim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html",
    "href": "mini.nvim/readmes/mini-visits.html",
    "title": "mini.visits",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html#demo",
    "href": "mini.nvim/readmes/mini-visits.html#demo",
    "title": "mini.visits",
    "section": "Demo",
    "text": "Demo\nVideo\nNote: This demo uses custom vim.ui.select() from mini.pick."
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html#features",
    "href": "mini.nvim/readmes/mini-visits.html#features",
    "title": "mini.visits",
    "section": "Features",
    "text": "Features\n\nPersistently track file system visits (both files and directories) per project directory. Store visit index is human readable and editable.\nVisit index is normalized on every write to contain relevant information. Exact details can be customized. See :h MiniVisits.normalize().\nBuilt-in ability to persistently use label paths for later use. See :h MiniVisits.add_label() and :h MiniVisits.remove_label().\nExported functions to reuse visit data:\n\nList visited paths/labels with custom filter and sort (uses “robust frecency” by default). Can be used as source for pickers.\nSee :h MiniVisits.list_paths() and :h MiniVisits.list_labels(). See :h MiniVisits.gen_filter and :h MiniVisits.gen_sort.\nSelect visited paths/labels using vim.ui.select().\nSee :h MiniVisits.select_path() and :h MiniVisits.select_label().\nIterate through visit paths in target direction (“forward”, “backward”, “first”, “last”). See :h MiniVisits.iterate_paths().\n\nExported functions to manually update visit index allowing persistent track of any user information. See *_index() functions.\n\nNotes:\n\nAll data is stored only in in-session Lua variable (for quick operation) and at config.store.path on disk (for persistent usage).\nIt doesn’t account for paths being renamed or moved (because there is no general way to detect that). Usually a manual intervention to the visit index is required after the change but before the next writing to disk (usually before closing current session) because it will treat previous path as deleted and remove it from index.\nThere is a MiniVisits.rename_in_index() helper for that. If rename/move is done with ‘mini.files’, index is autoupdated.\n\nFor more information see these parts of help:\n\n:h MiniVisits-overview\n:h MiniVisits-index-specification\n:h MiniVisits-examples"
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html#overview",
    "href": "mini.nvim/readmes/mini-visits.html#overview",
    "title": "mini.visits",
    "section": "Overview",
    "text": "Overview\n\nTracking visits\nFile system visits (both directory and files) tracking is done in two steps:\n\nOn every dedicated event timer is (re)started to actually register visit after certain amount of time.\nWhen delay time passes without any dedicated events being triggered (meaning user is “settled” on certain buffer), visit is registered if all of the following conditions are met:\n\nModule is not disabled.\nBuffer is normal with non-empty name (used as visit path).\nVisit path does not equal to the latest tracked one.\n\n\nVisit is autoregistered for current directory and leads to increase of count and latest time of visit. See :h MiniVisits-index-specification for more details.\nNotes:\n\nAll data is stored only in in-session Lua variable (for quick operation) and in one place on disk (for persistent usage). It is automatically written to disk before every Neovim exit.\nTracking can be disabled by supplying empty string as track.event. Then it is up to the user to properly call MiniVisits.register_visit().\n\n\n\nReusing visits\nVisit data can be reused in at least these ways:\n\nGet a list of visited paths and use it to visualize/pick/navigate visit history.\nSelect one of the visited paths to open it.\nMove along visit history.\nUtilize labels. Any visit can be added one or more labels (like “core”, “tmp”, etc.). They are bound to the visit and are stored persistently.\nLabels can be used to manually create groups of files and/or directories that have particular interest to the user.\nThere is no one right way to use them, though. See :h MiniVisits-examples for some inspiration.\nUtilizing custom data. Visit index can be manipulated manually using _index() set of functions. All “storable” user data inside index is then stored on disk, so it can be used to create any kind of workflow user wants.\n\nSee :h MiniVisits-examples for some actual configuration and workflow examples."
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html#installation",
    "href": "mini.nvim/readmes/mini-visits.html#installation",
    "title": "mini.visits",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.visits’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.visits’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.visits', version = false },\n\n\nStable\n{ 'nvim-mini/mini.visits', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.visits'\n\n\nStable\nPlug 'nvim-mini/mini.visits', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.visits').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html#default-config",
    "href": "mini.nvim/readmes/mini-visits.html#default-config",
    "title": "mini.visits",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- How visit index is converted to list of paths\n  list = {\n    -- Predicate for which paths to include (all by default)\n    filter = nil,\n\n    -- Sort paths based on the visit data (robust frecency by default)\n    sort = nil,\n  },\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n\n  -- How visit index is stored\n  store = {\n    -- Whether to write all visits before Neovim is closed\n    autowrite = true,\n\n    -- Function to ensure that written index is relevant\n    normalize = nil,\n\n    -- Path to store visit index\n    path = vim.fn.stdpath('data') .. '/mini-visits-index',\n  },\n\n  -- How visit tracking is done\n  track = {\n    -- Start visit register timer at this event\n    -- Supply empty string (`''`) to not do this automatically\n    event = 'BufEnter',\n\n    -- Debounce delay after event to register a visit\n    delay = 1000,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-visits.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-visits.html#similar-plugins",
    "title": "mini.visits",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-telescope/telescope-frecency.nvim\nThePrimeagen/harpoon"
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html",
    "href": "mini.nvim/readmes/mini-keymap.html",
    "title": "mini.keymap",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html#demo",
    "href": "mini.nvim/readmes/mini-keymap.html#demo",
    "title": "mini.keymap",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html#features",
    "href": "mini.nvim/readmes/mini-keymap.html#features",
    "title": "mini.keymap",
    "section": "Features",
    "text": "Features\n\nMap keys to perform configurable multi-step actions: if condition for step one is true - execute step one action, else check step two, and so on until falling back to executing original keys. This is usually referred to as “smart” keys (like “smart tab”). See :h MiniKeymap.map_multistep().\nThere are many built-in steps targeted for Insert mode mappings of special keys like &lt;Tab&gt;, &lt;S-Tab&gt;, &lt;CR&gt;, and &lt;BS&gt;:\n\nNavigate and accept built-in Insert mode completion. Useful for mini.completion.\nNavigate and expand mini.snippets.\nExecute &lt;CR&gt; and &lt;BS&gt; respecting mini.pairs.\nJump before/after current tree-sitter node.\nJump before opening and after closing characters (brackets and quotes).\nIncrease/decrease indent when cursor is inside of it.\nDelete all whitespace to the left (“hungry backspace”).\nNavigate built-in snippet engine (:h vim.snippet).\nNavigate and accept in hrsh7th/nvim-cmp completion.\nNavigate and accept in Saghen/blink.cmp completion.\nNavigate and expand L3MON4D3/LuaSnip snippets.\nExecute &lt;CR&gt; and &lt;BS&gt; respecting windwp/nvim-autopairs.\n\nMap keys as “combo”: each key acts immediately plus execute extra action if all are typed within configurable delay between each other. See :h MiniKeymap.map_combo().\nSome of the common use cases include:\n\nMap insertable keys (like “jk”, “kj”) in Insert and Command-line mode to exit into Normal mode.\nFight against bad habits of pressing the same navigation key by showing a notification if there are too many of them pressed in a row.\n\n\nSources with more details:\n\n:h MiniKeymap-examples"
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html#quickstart",
    "href": "mini.nvim/readmes/mini-keymap.html#quickstart",
    "title": "mini.keymap",
    "section": "Quickstart",
    "text": "Quickstart\n\nMulti-step\nSetup that works well with ‘mini.completion’ and ‘mini.pairs’:\nlocal map_multistep = require('mini.keymap').map_multistep\n\nmap_multistep('i', '&lt;Tab&gt;',   { 'pmenu_next' })\nmap_multistep('i', '&lt;S-Tab&gt;', { 'pmenu_prev' })\nmap_multistep('i', '&lt;CR&gt;',    { 'pmenu_accept', 'minipairs_cr' })\nmap_multistep('i', '&lt;BS&gt;',    { 'minipairs_bs' })\n\n\nCombos\n“Better escape” to Normal mode without having to reach for &lt;Esc&gt; key:\nlocal map_combo = require('mini.keymap').map_combo\n\n-- Support most common modes. This can also contain 't', but would\n-- only mean to press `&lt;Esc&gt;` inside terminal.\nlocal mode = { 'i', 'c', 'x', 's' }\nmap_combo(mode, 'jk', '&lt;BS&gt;&lt;BS&gt;&lt;Esc&gt;')\n\n-- To not have to worry about the order of keys, also map \"kj\"\nmap_combo(mode, 'kj', '&lt;BS&gt;&lt;BS&gt;&lt;Esc&gt;')\n\n-- Escape into Normal mode from Terminal mode\nmap_combo('t', 'jk', '&lt;BS&gt;&lt;BS&gt;&lt;C-\\\\&gt;&lt;C-n&gt;')\nmap_combo('t', 'kj', '&lt;BS&gt;&lt;BS&gt;&lt;C-\\\\&gt;&lt;C-n&gt;')\nShow notification if there is too much movement by repeating same key:\nlocal notify_many_keys = function(key)\n  local lhs = string.rep(key, 5)\n  local action = function() vim.notify('Too many ' .. key) end\n  require('mini.keymap').map_combo({ 'n', 'x' }, lhs, action)\nend\nnotify_many_keys('h')\nnotify_many_keys('j')\nnotify_many_keys('k')\nnotify_many_keys('l')"
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html#installation",
    "href": "mini.nvim/readmes/mini-keymap.html#installation",
    "title": "mini.keymap",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.keymap’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.keymap’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.keymap', version = false },\n\n\nStable\n{ 'nvim-mini/mini.keymap', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.keymap'\n\n\nStable\nPlug 'nvim-mini/mini.keymap', { 'branch': 'stable' }\n\n\n\n\n\nImportant: no need to call require('mini.keymap').setup(), but it can be done to improve usability.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html#default-config",
    "href": "mini.nvim/readmes/mini-keymap.html#default-config",
    "title": "mini.keymap",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-keymap.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-keymap.html#similar-plugins",
    "title": "mini.keymap",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nmax397574/better-escape.nvim\nabecodes/tabout.nvim"
  },
  {
    "objectID": "mini.nvim/CONTRIBUTING.html",
    "href": "mini.nvim/CONTRIBUTING.html",
    "title": "Contributing",
    "section": "",
    "text": "Thank you for your willingness to contribute to ‘mini.nvim’. It means a lot!\nYou can make contributions in the following ways:\n\nMention it somehow to help reach broader audience. This helps a lot.\nCreate a GitHub issue. It can be one of the following types:\n\nBug report. Describe your actions in a reproducible way along with their effect and what you expected should happen. Before making one, please make your best efforts to:\n\nMake sure that it is not an intended behavior, i.e. not described in documentation as such.\nMake sure that it was not reported before, i.e. there is no bug report already created (no matter open or closed).\n\nFeature request. A concise and justified description of what one or several modules should be able to do. Before making one, please make your best efforts to make sure that it is not a feature that won’t get implemented (these should be described in documentation; for example: block comments in ‘mini.comment’).\n\nCreate a pull request (PR). It can be one of the following types:\n\nCode related. For example, fix a bug or implement a feature. Before even starting one, please make sure that it is aligned with project vision and goals. The best way to do so is to receive positive feedback from maintainer on your initiative in one of the GitHub issues (existing or created by you). Please, make sure to regenerate latest help file and that all tests pass (see later sections).\nDocumentation related. For example, fix typo/wording in ‘README.md’, code comments or annotations (which are used to generate Neovim documentation; see later section). Feel free to make these without creating a GitHub issue.\nAdd plugin integration to ‘mini.base16’ and ‘mini.hues’ modules.\n\nAdd explicit support to other colorschemes. Every ‘mini.nvim’ module supports any colorscheme right out of the box. This is done by making most highlight groups be linked to a semantically similar builtin highlight group. Other groups are hard-coded based on personal preference. However, these choices might be out of tune with a particular colorscheme. Updating as many colorschemes as possible to have explicit ‘mini.nvim’ support is highly appreciated. For your convenience, there is a list of all highlight groups in later section of this file.\nParticipate in discussions.\n\nAll well-intentioned, polite, and respectful contributions are always welcome! Thanks for reading this!\n\n\n\nTry to make commit message as concise as possible while giving enough information about nature of a change. Think about whether it will be easy to understand in one year time when browsing through commit history.\nSingle commit should change either zero or one module, or affect all modules (i.e. enforcing some universal rule but not necessarily change files). Changes for two or more modules should be split in several module-specific commits.\nUse Conventional commits style:\n\nMessages should have the following structure:\n&lt;type&gt;[optional scope][!]: &lt;description&gt;\n&lt;empty line&gt;\n[optional body]\n&lt;empty line&gt;\n[optional footer(s)]\n&lt;type&gt; is mandatory and can be one of:\n\nci - change in how automation (GitHub actions, dual distribution scripts, etc.) is done.\ndocs - change in user facing documentation (help, README, CONTRIBUTING, etc.).\nfeat - adding new user facing feature.\nfix - resolving user facing issue.\nrefactor - change in code or documentation that should not affect users.\nstyle - change in convention of how something should be done (formatting, wording, etc.) and its effects.\ntest - change in tests. For temporary commits which later should be squashed (when working on PR, for example), use fixup type.\n\n[optional scope], if present, should be done in parenthesis (). If commit changes single module (as it usually should), using scope with module name is mandatory. If commit enforces something for all modules, use ALL scope.\nBreaking change, if present, should be expressed with ! before :.\n&lt;description&gt; is a change overview in imperative, present tense (“change” not “changed” nor “changes”). Should result into first line under 72 characters. Should start with not capitalized word and NOT end with sentence ending punctuation (i.e. one of .,?!;).\n[optional body], if present, should contain details and motivation about the change in plain language. Should be formatted to have maximum 80 characters in line.\n[optional footer(s)], if present, should be instruction(s) to Git or Github. Use “Resolve #xxx” on separate line if this commit resolves issue or PR.\n\nUse module’s function and field names without module’s name. Like add() and not MiniSurround.add().\n\nExamples:\nfeat(deps): add folds in update confirmation buffer\nfix(jump): make operator not delete one character if target is not found\n\nOne main goal is to do that in a dot-repeatable way, because this is very\nlikely to be repeated after an unfortunate first try.\n\nResolve #688\nrefactor(bracketed): do not source 'vim.treesitter' on `require()`\n\nAlthough less explicit, this considerably reduces startup footprint of\n'mini.bracketed' in isolation.\nfeat(hues)!: update verbatim text to be distinctive\ntest(ALL): update screenshots to work on Nightly\n\n\n\nTo lint messages of already done commits, execute scripts/lintcommit-ci.sh &lt;git-log-range&gt;. For example, to lint currently latest commit use scripts/lintcommit-ci.sh HEAD~..HEAD.\nTo lint commit message before doing commit, install pre-commit and enable it with pre-commit install --hook-type commit-msg (from the root directory). NOTE: requires nvim executable. If it throws (usually descriptive) error - recommit with proper message.\n\n\n\n\n\nIf your contribution updates annotations used to generate help file, please regenerate it. You can make this with one of the following (assuming current directory being project root):\n\nFrom command line execute make documentation.\nInside Neovim instance run :luafile scripts/minidoc.lua or :lua require('mini.doc').generate().\n\n\n\n\nIf your contribution updates code, please make sure that it doesn’t break existing tests. If it adds new functionality or fixes a recognized bug, add new test case(s). There are two ways of running tests:\n\nFrom command line:\n\nExecute make test to run all tests (with nvim as executable).\nExecute make test_xxx to run tests only from file tests/test_xxx.lua (with nvim as executable). For example, make test_ai.\nIf you have multiple Neovim executables (say, nvim_07, nvim_08, nvim_09, nvim_010), you can use NVIM_EXEC variable to tests against multiple versions like this: NVIM_EXEC=\"nvim_07 nvim_08 nvim_09 nvim_010\" make test or NVIM_EXEC=\"nvim_07 nvim_08 nvim_09 nvim_010\" make test_xxx.\n\nInside Neovim instance execute :lua require('mini.test').setup(); MiniTest.run() to run all tests or :lua require('mini.test').setup(); MiniTest.run_file() to run tests only from current buffer.\n\nThis plugin uses ‘mini.test’ to manage its tests. For a more hands-on introduction, see TESTING.md.\nNotes:\n\nIf new functionality relies on an external dependency (git CLI tool, LSP server, etc.), use mocking (writing Lua code which emulates dependency usage as close as reasonably possible). For examples, take a look at tests for ‘mini.pick’, ‘mini.completion’, and ‘mini.statusline’.\nThere is a certain number of tests that are flaky (i.e. will sometimes report an error due to other reasons than actual functionality being broke). It is usually the ones which test time related functionality (i.e. that certain action was done after specific amount of delay).\nA commonly used way to know if the test is flaky is that it fails on non-nightly Neovim version yet there were no changes to its tested module after it had passed in the past. For example, some ‘mini.animate’ test is shown to break but there were no changes to it since test passed in CI couple of days before.\nThis issue is addressed by having test cases being executed several times in case of failure (with more retries in slow context). See “Retry” section in ‘TESTING.md’.\nIn case there is some test breaking which reasonably should not, rerun that test (or the whole file) at least several times.\nAdvice for writing more robust tests:\n\nTo test asynchronous or slow execution, use common sleep() test helper. For a more robust testing code, never directly use numbers to compute sleep time. Use precomputed time delay constants, which should always take into account different testing OSs (like be bigger on Windows, etc.). If module testing requires its extensive use and tests can not be made robust enough (examples are ‘mini.animate’, ‘mini.jump’, etc.), consider using it with argument that skips entire test case if sleep() is called in slow context.\nTake into account that Windows uses “\" as default path separator instead of Unix”/“. This should be accounted either in module’s code (preferably) or in test files (for example, by computing path separator and relying on it).\n\n\n\n\n\nThis project uses StyLua version 2.1.0 for formatting Lua code. Before making changes to code, please:\n\nInstall StyLua. NOTE: use v2.1.0.\nFormat with it. Currently there are two ways to do this:\n\nManually run stylua . from the root directory of this project.\nInstall pre-commit and enable it with pre-commit install (from the root directory). This will auto-format relevant code before making commits.\n\n\n\n\n\nHere is a list of all highlight groups defined inside ‘mini.nvim’ modules. See documentation in ‘doc’ directory to find out what they are used for.\n\n‘mini.animate’:\n\nMiniAnimateCursor\nMiniAnimateNormalFloat\n\n‘mini.clue’:\n\nMiniClueBorder\nMiniClueDescGroup\nMiniClueDescSingle\nMiniClueNextKey\nMiniClueNextKeyWithPostkeys\nMiniClueSeparator\nMiniClueTitle\n\n‘mini.cmdline’:\n\nMiniCmdlinePeekBorder\nMiniCmdlinePeekLineNr\nMiniCmdlinePeekNormal\nMiniCmdlinePeekSep\nMiniCmdlinePeekSign\nMiniCmdlinePeekTitle\n\n‘mini.completion’:\n\nMiniCompletionActiveParameter\nMiniCompletionDeprecated\nMiniCompletionInfoBorderOutdated\n\n‘mini.cursorword’:\n\nMiniCursorword\nMiniCursorwordCurrent\n\n‘mini.deps’:\n\nMiniDepsChangeAdded\nMiniDepsChangeRemoved\nMiniDepsHint\nMiniDepsInfo\nMiniDepsMsgBreaking\nMiniDepsPlaceholder\nMiniDepsTitle\nMiniDepsTitleError\nMiniDepsTitleSame\nMiniDepsTitleUpdate\n\n‘mini.diff’:\n\nMiniDiffSignAdd\nMiniDiffSignChange\nMiniDiffSignDelete\nMiniDiffOverAdd\nMiniDiffOverChange\nMiniDiffOverChangeBuf\nMiniDiffOverContext\nMiniDiffOverContextBuf\nMiniDiffOverDelete\n\n‘mini.files’:\n\nMiniFilesBorder\nMiniFilesBorderModified\nMiniFilesCursorLine\nMiniFilesDirectory\nMiniFilesFile\nMiniFilesNormal\nMiniFilesTitle\nMiniFilesTitleFocused\n\n‘mini.hipatterns’:\n\nMiniHipatternsFixme\nMiniHipatternsHack\nMiniHipatternsNote\nMiniHipatternsTodo\n\n‘mini.icons’:\n\nMiniIconsAzure\nMiniIconsBlue\nMiniIconsCyan\nMiniIconsGreen\nMiniIconsGrey\nMiniIconsOrange\nMiniIconsPurple\nMiniIconsRed\nMiniIconsYellow\n\n‘mini.indentscope’:\n\nMiniIndentscopeSymbol\nMiniIndentscopeSymbolOff\n\n‘mini.jump’:\n\nMiniJump\n\n‘mini.jump2d’:\n\nMiniJump2dDim\nMiniJump2dSpot\nMiniJump2dSpotAhead\nMiniJump2dSpotUnique\n\n‘mini.map’:\n\nMiniMapNormal\nMiniMapSymbolCount\nMiniMapSymbolLine\nMiniMapSymbolView\n\n‘mini.notify’:\n\nMiniNotifyBorder\nMiniNotifyLspProgress\nMiniNotifyNormal\nMiniNotifyTitle\n\n‘mini.operators’:\n\nMiniOperatorsExchangeFrom\n\n‘mini.pick’:\n\nMiniPickBorder\nMiniPickBorderBusy\nMiniPickBorderText\nMiniPickCursor\nMiniPickIconDirectory\nMiniPickIconFile\nMiniPickHeader\nMiniPickMatchCurrent\nMiniPickMatchMarked\nMiniPickMatchRanges\nMiniPickNormal\nMiniPickPreviewLine\nMiniPickPreviewRegion\nMiniPickPrompt\nMiniPickPromptCaret\nMiniPickPromptPrefix\n\n‘mini.snippets’:\n\nMiniSnippetsCurrent\nMiniSnippetsCurrentReplace\nMiniSnippetsFinal\nMiniSnippetsUnvisited\nMiniSnippetsVisited\n\n‘mini.starter’:\n\nMiniStarterCurrent\nMiniStarterFooter\nMiniStarterHeader\nMiniStarterInactive\nMiniStarterItem\nMiniStarterItemBullet\nMiniStarterItemPrefix\nMiniStarterSection\nMiniStarterQuery\n\n‘mini.statusline’:\n\nMiniStatuslineDevinfo\nMiniStatuslineFileinfo\nMiniStatuslineFilename\nMiniStatuslineInactive\nMiniStatuslineModeCommand\nMiniStatuslineModeInsert\nMiniStatuslineModeNormal\nMiniStatuslineModeOther\nMiniStatuslineModeReplace\nMiniStatuslineModeVisual\n\n‘mini.surround’:\n\nMiniSurround\n\n‘mini.tabline’:\n\nMiniTablineCurrent\nMiniTablineFill\nMiniTablineHidden\nMiniTablineModifiedCurrent\nMiniTablineModifiedHidden\nMiniTablineModifiedVisible\nMiniTablineTabpagesection\nMiniTablineTrunc\nMiniTablineVisible\n\n‘mini.test’:\n\nMiniTestEmphasis\nMiniTestFail\nMiniTestPass\n\n‘mini.trailspace’:\n\nMiniTrailspace"
  },
  {
    "objectID": "mini.nvim/CONTRIBUTING.html#commit-messages",
    "href": "mini.nvim/CONTRIBUTING.html#commit-messages",
    "title": "Contributing",
    "section": "",
    "text": "Try to make commit message as concise as possible while giving enough information about nature of a change. Think about whether it will be easy to understand in one year time when browsing through commit history.\nSingle commit should change either zero or one module, or affect all modules (i.e. enforcing some universal rule but not necessarily change files). Changes for two or more modules should be split in several module-specific commits.\nUse Conventional commits style:\n\nMessages should have the following structure:\n&lt;type&gt;[optional scope][!]: &lt;description&gt;\n&lt;empty line&gt;\n[optional body]\n&lt;empty line&gt;\n[optional footer(s)]\n&lt;type&gt; is mandatory and can be one of:\n\nci - change in how automation (GitHub actions, dual distribution scripts, etc.) is done.\ndocs - change in user facing documentation (help, README, CONTRIBUTING, etc.).\nfeat - adding new user facing feature.\nfix - resolving user facing issue.\nrefactor - change in code or documentation that should not affect users.\nstyle - change in convention of how something should be done (formatting, wording, etc.) and its effects.\ntest - change in tests. For temporary commits which later should be squashed (when working on PR, for example), use fixup type.\n\n[optional scope], if present, should be done in parenthesis (). If commit changes single module (as it usually should), using scope with module name is mandatory. If commit enforces something for all modules, use ALL scope.\nBreaking change, if present, should be expressed with ! before :.\n&lt;description&gt; is a change overview in imperative, present tense (“change” not “changed” nor “changes”). Should result into first line under 72 characters. Should start with not capitalized word and NOT end with sentence ending punctuation (i.e. one of .,?!;).\n[optional body], if present, should contain details and motivation about the change in plain language. Should be formatted to have maximum 80 characters in line.\n[optional footer(s)], if present, should be instruction(s) to Git or Github. Use “Resolve #xxx” on separate line if this commit resolves issue or PR.\n\nUse module’s function and field names without module’s name. Like add() and not MiniSurround.add().\n\nExamples:\nfeat(deps): add folds in update confirmation buffer\nfix(jump): make operator not delete one character if target is not found\n\nOne main goal is to do that in a dot-repeatable way, because this is very\nlikely to be repeated after an unfortunate first try.\n\nResolve #688\nrefactor(bracketed): do not source 'vim.treesitter' on `require()`\n\nAlthough less explicit, this considerably reduces startup footprint of\n'mini.bracketed' in isolation.\nfeat(hues)!: update verbatim text to be distinctive\ntest(ALL): update screenshots to work on Nightly\n\n\n\nTo lint messages of already done commits, execute scripts/lintcommit-ci.sh &lt;git-log-range&gt;. For example, to lint currently latest commit use scripts/lintcommit-ci.sh HEAD~..HEAD.\nTo lint commit message before doing commit, install pre-commit and enable it with pre-commit install --hook-type commit-msg (from the root directory). NOTE: requires nvim executable. If it throws (usually descriptive) error - recommit with proper message."
  },
  {
    "objectID": "mini.nvim/CONTRIBUTING.html#generating-help-file",
    "href": "mini.nvim/CONTRIBUTING.html#generating-help-file",
    "title": "Contributing",
    "section": "",
    "text": "If your contribution updates annotations used to generate help file, please regenerate it. You can make this with one of the following (assuming current directory being project root):\n\nFrom command line execute make documentation.\nInside Neovim instance run :luafile scripts/minidoc.lua or :lua require('mini.doc').generate()."
  },
  {
    "objectID": "mini.nvim/CONTRIBUTING.html#testing",
    "href": "mini.nvim/CONTRIBUTING.html#testing",
    "title": "Contributing",
    "section": "",
    "text": "If your contribution updates code, please make sure that it doesn’t break existing tests. If it adds new functionality or fixes a recognized bug, add new test case(s). There are two ways of running tests:\n\nFrom command line:\n\nExecute make test to run all tests (with nvim as executable).\nExecute make test_xxx to run tests only from file tests/test_xxx.lua (with nvim as executable). For example, make test_ai.\nIf you have multiple Neovim executables (say, nvim_07, nvim_08, nvim_09, nvim_010), you can use NVIM_EXEC variable to tests against multiple versions like this: NVIM_EXEC=\"nvim_07 nvim_08 nvim_09 nvim_010\" make test or NVIM_EXEC=\"nvim_07 nvim_08 nvim_09 nvim_010\" make test_xxx.\n\nInside Neovim instance execute :lua require('mini.test').setup(); MiniTest.run() to run all tests or :lua require('mini.test').setup(); MiniTest.run_file() to run tests only from current buffer.\n\nThis plugin uses ‘mini.test’ to manage its tests. For a more hands-on introduction, see TESTING.md.\nNotes:\n\nIf new functionality relies on an external dependency (git CLI tool, LSP server, etc.), use mocking (writing Lua code which emulates dependency usage as close as reasonably possible). For examples, take a look at tests for ‘mini.pick’, ‘mini.completion’, and ‘mini.statusline’.\nThere is a certain number of tests that are flaky (i.e. will sometimes report an error due to other reasons than actual functionality being broke). It is usually the ones which test time related functionality (i.e. that certain action was done after specific amount of delay).\nA commonly used way to know if the test is flaky is that it fails on non-nightly Neovim version yet there were no changes to its tested module after it had passed in the past. For example, some ‘mini.animate’ test is shown to break but there were no changes to it since test passed in CI couple of days before.\nThis issue is addressed by having test cases being executed several times in case of failure (with more retries in slow context). See “Retry” section in ‘TESTING.md’.\nIn case there is some test breaking which reasonably should not, rerun that test (or the whole file) at least several times.\nAdvice for writing more robust tests:\n\nTo test asynchronous or slow execution, use common sleep() test helper. For a more robust testing code, never directly use numbers to compute sleep time. Use precomputed time delay constants, which should always take into account different testing OSs (like be bigger on Windows, etc.). If module testing requires its extensive use and tests can not be made robust enough (examples are ‘mini.animate’, ‘mini.jump’, etc.), consider using it with argument that skips entire test case if sleep() is called in slow context.\nTake into account that Windows uses “\" as default path separator instead of Unix”/“. This should be accounted either in module’s code (preferably) or in test files (for example, by computing path separator and relying on it)."
  },
  {
    "objectID": "mini.nvim/CONTRIBUTING.html#formatting",
    "href": "mini.nvim/CONTRIBUTING.html#formatting",
    "title": "Contributing",
    "section": "",
    "text": "This project uses StyLua version 2.1.0 for formatting Lua code. Before making changes to code, please:\n\nInstall StyLua. NOTE: use v2.1.0.\nFormat with it. Currently there are two ways to do this:\n\nManually run stylua . from the root directory of this project.\nInstall pre-commit and enable it with pre-commit install (from the root directory). This will auto-format relevant code before making commits."
  },
  {
    "objectID": "mini.nvim/CONTRIBUTING.html#list-of-highlight-groups",
    "href": "mini.nvim/CONTRIBUTING.html#list-of-highlight-groups",
    "title": "Contributing",
    "section": "",
    "text": "Here is a list of all highlight groups defined inside ‘mini.nvim’ modules. See documentation in ‘doc’ directory to find out what they are used for.\n\n‘mini.animate’:\n\nMiniAnimateCursor\nMiniAnimateNormalFloat\n\n‘mini.clue’:\n\nMiniClueBorder\nMiniClueDescGroup\nMiniClueDescSingle\nMiniClueNextKey\nMiniClueNextKeyWithPostkeys\nMiniClueSeparator\nMiniClueTitle\n\n‘mini.cmdline’:\n\nMiniCmdlinePeekBorder\nMiniCmdlinePeekLineNr\nMiniCmdlinePeekNormal\nMiniCmdlinePeekSep\nMiniCmdlinePeekSign\nMiniCmdlinePeekTitle\n\n‘mini.completion’:\n\nMiniCompletionActiveParameter\nMiniCompletionDeprecated\nMiniCompletionInfoBorderOutdated\n\n‘mini.cursorword’:\n\nMiniCursorword\nMiniCursorwordCurrent\n\n‘mini.deps’:\n\nMiniDepsChangeAdded\nMiniDepsChangeRemoved\nMiniDepsHint\nMiniDepsInfo\nMiniDepsMsgBreaking\nMiniDepsPlaceholder\nMiniDepsTitle\nMiniDepsTitleError\nMiniDepsTitleSame\nMiniDepsTitleUpdate\n\n‘mini.diff’:\n\nMiniDiffSignAdd\nMiniDiffSignChange\nMiniDiffSignDelete\nMiniDiffOverAdd\nMiniDiffOverChange\nMiniDiffOverChangeBuf\nMiniDiffOverContext\nMiniDiffOverContextBuf\nMiniDiffOverDelete\n\n‘mini.files’:\n\nMiniFilesBorder\nMiniFilesBorderModified\nMiniFilesCursorLine\nMiniFilesDirectory\nMiniFilesFile\nMiniFilesNormal\nMiniFilesTitle\nMiniFilesTitleFocused\n\n‘mini.hipatterns’:\n\nMiniHipatternsFixme\nMiniHipatternsHack\nMiniHipatternsNote\nMiniHipatternsTodo\n\n‘mini.icons’:\n\nMiniIconsAzure\nMiniIconsBlue\nMiniIconsCyan\nMiniIconsGreen\nMiniIconsGrey\nMiniIconsOrange\nMiniIconsPurple\nMiniIconsRed\nMiniIconsYellow\n\n‘mini.indentscope’:\n\nMiniIndentscopeSymbol\nMiniIndentscopeSymbolOff\n\n‘mini.jump’:\n\nMiniJump\n\n‘mini.jump2d’:\n\nMiniJump2dDim\nMiniJump2dSpot\nMiniJump2dSpotAhead\nMiniJump2dSpotUnique\n\n‘mini.map’:\n\nMiniMapNormal\nMiniMapSymbolCount\nMiniMapSymbolLine\nMiniMapSymbolView\n\n‘mini.notify’:\n\nMiniNotifyBorder\nMiniNotifyLspProgress\nMiniNotifyNormal\nMiniNotifyTitle\n\n‘mini.operators’:\n\nMiniOperatorsExchangeFrom\n\n‘mini.pick’:\n\nMiniPickBorder\nMiniPickBorderBusy\nMiniPickBorderText\nMiniPickCursor\nMiniPickIconDirectory\nMiniPickIconFile\nMiniPickHeader\nMiniPickMatchCurrent\nMiniPickMatchMarked\nMiniPickMatchRanges\nMiniPickNormal\nMiniPickPreviewLine\nMiniPickPreviewRegion\nMiniPickPrompt\nMiniPickPromptCaret\nMiniPickPromptPrefix\n\n‘mini.snippets’:\n\nMiniSnippetsCurrent\nMiniSnippetsCurrentReplace\nMiniSnippetsFinal\nMiniSnippetsUnvisited\nMiniSnippetsVisited\n\n‘mini.starter’:\n\nMiniStarterCurrent\nMiniStarterFooter\nMiniStarterHeader\nMiniStarterInactive\nMiniStarterItem\nMiniStarterItemBullet\nMiniStarterItemPrefix\nMiniStarterSection\nMiniStarterQuery\n\n‘mini.statusline’:\n\nMiniStatuslineDevinfo\nMiniStatuslineFileinfo\nMiniStatuslineFilename\nMiniStatuslineInactive\nMiniStatuslineModeCommand\nMiniStatuslineModeInsert\nMiniStatuslineModeNormal\nMiniStatuslineModeOther\nMiniStatuslineModeReplace\nMiniStatuslineModeVisual\n\n‘mini.surround’:\n\nMiniSurround\n\n‘mini.tabline’:\n\nMiniTablineCurrent\nMiniTablineFill\nMiniTablineHidden\nMiniTablineModifiedCurrent\nMiniTablineModifiedHidden\nMiniTablineModifiedVisible\nMiniTablineTabpagesection\nMiniTablineTrunc\nMiniTablineVisible\n\n‘mini.test’:\n\nMiniTestEmphasis\nMiniTestFail\nMiniTestPass\n\n‘mini.trailspace’:\n\nMiniTrailspace"
  },
  {
    "objectID": "mini.nvim/doc/mini-snippets.html",
    "href": "mini.nvim/doc/mini-snippets.html",
    "title": "mini.snippets documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.snippets Manage and expand snippets\nMIT License Copyright (c) 2024 Evgeni Chasnovski\n\n\nModule\nSnippet is a template for a frequently used text. Typical workflow is to type snippet’s (configurable) prefix and expand it into a snippet session.\nThe template usually contains both pre-defined text and places (called “tabstops”) for user to interactively change/add text during snippet session.\nThis module supports (only) snippet syntax defined in LSP specification (with small deviations). See MiniSnippets-syntax-specification.\nFeatures:\n\nManage snippet collection by adding it explicitly or with a flexible set of performant built-in loaders. See MiniSnippets.gen_loader.\nConfigured snippets are efficiently resolved before every expand based on current local context. This, for example, allows using different snippets in different local tree-sitter languages (like in markdown code blocks). See MiniSnippets.default_prepare().\nMatch which snippet to insert based on the currently typed text. Supports both exact and fuzzy matching. See MiniSnippets.default_match().\nSelect from several matched snippets via vim.ui.select(). See MiniSnippets.default_select().\nStart specialized in-process LSP server to show loaded snippets inside (auto)completion engines (like mini.completion). See MiniSnippets.start_lsp_server().\nInsert, jump, and edit during snippet session in a configurable manner:\n\nConfigurable mappings for jumping and stopping.\nJumping wraps around the tabstops for easier navigation.\nEasy to reason rules for when session automatically stops.\nText synchronization of linked tabstops preserving relative indent.\nDynamic tabstop state visualization (current/visited/unvisited, etc.)\nInline visualization of empty tabstops (requires Neovim&gt;=0.10).\nWorks inside comments by preserving comment leader on new lines.\nSupports nested sessions (expand snippet while there is an active one). See MiniSnippets.default_insert().\n\nExported function to parse snippet body into easy-to-reason data structure. See MiniSnippets.parse().\n\nNotes:\n\nIt does not set up any snippet collection by default. Explicitly populate config.snippets to have snippets to match from.\nIt does not come with a built-in snippet collection. It is expected from users to add their own snippets, manually or with dedicated plugin(s).\nIt does not support variable/tabstop transformations in default snippet session. This requires ECMAScript Regular Expression parser which can not be implemented concisely.\n\nSources with more details:\n\nMiniSnippets-glossary\nMiniSnippets-overview\nMiniSnippets-examples\nMiniSnippets-in-other-plugins (for plugin authors)\n\n\nDependencies\nThis module doesn’t come with snippet collection. Either create it manually or install a dedicated plugin. For example, rafamadriz/friendly-snippets.\n\n\nSetup\nThis module needs a setup with require('mini.snippets').setup({}) (replace {} with your config table). It will create global Lua table MiniSnippets which you can use for scripting or manually (with :lua MiniSnippets.*).\nSee MiniSnippets.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minisnippets_config which should have same structure as MiniSnippets.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nL3MON4D3/LuaSnip:\n\nBoth contain functionality to load snippets from file system. This module provides several common loader generators while ‘LuaSnip’ contains a more elaborate loading setup. Also both require explicit opt-in for which snippets to load.\nBoth support LSP snippet format. ‘LuaSnip’ also provides own more elaborate snippet format which is out of scope for this module.\n‘LuaSnip’ can autoexpand snippets, while this module always requires an explicit user action to expand (by design).\nBoth contain snippet expand functionality which differs in some aspects:\n\n‘LuaSnip’ has an elaborate dynamic tabstop visualization config. This module provides a handful of dedicated highlight groups.\nThis module provides configurable visualization of empty tabstops.\n‘LusSnip’ implements nested sessions by essentially merging them into one. This module treats each nested session separately (to not visually overload) while storing them in stack (first in last out).\n‘LuaSnip’ uses Select-mode to power replacing current tabstop, while this module always stays in Insert-mode. This enables easier mapping understanding and more targeted highlighting.\nThis module implements jumping which wraps after final tabstop for more flexible navigation (enhanced with by a more flexible autostopping rules), while ‘LuaSnip’ autostops session once jumping reached the final tabstop.\n\n\nBuilt-in vim.snippet (on Neovim&gt;=0.10):\n\nDoes not contain functionality to load or match snippets (by design), while this module does.\nBoth contain expand functionality based on LSP snippet format. Differences in how snippet sessions are handled are similar to comparison with ‘LuaSnip’.\n\nrafamadriz/friendly-snippets:\n\nA snippet collection plugin without features to manage or expand them. This module is designed with ‘friendly-snippets’ compatibility in mind.\n\nabeldekat/cmp-mini-snippets:\n\nA source for hrsh7th/nvim-cmp that integrates ‘mini.snippets’.\n\n\n\n\nHighlight groups\n\nMiniSnippetsCurrent - current tabstop.\nMiniSnippetsCurrentReplace - current tabstop, placeholder is to be replaced.\nMiniSnippetsFinal - special $0 tabstop.\nMiniSnippetsUnvisited - not yet visited tabstop(s).\nMiniSnippetsVisited - visited tabstop(s).\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable core functionality, set vim.g.minisnippets_disable (globally) or vim.b.minisnippets_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nGlossary\n\nPOSITION\nTable representing position in a buffer. Fields:\n\n&lt;line&gt; (number) - line number (starts at 1).\n&lt;col&gt; (number) - column number (starts at 1).\n\n\n\nREGION\nTable representing region in a buffer. Fields: &lt;from&gt; and &lt;to&gt; for inclusive start/end POSITIONs.\n\n\nSNIPPET\nData about template to insert. Should contain fields:\n\n&lt;prefix&gt; - string snippet identifier.\n&lt;body&gt; - string snippet content with appropriate syntax.\n&lt;desc&gt; - string snippet description in human readable form.\n\nCan also be used to mean snippet body if distinction is clear.\n\n\nSNIPPET SESSION\nInteractive state for user to adjust inserted snippet.\n\n\nMATCHED SNIPPET\nSnippet which contains &lt;region&gt; field with region that matched it. Usually region needs to be removed.\n\n\nSNIPPET NODE\nUnit of parsed snippet body. See MiniSnippets.parse().\n\n\nTABSTOP\nDedicated places in snippet body for users to interactively adjust. Specified in snippet body with $ followed by digit(s).\n\n\nLINKED TABSTOPS\nDifferent nodes assigned the same tabstop. Updated in sync.\n\n\nREFERENCE NODE\nFirst (from left to right) node of linked tabstops. Used to determine synced text and cursor placement after jump.\n\n\nEXPAND\nAction to start snippet session based on currently typed text. Always done in current buffer at cursor. Executed steps:\n\nPREPARE - resolve raw config snippets at context.\nMATCH - match resolved snippets at cursor position.\nSELECT - possibly choose among matched snippets.\nINSERT - insert selected snippet and start snippet session.\n\n\n\n\n\nOverview\nSnippet is a template for a frequently used text. Typical workflow is to type snippet’s (configurable) prefix and expand it into a snippet session: add some pre-defined text and allow user to interactively change/add at certain places.\nThis overview assumes default config for mappings and expand. See MiniSnippets.config and MiniSnippets-examples for more details.\n\nSnippet structure\nSnippet consists from three parts:\n\nPrefix - identifier used to match against current text.\nBody - actually inserted content with appropriate syntax.\nDesc - description in human readable form.\n\nExample: { prefix = 'tis', body = 'This is snippet', desc = 'Snip' } Typing tis and pressing “expand” mapping (&lt;C-j&gt; by default) will remove “tis”, add “This is snippet”, and place cursor at the end in Insert mode.\n\n\nSyntax\nMiniSnippets-syntax-specification\nInserting just text after typing smaller prefix is already powerful enough. For more flexibility, snippet body can be formatted in a special way to provide extra features. This module implements support for syntax defined in LSP specification (with small deviations). See this link for reference: https://microsoft.github.io/language-server-protocol/specifications/lsp/3.18/specification/#snippet_syntax\nA quick overview of basic syntax features:\n\nTabstops are snippet parts meant for interactive editing at their location. They are denoted as $1, $2, etc. Navigating between them is called “jumping” and is done in numerical order of tabstop identifiers by pressing special keys: &lt;C-l&gt; and &lt;C-h&gt; to jump to next and previous tabstop respectively. Special tabstop $0 is called “final tabstop”: it is used to decide when snippet session is automatically stopped and is visited last during jumping.\nExample: T1=$1 T2=$2 T0=$0 is expanded as T1= T2= T0= with three tabstops.\nTabstop can have placeholder: a text used if tabstop is not yet edited. Text is preserved if no editing is done. It follows this same syntax, which means it can itself contain tabstops with placeholders (i.e. be nested). Tabstop with placeholder is denoted as ${1:placeholder} ($1 is ${1:}).\nExample: T1=${1:text} T2=${2:&lt;$1&gt;} is expanded as T1=text T2=&lt;text&gt;; typing x at first placeholder results in T1=x T2=&lt;x&gt;; jumping once and typing y results in T1=x T2=y.\nThere can be several tabstops with same identifier. They are linked and updated in sync during text editing. Can also have different placeholders; they are forced to be the same as in the first (from left to right) tabstop.\nExample: T1=${1:text} T1=$1 is expanded as T1=text T1=text; typing x at first placeholder results in T1=x T1=x.\nTabstop can also have choices: suggestions about tabstop text. It is denoted as ${1|a,b,c|}. First choice is used as placeholder.\nExample: T1=${1|left,right|} is expanded as T1=left.\nVariables can be used to automatically insert text without user interaction. As tabstops, each one can have a placeholder which is used if variable is not defined. There is a special set of variables describing editor state.\nExample: V1=$TM_FILENAME V2=${NOTDEFINED:placeholder} is expanded as V1=current-file-basename V2=placeholder.\n\nWhat’s different from LSP specification:\n\nSpecial set of variables is wider and is taken from VSCode specification: https://code.visualstudio.com/docs/editor/userdefinedsnippets#_variables Exceptions are BLOCK_COMMENT_START and BLOCK_COMMENT_END as Neovim doesn’t provide this information.\nVariable TM_SELECTED_TEXT is resolved as contents of quote_quote register. It assumes that text is put there prior to expanding. For example, visually select, press c, type prefix, and expand. See MiniSnippets-examples for how to adjust this.\nEnvironment variables are recognized and supported: V1=$VIMRUNTIME will use an actual value of $VIMRUNTIME.\nVariable transformations are not supported during snippet session. It would require interacting with ECMAScript-like regular expressions for which there is no easy way in Neovim. It may change in the future. Transformations are recognized during parsing, though, with some exceptions:\n\nThe } inside if of ${1:?if:else} needs escaping (for technical reasons).\n\n\nThere is a MiniSnippets.parse() function for programmatically parsing snippet body into a comprehensible data structure.\n\n\nExpand\nUsing snippets is done via what is called “expanding”. It goes like this:\n\nType snippet prefix or its recognizable part.\nPress &lt;C-j&gt; to expand. It will perform the following steps:\n\nPrepare available snippets in current context (buffer + local language). This allows snippet setup to have general function loaders which return different snippets in different contexts.\nMatch text to the left of cursor with available prefixes. It first tries to do exact match and falls back to fuzzy matching.\nIf there are several matches, use vim.ui.select() to choose one.\nInsert single matching snippet. If snippet contains tabstops, start snippet session.\n\n\nFor more details about each step see:\n\nMiniSnippets.default_prepare()\nMiniSnippets.default_match()\nMiniSnippets.default_select()\nMiniSnippets.default_insert()\n\nSnippet session allows interactive editing at tabstop locations:\n\nAll tabstop locations are visualized depending on tabstop “state” (whether it is current/visited/unvisited/final and whether it was already edited). Empty tabstops are visualized with inline virtual text (“•”/“∎” for regular/final tabstops). It is removed after session is stopped.\nStart session at first tabstop. Type text to replace placeholder. When finished with current tabstop, jump to next with &lt;C-l&gt;. Repeat. If changed mind about some previous tabstop, jump back with &lt;C-h&gt;. Jumping also wraps around the edge (first tabstop is next after final).\nIf tabstop has choices, use &lt;C-n&gt; / &lt;C-p&gt; to select next / previous item.\nStarting another snippet session while there is an active one is allowed. This creates nested sessions: suspend current, start the new one. After newly created is stopped, resume the suspended one.\nStop session manually by pressing &lt;C-c&gt; or make it stop automatically: if final tabstop is current either make a text edit or exit to Normal mode. If snippet doesn’t explicitly define final tabstop, it is added at the end of the snippet.\n\nFor more details about snippet session see MiniSnippets-session.\nTo select and insert snippets via completion engine (that supports LSP completion; like mini.completion or lsp-autocompletion), call MiniSnippets.start_lsp_server() after MiniSnippets.setup(). This sets up an LSP server that matches and provides snippets loaded with ‘mini.snippets’. To match with completion engine, use start_lsp_server({ match = false }).\n\n\nManagement\nOut of the box ‘mini.snippets’ doesn’t load any snippets, it should be done explicitly inside MiniSnippets.setup() following MiniSnippets.config.\nThe suggested approach to snippet management is to create dedicated files with snippet data and load them through function loaders in config.snippets. See MiniSnippets-examples for basic (yet capable) snippet management config.\n\nFile specification\nMiniSnippets-file-specification\nGeneral idea of supported files is to have at least out of the box experience with common snippet collections. Namely “rafamadriz/friendly-snippets”. The following files are supported:\n\nExtensions:\n\nRead/decoded as JSON object (vim.json.decode()): *.json, *.code-snippets\nExecuted as Lua file (dofile()) and uses returned value: *.lua\n\nContent:\n\nDict-like: object in JSON; returned table in Lua; no order guarantees.\nArray-like: array in JSON; returned array table in Lua; preserves order.\n\n\nExample of file content with a single snippet:\n\nLua dict-like: return { name = { prefix = 't', body = 'Text' } }\nLua array-like: return { { prefix = 't', body = 'Text', desc = 'name' } }\nJSON dict-like: { \"name\": { \"prefix\": \"t\", \"body\": \"Text\" } }\nJSON array-like: [ { \"prefix\": \"t\", \"body\": \"Text\", \"desc\": \"name\" } ]\n\nNotes:\n\nThere is no built-in support for VSCode-like “package.json” files. Define structure manually in MiniSnippets.setup() via built-in or custom loaders.\nThere is no built-in support for scope field of snippet data. Snippets are expected to be manually separated into smaller files and loaded on demand.\n\nFor supported snippet syntax see MiniSnippets-syntax-specification.\n\n\nGeneral advice\n\nPut files in “snippets” subdirectory of any path in ‘runtimepath’ (like ‘$XDG_CONFIG_HOME/nvim/snippets/global.json’). This is compatible with MiniSnippets.gen_loader.from_runtime() and example from MiniSnippets-examples.\nPrefer *.json files with dict-like content if you want more cross platfrom setup. Otherwise use *.lua files with array-like content.\nTo implement “dynamic snippet” that changes data (usually &lt;body&gt;) depending on the context, use *.lua file with function returning snippet data. It should be an element in the output table (dict or array like).\n\n\n\n\nDemo\nThe best way to grasp the design of snippet management and expansion is to try them out yourself. Here are steps for a basic demo:\n\nCreate ‘snippets/global.json’ file in the config directory with the content:\n{\n  \"Basic\":        { \"prefix\": \"ba\", \"body\": \"T1=$1 T2=$2 T0=$0\"         },\n  \"Placeholders\": { \"prefix\": \"pl\", \"body\": \"T1=${1:aa}\\nT2=${2:&lt;$1&gt;}\"  },\n  \"Choices\":      { \"prefix\": \"ch\", \"body\": \"T1=${1|a,b|} T2=${2|c,d|}\" },\n  \"Linked\":       { \"prefix\": \"li\", \"body\": \"T1=$1\\n\\tT1=$1\"            },\n  \"Variables\":    { \"prefix\": \"va\", \"body\": \"Runtime: $VIMRUNTIME\\n\"    },\n  \"Complex\":      {\n    \"prefix\": \"co\",\n    \"body\": [ \"T1=${1:$RANDOM}\", \"T3=${3:$1_${2:$1}}\", \"T2=$2\" ]\n  }\n}\nSet up ‘mini.snippets’ as recommended in MiniSnippets-examples.\nOpen Neovim. Type each snippet prefix and press &lt;C-j&gt; (even if there is still active session). Explore from there.\n\n\n\n\n\nExamples\n\nBasic snippet management config\nExample of snippet management setup that should cover most cases:\n-- Setup\nlocal gen_loader = require('mini.snippets').gen_loader\nrequire('mini.snippets').setup({\n  snippets = {\n    -- Load custom file with global snippets first\n    gen_loader.from_file('~/.config/nvim/snippets/global.json'),\n\n    -- Load snippets based on current language by reading files from\n    -- \"snippets/\" subdirectories from 'runtimepath' directories.\n    gen_loader.from_lang(),\n  },\n})\nThis setup allows having single file with custom “global” snippets (will be present in every buffer) and snippets which will be loaded based on the local language (see MiniSnippets.gen_loader.from_lang()).\nCreate language snippets manually (by creating and populating ‘$XDG_CONFIG_HOME/nvim/snippets/lua.json’ file) or by installing dedicated snippet collection plugin (like ‘rafamadriz/friendly-snippets’).\nNote: all built-in loaders and MiniSnippets.read_file() cache their output by default. It means that after a file is first read, changing it won’t have effect during current Neovim session. See MiniSnippets.gen_loader about how to reset cache if necessary.\n\n\nSelect from all available snippets in current context\nWith MiniSnippets.default_match(), expand snippets (&lt;C-j&gt; by default) at line start or after whitespace. To be able to always select from all current context snippets, make mapping similar to the following:\nlocal rhs = function() MiniSnippets.expand({ match = false }) end\nvim.keymap.set('i', '&lt;C-g&gt;&lt;C-j&gt;', rhs, { desc = 'Expand all' })\n\n\n“Supertab”-like &lt;Tab&gt; / &lt;S-Tab&gt; mappings\nThis module intentionally by default uses separate keys to expand and jump as it enables cleaner use of nested sessions. Here is an example of setting up custom &lt;Tab&gt; to “expand or jump” and &lt;S-Tab&gt; to “jump to previous”:\nlocal snippets = require('mini.snippets')\nlocal match_strict = function(snips)\n  -- Do not match with whitespace to cursor's left\n  return snippets.default_match(snips, { pattern_fuzzy = '%S+' })\nend\nsnippets.setup({\n  -- ... Set up snippets ...\n  mappings = { expand = '', jump_next = '', jump_prev = '' },\n  expand   = { match = match_strict },\n})\nlocal expand_or_jump = function()\n  local can_expand = #MiniSnippets.expand({ insert = false }) &gt; 0\n  if can_expand then vim.schedule(MiniSnippets.expand); return '' end\n  local is_active = MiniSnippets.session.get() ~= nil\n  if is_active then MiniSnippets.session.jump('next'); return '' end\n  return '\\t'\nend\nlocal jump_prev = function() MiniSnippets.session.jump('prev') end\nvim.keymap.set('i', '&lt;Tab&gt;', expand_or_jump, { expr = true })\nvim.keymap.set('i', '&lt;S-Tab&gt;', jump_prev)\n\n\nStop session immediately after jumping to final tabstop\nUtilize a dedicated MiniSnippets-events:\nlocal fin_stop = function(args)\n  if args.data.tabstop_to == '0' then MiniSnippets.session.stop() end\nend\nlocal au_opts = { pattern = 'MiniSnippetsSessionJump', callback = fin_stop }\nvim.api.nvim_create_autocmd('User', au_opts)\n\n\nStop all sessions on Normal mode exit\nUse ModeChanged and MiniSnippets-events events:\nlocal make_stop = function()\n  local au_opts = { pattern = '*:n', once = true }\n  au_opts.callback = function()\n    while MiniSnippets.session.get() do\n      MiniSnippets.session.stop()\n    end\n  end\n  vim.api.nvim_create_autocmd('ModeChanged', au_opts)\nend\nlocal opts = { pattern = 'MiniSnippetsSessionStart', callback = make_stop }\nvim.api.nvim_create_autocmd('User', opts)\n\n\nCustomize variable evaluation\nCreate environment variables and config.expand.insert wrapper:\n-- Use evnironment variables with value is same for all snippet sessions\nvim.loop.os_setenv('USERNAME', 'user')\n\n-- Compute custom lookup for variables with dynamic values\nlocal insert_with_lookup = function(snippet)\n  local lookup = {\n    TM_SELECTED_TEXT = table.concat(vim.fn.getreg('a', true, true), '\\n'),\n  }\n  return MiniSnippets.default_insert(snippet, { lookup = lookup })\nend\n\nrequire('mini.snippets').setup({\n  -- ... Set up snippets ...\n  expand = { insert = insert_with_lookup },\n})\n\n\nUsing Neovim’s built-ins to insert snippet\nDefine custom expand.insert in MiniSnippets.config and mappings:\nrequire('mini.snippets').setup({\n  -- ... Set up snippets ...\n  expand = {\n    insert = function(snippet, _) vim.snippet.expand(snippet.body) end\n  }\n})\n-- Make jump mappings or skip to use built-in &lt;Tab&gt;/&lt;S-Tab&gt; in Neovim&gt;=0.11\nlocal jump_next = function()\n  if vim.snippet.active({direction = 1}) then return vim.snippet.jump(1) end\nend\nlocal jump_prev = function()\n  if vim.snippet.active({direction = -1}) then vim.snippet.jump(-1) end\nend\nvim.keymap.set({ 'i', 's' }, '&lt;C-l&gt;', jump_next)\nvim.keymap.set({ 'i', 's' }, '&lt;C-h&gt;', jump_prev)\n\n\nUsing ‘mini.snippets’ in other plugins\nMiniSnippets-in-other-plugins\n\nPerform a _G.MiniSnippets ~= nil check before using any feature. This ensures that user explicitly set up ‘mini.snippets’.\nTo insert snippet given its body (like vim.snippet.expand()), use:\n-- Use configured `insert` method with falling back to default\nlocal insert = MiniSnippets.config.expand.insert\n  or MiniSnippets.default_insert\n-- Insert at cursor\ninsert({ body = snippet })\nTo get available snippets, use:\n-- Get snippets matched at cursor\nMiniSnippets.expand({ insert = false })\n\n-- Get all snippets available at cursor context\nMiniSnippets.expand({ match = false, insert = false })\n\n\n\n\n\nsetup()\n\nMiniSnippets.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniSnippets.config.\n\n\nUsage\nrequire('mini.snippets').setup({}) -- replace {} with your config table\n                                   -- needs `snippets` field present\n\n\n\n\nconfig\n\nMiniSnippets.config\n\n\nDefaults\nMiniSnippets.config = {\n  -- Array of snippets and loaders (see |MiniSnippets.config| for details).\n  -- Nothing is defined by default. Add manually to have snippets to match.\n  snippets = {},\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Expand snippet at cursor position. Created globally in Insert mode.\n    expand = '&lt;C-j&gt;',\n\n    -- Interact with default `expand.insert` session.\n    -- Created for the duration of active session(s)\n    jump_next = '&lt;C-l&gt;',\n    jump_prev = '&lt;C-h&gt;',\n    stop = '&lt;C-c&gt;',\n  },\n\n  -- Functions describing snippet expansion. If `nil`, default values\n  -- are `MiniSnippets.default_&lt;field&gt;()`.\n  expand = {\n    -- Resolve raw config snippets at context\n    prepare = nil,\n    -- Match resolved snippets at cursor position\n    match = nil,\n    -- Possibly choose among matched snippets\n    select = nil,\n    -- Insert selected snippet\n    insert = nil,\n  },\n}\n\n\nLoaded snippets\nconfig.snippets is an array containing snippet data which can be: snippet table, function loader, or (however deeply nested) array of snippet data.\nSnippet is a table with the following fields:\n\n&lt;prefix&gt; (string|table|nil) - string used to match against current text. If array, all strings should be used as separate prefixes.\n&lt;body&gt; (string|table|nil) - content of a snippet which should follow the MiniSnippets-syntax-specification. Array is concatenated with \"\\n\".\n&lt;desc&gt; (string|table|nil) - description of snippet. Can be used to display snippets in a more human readable form. Array is concatenated with \"\\n\".\n\nFunction loaders are expected to be called with single context table argument (containing any data about current context) and return same as config.snippets data structure.\nconfig.snippets is resolved with config.prepare on every expand. See MiniSnippets.default_prepare() for how it is done by default.\nFor a practical example see MiniSnippets-examples. Here is an illustration of config.snippets customization capabilities:\nlocal gen_loader = require('mini.snippets').gen_loader\nrequire('mini.snippets').setup({\n  snippets = {\n    -- Load custom file with global snippets first (order matters)\n    gen_loader.from_file('~/.config/nvim/snippets/global.json'),\n\n    -- Or add them here explicitly\n    { prefix='cdate', body='$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE' },\n\n    -- Load snippets based on current language by reading files from\n    -- \"snippets/\" subdirectories from 'runtimepath' directories.\n    gen_loader.from_lang(),\n\n    -- Load project-local snippets with `gen_loader.from_file()`\n    -- and relative path (file doesn't have to be present)\n    gen_loader.from_file('.vscode/project.code-snippets'),\n\n    -- Custom loader for language-specific project-local snippets\n    function(context)\n      local rel_path = '.vscode/' .. context.lang .. '.code-snippets'\n      if vim.fn.filereadable(rel_path) == 0 then return end\n      return MiniSnippets.read_file(rel_path)\n    end,\n\n    -- Ensure that some prefixes are not used (as there is no `body`)\n    { prefix = { 'bad', 'prefix' } },\n  }\n})\n\n\nMappings\nconfig.mappings describes which mappings are automatically created.\nmappings.expand is created globally in Insert mode and is used to expand snippet at cursor. Use MiniSnippets.expand() for custom mappings.\nmappings.jump_next, mappings.jump_prev, and mappings.stop are created for the duration of active snippet session(s) from MiniSnippets.default_insert(). Used to jump to next/previous tabstop and stop active session respectively. Use MiniSnippets.session.jump() and MiniSnippets.session.stop() for custom Insert mode mappings. Note: do not use \"&lt;C-n&gt;\" or \"&lt;C-p&gt;\" for any action as they conflict with built-in completion: it forces them to mean “change focus to next/previous completion item”. This matters more frequently than when there is a tabstop with choices due to how this module handles built-in completion during jumps.\n\n\nExpand\nconfig.expand defines expand steps (see MiniSnippets-glossary), either after pressing mappings.expand or starting manually via MiniSnippets.expand().\nexpand.prepare is a function that takes raw_snippets in the form of config.snippets and should return a plain array of snippets (as described in MiniSnippets-glossary). Will be called on every MiniSnippets.expand() call. If returns second value, it will be used as context for warning messages. Default: MiniSnippets.default_prepare().\nexpand.match is a function that takes expand.prepare output and returns an array of matched snippets: one or several snippets user might intend to eventually insert. Should sort matches in output from best to worst. Entries can contain region field with current buffer region used to do the match; usually it needs to be removed (similar to how ins-completion and abbreviations work). Default: MiniSnippets.default_match()\nexpand.select is a function that takes output of expand.match and function that inserts snippet (and also ensures Insert mode and removes snippet’s match region). Should allow user to perform interactive snippet selection and insert the chosen one. Designed to be compatible with vim.ui.select(). Called for any non-empty expand.match output (even with single entry). Default: MiniSnippets.default_select()\nexpand.insert is a function that takes single snippet table as input and inserts snippet at cursor position. This is a main entry point for adding text template to buffer and starting a snippet session. If called inside MiniSnippets.expand() (which is a usual interactive case), all it has to do is insert snippet at cursor position. Ensuring Insert mode and removing matched snippet region is done beforehand. Default: MiniSnippets.default_insert()\nIllustration of config.expand customization:\n-- Supply extra data as context\nlocal my_p = function(raw_snippets)\n  local _, cont = MiniSnippets.default_prepare({})\n  cont.cursor = vim.api.nvim_win_get_cursor()\n  return MiniSnippets.default_prepare(raw_snippets, { context = cont })\nend\n-- Perform fuzzy match based only on alphanumeric characters\nlocal my_m = function(snippets)\n  return MiniSnippets.default_match(snippets, { pattern_fuzzy = '%w*' })\nend\n-- Always insert the best matched snippet\nlocal my_s = function(snippets, insert) return insert(snippets[1]) end\n-- Use different string to show empty tabstop as inline virtual text\nlocal my_i = function(snippet)\n  return MiniSnippets.default_insert(snippet, { empty_tabstop = '$' })\nend\n\nrequire('mini.snippets').setup({\n  -- ... Set up snippets ...\n  expand = { prepare = my_p, match = my_m, select = my_s, insert = my_i }\n})\n\n\n\n\nexpand()\n\nMiniSnippets.expand({opts})\n\nExpand snippet at cursor position\nPerform expand steps (see MiniSnippets-glossary). Initial raw snippets are taken from config.snippets in current buffer. Snippets from vim.b.minisnippets_config are appended to global snippet array.\n\nParameters\n{opts} (table|nil) Options. Same structure as expand in MiniSnippets.config and uses its values as default. There are differences in allowed values:\n\nUse match = false to have all buffer snippets as matches.\nUse select = false to always expand the best match (if any).\nUse insert = false to return all matches without inserting.\n\nNote: opts.insert is called after ensuring Insert mode, removing snippet’s match region, and positioning cursor.\n\n\nReturn\n(table|nil) If insert is false, an array of matched snippets (expand.match output). Otherwise nil.\n\n\nUsage\n-- Match, maybe select, and insert\nMiniSnippets.expand()\n\n-- Match and force expand the best match (if any)\nMiniSnippets.expand({ select = false })\n\n-- Use all current context snippets as matches\nMiniSnippets.expand({ match = false })\n\n-- Get all matched snippets\nlocal matches = MiniSnippets.expand({ insert = false })\n\n-- Get all current context snippets\nlocal all = MiniSnippets.expand({ match = false, insert = false })\n\n\nSee also\nMiniSnippets.start_lsp_server() to instead show loaded snippets in (auto)completion engines (like mini.completion).\n\n\n\n\ngen_loader\n\nMiniSnippets.gen_loader\n\nGenerate snippet loader\nThis is a table with function elements. Call to actually get a loader.\nCommon features for all produced loaders:\n\nDesigned to work with MiniSnippets-file-specification.\nCache output by default, i.e. second and later calls with same input value don’t read file system. Different loaders from same generator share cache. Disable by setting opts.cache to false. To clear all cache, call MiniSnippets.setup(). For example:\n\nMiniSnippets.setup(MiniSnippets.config)\n\nUse vim.notify() to show problems during loading while trying to load as much correctly defined snippet data as possible. Disable by setting opts.silent to true.\n\n\n\n\ngen_loader.from_lang()\n\nMiniSnippets.gen_loader.from_lang({opts})\n\nGenerate language loader\nOutput loads files from “snippets/” subdirectories of ‘runtimepath’ matching configured language patterns. See MiniSnippets.gen_loader.from_runtime() for runtime loading details.\nLanguage is taken from &lt;lang&gt; field (if present with string value) of context argument used in loader calls during “prepare” stage. This is compatible with MiniSnippets.default_prepare() and most snippet collection plugins.\n\nParameters\n{opts} (table|nil) Options. Possible values:\n\n&lt;lang_patterns&gt; (table) - map from language to array of runtime patterns used to find snippet files, as in MiniSnippets.gen_loader.from_runtime(). Patterns will be processed in order. With MiniSnippets.default_prepare() it means if snippets have same prefix, data from later patterns is used. To interactively check the current language with default context, execute :=MiniSnippets.default_prepare({}) and see data in the second table.\nDefault pattern array (for non-empty language) is constructed as to read *.json and *.lua files that are:\n\nInside “snippets/” subdirectory named as language (files can be however deeply nested).\nNamed as language and is in “snippets/” directory (however deep). Example for “lua” language:\n{ 'lua/**/*.json', 'lua/**/*.lua', '**/lua.json', '**/lua.lua' }\n\nAdd entry for \"\" (empty string) as language to be sourced when lang context is empty string (which is usually temporary scratch buffers).\n&lt;cache&gt; (boolean) - whether to use cached output. Default: true. Note: caching is done per used runtime pattern, not lang value to allow different from_lang() loaders to share cache.\n&lt;silent&gt; (boolean) - whether to hide non-error messages. Default: false.\n\n\n\nReturn\n(function) Snippet loader.\n\n\nUsage\n-- Adjust language patterns\nlocal latex_patterns = { 'latex/**/*.json', '**/latex.json' }\nlocal lang_patterns = {\n  tex = latex_patterns, plaintex = latex_patterns,\n  -- Recognize special injected language of markdown tree-sitter parser\n  markdown_inline = { 'markdown.json' },\n}\nlocal gen_loader = require('mini.snippets').gen_loader\nrequire('mini.snippets').setup({\n  snippets = {\n    gen_loader.from_lang({ lang_patterns = lang_patterns }),\n  },\n})\n\n\n\n\ngen_loader.from_runtime()\n\nMiniSnippets.gen_loader.from_runtime({pattern}, {opts})\n\nGenerate runtime loader\nOutput loads files which match pattern inside “snippets/” directories from ‘runtimepath’. This is useful to simultaneously read several similarly named files from different sources. Order from ‘runtimepath’ is preserved.\nTypical case is loading snippets for a language from files like xxx.{json,lua} but located in different “snippets/” directories inside ‘runtimepath’.\n\n&lt;config&gt;/snippets/lua.json - manually curated snippets in user config.\n&lt;path/to/installed/plugin&gt;/snippets/lua.json - from installed plugin.\n&lt;config&gt;/after/snippets/lua.json - used to adjust snippets from plugins. For example, remove some snippets by using prefixes and no body.\n\n\nParameters\n{pattern} (string) Pattern of files to read. Can have wildcards as described in nvim_get_runtime_file(). Example for “lua” language: 'lua.{json,lua}'.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;all&gt; (boolean) - whether to load from all matching runtime files. Default: true.\n&lt;cache&gt; (boolean) - whether to use cached output. Default: true. Note: caching is done per pattern value, which assumes that both ‘runtimepath’ value and snippet files do not change during Neovim session. Caching this way gives significant speed improvement by reducing the need to traverse file system on every snippet expand.\n&lt;silent&gt; (boolean) - whether to hide non-error messages. Default: false.\n\n\n\nReturn\n(function) Snippet loader.\n\n\n\n\ngen_loader.from_file()\n\nMiniSnippets.gen_loader.from_file({path}, {opts})\n\nGenerate single file loader\nOutput is a thin wrapper around MiniSnippets.read_file() which will skip warning if file is absent (other messages are still shown). Use it to load file which is not guaranteed to exist (like project-local snippets).\n\nParameters\n{path} (string) Same as in MiniSnippets.read_file().\n{opts} (table|nil) Same as in MiniSnippets.read_file().\n\n\nReturn\n(function) Snippet loader.\n\n\n\n\nread_file()\n\nMiniSnippets.read_file({path}, {opts})\n\nRead file with snippet data\n\nParameters\n{path} (string) Path to file with snippets. Can be relative. See MiniSnippets-file-specification for supported file formats.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;cache&gt; (boolean) - whether to use cached output. Default: true. Note: Caching is done per full path only after successful reading.\n&lt;silent&gt; (boolean) - whether to hide non-error messages. Default: false.\n\n\n\nReturn\n(table|nil) Array of snippets or nil if failed (also warn with vim.notify() about the reason).\n\n\n\n\ndefault_prepare()\n\nMiniSnippets.default_prepare({raw_snippets}, {opts})\n\nDefault prepare\nNormalize raw snippets (as in snippets from MiniSnippets.config) based on supplied context:\n\nTraverse and flatten nested arrays. Function loaders are executed with opts.context as argument and output is processed recursively.\nEnsure unique non-empty prefixes: later ones completely override earlier ones (similar to how ftplugin and similar runtime design behave). Empty string prefixes are all added (to allow inserting without matching).\nTransform and infer fields:\n\nMultiply array prefix into several snippets with same body/description. Infer absent prefix as empty string.\nConcatenate array body with \"\\n\". Do not infer absent body to have it remove previously added snippet with the same prefix.\nConcatenate array desc with \"\\n\". Infer desc field from description (for compatibility) or body fields, in that order.\n\nSort output by prefix.\n\nUnlike MiniSnippets.gen_loader entries, there is no output caching. This avoids duplicating data from gen_loader cache and reduces memory usage. It also means that every MiniSnippets.expand() call prepares snippets, which is usually fast enough. If not, consider manual caching:\nlocal cache = {}\nlocal prepare_cached = function(raw_snippets)\n  local _, cont = MiniSnippets.default_prepare({})\n  local id = 'buf=' .. cont.buf_id .. ',lang=' .. cont.lang\n  if cache[id] then return unpack(vim.deepcopy(cache[id])) end\n  local snippets = MiniSnippets.default_prepare(raw_snippets)\n  cache[id] = vim.deepcopy({ snippets, cont })\n  return snippets, cont\nend\n\nParameters\n{raw_snippets} (table) Array of snippet data as from MiniSnippets.config.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;context&gt; (any) - Context used as an argument for callable snippet data. Default: table with &lt;buf_id&gt; (current buffer identifier) and &lt;lang&gt; (local language) fields. Language is computed from tree-sitter parser at cursor (allows different snippets in injected languages), ‘filetype’ otherwise.\n\n\n\nReturn\n(...) Array of snippets and supplied context (default if none was supplied).\n\n\n\n\ndefault_match()\n\nMiniSnippets.default_match({snippets}, {opts})\n\nDefault match\nMatch snippets based on the line before cursor.\nTries two matching approaches consecutively:\n\nFind exact snippet prefix (if present and non-empty) to the left of cursor. It should also be preceded with a byte that matches pattern_exact_boundary. In case of any match, return the one with the longest prefix.\nMatch fuzzily snippet prefixes against the base (text to the left of cursor extracted via opts.pattern_fuzzy). Matching is done via matchfuzzy(). Empty base results in all snippets being matched. Return all fuzzy matches.\n\n\nParameters\n{snippets} (table) Array of snippets which can be matched.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;pattern_exact_boundary&gt; (string) - Lua pattern for the byte to the left of exact match to accept it. Line start is matched against empty string; use ? quantifier to allow it as boundary. Default: [%s%p]? (accept only whitespace and punctuation as boundary, allow match at line start). Example: prefix “l” matches in lines l, _l, x l; but not 1l, ll.\n&lt;pattern_fuzzy&gt; (string) - Lua pattern to extract base to the left of cursor for fuzzy matching. Supply empty string to skip this step. Default: '%S*' (as many as possible non-whitespace; allow empty string).\n\n\n\nReturn\n(table) Array of matched snippets ordered from best to worst match.\n\n\nUsage\n-- Accept any exact match\nMiniSnippets.default_match(snippets, { pattern_exact_boundary = '.?' })\n\n-- Perform fuzzy match based only on alphanumeric characters\nMiniSnippets.default_match(snippets, { pattern_fuzzy = '%w*' })\n\n\n\n\ndefault_select()\n\nMiniSnippets.default_select({snippets}, {insert}, {opts})\n\nDefault select\nShow snippets as vim.ui.select() items and insert the chosen one. For best interactive experience requires vim.ui.select() to work from Insert mode (be properly called and restore Insert mode after choice). This is the case for at least MiniPick.ui_select() and Neovim’s default.\n\nParameters\n{snippets} (table) Array of snippets (as an output of config.expand.match).\n{insert} (function|nil) Function to insert chosen snippet (passed as the only argument). Expected to remove snippet’s match region (if present as a field) and ensure proper cursor position in Insert mode. Default: MiniSnippets.default_insert().\n{opts} (table|nil) Options. Possible fields:\n\n&lt;insert_single&gt; (boolean) - whether to skip vim.ui.select() for snippets with a single entry and insert it directly. Default: true.\n\n\n\n\n\ndefault_insert()\n\nMiniSnippets.default_insert({snippet}, {opts})\n\nDefault insert\nPrepare for snippet insert and do it:\n\nEnsure Insert mode.\nDelete snippet’s match region (if present as &lt;region&gt; field). Ensure cursor.\nParse snippet body with MiniSnippets.parse() and enabled normalize. In particular, evaluate variables, ensure final node presence and same text for nodes with same tabstops. Stop if not able to.\nInsert snippet at cursor:\n\nAdd snippet’s text. Lines are split at “”. Indent and left comment leaders (inferred from ‘commentstring’ and ‘comments’) of current line are repeated on the next. Tabs (“) are expanded according to ‘expandtab’ and ‘shiftwidth’.\nIf there is an actionable tabstop (not final), start snippet session.\n\n\n\nSession life cycle\nMiniSnippets-session\n\nStart with cursor at first tabstop. If there are linked tabstops, cursor is placed at start of reference node (see MiniSnippets-glossary). All tabstops are visualized with dedicated highlight groups (see “Highlight groups” section in mini.snippets). Empty tabstops are visualized with inline virtual text (“•”/“∎” for regular/final tabstops) meaning that it is not an actual text in the buffer and will be removed after session is stopped.\nDecide whether you want to replace the placeholder. If not, jump to next or previous tabstop. If yes, edit it: add new and/or delete already added text. While doing so, several things happen in all linked tabstops (if any):\n\nAfter first typed character the placeholder is removed and highlighting changes from MiniSnippetsCurrentReplace to MiniSnippetsCurrent.\nText in all tabstop nodes is synchronized with the reference one. Relative indent of reference tabstop’s text is preserved: all but first lines in linked tabstops are reindented based on the first line indent. Note: text sync is forced only for current tabstop (for performance).\n\nJump with &lt;C-l&gt; / &lt;C-h&gt; to next / previous tabstop. Exact keys can be adjusted in MiniSnippets.config mappings. See MiniSnippets.session.jump() for jumping details.\nIf tabstop has choices, all of them are shown after each jump and deleting tabstop text. It is done with complete(), so use &lt;C-n&gt; / &lt;C-p&gt; to select next / previous choice. Type text to narrow down the list. Works best when ‘completeopt’ option contains menuone and noselect flags. Note: deleting character hides the list due to how complete() works; delete whole tabstop text (for example with one or more i_CTRL-W) for full list to reappear.\nNest another session by expanding snippet in the same way as without active session (can be even done in another buffer). If snippet has no actionable tabstop, text is just inserted. Otherwise start nested session:\n\nSuspend current session: hide highlights, keep text change tracking.\nStart new session and act as if it is the only one (edit/jump/nest).\nWhen ready (possibly after even more nested sessions), stop the session. This will resume previous one: sync text for its current tabstop and show highlighting. The experience of text synchronization only after resuming session is similar to how editing in visual-block mode works. Nothing else (like cursor/mode/buffer) is changed for a smoother automated session stop.\n\nNotes about the choice of the “session stack” approach to nesting over more common “merge into single session” approach:\n\nDoes not overload with highlighting.\nAllows nested sessions in different buffers.\nDoesn’t need a complex logic of injecting one session into another.\n\nRepeat edit/jump/nest steps any number of times.\nStop. It can be done in two ways:\n\nManually by pressing &lt;C-c&gt; or calling MiniSnippets.session.stop(). Exact key can be adjusted in MiniSnippets.config mappings.\nAutomatically: any text edit or switching to Normal mode stops session if final tabstop ($0) is current. Its presence is ensured after insert. Not stopping session right away after jumping to final mode (as most other snippet plugins do) allows going back to other tabstops in case of a late missed typo. Wrapping around the edge during jumping also helps with that. If current tabstop is not final, exiting into Normal mode for quick edit outside of snippets range (or carefully inside) is fine. Later get back into Insert mode and jump to next tabstop or manually stop session. See MiniSnippets-examples for how to set up custom stopping rules.\n\n\nUse MiniSnippets.session.get() to get data about active/nested session(s). Use MiniSnippets.session.jump() / MiniSnippets.session.stop() in mappings.\nWhat is allowed but not officially supported/recommended:\n\nEditing text within snippet range but outside of session life cycle. Mostly behaves as expected, but may harm tracking metadata (extmarks). In general anything but deleting tabstop range should be OK. Text synchronization of current tabstop would still be active.\n\n\n\nEvents\nMiniSnippets-events\nGeneral session activity (autocommand data contains &lt;session&gt; field):\n\nMiniSnippetsSessionStart - after a session is started.\nMiniSnippetsSessionStop - before a session is stopped.\n\nNesting session activity (autocommand data contains &lt;session&gt; field):\n\nMiniSnippetsSessionSuspend - before a session is suspended.\nMiniSnippetsSessionResume - after a session is resumed.\n\nJumping between tabstops (autocommand data contains &lt;tabstop_from&gt; and &lt;tabstop_new&gt; fields):\n\nMiniSnippetsSessionJumpPre - before jumping to a new tabstop.\nMiniSnippetsSessionJump - after jumping to a new tabstop.\n\n\n\nParameters\n{snippet} (table) Snippet table. Field &lt;body&gt; is mandatory.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;empty_tabstop&gt; (string) - used to visualize empty regular tabstops. Default: “•”.\n&lt;empty_tabstop_final&gt; (string) - used to visualize empty final tabstop(s). Default: “∎”.\n&lt;lookup&gt; (table) - passed to MiniSnippets.parse(). Use it to adjust how variables are evaluated. Default: {}.\n\n\n\n\n\nsession\n\nMiniSnippets.session\n\nWork with snippet session from MiniSnippets.default_insert()\n\n\n\nsession.get()\n\nMiniSnippets.session.get({all})\n\nGet data about active session\n\nParameters\n{all} (boolean|nil) Whether to return array with the whole session stack. Default: false.\n\n\nReturn\n(table) Single table with session data (if all is false) or array of them. Session data contains the following fields:\n\n&lt;buf_id&gt; (number) - identifier of session’s buffer.\n&lt;cur_tabstop&gt; (string) - identifier of session’s current tabstop.\n&lt;extmark_id&gt; (number) - extmark identifier which track session range.\n&lt;insert_args&gt; (table) - MiniSnippets.default_insert() arguments used to create the session. A table with &lt;snippet&gt; and &lt;opts&gt; fields.\n&lt;nodes&gt; (table) - parsed array of snippet nodes which is kept up to date during session. Has the structure of a normalized MiniSnippets.parse() output, plus every node contains extmark_id field with extmark identifier which can be used to get data about the current node state.\n&lt;ns_id&gt; (number) - namespace identifier for all session’s extmarks.\n&lt;tabstops&gt; (table) - data about session’s tabstops. Fields are string tabstop identifiers and values are tables with the following fields:\n\n&lt;is_visited&gt; (boolean) - whether tabstop was visited.\n&lt;next&gt; (string) - identifier of the next tabstop.\n&lt;prev&gt; (string) - identifier of the previous tabstop.\n\n\n\n\n\n\nsession.jump()\n\nMiniSnippets.session.jump({direction})\n\nJump to next/previous tabstop\nMake next/previous tabstop be current. Executes the following steps:\n\nMark current tabstop as visited.\nFind the next/previous tabstop id assuming they are sorted as numbers. Tabstop “0” is always last. Search is wrapped around the edges: first and final tabstops are next/previous for one another.\nFocus on target tabstop:\n\nEnsure session’s buffer is current.\nAdjust highlighting of affected nodes.\nSet cursor at tabstop’s reference node (first node among linked). Cursor is placed on left edge if tabstop has not been edited yet (so typing text replaces placeholder), on right edge otherwise (to update already edited text).\nShow all choices for tabstop with choices. Navigating through choices will update tabstop’s text.\n\n\n\nParameters\n{direction} (string) One of “next” or “prev”.\n\n\n\n\nsession.stop()\n\nMiniSnippets.session.stop()\n\nStop (only) active session\nTo stop all nested sessions use the following code:\nwhile MiniSnippets.session.get() do\n  MiniSnippets.session.stop()\nend\n\n\n\nparse()\n\nMiniSnippets.parse({snippet_body}, {opts})\n\nParse snippet\n\nParameters\n{snippet_body} (string|table) Snippet body as string or array of strings. Should follow MiniSnippets-syntax-specification.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;normalize&gt; (boolean) - whether to normalize nodes:\n\nEvaluate variable nodes and add output as a text field. If variable is not set, text field is nil. Values from opts.lookup are preferred over evaluation output. See MiniSnippets-syntax-specification for more info about variables.\nAdd text field for tabstops present in opts.lookup.\nEnsure every node contains exactly one of text or placeholder fields. If there are none, add default placeholder (one text node with first choice or empty string). If there are both, remove placeholder field.\nEnsure present final tabstop: append to end if absent.\nEnsure that nodes for same tabstop have same placeholder. Use the one from the first node. Default: false.\n\n&lt;lookup&gt; (table) - map from variable/tabstop (string) name to its value. Default: {}.\n\n\n\nReturn\n(table) Array of nodes. Node is a table with fields depending on node type:\n\nText node:\n\n&lt;text&gt; (string) - node’s text.\n\nTabstop node:\n\n&lt;tabstop&gt; (string) - tabstop identifier.\n&lt;text&gt; (string|nil) - tabstop value (if present in &lt;lookup&gt;).\n&lt;placeholder&gt; (table|nil) - array of nodes to be used as placeholder.\n&lt;choices&gt; (table|nil) - array of string choices.\n&lt;transform&gt; (table|nil) - array of transformation string parts.\n\nVariable node:\n\n&lt;var&gt; (string) - variable name.\n&lt;text&gt; (string|nil) - variable value.\n&lt;placeholder&gt; (table|nil) - array of nodes to be used as placeholder.\n&lt;transform&gt; (table|nil) - array of transformation string parts.\n\n\n\n\n\n\nstart_lsp_server()\n\nMiniSnippets.start_lsp_server({opts})\n\nStart completion LSP server\nThis starts (vim.lsp.start()) an LSP server with the purpose of displaying snippets in (auto)completion engines (mini.completion in particular). The server:\n\nOnly implements textDocument/completion method which prepares and matches snippets at cursor (via MiniSnippets.expand()).\nAuto-attaches to all loaded buffers by default.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;before_attach&gt; (function) - function executed before every attach to the buffer. Takes buffer id as input and can return false (not nil) to cancel attaching to the buffer. Default: attach to loaded normal buffers.\n&lt;match&gt; (false|function) - value of opts.match forwarded to the MiniSnippets.expand() when computing completion candidates. Supply false to not do matching at cursor, return all available snippets in cursor context, and rely on completion engine to match and sort items. Default: nil (equivalent to MiniSnippets.default_match()).\n&lt;server_config&gt; (table) - server config to be used as basis for first argument to vim.lsp.start() (cmd will be overridden). Default: {}.\n&lt;triggers&gt; (table) - array of trigger characters to be used as completionProvider.triggerCharacters server capability. Default: {}.\n\n\n\nReturn\n(integer|nil) Identifier of started LSP server."
  },
  {
    "objectID": "mini.nvim/doc/mini-completion.html",
    "href": "mini.nvim/doc/mini-completion.html",
    "title": "mini.completion documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.completion Completion and signature help\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nKey design ideas:\n\nHave an async (with customizable “debounce” delay) “two-stage chain completion”: first try to get completion items from LSP client (if set up) and if no result, fallback to custom action.\nManaging completion is done as much with Neovim’s built-in tools as possible. popupmenu-completion is used to show completion suggestions.\n\nFeatures:\n\nTwo-stage chain completion:\n\nFirst stage is an LSP completion implemented via MiniCompletion.completefunc_lsp(). It should be set up as either ‘completefunc’ or ‘omnifunc’. It tries to get completion items from LSP client (via ‘textDocument/completion’ request). Custom preprocessing of response items is possible (with MiniCompletion.config.lsp_completion.process_items), for example with fuzzy matching. By default items directly starting with completed word are kept and are sorted according to LSP specification. Supports additionalTextEdits, like auto-import and others (see ‘Notes’), and snippet items (best results require mini.snippets dependency).\nIf first stage is not set up or resulted into no candidates, fallback action is executed. The most tested actions are Neovim’s built-in insert completion (see ins-completion).\n\nAutomatic display in floating window of completion item info (via ‘completionItem/resolve’ request) and signature help (with highlighting of active parameter if LSP server provides such information). Signature help is shown if character to cursor’s left is a dedicated trigger character (configured in signatureHelpProvider.triggerCharacters of LSP server capabilities) and updated without delay if is currently opened. Already shown window for signature help is fixed and is closed when there is nothing to show, its text is different, or when leaving Insert mode. Scroll in either info/signature window with &lt;C-f&gt; / &lt;C-b&gt; (by default).\nAutomatic actions are done after some configurable amount of delay. This reduces computational load and allows fast typing (completion and signature help) and item selection (item info)\nForce two-stage/fallback completion (&lt;C-Space&gt; / &lt;A-Space&gt; by default).\nCustomizable highlighting of LSP items. Requires Neovim&gt;=0.11. Use config.lsp_completion.process_items to set dedicated highlight group in supported fields:\n\n&lt;abbr_hlgroup&gt; - item label (abbr in terms of complete-items). By default only checks if item is marked as deprecated and sets MiniCompletionDeprecated highlight group.\n&lt;kind_hlgroup&gt; - LSP kind (“Function”, “Keyword”, etc.). By default uses “lsp” category of mini.icons (if enabled).\n\n\nWhat it doesn’t do:\n\nMany configurable sources.\nAutomatic mapping of &lt;CR&gt;, &lt;Tab&gt;, etc. Those tend to have highly variable user expectations. See ‘Helpful mappings’ for suggestions or use MiniKeymap.map_multistep() with \"pmenu_*\" built-in steps.\n\n\nDependencies\nSuggested dependencies (provide extra functionality, will work without them):\n\nEnabled mini.icons module to highlight LSP kind (requires Neovim&gt;=0.11). If absent, MiniCompletion.default_process_items() does not add highlighting. Also take a look at MiniIcons.tweak_lsp_kind().\nEnabled mini.snippets module for better snippet handling (much recommended). If absent and custom snippet insert is not configured, vim.snippet.expand() is used on Neovim&gt;=0.10 (nothing extra is done on earlier versions). See MiniCompletion.default_snippet_insert().\n\n\n\nSetup\nThis module needs a setup with require('mini.completion').setup({}) (replace {} with your config table). It will create global Lua table MiniCompletion which you can use for scripting or manually (with :lua MiniCompletion.*).\nSee MiniCompletion.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minicompletion_config which should have same structure as MiniCompletion.config. See mini.nvim-buffer-local-config for more details.\n\n\nSuggested option values\nSome options are set automatically (if not set before MiniCompletion.setup()):\n\n‘completeopt’ is set to “menuone,noselect” for less intrusive popup. To enable fuzzy matching, manually set to “menuone,noselect,fuzzy”. Consider also adding “nosort” flag to preserve initial order when filtering.\n‘shortmess’ is appended with “c” flag for silent &lt;C-n&gt; fallback.\n‘complete’ gets removed “t” flag (if fallback action is default), as it leads to visible lags.\n\n\n\nSnippets\nAs per LSP specification, some completion items can be supplied in the form of snippet - a template with both pre-defined text and places (called “tabstops”) for user to interactively change/add text during snippet session.\nIn ‘mini.completion’ items that will insert snippet have “S” symbol shown in the popup (as part of menu in complete-items). To actually insert a snippet:\n\nSelect an item via &lt;C-n&gt; / &lt;C-p&gt;. This will insert item’s label (usually not full snippet) first to reduce visual flicker. The full snippet text will be shown in info window if LSP server doesn’t provide its own info for an item.\nPress &lt;C-y&gt; (complete_CTRL-Y) or attempt inserting a non-keyword character (like &lt;CR&gt;; new character will be removed). It will clear text from previous step, set cursor, and call lsp_completion.snippet_insert with snippet text.\nPress &lt;C-e&gt; (complete_CTRL-E) to cancel snippet insert and properly end completion.\n\nSee MiniCompletion.default_snippet_insert() for overview of how to work with inserted snippets.\nNotes:\n\nTo stop LSP server from suggesting snippets, disable (set to false) the following capability during LSP server start: textDocument.completion.completionItem.snippetSupport.\nIf snippet body doesn’t contain tabstop, variable, tab, or newline, lsp_completion.snippet_insert is not called and text is inserted as-is.\n\n\n\nNotes\n\nA more appropriate (albeit slightly advanced) LSP completion setup is to set it not on every BufEnter event (default), but on every attach of LSP client. To do that:\n\nUse in MiniCompletion.setup() config:\nlsp_completion = { source_func = 'omnifunc', auto_setup = false }\nSet ‘omnifunc’ option to exactly v:lua.MiniCompletion.completefunc_lsp for every client attach in an LspAttach event. Like this:\nlocal on_attach = function(args)\n  vim.bo[args.buf].omnifunc = 'v:lua.MiniCompletion.completefunc_lsp'\nend\nvim.api.nvim_create_autocmd('LspAttach', { callback = on_attach })\n\nThis setup is not default to allow simultaneous usage of filetype-specific ‘omnifunc’ (with manual i_CTRL-X_CTRL-O) and automated LSP completion.\nUse MiniCompletion.get_lsp_capabilities() to get/set information about part of LSP specification supported by module. See its help for usability notes.\nUses vim.lsp.protocol.CompletionItemKind map in LSP step to show a readable version of item’s kind. Modify it directly to change what is displayed. If you have mini.icons enabled, take a look at MiniIcons.tweak_lsp_kind().\nIf you have trouble using custom (overridden) vim.ui.input(), disable ‘mini.completion’ for input buffer (usually based on its ‘filetype’).\n\n\n\nComparisons\n\nhrsh7th/nvim-cmp:\n\nImplements own popup menu to show completion candidates, while this module reuses ins-completion-menu.\nHas more complex design which allows multiple sources, each in a form of a separate plugin. This module has two built-in: LSP and fallback.\nRequires separate plugin for automated signature help.\nImplements own “ghost text” feature, while this module does not.\n\nSaghen/blink.cmp:\n\nMostly similar to ‘nvim-cmp’ comparison: provides more features at the cost of more code and config complexity, while this module is designed to provide only a handful of “enough” features while relying on Neovim’s built-in capabilities as much as possible.\nBoth provide automated signature help out of the box.\n\n\n\n\nHelpful mappings\nIf there is mini.keymap available, prefer using MiniKeymap.map_multistep() with \"pmenu_*\" built-in steps. See MiniKeymap-examples for examples.\nTo use &lt;Tab&gt; and &lt;S-Tab&gt; for navigation through completion list, make these mappings:\nlocal imap_expr = function(lhs, rhs)\n  vim.keymap.set('i', lhs, rhs, { expr = true })\nend\nimap_expr('&lt;Tab&gt;',   [[pumvisible() ? \"\\&lt;C-n&gt;\" : \"\\&lt;Tab&gt;\"]])\nimap_expr('&lt;S-Tab&gt;', [[pumvisible() ? \"\\&lt;C-p&gt;\" : \"\\&lt;S-Tab&gt;\"]])\nTo get more consistent behavior of &lt;CR&gt;, you can use this template in your ‘init.lua’ to make customized mapping:\n_G.cr_action = function()\n  -- If there is selected item in popup, accept it with &lt;C-y&gt;\n  if vim.fn.complete_info()['selected'] ~= -1 then return '\\25' end\n  -- Fall back to plain `&lt;CR&gt;`. You might want to customize according\n  -- to other plugins. For example if 'mini.pairs' is set up, replace\n  -- next line with `return MiniPairs.cr()`\n  return '\\r'\nend\n\nvim.keymap.set('i', '&lt;CR&gt;', 'v:lua.cr_action()', { expr = true })\n\n\nHighlight groups\n\nMiniCompletionActiveParameter - signature active parameter.\nMiniCompletionDeprecated - candidates that marked as deprecated.\nMiniCompletionInfoBorderOutdated - info window border when text is outdated due to explicit delay during fast movement through candidates.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minicompletion_disable (globally) or vim.b.minicompletion_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nEvents\nTo allow user customization, certain User autocommand events are triggered under common circumstances:\n\nInfo and signature help window:\n\nMiniCompletionWindowOpen - after opening new window.\nMiniCompletionWindowUpdate - after updating existing window.\n\nEach event’s event-data table contains kind (one of “info” or “signature”) and win_id (affected window identifier) fields.\n\n\n\n\nsetup()\n\nMiniCompletion.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniCompletion.config.\n\n\nUsage\nrequire('mini.completion').setup() -- use default config\n-- OR\nrequire('mini.completion').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniCompletion.config\n\n\nDefaults\nMiniCompletion.config = {\n  -- Delay (debounce type, in ms) between certain Neovim event and action.\n  -- This can be used to (virtually) disable certain automatic actions by\n  -- setting very high delay time (like 10^7).\n  delay = { completion = 100, info = 100, signature = 50 },\n\n  -- Configuration for action windows:\n  -- - `height` and `width` are maximum dimensions.\n  -- - `border` defines border (as in `nvim_open_win()`; default \"single\").\n  window = {\n    info = { height = 25, width = 80, border = nil },\n    signature = { height = 25, width = 80, border = nil },\n  },\n\n  -- Way of how module does LSP completion\n  lsp_completion = {\n    -- `source_func` should be one of 'completefunc' or 'omnifunc'.\n    source_func = 'completefunc',\n\n    -- `auto_setup` should be boolean indicating if LSP completion is set up\n    -- on every `BufEnter` event.\n    auto_setup = true,\n\n    -- A function which takes LSP 'textDocument/completion' response items\n    -- (each with `client_id` field for item's server) and word to complete.\n    -- Output should be a table of the same nature as input. Common use case\n    -- is custom filter/sort. Default: `default_process_items`\n    process_items = nil,\n\n    -- A function which takes a snippet as string and inserts it at cursor.\n    -- Default: `default_snippet_insert` which tries to use 'mini.snippets'\n    -- and falls back to `vim.snippet.expand` (on Neovim&gt;=0.10).\n    snippet_insert = nil,\n  },\n\n  -- Fallback action as function/string. Executed in Insert mode.\n  -- To use built-in completion (`:h ins-completion`), set its mapping as\n  -- string. Example: set '&lt;C-x&gt;&lt;C-l&gt;' for 'whole lines' completion.\n  fallback_action = '&lt;C-n&gt;',\n\n  -- Module mappings. Use `''` (empty string) to disable one. Some of them\n  -- might conflict with system mappings.\n  mappings = {\n    -- Force two-step/fallback completions\n    force_twostep = '&lt;C-Space&gt;',\n    force_fallback = '&lt;A-Space&gt;',\n\n    -- Scroll info/signature window down/up. When overriding, check for\n    -- conflicts with built-in keys for popup menu (like `&lt;C-u&gt;`/`&lt;C-o&gt;`\n    -- for 'completefunc'/'omnifunc' source function; or `&lt;C-n&gt;`/`&lt;C-p&gt;`).\n    scroll_down = '&lt;C-f&gt;',\n    scroll_up = '&lt;C-b&gt;',\n  },\n}\n\n\n\n\ncomplete_twostage()\n\nMiniCompletion.complete_twostage({fallback}, {force})\n\nRun two-stage completion\n\nParameters\n{fallback} (boolean|nil) Whether to use fallback completion. Default: true.\n{force} (boolean|nil) Whether to force update of completion popup. Default: true.\n\n\n\n\ncomplete_fallback()\n\nMiniCompletion.complete_fallback()\n\nRun fallback completion\n\n\n\nscroll()\n\nMiniCompletion.scroll({direction})\n\nScroll in info/signature window\nDesigned to be used in :map-&lt;expr&gt;. Scrolling is done as if CTRL-F and CTRL-B is pressed inside target window. Used in default config.mappings.scroll_xxx mappings.\n\nParameters\n{direction} (string) One of \"down\" or \"up\".\n\n\nReturn\n(boolean) Whether scroll is scheduled to be done.\n\n\n\n\nstop()\n\nMiniCompletion.stop({actions})\n\nStop actions\nThis stops currently active (because of module delay or LSP answer delay) actions.\nDesigned to be used with autocmd. No need to use it directly, everything is setup in MiniCompletion.setup().\n\nParameters\n{actions} (table|nil) Array containing any of ‘completion’, ‘info’, or ‘signature’ string. Default: array containing all of them.\n\n\n\n\ncompletefunc_lsp()\n\nMiniCompletion.completefunc_lsp({findstart}, {base})\n\nModule’s complete-functions\nThis is the main function which enables two-stage completion. It should be set as one of ‘completefunc’ or ‘omnifunc’.\nNo need to use it directly, everything is setup in MiniCompletion.setup().\n\n\n\ndefault_process_items()\n\nMiniCompletion.default_process_items({items}, {base}, {opts})\n\nDefault processing of LSP items\nSteps:\n\nFilter and sort items according to supplied method.\nArrange items further by completion item kind according to their priority.\nAdd MiniCompletionDeprecated &lt;abbr_hlgroup&gt; if item is marked as deprecated.\nIf mini.icons is enabled, add &lt;kind_hlgroup&gt; based on the “lsp” category.\n\nExample of forcing fuzzy matching, filtering out Text items, and putting Snippet items last:\nlocal kind_priority = { Text = -1, Snippet = 99 }\nlocal opts = { filtersort = 'fuzzy', kind_priority = kind_priority }\nlocal process_items = function(items, base)\n  return MiniCompletion.default_process_items(items, base, opts)\nend\nrequire('mini.completion').setup({\n  lsp_completion = { process_items = process_items },\n})\n\nParameters\n{items} (table) Array of items from LSP response.\n{base} (string) Base for which completion is done. See complete-functions.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filtersort&gt; (string|function) - method of filtering and sorting items. If string, should be one of the following:\n\n'prefix' - filter out items not starting with base, sort according to LSP specification. Use filterText and sortText respectively with fallback to label.\n'fuzzy' - filter and sort with matchfuzzy() using filterText.\n'none' - no filter and no sort. If callable, should take items and base arguments and return items array. Default: 'fuzzy' if ‘completeopt’ contains “fuzzy”, 'prefix' otherwise.\n\n&lt;kind_priority&gt; (table) - map of completion item kinds (like Variable, Snippet; see string keys of vim.lsp.protocol.CompletionItemKind) to their numerical priority. It will be used after applying &lt;filtersort&gt; to arrange by completion item kind: items with negative priority kinds will be filtered out, the rest are sorted by decreasing priority (preserving order in case of same priority). Priorities can be any number, only matters how they compare to each other. Value 100 is used for missing kinds (i.e. not all can be supplied). Default: {} (all equal priority).\n\n\n\nReturn\n(table) Array of processed items from LSP response.\n\n\n\n\ndefault_snippet_insert()\n\nMiniCompletion.default_snippet_insert({snippet})\n\nDefault snippet insert\nOrder of preference:\n\nUse mini.snippets if set up (i.e. after require('mini.snippets').setup()).\nUse vim.snippet.expand() on Neovim&gt;=0.10\nAdd snippet text at cursor as is.\n\nAfter snippet is inserted, user is expected to navigate/jump between dedicated places (tabstops) to adjust inserted text as needed:\n\nmini.snippets by default uses &lt;C-l&gt; / &lt;C-h&gt; to jump to next/previous tabstop. Can be adjusted in mappings of MiniSnippets.config.\nvim.snippet on Neovim=0.10 requires manually created mappings for jumping between tabstops (see vim.snippet.jump()). Neovim&gt;=0.11 sets them up automatically to &lt;Tab&gt; / &lt;S-Tab&gt; (if not overridden by user).\n\nEnd session by navigating all the way to the last tabstop. In ‘mini.snippets’:\n\nAlso make any text edit or exit Insert mode to end the session. This allows smoother navigation to previous tabstops in case of a lately spotted typo.\nPress &lt;C-c&gt; to force session stop.\n\n\nParameters\n{snippet} (string) Snippet body to insert at cursor.\n\n\nSee also\n\nMiniSnippets-session if ‘mini.snippets’ is set up.\nvim.snippet for Neovim’s built-in snippet engine.\n\n\n\n\n\nget_lsp_capabilities()\n\nMiniCompletion.get_lsp_capabilities({opts})\n\nGet client LSP capabilities\nPossible usages:\n\nOn Neovim&gt;=0.11 via vim.lsp.config():\nvim.lsp.config('*', {capabilities = MiniCompletion.get_lsp_capabilities()})\nTogether with vim.lsp.protocol.make_client_capabilities() to get the full client capabilities (use vim.tbl_deep_extend() to merge tables).\nManually execute :=MiniCompletion.get_lsp_capabilities() to see the info.\n\nNotes:\n\nIt declares completion resolve support for 'additionalTextEdits' (usually used for something like auto-import feature), as it is usually a more robust choice for various LSP servers. As a consequence, this requires selecting completion item and waiting for config.delay.info milliseconds plus server response time (i.e. until information window shows relevant text). To not have to wait after an item selection and if the server handles absent 'additionalTextEdits' well, set opts.resolve_additional_text_edits = false.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;resolve_additional_text_edits&gt; (boolean) - whether to declare\n\n'additionalTextEdits' as possible to resolve in 'completionitem/resolve'\n\nrequrest. See above “Notes” section. Default: true.\n\n\n\nReturn\n(table) Data about LSP capabilities supported by ‘mini.completion’. Has same structure as relevant parts of vim.lsp.protocol.make_client_capabilities().\n\n\nSee also\nStructures of completionClientCapabilities and signatureHelpClientCapabilities at https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification"
  },
  {
    "objectID": "mini.nvim/doc/mini-align.html",
    "href": "mini.nvim/doc/mini-align.html",
    "title": "mini.align documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.align Align text interactively\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nRich and flexible customization of both alignment rules and user interaction. Works with charwise, linewise, and blockwise selections in both Normal mode (on textobject/motion; with dot-repeat) and Visual mode.\nFeatures:\n\nAlignment is done in three main steps:\n\n&lt;Split&gt; lines into parts based on Lua pattern(s) or user-supplied rule.\n&lt;Justify&gt; parts for certain side(s) to be same width inside columns.\n&lt;Merge&gt; parts to be lines, with customizable delimiter(s).\n\nEach main step can be preceded by other steps (pre-steps) to achieve highly customizable outcome. See steps value in MiniAlign.config. For more details, see MiniAlign-glossary and MiniAlign-algorithm.\nUser can control alignment interactively by pressing customizable modifiers (single keys representing how alignment steps and/or options should change). Some of default modifiers:\n\nPress s to enter split Lua pattern.\nPress j to choose justification side from available ones (“left”, “center”, “right”, “none”).\nPress m to enter merge delimiter.\nPress f to enter filter Lua expression to configure which parts will be affected (like “align only first column”).\nPress i to ignore some commonly unwanted split matches.\nPress p to pair neighboring parts so they be aligned together.\nPress t to trim whitespace from parts.\nPress &lt;BS&gt; (backspace) to delete some last pre-step.\n\nFor more details, see MiniAlign-modifiers-builtin and MiniAlign-examples.\nAlignment can be done with instant preview (result is updated after each modifier) or without it (result is shown and accepted after non-default split pattern is set).\nEvery user interaction is accompanied with helper status message showing relevant information about current alignment process.\n\n\nSetup\nThis module needs a setup with require('mini.align').setup({}) (replace {} with your config table). It will create global Lua table MiniAlign which you can use for scripting or manually (with :lua MiniAlign.*).\nSee MiniAlign.config for available config settings.\nYou can override runtime config settings (like config.modifiers) locally to buffer inside vim.b.minialign_config which should have same structure as MiniAlign.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nComparisons\n\njunegunn/vim-easy-align:\n\n‘mini.align’ is mostly designed after ‘junegunn/vim-easy-align’, so there are a lot of similarities.\nBoth plugins allow users to change alignment options interactively by pressing modifier keys (albeit completely different default ones). ‘junegunn/vim-easy-align’ has those modifiers fixed, while ‘mini.align’ allows their full customization. See MiniAlign.config for examples.\n‘junegunn/vim-easy-align’ is designed to treat delimiters differently than other parts of strings. ‘mini.align’ doesn’t distinguish split parts from one another by design: splitting is allowed to be done based on some other logic than by splitting on delimiters.\n‘junegunn/vim-easy-align’ initially aligns by only first delimiter. ‘mini.align’ initially aligns by all delimiter.\n‘junegunn/vim-easy-align’ implements special filtering by delimiter row number. ‘mini.align’ has builtin filtering based on Lua code supplied by user in modifier phase. See MiniAlign.gen_step.filter() and ‘f’ builtin modifier.\n‘mini.align’ treats any non-registered modifier as a plain delimiter pattern, while ‘junegunn/vim-easy-align’ does not.\n‘mini.align’ exports core Lua function used for aligning strings (MiniAlign.align_strings()).\n\ngodlygeek/tabular:\n\n‘godlygeek/tabular’ is mostly designed around single command which is customized by printing its parameters. ‘mini.align’ implements different concept of interactive alignment through pressing customizable single character modifiers.\n‘godlygeek/tabular’ can detect region upon which alignment can be desirable. ‘mini.align’ does not by design: use Visual selection or textobject/motion to explicitly define region to align.\n\n\n\n\nDisabling\nTo disable, set vim.g.minialign_disable (globally) or vim.b.minialign_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nGlossary\n\nPARTS\n2d array of strings (array of arrays of strings). See more in MiniAlign.as_parts().\n\n\nROW\nFirst-level array of parts (like parts[1]).\n\n\nCOLUMN\nArray of strings, constructed from parts elements with the same | second-level index (like { parts[1][1], parts[2][1], | }). |\n\n\nSTEP\nA named callable. See MiniAlign.new_step(). When used in terms of alignment steps, callable takes two arguments: some object (parts or string array) and option table.\n\n\nSPLIT\nProcess of taking array of strings and converting it into parts.\n\n\nJUSTIFY\nProcess of taking parts and converting them to aligned parts (all elements have same widths inside columns).\n\n\nMERGE\nProcess of taking parts and converting it back to array of strings. Usually by concatenating rows into strings.\n\n\nREGION\nTable representing region in a buffer. Fields &lt;from&gt; / &lt;to&gt; have inclusive start / end positions (&lt;to&gt; might be nil to describe empty region). Positions are also tables with &lt;line&gt; and &lt;col&gt; fields (both start at 1).\n\n\nMODE\nEither charwise (“char”, v, charwise), linewise (“line”, V, linewise) or blockwise (“block”, &lt;C-v&gt;, blockwise-visual)\n\n\n\n\nAlgorithm\nThere are two main processes implemented in ‘mini.align’: strings alignment and interactive region alignment. See MiniAlign-glossary for more information about used terms.\n\nStrings alignment\nMain implementation is in MiniAlign.align_strings(). Its input is array of strings and output - array of aligned strings. The process consists from three main steps (split, justify, merge) which can be preceded by any number of preliminary steps (pre-split, pre-justify, pre-merge).\nAlgorithm:\n\n&lt;Pre-split&gt;. Take input array of strings and consecutively apply all pre-split steps (steps.pre_split). Each one has (strings, opts) signature and should modify array in place.\n&lt;Split&gt;. Take array of strings and convert it to parts with steps.split(). It has (strings, opts) signature and should return parts.\n&lt;Pre-justify&gt;. Take parts and consecutively apply all pre-justify steps (steps.pre_justify). Each one has (parts, opts) signature and should modify parts in place.\n&lt;Justify&gt;. Take parts and apply steps.justify(). It has (parts, opts) signature and should modify parts in place.\n&lt;Pre-merge&gt;. Take parts and consecutively apply all pre-merge steps (steps.pre_merge). Each one has (parts, opts) signature and should modify parts in place.\n&lt;Merge&gt;. Take parts and convert it to array of strings with steps.merge(). It has (parts, opts) signature and should return array of strings.\n\nNotes:\n\nAll table objects are initially copied so that modification in place doesn’t affect workflow.\nDefault main steps are designed to be controlled via options. See MiniAlign.align_strings() and default step entries in MiniAlign.gen_step.\nAll steps are guaranteed to take same option table as second argument. This allows steps to “talk” to each other, i.e. earlier steps can pass data to later ones.\n\n\n\nInteractive region alignment\nInteractive alignment is a main entry point for most users. It can be done in two flavors:\n\n&lt;Without-preview&gt;. Initiated via mapping defined in start of MiniAlign.config.mappings. Alignment is accepted once split pattern becomes non-default.\n&lt;With-preview&gt;. Initiated via mapping defined in start_with_preview of MiniAlign.config.mappings. Alignment result is shown after every modifier and is accepted after &lt;CR&gt; (Enter) is hit. Note: each preview is done by applying current alignment steps and options to the initial region lines, not the ones currently displaying in preview.\n\nLifecycle (assuming default mappings):\n\n&lt;Initiate-alignment&gt;:\n\nIn Normal mode type ga (or gA to show preview) followed by textobject or motion defining region to be aligned.\nIn Visual mode select region and type ga (or gA to show preview). Strings contained in selected region will be used as input to MiniAlign.align_strings(). Beware of mode when selecting region: charwise (v), linewise (V), or blockwise (&lt;C-v&gt;). They all behave differently.\n\n&lt;Press-modifiers&gt;. Press single keys one at a time:\n\nIf pressed key is among table keys of modifiers table of MiniAlign.config, its function value is executed. It usually modifies some options(s) and/or affects some pre-step(s).\nIf pressed key is not among defined modifiers, it is treated as plain split pattern. This process can either end by itself (usually in case of no preview and non-default split pattern being set) or you can choose to end it manually.\n\n&lt;Accept-or-discard&gt;. In case of active preview, accept current result by pressing &lt;CR&gt;. Discard any result and return to initial regions with either &lt;Esc&gt; or &lt;C-c&gt;.\n\nSee more in MiniAlign-modifiers-builtin and MiniAlign-examples.\nNotes:\n\nVisual blockwise selection works best with ‘virtualedit’ equal to “block” or “all”.\nAlignment with preview works best with ‘showmode’ disabled.\n\n\n\n\n\nModifiers builtin\nOverview of builtin modifiers\nAll examples assume interactive alignment with preview in linewise mode. With default mappings, use V to select lines and gA to initiate alignment. It might be helpful to copy lines into modifiable buffer and experiment yourself.\nNotes:\n\nAny pressed key which doesn’t have defined modifier will be treated as plain split pattern.\nAll modifiers can be customized inside MiniAlign.setup(). See “Modifiers” section of MiniAlign.config.\n\n\nMain option modifiers\n&lt;s&gt; Enter split pattern (confirm prompt by pressing &lt;CR&gt;). Input is treated as plain delimiter.\nBefore:\na-b-c\naa-bb-cc\nAfter typing s-&lt;CR&gt;:\na -b -c\naa-bb-cc\n&lt;j&gt; Choose justify side. Prompts user (with helper message) to type single character identifier of side: left, center, right, none.\nBefore:\na_b_c\naa_bb_cc\nAfter typing _jr (first make split by _):\n a_ b_ c\naa_bb_cc\n&lt;m&gt; Enter merge delimiter (confirm prompt by pressing &lt;CR&gt;).\nBefore:\na_b_c\naa_bb_cc\nAfter typing _m--&lt;CR&gt; (first make split by _):\na --_--b --_--c\naa--_--bb--_--cc\n\n\nModifiers adding pre-steps\n&lt;f&gt; Enter filter expression. See more details in MiniAlign.gen_step.filter().\nBefore:\na_b_c\naa_bb_cc\nAfter typing _fn==1&lt;CR&gt; (first make split by _):\na _b_c\naa_bb_cc\n&lt;i&gt; Ignore some split matches. It modifies split_exclude_patterns option by adding commonly wanted patterns. See more details in MiniAlign.gen_step.ignore_split().\nBefore:\n/* This_is_assumed_to_be_comment */\na\"_\"_b\naa_bb\nAfter typing _i (first make split by _):\n/* This_is_assumed_to_be_comment */\na\"_\"_b\naa  _bb\n&lt;p&gt; Pair neighboring parts.\nBefore:\na_b_c\naaa_bbb_ccc\nAfter typing _p (first make split by _):\na_  b_  c\naaa_bbb_ccc\n&lt;t&gt; Trim parts from whitespace on both sides (keeping indentation).\nBefore:\na   _   b   _   c\n  aa _bb _cc\nAfter typing _t (first make split by _):\na   _b _c\n  aa_bb_cc\n\n\nDelete some last pre-step\n&lt;BS&gt; Delete one of the pre-steps. If there is only one kind of pre-steps, remove its latest added one. If not, prompt user to choose pre-step kind by entering single character: split, justify, merge.\nExamples:\n\ntp&lt;BS&gt; results in only “trim” step to be left.\nit&lt;BS&gt; prompts to choose which step to delete (pre-split or pre-justify in this case).\n\n\n\nSpecial configurations for common splits\n&lt;=&gt; Use special pattern to align by a group of consecutive “=”. It can be preceded by any number of punctuation marks and followed by some sommon punctuation characters. Trim whitespace and merge with single space.\nBefore:\na=b\naa&lt;=bb\naaa===bbb\naaaa   =   cccc\nAfter typing =:\na    =   b\naa   &lt;=  bb\naaa  === bbb\naaaa =   cccc\n&lt;,&gt; Besides splitting by “,” character, trim whitespace, pair neighboring parts and merge with single space.\nBefore:\na,b\naa,bb\naaa    ,    bbb\nAfter typing ,:\na,   b\naa,  bb\naaa, bbb\n&lt;|&gt; Split by “|” character, trim whitespace, merge with single space.\nBefore:\n|a|b|\n|aa|bb|\n|aaa    |    bbb   |\nAfter typing |:\n| a   | b   |\n| aa  | bb  |\n| aaa | bbb |\n&lt;Space&gt; (Space bar) Squash consecutive whitespace into single space (except possible indentation) and split by %s+ pattern (keeps indentation).\nBefore:\na b c\n  aa    bb   cc\nAfter typing &lt;Space&gt;:\n```\na  b  c\naa bb cc\n```\n\n\n\n\nExamples\nCopy lines in modifiable buffer, initiate alignment with preview (gAip) and try typing suggested key sequences. These are modified examples taken from ‘junegunn/vim-easy-align’.\n\nEqual sign\nLines:\n# This=is=assumed=to be a comment\n\"a =\"\na =\na = 1\nbbbb = 2\nccccccc = 3\nccccccccccccccc\nddd = 4\neeee === eee = eee = eee=f\nfff = ggg += gg &&= gg\ng != hhhhhhhh == 888\ni   := 5\ni     %= 5\ni       *= 5\nj     =~ 5\nj   &gt;= 5\naa      =&gt;         123\naa &lt;&lt;= 123\naa        &gt;&gt;= 123\nbbb               =&gt; 123\nc     =&gt; 1233123\nd   =&gt;      123\ndddddd &&= 123\ndddddd ||= 123\ndddddd /= 123\ngg &lt;=&gt; ee\nKey sequences:\n\n=\n=jc\n=jr\n=m!&lt;CR&gt;\n=p\n=i (execute :lua vim.o.commentstring = '# %s' for full experience)\n=&lt;BS&gt;\n=&lt;BS&gt;p\n=fn==1&lt;CR&gt;\n=&lt;BS&gt;fn==1&lt;CR&gt;t\n=frow&gt;7&lt;CR&gt;\n\n\n\n\n\nsetup()\n\nMiniAlign.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniAlign.config.\n\n\nUsage\nrequire('mini.align').setup() -- use default config\n-- OR\nrequire('mini.align').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniAlign.config\n\n\nDefaults\nMiniAlign.config = {\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    start = 'ga',\n    start_with_preview = 'gA',\n  },\n\n  -- Modifiers changing alignment steps and/or options\n  modifiers = {\n    -- Main option modifiers\n    ['s'] = --&lt;function: enter split pattern&gt;,\n    ['j'] = --&lt;function: choose justify side&gt;,\n    ['m'] = --&lt;function: enter merge delimiter&gt;,\n\n    -- Modifiers adding pre-steps\n    ['f'] = --&lt;function: filter parts by entering Lua expression&gt;,\n    ['i'] = --&lt;function: ignore some split matches&gt;,\n    ['p'] = --&lt;function: pair parts&gt;,\n    ['t'] = --&lt;function: trim parts&gt;,\n\n    -- Delete some last pre-step\n    ['&lt;BS&gt;'] = --&lt;function: delete some last pre-step&gt;,\n\n    -- Special configurations for common splits\n    ['='] = --&lt;function: enhanced setup for '='&gt;,\n    [','] = --&lt;function: enhanced setup for ','&gt;,\n    ['|'] = --&lt;function: enhanced setup for '|'&gt;,\n    [' '] = --&lt;function: enhanced setup for ' '&gt;,\n  },\n\n  -- Default options controlling alignment process\n  options = {\n    split_pattern = '',\n    justify_side = 'left',\n    merge_delimiter = '',\n  },\n\n  -- Default steps performing alignment (if `nil`, default is used)\n  steps = {\n    pre_split = {},\n    split = nil,\n    pre_justify = {},\n    justify = nil,\n    pre_merge = {},\n    merge = nil,\n  },\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}\n\n\nModifiers\nMiniAlign.config.modifiers is used to define interactive user experience of managing alignment process. It is a table with single character keys and modifier function values.\nEach modifier function:\n\nIs called when corresponding modifier key is pressed.\nHas signature (steps, opts) and should modify any of its input in place.\n\nExamples:\n\nModifier function used for default ‘i’ modifier:\nfunction(steps, _)\n  table.insert(steps.pre_split, MiniAlign.gen_step.ignore_split())\nend\nTweak ‘t’ modifier to use highest indentation instead of keeping it:\nrequire('mini.align').setup({\n  modifiers = {\n    t = function(steps, _)\n      local trim_high = MiniAlign.gen_step.trim('both', 'high')\n      table.insert(steps.pre_justify, trim_high)\n    end\n  }\n})\nTweak j modifier to cycle through available “justify_side” option values (like in ‘junegunn/vim-easy-align’):\nrequire('mini.align').setup({\n  modifiers = {\n    j = function(_, opts)\n      local next_option = ({\n        left = 'center', center = 'right', right = 'none', none = 'left',\n      })[opts.justify_side]\n      opts.justify_side = next_option or 'left'\n    end,\n  },\n})\n\n\n\nOptions\nMiniAlign.config.options defines default values of options used to control behavior of steps.\nExamples:\n\nSet justify_side = 'center' to center align at initialization.\n\nFor more details about options see MiniAlign.align_strings() and entries of MiniAlign.gen_step for default main steps.\n\n\nSteps\nMiniAlign.config.steps defines default steps to be applied during alignment process.\nExamples:\n\nAlign by default only first pair of columns:\nlocal align = require('mini.align')\nalign.setup({\n  steps = {\n    pre_justify = { align.gen_step.filter('n == 1') }\n  },\n})\n\n\n\n\n\nalign_strings()\n\nMiniAlign.align_strings({strings}, {opts}, {steps})\n\nAlign strings\nFor details about alignment process see MiniAlign-algorithm.\n\nParameters\n{strings} (table) Array of strings.\n{opts} (table|nil) Options. Its copy will be passed to steps as second argument. Extended with MiniAlign.config.options. This is a place to control default main steps:\n\nopts.split_pattern - Lua pattern(s) used to make split parts.\nopts.split_exclude_patterns - which split matches should be ignored.\nopts.justify_side - which direction(s) alignment should be done.\nopts.justify_offsets - offsets tweaking width of first column\nopts.merge_delimiter - which delimiter(s) to use when merging. For more information see MiniAlign.gen_step entry for corresponding default step.\n\n{steps} (table|nil) Steps. Extended with MiniAlign.config.steps. Possible nil values are replaced with corresponding default steps:\n\nsplit - MiniAlign.gen_step.default_split().\njustify - MiniAlign.gen_step.default_justify().\nmerge - MiniAlign.gen_step.default_merge().\n\n\n\n\n\nalign_user()\n\nMiniAlign.align_user({mode})\n\nAlign current region with user-supplied steps\nMostly designed to be used inside mappings.\nWill use MiniAlign.align_strings() and set the following options in opts:\n\njustify_offsets - array of offsets used to achieve actual alignment of a region. It is non-trivial (not array of zeros) only for charwise selection: offset of first string is computed as width of prefix to the left of region start.\nregion - current affected region (see MiniAlign-glossary). Can be used to create more advanced steps.\nmode - mode of selection (see MiniAlign-glossary).\n\n\nParameters\n{mode} (string) Selection mode. One of “char”, “line”, “block”.\n\n\n\n\nas_parts()\n\nMiniAlign.as_parts({arr2d})\n\nConvert 2d array of strings to parts\nThis function verifies if input is a proper 2d array of strings and adds methods to its copy.\n\nClass\n{parts}\n\n\nFields\n{apply} (function) Takes callable f and applies it to every part. Callable should have signature (s, data): s is a string part, data - table with its data (&lt;row&gt; has row number, &lt;col&gt; has column number). Returns new 2d array.\n{apply_inplace} (function) Takes callable f and applies it to every part. Should have same signature as in apply method. Outputs (should all be strings) are assigned in place to a corresponding parts element. Returns parts itself to enable method chaining.\n{get_dims} (function) Return dimensions of parts array: a table with &lt;row&gt; and &lt;col&gt; keys having number of rows and number of columns (maximum number of elements across all rows).\n{group} (function) Concatenate neighboring strings based on supplied boolean mask and direction (one of “left”, default, or “right”). Has signature (mask, direction) and modifies parts in place. Returns parts itself to enable method chaining. Example:\n\nParts: { { \"a\", \"b\", \"c\" }, { \"d\", \"e\" }, { \"f\" } }\nMask: { { false, false, true }, { true, false }, { false } }\nResult for direction “left”: { { \"abc\" },    { \"d\", \"e\" }, { \"f\" } }\nResult for direction “right”: { { \"ab\",\"c\" }, { \"de\" },     { \"f\" } }\n\n{pair} (function) Concatenate neighboring element pairs. Takes direction as input (one of “left”, default, or “right”) and applies group() for an alternating mask. Example:\n\nParts: { { \"a\", \"b\", \"c\" }, { \"d\", \"e\" }, { \"f\" } }\nResult for direction “left”: { { \"ab\", \"c\" }, { \"de\" }, { \"f\" } }\nResult for direction “right”: { { \"a\", \"bc\" }, { \"de\" }, { \"f\" } }\n\n{slice_col} (function) Return column with input index j. Note: it might not be an array if rows have unequal number of columns.\n{slice_row} (function) Return row with input index i.\n{trim} (function) Trim elements whitespace. Has signature (direction, indent) and modifies parts in place. Returns parts itself to enable method chaining.\n\nPossible values of direction: “both” (default), “left”, “right”, “none”. Defines from which side whitespaces should be removed.\nPossible values of indent: “keep” (default), “low”, “high”, “remove”. Defines what to do with possible indent (left whitespace of first string in a row). Value “keep” keeps it; “low” makes all indent equal to the lowest across rows; “high” - highest across rows; “remove” - removes indent.\n\n\n\nUsage\nparts = MiniAlign.as_parts({ { 'a', 'b' }, { 'c' } })\nprint(vim.inspect(parts.get_dims())) -- Should be { row = 2, col = 2 }\n\nparts.apply_inplace(function(s, data)\n  return ' ' .. data.row .. s .. data.col .. ' '\nend)\nprint(vim.inspect(parts)) -- Should be { { ' 1a1 ', ' 1b2 ' }, { ' 2c1 ' } }\n\nparts.trim('both', 'remove').pair()\nprint(vim.inspect(parts)) -- Should be { { '1a11b2' }, { '2c1' } }\n\n\n\n\nnew_step()\n\nMiniAlign.new_step({name}, {action})\n\nCreate step\nA step is basically a named callable object. Having a name bundled with some action powers helper status message during interactive alignment process.\n\nParameters\n{name} (string) Step name.\n{action} (function|table) Step action. Should be a callable object (see vim.is_callable()).\n\n\nReturn\n(table) A table with keys: &lt;name&gt; with name argument, &lt;action&gt; with action.\n\n\n\n\ngen_step\n\nMiniAlign.gen_step\n\nGenerate common action steps\nThis is a table with function elements. Call to actually get step.\nEach step action is a function that has signature (object, opts), where object is either parts or array of strings (depends on which stage of alignment process it is assumed to be applied) and opts is table of options.\nOutputs of elements named default_* are used as default corresponding main step (split, justify, merge). Behavior of all of them depend on values from supplied options (second argument).\nOutputs of other elements depend on both step generator input values and options supplied at execution. This design is mostly because their output can be used several times in pre-steps.\n\nUsage\nlocal align = require('mini.align')\nalign.setup({\n  modifiers = {\n    -- Use 'T' modifier to remove both whitespace and indent\n    T = function(steps, _)\n      table.insert(steps.pre_justify, align.gen_step.trim('both', 'remove'))\n    end,\n  },\n  options = {\n    -- By default align \"right\", \"left\", \"right\", \"left\", ...\n    justify_side = { 'right', 'left' },\n  },\n  steps = {\n    -- Align by default only first pair of columns\n    pre_justify = { align.gen_step.filter('n == 1') },\n  },\n})\n\n\n\n\ngen_step.default_split()\n\nMiniAlign.gen_step.default_split()\n\nGenerate default split step\nOutput splits strings using matches of Lua pattern(s) from split_pattern option which are not dismissed by split_exclude_patterns option.\nOutline of how single string is split:\n\nConvert split_pattern option to array of strings (string is converted as one-element array). This array will be recycled in case there are more split matches than in converted split_pattern array (which almost always).\nFind all forbidden spans (intervals inside string) - all matches of all patterns in split_exclude_patterns.\nFind match for the next pattern. If it is not inside any forbidden span, add preceding unmatched substring and matched split as two parts. Repeat with the next pattern.\nIf no pattern match is found, add the rest of string as final part.\n\nOutput uses following options (as part second argument, opts table):\n\n&lt;split_pattern&gt; - string or array of strings used to detect split matches and create parts. Default: '' meaning no matches (whole string is used as part). Examples: '%s+', { '&lt;', '&gt;' }.\n&lt;split_exclude_patterns&gt; - array of strings defining which regions to exclude from being matched. Default: {}. Examples: { '\".-\"', '^%s*#.*' }.\n\n\nReturn\n(table) A step named “split” and with appropriate callable action.\n\n\nSee also\nMiniAlign.gen_step.ignore_split() heavily uses split_exclude_patterns.\n\n\n\n\ngen_step.default_justify()\n\nMiniAlign.gen_step.default_justify()\n\nGenerate default justify step\nOutput makes column elements of string parts have equal width by adding left and/or right whitespace padding. Which side(s) to pad is defined by justify_side option. Width of first column can be tweaked with justify_offsets option.\nOutline of how parts are justified:\n\nConvert justify_side option to array of strings (single string is converted as one-element array). Recycle this array to have length equal to number of columns in parts.\nFor all columns compute maximum width of strings from it (add offsets from justify_offsets to first column widths). Note: for left alignment, width of last row element does not affect column width. This is mainly because it won’t be padded and helps dealing with “no single match” lines.\nMake all elements have same width inside column by adding appropriate amount of whitespace. Which side(s) to add is controlled by the corresponding justify_side array element. Note: padding is done with spaces which might conflict with tab indentation.\n\nOutput uses following options (as part second argument, opts table):\n\n&lt;justify_side&gt; - string or array of strings. Each element can be one of “left” (pad right side), “center” (pad both sides equally), “right” (pad left side), “none” (no padding). Default: “left”.\n&lt;justify_offsets&gt; - array of numeric left offsets of rows. Used to adjust for possible not equal indents, like in case of charwise selection when left edge is not on the first column. Default: array of zeros. Set automatically during interactive alignment in charwise mode.\n\n\nReturn\n(table) A step named “justify” and with appropriate callable action.\n\n\n\n\ngen_step.default_merge()\n\nMiniAlign.gen_step.default_merge()\n\nGenerate default merge step\nOutput merges rows of parts into strings by placing merge delimiter(s) between them.\nOutline of how parts are converted to array of strings:\n\nConvert merge_delimiter option to array of strings (single string is converted as one-element array). Recycle this array to have length equal to number of columns in parts minus 1. Also possibly trim leading whitespace in first merge character to not affect indentation.\nExclude empty strings from parts. They add nothing to output except extra usage of merge delimiter.\nConcatenate each row interleaving with array of merge delimiters.\n\nOutput uses following options (as part second argument, opts table):\n\n&lt;merge_delimiter&gt; - string or array of strings. Default: ''. Examples: ' ', { '', ' ' }.\n\n\nReturn\n(table) A step named “merge” and with appropriate callable action.\n\n\n\n\ngen_step.filter()\n\nMiniAlign.gen_step.filter({expr})\n\nGenerate filter step\nConstruct function predicate from supplied Lua string expression and make step evaluating it on every part element.\nOutline of how filtering is done:\n\nConvert Lua filtering expression into function predicate which can be evaluated in manually created context (some specific variables being set).\nCompute boolean mask for parts by applying predicate to each element of 2d array with special variables set to specific values (see next section).\nGroup parts with computed mask. See group() method of parts in MiniAlign.as_parts().\n\nSpecial variables which can be used in expression:\n\n&lt;row&gt; - row number of current element.\n&lt;ROW&gt; - total number of rows in parts.\n&lt;col&gt; - column number of current element.\n&lt;COL&gt; - total number of columns in current row.\n&lt;s&gt; - string value of current element.\n&lt;n&gt; - column pair number of current element. Useful when filtering by result of pattern splitting.\n&lt;N&gt; - total number of column pairs in current row.\nAll variables from global table _G.\n\nTips:\n\nThis general filtering approach can be used to both include and exclude certain parts from alignment. Examples:\n\nUse row ~= 2 to align all parts except from second row.\nUse n == 1 to align only by first pair of columns.\n\nFiltering by last equal sign usually can be done with n &gt;= (N - 1) (because there is usually something to the right of it).\n\n\nParameters\n{expr} (string) Lua expression as a string which will be used as predicate.\n\n\nReturn\n(table|nil) A step named “filter” and with appropriate callable action.\n\n\n\n\ngen_step.ignore_split()\n\nMiniAlign.gen_step.ignore_split({patterns}, {exclude_comment})\n\nGenerate ignore step\nOutput adds certain values to split_exclude_patterns option. Should be used as pre-split step.\n\nParameters\n{patterns} (table) Array of patterns to be added to split_exclude_patterns as is. Default: { [[\".-\"]] } (excludes strings for most cases).\n{exclude_comment} (boolean|nil) Whether to add comment pattern to split_exclude_patterns. Comment pattern is derived from ‘commentstring’ option. Default: true.\n\n\nReturn\n(table) A step named “ignore” and with appropriate callable action.\n\n\nSee also\nMiniAlign.gen_step.default_split() for details about split_exclude_patterns option.\n\n\n\n\ngen_step.pair()\n\nMiniAlign.gen_step.pair({direction})\n\nGenerate pair step\nOutput calls pair() method of parts (see MiniAlign.as_parts()) with supplied direction argument.\n\nParameters\n{direction} (string) Which direction to pair. One of “left” (default) or\n\n\nReturn\n(table) A step named “pair” and with appropriate callable action.\n\n\n\n\ngen_step.trim()\n\nMiniAlign.gen_step.trim({direction}, {indent})\n\nGenerate trim step\nOutput calls trim() method of parts (see MiniAlign.as_parts()) with supplied direction and indent arguments.\n\nParameters\n{direction} (string|nil) Which sides to trim whitespace. One of “both” (default), “left”, “right”, “none”.\n{indent} (string|nil) What to do with possible indent (left whitespace of first string in a row). One of “keep” (default), “low”, “high”, “remove”.\n\n\nReturn\n(table) A step named “trim” and with appropriate callable action."
  },
  {
    "objectID": "mini.nvim/doc/mini-keymap.html",
    "href": "mini.nvim/doc/mini-keymap.html",
    "title": "mini.keymap documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.keymap Special key mappings\nMIT License Copyright (c) 2025 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nMap keys to perform configurable multi-step actions: if condition for step one is true - execute step one action, else check step two, and so on until falling back to executing original keys. This is usually referred to as “smart” keys (like “smart tab”). See MiniKeymap.map_multistep().\nThere are many built-in steps targeted for Insert mode mappings of special keys like &lt;Tab&gt;, &lt;S-Tab&gt;, &lt;CR&gt;, and &lt;BS&gt;:\n\nNavigate and accept popupmenu-completion. Useful for mini.completion.\nNavigate and expand mini.snippets.\nExecute &lt;CR&gt; and &lt;BS&gt; respecting mini.pairs.\nJump before/after current tree-sitter node.\nJump before opening and after closing characters (brackets and quotes).\nIncrease/decrease indent when cursor is inside of it.\nDelete all whitespace to the left (“hungry backspace”).\nNavigate vim.snippet.\nNavigate and accept in hrsh7th/nvim-cmp completion.\nNavigate and accept in Saghen/blink.cmp completion.\nNavigate and expand L3MON4D3/LuaSnip snippets.\nExecute &lt;CR&gt; and &lt;BS&gt; respecting windwp/nvim-autopairs.\n\nMap keys as “combo”: each key acts immediately plus execute extra action if all are typed within configurable delay between each other. See MiniKeymap.map_combo(). Some of the common use cases include:\n\nMap insertable keys (like “jk”, “kj”) in Insert and Command-line mode to exit into Normal mode.\nFight against bad habits of pressing the same navigation key by showing a notification if there are too many of them pressed in a row.\n\n\nSources with more details:\n\nMiniKeymap-examples\n\n\nSetup\nThis module doesn’t need setup, but it can be done to improve usability. Setup with require('mini.keymap').setup({}) (replace {} with your config table). It will create global Lua table MiniKeymap which you can use for scripting or manually (with :lua MiniKeymap.*).\nSee MiniKeymap.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minikeymap_config will have no effect here.\n\n\nComparisons\n\nmax397574/better-escape.nvim:\n\nMostly similar to MiniKeymap.map_combo() with a different approach to creating mappings.\nMostly targeted for Insert mode mappings as pressed keys get removed automatically after typed. This module allows more general cases while requiring explicit removal of keys (usually via explicit &lt;BS&gt;&lt;BS&gt;).\n\nabecodes/tabout.nvim:\n\nSimilar general idea as in 'jump_{after,before}_tsnode' steps of MiniKeymap.map_multistep().\nWorks only with enabled tree-sitter parser. This module provides fallback via ‘jump_after_close’ and ‘jump_before_open’ that work without tree-sitter parser.\n‘tabout.nvim’ has finer control of how the tree-sitter node movement is done, while this module has “jump outside of current node” behavior.\n\n\n\n\nDisabling\nTo disable acting in mappings, set vim.g.minikeymap_disable (globally) or vim.b.minikeymap_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nExamples\n\nMulti-step\nSee MiniKeymap.map_multistep() for a general description of how multi-step mappings work and what built-in steps are available.\nSetup that works well with mini.completion and mini.pairs:\nlocal map_multistep = require('mini.keymap').map_multistep\nmap_multistep('i', '&lt;Tab&gt;',   { 'pmenu_next' })\nmap_multistep('i', '&lt;S-Tab&gt;', { 'pmenu_prev' })\nmap_multistep('i', '&lt;CR&gt;',    { 'pmenu_accept', 'minipairs_cr' })\nmap_multistep('i', '&lt;BS&gt;',    { 'minipairs_bs' })\nUse &lt;Tab&gt; / &lt;S-Tab&gt; to also navigate and expand mini.snippets:\nlocal map_multistep = require('mini.keymap').map_multistep\n\nlocal tab_steps = { 'minisnippets_next','minisnippets_expand','pmenu_next' }\nmap_multistep('i', '&lt;Tab&gt;', tab_steps)\n\nlocal shifttab_steps = { 'minisnippets_prev', 'pmenu_prev' }\nmap_multistep('i', '&lt;S-Tab&gt;', shifttab_steps)\nAn extra smart &lt;Tab&gt; and &lt;S-Tab&gt;:\nlocal map_multistep = require('mini.keymap').map_multistep\n\n-- NOTE: this will never insert tab, press &lt;C-v&gt;&lt;Tab&gt; for that\nlocal tab_steps = {\n  'minisnippets_next', 'minisnippets_expand', 'pmenu_next',\n  'jump_after_tsnode', 'jump_after_close',\n}\nmap_multistep('i', '&lt;Tab&gt;', tab_steps)\n\nlocal shifttab_steps = {\n  'minisnippets_prev',  'pmenu_prev',\n  'jump_before_tsnode', 'jump_before_open',\n}\nmap_multistep('i', '&lt;S-Tab&gt;', shifttab_steps)\nNavigation in active vim.snippet session also requires mapping in Select-mode:\nlocal map_multistep = require('mini.keymap').map_multistep\nmap_multistep({ 'i', 's' }, '&lt;Tab&gt;',   { 'vimsnippet_next', 'pmenu_next' })\nmap_multistep({ 'i', 's' }, '&lt;S-Tab&gt;', { 'vimsnippet_prev', 'pmenu_prev' })\n\n\nCombos\nSee MiniKeymap.map_combo() for a general description of what is a combo and more caveats about its usage.\nAll combos require their left hand side keys to be typed relatively quickly. To adjust the delay between keys, add { delay = 500 } (use custom value) as fourth argument.\n\n“Better escape” to Normal mode\nLeave into Normal-mode without having to reach for &lt;Esc&gt; key:\n-- Support most common modes. This can also contain 't', but would\n-- only mean to press `&lt;Esc&gt;` inside terminal.\nlocal mode = { 'i', 'c', 'x', 's' }\nrequire('mini.keymap').map_combo(mode, 'jk', '&lt;BS&gt;&lt;BS&gt;&lt;Esc&gt;')\n\n-- To not have to worry about the order of keys, also map \"kj\"\nrequire('mini.keymap').map_combo(mode, 'kj', '&lt;BS&gt;&lt;BS&gt;&lt;Esc&gt;')\n\n-- Escape into Normal mode from Terminal mode\nrequire('mini.keymap').map_combo('t', 'jk', '&lt;BS&gt;&lt;BS&gt;&lt;C-\\\\&gt;&lt;C-n&gt;')\nrequire('mini.keymap').map_combo('t', 'kj', '&lt;BS&gt;&lt;BS&gt;&lt;C-\\\\&gt;&lt;C-n&gt;')\n\n\nShow bad navigation habits\nShow notification if there is too much movement by repeating same key:\nlocal notify_many_keys = function(key)\n  local lhs = string.rep(key, 5)\n  local action = function() vim.notify('Too many ' .. key) end\n  require('mini.keymap').map_combo({ 'n', 'x' }, lhs, action)\nend\nnotify_many_keys('h')\nnotify_many_keys('j')\nnotify_many_keys('k')\nnotify_many_keys('l')\n\n\nFix previous spelling mistake\nFix previous spelling mistake (see [s and z=) without manually leaving Insert mode:\nlocal action = '&lt;BS&gt;&lt;BS&gt;&lt;Esc&gt;[s1z=gi&lt;Right&gt;'\nrequire('mini.keymap').map_combo('i', 'kk', action)\n\n\nHide search highlighting\nUse double &lt;Esc&gt;&lt;Esc&gt; to execute :nohlsearch. Although this can also be done with nmap &lt;Esc&gt; &lt;Cmd&gt;nohl&lt;CR&gt;, the combo approach also exists and can be used to free &lt;Esc&gt; mapping in Normal mode for something else.\nlocal action = function() vim.cmd('nohlsearch') end\nrequire('mini.keymap').map_combo({ 'n','i','x','c' }, '&lt;Esc&gt;&lt;Esc&gt;', action)\n\n\nBuffer navigation\nReplace some movements with easier to type alternatives:\nlocal map_combo = require('mini.keymap').map_combo\nmap_combo({ 'n', 'x' }, 'll', 'g$')\nmap_combo({ 'n', 'x' }, 'hh', 'g^')\nmap_combo({ 'n', 'x' }, 'jj', '}')\nmap_combo({ 'n', 'x' }, 'kk', '{')\n\n\n\n\n\nsetup()\n\nMiniKeymap.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniKeymap.config.\n\n\nUsage\nrequire('mini.keymap').setup({}) -- replace {} with your config table\n                                 -- needs `keymap` field present\n\n\n\n\nconfig\n\nMiniKeymap.config\n\n\nDefaults\nMiniKeymap.config = {}\n\n\n\n\nmap_multistep()\n\nMiniKeymap.map_multistep({mode}, {lhs}, {steps}, {opts})\n\nMap multi-step action\nMapping of a multi-step action is an expression mapping (:map-expression). Executing a multi-step action is essentially:\n\nCheck condition for step one. If true - execute step one action and stop.\nCheck condition for step two, and so on.\nIf there is no more steps, fall back to returning mapped key.\n\nFor better user experience there are many built-in steps mostly designed to create Insert mode “smart” mappings of &lt;Tab&gt;, &lt;S-Tab&gt;, &lt;CR&gt;, and &lt;BS&gt;. Available built-in steps (“For key” is a suggestion, any can be used):\n┌─────────────────────┬────────────────┬──────────────────────────┬─────────┐\n│      Step name      │   Condition    │          Action          │ For key │\n├─────────────────────┴────────────────┴──────────────────────────┴─────────┤\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ |ins-completion-menu| ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ pmenu_next          │ Pmenu visible  │ Select next (as &lt;C-n&gt;)   │ &lt;Tab&gt;   │\n│ pmenu_prev          │ Pmenu visible  │ Select prev (as &lt;C-p&gt;)   │ &lt;S-Tab&gt; │\n│ pmenu_accept        │ Item selected  │ Accept (as &lt;C-y&gt;)        │ &lt;CR&gt;    │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ |mini.snippets| ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ minisnippets_next   │ Session active │ Jump to next tabstop     │ &lt;Tab&gt;   │\n│ minisnippets_prev   │ Session active │ Jump to prev tabstop     │ &lt;S-Tab&gt; │\n│ minisnippets_expand │ Can expand     │ Expand snippet at cursor │ &lt;Tab&gt;   │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ |mini.pairs| ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ minipairs_cr        │ Module set up  │ &lt;CR&gt; respecting pairs    │ &lt;CR&gt;    │\n│ minipairs_bs        │ Module set up  │ &lt;BS&gt; respecting pairs    │ &lt;BS&gt;    │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ Jump around in Insert mode ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ jump_after_tsnode   │ TS parser      │ Jump after node end      │ &lt;Tab&gt;   │\n│ jump_before_tsnode  │ TS parser      │ Jump before node start   │ &lt;S-Tab&gt; │\n│ jump_after_close    │ Insert mode    │ Jump after  )]}\"'`       │ &lt;Tab&gt;   │\n│ jump_before_open    │ Insert mode    │ Jump before ([{\"'`       │ &lt;S-Tab&gt; │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ Work with whitespace ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ increase_indent     │ Is on indent   │ Increase indent          │ &lt;Tab&gt;   │\n│ decrease_indent     │ Is on indent   │ Decrease indent          │ &lt;S-Tab&gt; │\n│ hungry_bs           │ Space to left  │ Delete all space to left │ &lt;BS&gt;    │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ |vim.snippet| ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ vimsnippet_next     │ Session active │ Jump to next tabstop     │ &lt;Tab&gt;   │\n│ vimsnippet_prev     │ Session active │ Jump to prev tabstop     │ &lt;S-Tab&gt; │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ 'hrsh7th/nvim-cmp' ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ cmp_next            │ Menu visible   │ Select next item         │ &lt;Tab&gt;   │\n│ cmp_prev            │ Menu visible   │ Select prev item         │ &lt;S-Tab&gt; │\n│ cmp_accept          │ Item selected  │ Accept selected item     │ &lt;CR&gt;    │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ 'Saghen/blink.cmp' ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ blink_next          │ Menu visible   │ Select next item         │ &lt;Tab&gt;   │\n│ blink_prev          │ Menu visible   │ Select prev item         │ &lt;S-Tab&gt; │\n│ blink_accept        │ Item selected  │ Accept selected item     │ &lt;CR&gt;    │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ 'L3MON4D3/LuaSnip' ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ luasnip_next        │ Session active │ Jump to next tabstop     │ &lt;Tab&gt;   │\n│ luasnip_prev        │ Session active │ Jump to prev tabstop     │ &lt;S-Tab&gt; │\n│ luasnip_expand      │ Can expand     │ Expand snippet at cursor │ &lt;Tab&gt;   │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈ 'windwp/nvim-autopairs' ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ nvimautopairs_cr    │ Module present │ &lt;CR&gt; respecting pairs    │ &lt;CR&gt;    │\n│ nvimautopairs_bs    │ Module present │ &lt;BS&gt; respecting pairs    │ &lt;BS&gt;    │\n└─────────────────────┴────────────────┴──────────────────────────┴─────────┘\nNotes:\n\nExecuting action has limitations of :map-expression (like not allowed text or buffer changes, etc.). To execute complex lua code, use vim.schedule() inside action, return the code as string in :map-cmd format, or return a function to be later executed. See usage examples.\nSome mapped keys (like &lt;Tab&gt;, &lt;CR&gt;) might require disabling smart presets in plugins (like ‘nvim-cmp’, ‘blink-cmp’, ‘nvim-autopairs’).\n\n\nParameters\n{mode} (string|table) Same as for vim.keymap.set().\n{lhs} (string) Same as for vim.keymap.set().\n{steps} (table) Array of steps. Each step can be a string with the name of built-in step or a table with two callable methods (will be called without arguments):\n\n&lt;condition&gt; - return true if the action should be executed.\n&lt;action&gt; - action to be executed if &lt;condition&gt; returns true. For more flexibility, it can also return a value which can be:\n\nString - will be returned as expression output. Can be something like \"&lt;Tab&gt;\" (treat as &lt;Tab&gt; key) or \"&lt;Cmd&gt;lua vim.notify('Hello')&lt;CR&gt;\". Should not escape keycodes (i.e. return “&lt;Tab&gt;” and not “). To undo already done escape, use keytrans().\nFunction - will be executed as if \"&lt;Cmd&gt;lua f()&lt;CR&gt;\", but does not need to create a global function for that.\nfalse - do not stop going through steps.\n\n\n{opts} (table|nil) Same as for vim.keymap.set().\n\n\nUsage\nSee MiniKeymap-examples for practical examples.\nSome illustrative examples:\n_G.log = {}\nlocal steps = {}\nsteps[1] = {\n  condition = function() table.insert(_G.log, 'C1'); return _G.cond1 end,\n  -- Compute and return keys. Will be emulated as pressed.\n  action = function() table.insert(_G.log, 'A1'); return 'hello' end,\n}\n\nsteps[2] = {\n  condition = function() table.insert(_G.log, 'C2'); return _G.cond2 end,\n  -- Perform action immediately, return `false` to keep asking other steps\n  action = function() table.insert(_G.log, 'A2'); return false end,\n}\n\nsteps[3] = {\n  condition = function() table.insert(_G.log, 'C3'); return _G.cond3 end,\n  -- Perform action later (to overcom expression mapping limitations)\n  action = function()\n    table.insert(_G.log, 'A3_1')\n    return function() table.insert(_G.log, 'A3_2') end\n  end,\n}\n\n-- Make Insert mode &lt;Tab&gt; mapping\nrequire('mini.keymap').map_multistep('i', '&lt;Tab&gt;', steps)\n\n-- Pressing &lt;Tab&gt; inserts fallback `\\t`; logs C1+C2+C3\n_G.cond1, _G.cond2, _G.cond3 = false, false, false\n\n-- Pressing &lt;Tab&gt; inserts `hello`; logs C1+A1\n_G.cond1, _G.cond2, _G.cond3 = true, false, false\n\n-- Pressing &lt;Tab&gt; inserts nothing; logs C1+C2+A2+C3+A3_1+A3_2\n_G.cond1, _G.cond2, _G.cond3 = false, true, true\n\n\n\n\ngen_step\n\nMiniKeymap.gen_step\n\nGenerate step for multi-step mappings\nThis is a table with function elements. Call to actually get a step.\n\n\n\ngen_step.search_pattern()\n\nMiniKeymap.gen_step.search_pattern({pattern}, {flags}, {opts})\n\nSearch pattern step\nUse search() to jump to pattern match. Possibly adjust final position to be just to the right of the match (useful in Insert mode).\n\nParameters\n{pattern} (string) Same as for search().\n{flags} (string|nil) Same as for search().\n{opts} (table|nil) Options. Possible fields:\n\n&lt;side&gt; (string) - one of \"before\" (default) or \"after\".\n&lt;stopline&gt; (number|function) - forwarded to search() (as number or as function’s output after calling it before every search).\n&lt;timeout&gt; (number) - forwarded to search().\n&lt;skip&gt; (string|function) - forwarded to search().\n\n\n\nReturn\n(table) Step which searches pattern.\n\n\nUsage\nBuilt-in MiniKeymap.map_multistep() steps “jump_after_close” and “jump_before_open” use this, but only in Insert mode.\nSteps that jump before/after all consecutive brackets in several modes:\nlocal keymap = require('mini.keymap')\nlocal tab_step_insert = keymap.gen_step.search_pattern(\n  -- Need to use 'c' flag and 'after' side for robust \"chaining\"\n  [=[[)\\]}]\\+]=], 'ceW', { side = 'after' }\n)\nkeymap.map_multistep('i', '&lt;Tab&gt;', { tab_step_insert })\nlocal tab_step = keymap.gen_step.search_pattern([=[[)\\]}]\\+]=], 'eW')\nkeymap.map_multistep({ 'n', 'x' }, '&lt;Tab&gt;', { tab_step })\n\nlocal stab_step = keymap.gen_step.search_pattern([=[[(\\[{]\\+]=], 'bW')\nkeymap.map_multistep({ 'i', 'n', 'x' }, '&lt;S-Tab&gt;', { stab_step })\n\n\n\n\nmap_combo()\n\nMiniKeymap.map_combo({mode}, {lhs}, {action}, {opts})\n\nMap combo post action\nCreate a combo: sequence of keys where each acts immediately plus execute an extra action if all are typed within configurable delay between each other.\nExample for Insert mode “better escape” jk combo with &lt;BS&gt;&lt;BS&gt;&lt;Esc&gt; action:\n\nPress j. It is visible immediately without any side effects.\nQuickly (no more than default 200 ms after) press k. This triggers the action which is equivalent to typing &lt;BS&gt;&lt;BS&gt; (delete already present jk) and &lt;Esc&gt; to exit into Normal mode.\n\nNotes:\n\nIMPORTANT! Combo is not a regular mapping but a separate key tracking with vim.on_key(). This is important as combos will not be visible and can not be managed as regular mappings. Instead each combo is associated with a dedicated namespace (named for human readability). However, it is not really expected to manage them on the fly after they are created.\nString action is executed with nvim_input(), i.e. emulated keys will respect custom mappings.\nDifferent combos are tracked and act independent of each other. For example, if there are combos for jjk and jk keys, fast typing jjk will execute both.\nNeovim&gt;=0.11 is recommended due to vim.on_key() improvement to allow watching for keys as they are typed and not as if coming from mappings. For example, this matters when creating a jk combo for Visual mode while also having xnoremap j gj style of remaps. On Neovim&lt;0.11 the fix is to use gjgk as combo’s left hand side.\nEach combo adds very small but non-zero overhead on each keystroke. Usually about 1-3 microseconds (i.e. 0.001-0.003 ms), which should be fast enough for most setups. For a “normal, real world” coding session with a total of ~20000 keystrokes it results in extra ~40ms of overhead for a single created combo. Create many combos with caution.\n\n\nParameters\n{mode} (string|table) String or array of string mode id (like “n”, “i”, etc.). Array of several modes is more performant than several single mode combos.\n{lhs} (string|table) String with tracked key sequence or an array of tracked keys (one element - one key).\n{action} (string|function) Action to perform after key sequence is detected. If string, treated as keys and emulated with nvim_input(). If function, executed in vim.schedule(). Can return string keys which will be emulated.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;delay&gt; (number) - delay in milliseconds within which keys should be pressed to detect a key sequence. Default: 200.\n\n\n\nUsage\nSee MiniKeymap-examples for practical examples.\nSome illustrative examples:\nlocal map_combo = require('mini.keymap').map_combo\n\n-- In Insert mode pressing `x` followed by `x` within 1 second logs 'A'\n-- and emulates extra pressing of `yy`\n_G.log = {}\nlocal action = function() table.insert(_G.log, 'A'); return 'yy' end\nmap_combo('i', 'xx', action, { delay = 1000 })"
  },
  {
    "objectID": "mini.nvim/doc/mini-move.html",
    "href": "mini.nvim/doc/mini-move.html",
    "title": "mini.move documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.move Move any selection in any direction\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nWorks in two modes:\n\nVisual mode. Select text (charwise with v, linewise with V, and blockwise with CTRL-V) and press customizable mapping to move in all four directions (left, right, down, up). It keeps Visual mode.\nNormal mode. Press customizable mapping to move current line in all four directions (left, right, down, up).\nSpecial handling of linewise movement:\n\nVertical movement gets reindented with =.\nHorizontal movement is improved indent/dedent with &gt; / &lt;.\nCursor moves along with selection.\n\n\nProvides both mappings and Lua functions for motions. See MiniMove.move_selection() and MiniMove.move_line().\nRespects v:count. Movement mappings can be preceded by a number which multiplies command effect.\nAll consecutive moves (regardless of direction) can be undone by a single u.\nRespects preferred column for vertical movement. It will vertically move selection as how cursor is moving (not strictly vertically if target column is not present in target line).\n\nNotes:\n\nDoesn’t allow moving selection outside of current lines (by design).\n\n\nSetup\nThis module needs a setup with require('mini.move').setup({}) (replace {} with your config table). It will create global Lua table MiniMove which you can use for scripting or manually (with :lua MiniMove.*).\nSee MiniMove.config for available config settings.\nYou can override runtime config settings (but not config.mappings) locally to buffer inside vim.b.minimove_config which should have same structure as MiniMove.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nmatze/vim-move:\n\nDoesn’t support vertical movement of charwise and blockwise selections. While ‘mini.move’ does.\nDoesn’t support horizontal movement of current line in favor of horizontal movement of current character. While ‘mini.move’ supports horizontal movement of current line and doesn’t support such movement of current character.\nHas extra functionality for certain moves (like move by half page). While ‘mini.move’ does not (by design).\n\nbooperlv/nvim-gomove:\n\nDoesn’t support movement in charwise visual selection. While ‘mini.move’ does.\nHas extra functionality beyond moving text, like duplication. While ‘mini.move’ concentrates only on moving functionality.\n\n\n\n\nDisabling\nTo disable, set vim.g.minimove_disable (globally) or vim.b.minimove_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniMove.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniMove.config.\n\n\nUsage\nrequire('mini.move').setup() -- use default config\n-- OR\nrequire('mini.move').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniMove.config\n\n\nDefaults\nMiniMove.config = {\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Move visual selection in Visual mode. Defaults are Alt (Meta) + hjkl.\n    left = '&lt;M-h&gt;',\n    right = '&lt;M-l&gt;',\n    down = '&lt;M-j&gt;',\n    up = '&lt;M-k&gt;',\n\n    -- Move current line in Normal mode\n    line_left = '&lt;M-h&gt;',\n    line_right = '&lt;M-l&gt;',\n    line_down = '&lt;M-j&gt;',\n    line_up = '&lt;M-k&gt;',\n  },\n\n  -- Options which control moving behavior\n  options = {\n    -- Automatically reindent selection during linewise vertical move\n    reindent_linewise = true,\n  },\n}\n\n\nMappings\nOther possible choices of mappings:\n-- `HJKL` for moving visual selection (overrides H, L, J in Visual mode)\nrequire('mini.move').setup({\n  mappings = {\n    left  = 'H',\n    right = 'L',\n    down  = 'J',\n    up    = 'K',\n  }\n})\n\n-- Shift + arrows\nrequire('mini.move').setup({\n  mappings = {\n    left  = '&lt;S-left&gt;',\n    right = '&lt;S-right&gt;',\n    down  = '&lt;S-down&gt;',\n    up    = '&lt;S-up&gt;',\n\n    line_left  = '&lt;S-left&gt;',\n    line_right = '&lt;S-right&gt;',\n    line_down  = '&lt;S-down&gt;',\n    line_up    = '&lt;S-up&gt;',\n  }\n})\n\n\n\n\nmove_selection()\n\nMiniMove.move_selection({direction}, {opts})\n\nMove visually selected region in any direction within present lines\nMain function powering visual selection move in Visual mode.\nNotes:\n\nVertical movement in linewise mode is followed up by reindent with v_=.\nHorizontal movement in linewise mode is same as v_&lt; and v_&gt;.\n\n\nParameters\n{direction} (string) One of “left”, “down”, “up”, “right”.\n{opts} (table|nil) Options. Same structure as options in MiniMove.config (with its values as defaults) plus these allowed extra fields:\n\n&lt;n_times&gt; (number) - number of times to try to make a move. Default: v:count1.\n\n\n\n\n\nmove_line()\n\nMiniMove.move_line({direction}, {opts})\n\nMove current line in any direction\nMain function powering current line move in Normal mode.\nNotes:\n\nVertical movement is followed up by reindent with v_=.\nHorizontal movement is almost the same as &lt;&lt; and &gt;&gt; with a different handling of v:count (multiplies shift effect instead of modifying that number of lines).\n\n\nParameters\n{direction} (string) One of “left”, “down”, “up”, “right”.\n{opts} (table|nil) Options. Same structure as options in MiniMove.config (with its values as defaults) plus these allowed extra fields:\n\n&lt;n_times&gt; (number) - number of times to try to make a move. Default: v:count1."
  },
  {
    "objectID": "mini.nvim/doc/mini-bufremove.html",
    "href": "mini.nvim/doc/mini-bufremove.html",
    "title": "mini.bufremove documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.bufremove Remove buffers\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nUnshow, delete, and wipeout buffer while saving window layout (opposite to builtin Neovim’s commands).\n\n\nSetup\nThis module doesn’t need setup, but it can be done to improve usability. Setup with require('mini.bufremove').setup({}) (replace {} with your config table). It will create global Lua table MiniBufremove which you can use for scripting or manually (with :lua MiniBufremove.*).\nSee MiniBufremove.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minibufremove_config will have no effect here.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nNotes\n\nWhich buffer to show in window(s) after its current buffer is removed is decided by the algorithm:\n\nIf alternate buffer (see CTRL-^) is listed (see buflisted()), use it.\nIf previous listed buffer (see :bprevious) is different, use it.\nOtherwise create a new one with nvim_create_buf(true, false) and use it.\n\n\n\n\nDisabling\nTo disable core functionality, set vim.g.minibufremove_disable (globally) or vim.b.minibufremove_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniBufremove.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniBufremove.config.\n\n\nUsage\nrequire('mini.bufremove').setup() -- use default config\n-- OR\nrequire('mini.bufremove').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniBufremove.config\n\n\nDefaults\nMiniBufremove.config = {\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}\n\n\n\n\ndelete()\n\nMiniBufremove.delete({buf_id}, {force})\n\nDelete buffer buf_id with :bdelete after unshowing it\n\nParameters\n{buf_id} (number|nil) Buffer identifier (see bufnr()) to use. Default: 0 for current.\n{force} (boolean|nil) Whether to ignore unsaved changes (using ! version of command). If false, calling with unsaved changes will prompt confirm dialog. Default: false.\n\n\nReturn\n(boolean|nil) Whether operation was successful. If nil, no operation was done.\n\n\n\n\nwipeout()\n\nMiniBufremove.wipeout({buf_id}, {force})\n\nWipeout buffer buf_id with :bwipeout after unshowing it\n\nParameters\n{buf_id} (number|nil) Buffer identifier (see bufnr()) to use. Default: 0 for current.\n{force} (boolean|nil) Whether to ignore unsaved changes (using ! version of command). If false, calling with unsaved changes will prompt confirm dialog. Default: false.\n\n\nReturn\n(boolean|nil) Whether operation was successful. If nil, no operation was done.\n\n\n\n\nunshow()\n\nMiniBufremove.unshow({buf_id})\n\nStop showing buffer buf_id in all windows\n\nParameters\n{buf_id} (number|nil) Buffer identifier (see bufnr()) to use. Default: 0 for current.\n\n\nReturn\n(boolean|nil) Whether operation was successful. If nil, no operation was done.\n\n\n\n\nunshow_in_window()\n\nMiniBufremove.unshow_in_window({win_id})\n\nStop showing current buffer of window win_id\nNotes:\n\nIf win_id represents cmdline-window, this function will close it.\n\n\nParameters\n{win_id} (number|nil) Window identifier (see win_getid()) to use. Default: 0 for current.\n\n\nReturn\n(boolean|nil) Whether operation was successful. If nil, no operation was done."
  },
  {
    "objectID": "mini.nvim/doc/mini-tabline.html",
    "href": "mini.nvim/doc/mini-tabline.html",
    "title": "mini.tabline documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.tabline Tabline\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nKey idea: show all listed buffers in readable way with minimal total width.\nFeatures:\n\nBuffers are listed in the order of their identifier (see bufnr()).\nDifferent highlight groups for “states” of buffer affecting ‘buffer tabs’.\nBuffer names are made unique by extending paths to files or appending unique identifier to buffers without name.\nCurrent buffer is displayed “optimally centered” (in center of screen while maximizing the total number of buffers shown) when there are many buffers open.\n‘Buffer tabs’ are clickable if Neovim allows it.\nExtra information section in case of multiple Neovim tabpages.\nTruncation symbols which show if there are tabs to the left and/or right. Exact characters are taken from ‘listchars’ global value (precedes and extends fields) and are shown only if ‘list’ option is enabled.\n\nWhat it doesn’t do:\n\nCustom buffer order is not supported.\n\n\nDependencies\nSuggested dependencies (provide extra functionality, will work without them):\n\nEnabled mini.icons module to show icons near file names. Falls back to nvim-tree/nvim-web-devicons or shows nothing.\n\n\n\nSetup\nThis module needs a setup with require('mini.tabline').setup({}) (replace {} with your config table). It will create global Lua table MiniTabline which you can use for scripting or manually (with :lua MiniTabline.*).\nSee MiniTabline.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minitabline_config which should have same structure as MiniTabline.config. See mini.nvim-buffer-local-config for more details.\n\n\nSuggested option values\nSome options are set automatically by MiniTabline.setup():\n\n‘showtabline’ is set to 2 to always show tabline.\n\n\n\nHighlight groups\n\nMiniTablineCurrent - buffer is current (has cursor in it).\nMiniTablineVisible - buffer is visible (displayed in some window).\nMiniTablineHidden - buffer is hidden (not displayed).\nMiniTablineModifiedCurrent - buffer is modified and current.\nMiniTablineModifiedVisible - buffer is modified and visible.\nMiniTablineModifiedHidden - buffer is modified and hidden.\nMiniTablineFill - unused right space of tabline.\nMiniTablineTabpagesection - section with tabpage information.\nMiniTablineTrunc - truncation symbols indicating more left/right tabs.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable (show empty tabline), set vim.g.minitabline_disable (globally) or vim.b.minitabline_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniTabline.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniTabline.config.\n\n\nUsage\nrequire('mini.tabline').setup() -- use default config\n-- OR\nrequire('mini.tabline').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniTabline.config\n\n\nDefaults\nMiniTabline.config = {\n  -- Whether to show file icons (requires 'mini.icons')\n  show_icons = true,\n\n  -- Function which formats the tab label\n  -- By default surrounds with space and possibly prepends with icon\n  format = nil,\n\n  -- Where to show tabpage section in case of multiple vim tabpages.\n  -- One of 'left', 'right', 'none'.\n  tabpage_section = 'left',\n}\n\n\nFormat\nconfig.format is a callable that takes buffer identifier and pre-computed label as arguments and returns a string with formatted label. Output will be treated strictly as text (i.e. no ‘statusline’ like constructs is allowed). This function will be called for all displayable in tabline buffers. Default: MiniTabline.default_format().\nExample of adding “+” suffix for modified buffers:\nfunction(buf_id, label)\n  local suffix = vim.bo[buf_id].modified and '+ ' or ''\n  return MiniTabline.default_format(buf_id, label) .. suffix\nend\n\n\n\n\nmake_tabline_string()\n\nMiniTabline.make_tabline_string()\n\nMake string for ‘tabline’\n\n\n\ndefault_format()\n\nMiniTabline.default_format({buf_id}, {label})\n\nDefault tab format\nUsed by default as config.format. Prepends label with padded icon based on buffer’s name (if show_icon in MiniTabline.config is true) and surrounds label with single space. Note: it is meant to be used only as part of format in MiniTabline.config.\n\nParameters\n{buf_id} (number) Buffer identifier.\n{label} (string) Pre-computed label.\n\n\nReturn\n(string) Formatted label."
  },
  {
    "objectID": "mini.nvim/doc/mini-git.html",
    "href": "mini.nvim/doc/mini-git.html",
    "title": "mini.git documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.git Git integration\nMIT License Copyright (c) 2024 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nAutomated tracking of Git related data: root path, status, HEAD, etc. Exposes buffer-local variables for convenient use in statusline. See MiniGit.enable() and MiniGit.get_buf_data() for more information.\n:Git command for executing any git call inside file’s repository root with deeper current instance integration (show output as notification/buffer, use to edit commit messages, etc.).\nHelper functions to inspect Git history:\n\nMiniGit.show_range_history() shows how certain line range evolved.\nMiniGit.show_diff_source() shows file state as it was at diff entry.\nMiniGit.show_at_cursor() shows Git related data depending on context.\n\n\nWhat it doesn’t do:\n\nReplace fully featured Git client. Rule of thumb: if feature does not rely on a state of current Neovim (opened buffers, etc.), it is out of scope. For more functionality, use either mini.diff or fully featured Git client.\n\nSources with more details:\n\n:Git\nMiniGit-examples\nMiniGit.enable()\nMiniGit.get_buf_data()\n\n\nSetup\nThis module needs a setup with require('mini.git').setup({}) (replace {} with your config table). It will create global Lua table MiniGit which you can use for scripting or manually (with :lua MiniGit.*).\nSee MiniGit.config for config structure and default values.\n\n\nComparisons\n\ntpope/vim-fugitive:\n\nMostly a dedicated Git client, while this module is not (by design).\nProvides buffer-local Git data only through fixed statusline component, while this module has richer data in the form of a Lua table.\nBoth provide :Git command with ‘vim-fugitive’ treating some cases extra specially (like :Git blame, etc.), while this module mostly treats all cases the same. See MiniGit-examples for how they can be manually customized. Also this module provides slightly different (usually richer) completion suggestions.\n\nNeogitOrg/neogit:\n\nSimilar to ‘tpope/vim-fugitive’, but without :Git command.\n\nlewis6991/gitsigns.nvim:\n\nProvides buffer-local Git data with emphasis on granular diff status, while this module is more oriented towards repository and file level data (root, HEAD, file status, etc.). Use mini.diff for diff tracking.\n\n\n\n\nDisabling\nTo prevent buffer(s) from being tracked, set vim.g.minigit_disable (globally) or vim.b.minigit_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nExamples\n\nStatusline component\nTracked buffer data can be used in statusline via vim.b.minigit_summary_string buffer-local variable. It is expected to be used as is. To show another info, tweak buffer-local variable directly inside MiniGitUpdated User event:\n-- Use only HEAD name as summary string\nlocal format_summary = function(data)\n  -- Utilize buffer-local table summary\n  local summary = vim.b[data.buf].minigit_summary\n  vim.b[data.buf].minigit_summary_string = summary.head_name or ''\nend\n\nlocal au_opts = { pattern = 'MiniGitUpdated', callback = format_summary }\nvim.api.nvim_create_autocmd('User', au_opts)\n\n\nTweaking command output\nBuffer output of :Git command can be tweaked inside autocommand for MiniGitCommandSplit User event (see MiniGit-command-events). For example, to make :vertical Git blame -- % align blame output with the current window state, use the following code:\nlocal align_blame = function(au_data)\n  if au_data.data.git_subcommand ~= 'blame' then return end\n\n  -- Align blame output with source\n  local win_src = au_data.data.win_source\n  vim.wo.wrap = false\n  vim.fn.winrestview({ topline = vim.fn.line('w0', win_src) })\n  vim.api.nvim_win_set_cursor(0, { vim.fn.line('.', win_src), 0 })\n\n  -- Bind both windows so that they scroll together\n  vim.wo[win_src].scrollbind, vim.wo.scrollbind = true, true\nend\n\nlocal au_opts = { pattern = 'MiniGitCommandSplit', callback = align_blame }\nvim.api.nvim_create_autocmd('User', au_opts)\n\n\nHistory navigation\nFunction MiniGit.show_at_cursor() is specifically exported to make Git history navigation easier. Here are some different ways it can be used:\n\nCall inside buffer for already committed file to show the evolution of the current line (or visually selected range) through history. It is essentially a :Git log HEAD with proper -L flag. This also works inside output of MiniGit.show_diff_source().\nCall with cursor on commit hash to inspect that commit in full. This is usually helpful in the output of :Git log.\nCall with cursor inside diff entry to inspect its file in the state how it was at certain commit. By default it shows state after commit, unless cursor is on the “deleted” line (i.e. line starting with “-”) in which case state before commit is shown.\n\nThis workflow can be made more interactive when used with mapping, like this:\nlocal rhs = '&lt;Cmd&gt;lua MiniGit.show_at_cursor()&lt;CR&gt;'\nvim.keymap.set({ 'n', 'x' }, '&lt;Leader&gt;gs', rhs, { desc = 'Show at cursor' })\n\n\n\n\n:Git\nThe :Git user command runs git CLI call with extra integration for currently opened Neovim process:\n\nCommand is executed inside repository root of the currently active file (or current-directory if file is not tracked by this module).\nCommand output is shown either in dedicated buffer in window split or as notification via vim.notify(). Which method is used depends on whether particular Git subcommand is supposed to show data for user to inspect (like log, status, etc.) or not (like commit, push, etc.). This is determined automatically based on the data Git itself provides. Split window is made current after command execution.\nUse split-related :command-modifiers (:vertical, :horizontal, or :tab) to force output in a particular type of split. Default split direction is controlled by command.split in MiniGit.config.\nUse :silent command modifier to not show any output.\nErrors and warnings are always shown as notifications.\nSee MiniGit-examples for the example of tweaking command output.\nEditor for tasks that require interactive user input (like :Git commit or :Git rebase --interactive) is opened inside current session in a separate split. Make modifications as in regular buffer, :write changes followed by :close / :quit for Git CLI command to resume.\n\nExamples of usage:\n\n:Git log --oneline - show compact log of current repository.\n:vert Git blame -- % - show latest commits per line in vertical split.\n:Git help rebase - show help page for rebase subcommand.\n:Git -C &lt;cwd&gt; status - execute git status inside current-directory.\n\nThere is also a context aware completion which can be invoked with &lt;Tab&gt;:\n\nIf completed word starts with “-”, options for the current Git subcommand are shown. Like completion at :Git log - will suggest -L, --oneline, etc.\nIf there is an explicit ” – ” to the cursor’s left, incremental path suggestions will be shown.\nIf there is no recognized Git subcommand yet, show list of subcommands. Otherwise for some common subcommands list of its targets will be suggested: like for :Git branch it will be list of branches, etc.\n\nNotes:\n\nPaths are always treated as relative to command’s execution directory (file’s repository root or current-directory if absent).\nDon’t use quotes for entries containing space, escape it with \\ directly. Like :Git commit -m Hello\\ world and not :Git commit -m 'Hello world' (which treats 'Hello and world' as separate arguments).\n\n\nEvents\nMiniGit-command-events\nThere are several User events triggered during command execution:\n\nMiniGitCommandDone - after command is done executing. For Lua callbacks it provides a special data table with the following fields:\n\n&lt;cmd_input&gt; (table) - structured data about executed command. Has same structure as Lua function input in nvim_create_user_command().\n&lt;cwd&gt; (string) - directory path inside which Git command was executed.\n&lt;exit_code&gt; (number) - exit code of CLI process.\n&lt;git_command&gt; (table) - array with arguments of full executed command.\n&lt;git_subcommand&gt; (string) - detected Git subcommand (like “log”, etc.).\n&lt;stderr&gt; (string) - stderr process output.\n&lt;stdout&gt; (string) - stdout process output.\n\nMiniGitCommandSplit - after command showed its output in a split. Triggered after MiniGitCommandDone and provides similar data table with extra fields:\n\n&lt;win_source&gt; (number) - window identifier of “source” window (current at the moment before command execution).\n&lt;win_stdout&gt; (number) - window identifier of command output.\n\n\n\n\n\n\nsetup()\n\nMiniGit.setup({config})\n\nModule setup\nBesides general side effects (see mini.nvim), it also:\n\nSets up auto enabling in every normal buffer for an actual file on disk.\nCreates :Git command.\n\n\nParameters\n{config} (table|nil) Module config table. See MiniGit.config.\n\n\nUsage\nrequire('mini.git').setup() -- use default config\n-- OR\nrequire('mini.git').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniGit.config\n\n\nDefaults\nMiniGit.config = {\n  -- General CLI execution\n  job = {\n    -- Path to Git executable\n    git_executable = 'git',\n\n    -- Timeout (in ms) for each job before force quit\n    timeout = 30000,\n  },\n\n  -- Options for `:Git` command\n  command = {\n    -- Default split direction\n    split = 'auto',\n  },\n}\n\n\nJob\nconfig.job contains options for customizing CLI executions.\njob.git_executable defines a full path to Git executable. Default: “git”.\njob.timeout is a duration (in ms) from job start until it is forced to stop. Default: 30000.\n\n\nCommand\nconfig.command contains options for customizing :Git command.\ncommand.split defines default split direction for :Git command output. Can be one of “horizontal”, “vertical”, “tab”, or “auto”. Value “auto” uses :vertical if only ‘mini.git’ buffers are shown in the tabpage and :tab otherwise. Default: “auto”.\n\n\n\n\nshow_at_cursor()\n\nMiniGit.show_at_cursor({opts})\n\nShow Git related data at cursor\n\nIf inside mini.deps confirmation buffer, show in split relevant commit data.\nIf there is a commit-like &lt;cword&gt;, show it in split.\nIf possible, show diff source via MiniGit.show_diff_source().\nIf possible, show range history via MiniGit.show_range_history().\nOtherwise throw an error.\n\n\nParameters\n{opts} (table|nil) Options. Possible values:\n\n&lt;split&gt; (string) - split direction. One of “horizontal”, “vertical”, “tab”, or “auto” (default). Value “auto” uses :vertical if only ‘mini.git’ buffers are shown in the tabpage and :tab otherwise.\nFields appropriate for forwarding to other functions.\n\n\n\n\n\nshow_diff_source()\n\nMiniGit.show_diff_source({opts})\n\nShow diff source\nWhen buffer contains text formatted as unified patch (like after :Git log --patch, :Git diff, or MiniGit.show_range_history()), show state of the file at the particular state. Target commit/state, path, and line number are deduced from cursor position.\nNotes:\n\nNeeds current-directory to be the Git root for relative paths to work.\nNeeds cursor to be inside hunk lines or on “—” / “+++” lines with paths.\nOnly basic forms of :Git diff output is supported: :Git diff, :Git diff --cached, and :Git diff &lt;commit&gt;.\n\n\nParameters\n{opts} (table|nil) Options. Possible values:\n\n&lt;split&gt; (string) - split direction. One of “horizontal”, “vertical”, “tab”, or “auto” (default). Value “auto” uses :vertical if only ‘mini.git’ buffers are shown in the tabpage and :tab otherwise.\n&lt;target&gt; (string) - which file state to show. One of “before”, “after”, “both” (both states in vertical split), “auto” (default). Value “auto” shows “before” state if cursor line starts with “-”, otherwise - “after”.\n\n\n\n\n\nshow_range_history()\n\nMiniGit.show_range_history({opts})\n\nShow range history\nCompute and show in split data about how particular line range in current buffer evolved through Git history. Essentially a git log with -L flag.\nNotes:\n\nWorks well with MiniGit.diff_foldexpr().\nDoes not work if there are uncommited changes, as there is no easy way to compute effective range line numbers.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;line_start&gt; (number) - range start line.\n&lt;line_end&gt; (number) - range end line. If both &lt;line_start&gt; and &lt;line_end&gt; are not supplied, they default to current line in Normal mode and visual selection in Visual mode.\n&lt;log_args&gt; (table) - array of options to append to git log call.\n&lt;split&gt; (string) - split direction. One of “horizontal”, “vertical”, “tab”, or “auto” (default). Value “auto” uses :vertical if only ‘mini.git’ buffers are shown in the tabpage and :tab otherwise.\n\n\n\n\n\ndiff_foldexpr()\n\nMiniGit.diff_foldexpr({lnum})\n\nFold expression for Git logs\nFolds contents of hunks, file patches, and log entries in unified diff. Useful for filetypes “diff” (like after :Git diff) and “git” (like after :Git log --patch or :Git show for commit). Works well with MiniGit.show_range_history().\nGeneral idea of folding levels (use zr and zm to adjust interactively):\n\nAt level 0 there is one line per whole patch or log entry.\nAt level 1 there is one line per patched file.\nAt level 2 there is one line per hunk.\nAt level 3 there is no folds.\n\nFor automated setup, set the following for “git” and “diff” filetypes (either inside FileType autocommand or ftplugin):\nsetlocal foldmethod=expr foldexpr=v:lua.MiniGit.diff_foldexpr()\n\nParameters\n{lnum} (number|nil) Line number for which fold level is computed. Default: v:lnum.\n\n\nReturn\n(number|string) Line fold level. See fold-expr.\n\n\n\n\nenable()\n\nMiniGit.enable({buf_id})\n\nEnable Git tracking in a file buffer\nTracking is done by reacting to changes in file content or file’s repository in the form of keeping buffer data up to date. The data can be used via:\n\nMiniGit.get_buf_data(). See its help for a list of actually tracked data.\nvim.b.minigit_summary (table) and vim.b.minigit_summary_string (string) buffer-local variables which are more suitable for statusline. vim.b.minigit_summary_string contains information about HEAD, file status, and in progress action (see MiniGit.get_buf_data() for more details). See MiniGit-examples for how it can be tweaked and used in statusline.\n\nNote: this function is called automatically for all new normal buffers. Use it explicitly if buffer was disabled.\nUser event MiniGitUpdated is triggered whenever tracking data is updated. Note that not all data listed in MiniGit.get_buf_data() can be present (yet) at the point of event being triggered.\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\ndisable()\n\nMiniGit.disable({buf_id})\n\nDisable Git tracking in buffer\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\ntoggle()\n\nMiniGit.toggle({buf_id})\n\nToggle Git tracking in buffer\nEnable if disabled, disable if enabled.\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\nget_buf_data()\n\nMiniGit.get_buf_data({buf_id})\n\nGet buffer data\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\nReturn\n(table|nil) Table with buffer Git data or nil if buffer is not enabled. If the file is not part of Git repo, table will be empty. Table has the following fields:\n\n&lt;repo&gt; (string) - full path to ‘.git’ directory.\n&lt;root&gt; (string) - full path to worktree root.\n&lt;head&gt; (string) - full commit of current HEAD.\n&lt;head_name&gt; (string) - short name of current HEAD (like “master”). For detached HEAD it is “HEAD”.\n&lt;status&gt; (string) - two character file status as returned by git status.\n&lt;in_progress&gt; (string) - name of action(s) currently in progress (bisect, merge, etc.). Can be a combination of those separated by “,”."
  },
  {
    "objectID": "mini.nvim/doc/mini-misc.html",
    "href": "mini.nvim/doc/mini-misc.html",
    "title": "mini.misc documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.misc Miscellaneous functions\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures the following functions:\n\nMiniMisc.bench_time() to benchmark function execution time. Useful in combination with stat_summary().\nMiniMisc.log_add(), MiniMisc.log_show() and other helper functions to work with a special in-memory log array. Useful when debugging Lua code.\nMiniMisc.put() and MiniMisc.put_text() to pretty print its arguments into command line and current buffer respectively.\nMiniMisc.resize_window() to resize current window to its editable width.\nMiniMisc.setup_auto_root() to set up automated change of current directory.\nMiniMisc.setup_termbg_sync() to set up terminal background synchronization (removes possible “frame” around current Neovim instance).\nMiniMisc.setup_restore_cursor() to set up automated restoration of cursor position on file reopen.\nMiniMisc.stat_summary() to compute summary statistics of numerical array. Useful in combination with bench_time().\nMiniMisc.tbl_head() and MiniMisc.tbl_tail() to return “first” and “last” elements of table.\nMiniMisc.zoom() to zoom in and out of a buffer, making it full screen in a floating window.\nAnd more.\n\n\nSetup\nThis module doesn’t need setup, but it can be done to improve usability. Setup with require('mini.misc').setup({}) (replace {} with your config table). It will create global Lua table MiniMisc which you can use for scripting or manually (with :lua MiniMisc.*).\nSee MiniMisc.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minimisc_config will have no effect here.\n\n\n\n\nsetup()\n\nMiniMisc.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniMisc.config.\n\n\nUsage\nrequire('mini.misc').setup() -- use default config\n-- OR\nrequire('mini.misc').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniMisc.config\n\n\nDefaults\nMiniMisc.config = {\n  -- Array of fields to make global (to be used as independent variables)\n  make_global = { 'put', 'put_text' },\n}\n\n\n\n\nbench_time()\n\nMiniMisc.bench_time({f}, {n}, {…})\n\nExecute f several times and time how long it took\n\nParameters\n{f} (function) Function which execution to benchmark.\n{n} (number|nil) Number of times to execute f(...). Default: 1.\n{…} (any) Arguments when calling f.\n\n\nReturn\n(...) Table with durations (in seconds; up to nanoseconds) and output of (last) function execution.\n\n\n\n\nget_gutter_width()\n\nMiniMisc.get_gutter_width({win_id})\n\nCompute width of gutter (info column on the left of the window)\n\nParameters\n{win_id} (number|nil) Window identifier (see win_getid()) for which gutter width is computed. Default: 0 for current.\n\n\n\n\nlog_add()\n\nMiniMisc.log_add({desc}, {state}, {opts})\n\nAdd an entry to the in-memory log array\nUseful when trying to debug a Lua code (like Neovim config or plugin). Use this instead of ad-hoc print() statements.\nEach entry is a table with the following fields:\n\n&lt;desc&gt; (any) - entry description. Usually a string describing a place in the code.\n&lt;state&gt; (any) - data about current state. Usually a table.\n&lt;timestamp&gt; (number) - a timestamp of when the entry was added. A number of milliseconds since the in-memory log was initiated (after MiniMisc.setup() or MiniMisc.log_clear()). Useful during profiling.\n\n\nParameters\n{desc} (any) Entry description.\n{state} (any) Data about current state.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;deepcopy&gt; - (boolean) Whether to apply vim.deepcopy to the {state}. Usually helpful to record the exact state during code execution and avoid side effects of tables being changed in-place. Default true.\n\n\n\nUsage\nlocal t = { a = 1 }\nMiniMisc.log_add('before', { t = t }) -- Will show `t = { a = 1 }` state\nt.a = t.a + 1\nMiniMisc.log_add('after', { t = t })  -- Will show `t = { a = 2 }` state\n\n-- Use `:lua MiniMisc.log_show()` or `:=MiniMisc.log_get()` to see the log\n\n\nSee also\n\nMiniMisc.log_get() to get log array\nMiniMisc.log_show() to show log array in the dedicated buffer\nMiniMisc.log_clear() to clear the log array\n\n\n\n\n\nlog_get()\n\nMiniMisc.log_get()\n\nGet log array\n\nReturn\n(table[]) Log array. Returned as is, without vim.deepcopy().\n\n\nSee also\n\nMiniMisc.log_add() to add to the log array\n\n\n\n\n\nlog_show()\n\nMiniMisc.log_show()\n\nShow log array in a scratch buffer\n\nSee also\n\nMiniMisc.log_add() to add to the log array\n\n\n\n\n\nlog_clear()\n\nMiniMisc.log_clear()\n\nClear log array\nThis also sets a new starting point for entry timestamps.\n\nSee also\n\nMiniMisc.log_add() to add to the log array\n\n\n\n\n\nput()\n\nMiniMisc.put({…})\n\nPrint Lua objects in command line\n\nParameters\n{…} (any) Any number of objects to be printed each on separate line.\n\n\n\n\nput_text()\n\nMiniMisc.put_text({…})\n\nPrint Lua objects in current buffer\n\nParameters\n{…} (any) Any number of objects to be printed each on separate line.\n\n\n\n\nresize_window()\n\nMiniMisc.resize_window({win_id}, {text_width})\n\nResize window to have exact number of editable columns\n\nParameters\n{win_id} (number|nil) Window identifier (see win_getid()) to be resized. Default: 0 for current.\n{text_width} (number|nil) Number of editable columns resized window will display. Default: first element of ‘colorcolumn’ or otherwise ‘textwidth’ (using screen width as its default but not more than 79).\n\n\n\n\nsetup_auto_root()\n\nMiniMisc.setup_auto_root({names}, {fallback})\n\nSet up automated change of current directory\nWhat it does:\n\nCreates autocommand which on every BufEnter event with MiniMisc.find_root() finds root directory for current buffer file and sets current-directory to it (using chdir()).\nResets ‘autochdir’ to false.\n\n\nParameters\n{names} (table|function|nil) Forwarded to MiniMisc.find_root().\n{fallback} (function|nil) Forwarded to MiniMisc.find_root().\n\n\nUsage\nrequire('mini.misc').setup()\nMiniMisc.setup_auto_root()\n\n\n\n\nfind_root()\n\nMiniMisc.find_root({buf_id}, {names}, {fallback})\n\nFind root directory\nBased on a buffer name (full path to file opened in a buffer) find a root directory. If buffer is not associated with file, returns nil.\nRoot directory is a directory containing at least one of pre-defined files. It is searched using vim.fs.find() with upward = true starting from directory of current buffer file until first occurrence of root file(s).\nNotes:\n\nUses directory path caching to speed up computations. This means that no changes in root directory will be detected after directory path was already used in this function. Reload Neovim to account for that.\n\n\nParameters\n{buf_id} (number|nil) Buffer identifier (see bufnr()) to use. Default: 0 for current.\n{names} (table|function|nil) Array of file names or a callable used to identify a root directory. Forwarded to vim.fs.find(). Default: { '.git', 'Makefile' }.\n{fallback} (function|nil) Callable fallback to use if no root is found with vim.fs.find(). Will be called with a buffer path and should return a valid directory path.\n\n\n\n\nsetup_termbg_sync()\n\nMiniMisc.setup_termbg_sync()\n\nSet up terminal background synchronization\nWhat it does:\n\nChecks if terminal emulator supports OSC 11 control sequence through appropriate stdout. Stops if not.\nCreates autocommands for ColorScheme and VimResume events, which change terminal background to have same color as guibg of hl-Normal.\nCreates autocommands for VimLeavePre and VimSuspend events which set terminal background back to the color at the time this function was called first time in current session.\nSynchronizes background immediately to allow not depend on loading order.\n\nPrimary use case is to remove possible “frame” around current Neovim instance which appears if Neovim’s hl-Normal background color differs from what is used by terminal emulator itself.\nWorks only on Neovim&gt;=0.10.\n\n\n\nsetup_restore_cursor()\n\nMiniMisc.setup_restore_cursor({opts})\n\nRestore cursor position on file open\nWhen reopening a file this will make sure the cursor is placed back to the position where you left before. This implements restore-cursor in a nicer way. File should have a recognized file type (see ‘filetype’) and be opened in a normal buffer (see ‘buftype’).\nNote: it relies on file mark data stored in ‘shadafile’ (see shada-f). Be sure to enable it.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;center&gt; - (boolean) Center the window after we restored the cursor. Default: true.\n&lt;ignore_filetype&gt; - Array with file types to be ignored (see ‘filetype’). Default: { \"gitcommit\", \"gitrebase\" }.\n\n\n\nUsage\nrequire('mini.misc').setup_restore_cursor()\n\n\n\n\nstat_summary()\n\nMiniMisc.stat_summary({t})\n\nCompute summary statistics of numerical array\nThis might be useful to compute summary of time benchmarking with MiniMisc.bench_time().\n\nParameters\n{t} (table) Array (table suitable for ipairs) of numbers.\n\n\nReturn\n(table) Table with summary values under following keys (may be extended in the future): &lt;maximum&gt;, &lt;mean&gt;, &lt;median&gt;, &lt;minimum&gt;, &lt;n&gt; (number of elements), &lt;sd&gt; (sample standard deviation).\n\n\n\n\ntbl_head()\n\nMiniMisc.tbl_head({t}, {n})\n\nReturn “first” elements of table as decided by pairs\nNote: order of elements might vary.\n\nParameters\n{t} (table) Input table.\n{n} (number|nil) Maximum number of first elements. Default: 5.\n\n\nReturn\n(table) Table with at most n first elements of t (with same keys).\n\n\n\n\ntbl_tail()\n\nMiniMisc.tbl_tail({t}, {n})\n\nReturn “last” elements of table as decided by pairs\nThis function makes two passes through elements of t:\n\nFirst to count number of elements.\nSecond to construct result.\n\nNote: order of elements might vary.\n\nParameters\n{t} (table) Input table.\n{n} (number|nil) Maximum number of last elements. Default: 5.\n\n\nReturn\n(table) Table with at most n last elements of t (with same keys).\n\n\n\n\nuse_nested_comments()\n\nMiniMisc.use_nested_comments({buf_id})\n\nAdd possibility of nested comment leader\nThis works by parsing ‘commentstring’ buffer option, extracting non-whitespace comment leader (symbols on the left of commented line), and locally modifying ‘comments’ option (by prepending n:&lt;leader&gt;). Does nothing if ‘commentstring’ is empty or has comment symbols both in front and back (like “/%s/”).\nNested comment leader added with this function is useful for formatting nested comments. For example, have in Lua “first-level” comments with ‘–’ and “second-level” comments with ‘—-’. With nested comment leader second type can be formatted with gq in the same way as first one.\nRecommended usage is with autocmd:\nlocal use_nested_comments = function() MiniMisc.use_nested_comments() end\nvim.api.nvim_create_autocmd('BufEnter', { callback = use_nested_comments })\nNote: for most filetypes ‘commentstring’ option is added only when buffer with this filetype is entered, so using non-current buf_id can not lead to desired effect.\n\nParameters\n{buf_id} (number|nil) Buffer identifier (see bufnr()) in which function will operate. Default: 0 for current.\n\n\n\n\nzoom()\n\nMiniMisc.zoom({buf_id}, {config})\n\nZoom in and out of a buffer, making it full screen in a floating window\nThis function is useful when working with multiple windows but temporarily needing to zoom into one to see more of the code from that buffer. Call it again (without arguments) to zoom out.\n\nParameters\n{buf_id} (number|nil) Buffer identifier (see bufnr()) to be zoomed. Default: 0 for current.\n{config} (table|nil) Optional config for window (as for nvim_open_win()).\n\n\nReturn\n(boolean) Whether current buffer is zoomed in."
  },
  {
    "objectID": "mini.nvim/doc/mini-map.html",
    "href": "mini.nvim/doc/mini-map.html",
    "title": "mini.map documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.map Window with buffer text overview\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nShow and manage special floating window displaying automatically updated overview of current buffer text. Window takes up whole height of Neovim instance and is fixed to a left/right side. Map content is computed by taking all current lines, converting it to binary whitespace/non-whitespace mask, rescaling to appropriate dimensions, and converting back to strings consisting from special encoding symbols. All this is done very fast and asynchronously. See MiniMap.open(), MiniMap.refresh(), MiniMap.close(), MiniMap.toggle(), MiniMap.toggle_side(). For a general overview and tips, see mini.map-usage.\nShow scrollbar next to map content. It represents current line and view (top and bottom visible lines). Can be the only thing shown, making map window a “pure scrollbar”. See “Pure scrollbar config” section in MiniMap.config.\nHighlight map lines representing certain data in current buffer. This is done via extensible set of callables, called integrations (see “Integrations” section in MiniMap.config). There are pre-built generators for common integrations:\n\nBuiltin search (as result of / and similar).\nBuiltin diagnostic (taken from vim.diagnostic.get()).\nGeneral diff hunks provided by mini.diff.\nHunks computed provided by ‘lewis6991/gitsigns.nvim’. For more details see MiniMap.gen_integration.\n\nFocus on map window to quickly browse current (source) buffer. Moving inside map window updates cursor position in source window enabling fast and targeted buffer exploration. To focus back, hit &lt;CR&gt; to accept current explored position or &lt;Esc&gt; to go back to original position. See MiniMap.toggle_focus().\nCustomizable via MiniMap.config and/or opts argument of MiniMap.open() or MiniMap.refresh():\n\nEncoding symbols used to display binary information of different resolution (default is 3x2). There are pre-built generators for different basic character families and resolutions. See MiniMap.gen_encode_symbols.\nScrollbar symbols, separate for line and view. Can have any width (even zero, which virtually disables scrollbar).\nIntegrations producing map line highlights.\nWindow options: side (left/right), width, ‘winblend’, and more.\n\n\nWhat it doesn’t do:\n\nAutomatically refresh when typing in Insert mode. Although it can be done in non-blocking way, it still might introduce considerable computation overhead (especially in very large files).\nHas more flexible window configuration. In case a full height floating window obstructs vision of underlying buffers, use MiniMap.toggle() or MiniMap.toggle_side(). Works best with global statusline.\nProvide autoopen functionality. Due to vast differences in user preference of when map window should be shown, set up of automatic opening is left to user. A common approach would be to call MiniMap.open() on VimEnter event. If you use mini.starter, you can modify &lt;CR&gt; buffer mapping:\nlocal set_map_keymap = function()\n  local rhs = function()\n    MiniStarter.eval_current_item()\n    MiniMap.open()\n  end\n  vim.keymap.set('n', '&lt;CR&gt;', rhs, { buffer = true })\nend\nlocal opts = { pattern = 'MiniStarterOpened', callback = set_map_keymap }\nvim.api.nvim_create_autocmd('User', opts)\n\n\nSetup\nThis module needs a setup with require('mini.map').setup({}) (replace {} with your config table). It will create global Lua table MiniMap which you can use for scripting or manually (with :lua MiniMap.*).\nSee MiniMap.config for available config settings.\nYou can override runtime config settings (like config.modifiers) locally to buffer inside vim.b.minimap_config which should have same structure as MiniMap.config. See mini.nvim-buffer-local-config for more details.\n\n\nDependencies\nSuggested dependencies (provide extra functionality for integrations):\n\nEnabled mini.diff module for general diff highlighting via MiniMap.gen_integration.diff(). If missing, no highlighting is added.\nPlugin lewis6991/gitsigns.nvim for Git status highlighting via MiniMap.gen_integration.gitsigns(). If missing, no highlighting is added.\n\n\n\nComparisons\n\nwfxr/minimap.vim:\n\n‘mini.map’ doesn’t have dependencies while being as fast as written in Rust dependency of ‘minimap.vim’.\n‘mini.map’ uses floating window, while ‘minimap.vim’ uses regular one.\n‘mini.map’ provides slightly different visual interface with scrollbar and integration counts.\n‘mini.map’ allows encode symbols customization, ‘minimap.vim’ does not.\n‘mini.map’ allows extending highlight integrations, while only builtin search and git status are supported in ‘minimap.vim’.\n‘mini.map’ updates in asynchronous (non-blocking) fashion, ‘minimap.vim’ does not.\n‘mini.map’ can be used as a pure scrollbar, ‘minimap.vim’ can not.\n\ndstein64/nvim-scrollview:\n\n‘mini.map’ has two-part scrollbar showing current line and view (with variable height), while ‘nvim-scrollview’ shows only current view (with fixed height).\n‘nvim-scrollview’ respects folds, i.e. shows view of visible lines, while ‘mini.map’ by design always shows view based on actual lines.\n‘nvim-scrollview’ creates scrollbar which can be dragged with mouse, while ‘mini.nvim’ does not, by design (use MiniMap.toggle_focus()).\n‘mini.map’ can show buffer outline, while ‘nvim-scrollview’ can not.\n‘mini.map’ can show highlight integrations, while ‘nvim-scrollview’ can not.\n\npetertriho/nvim-scrollbar:\n\n‘mini.map’ has two-part scrollbar showing current line and view (with variable height), while ‘nvim-scrollbar’ shows only current view.\n‘mini.map’ can show buffer outline, while ‘nvim-scrollbar’ can not.\n‘mini.map’ has fully extendable highlight integrations, while ‘nvim-scrollbar’ only supports diagnostic and search (with dependency).\n\nlewis6991/satellite.nvim:\n\nAlmost the same differences as with ‘dstein64/nvim-scrollview’, except ‘satellite.nvim’ can display some set of integration highlights.\n\n\n\n\nHighlight groups\n\nMiniMapNormal - basic highlight of whole window.\nMiniMapSymbolCount - counts of per-line integration items.\nMiniMapSymbolLine - scrollbar part representing current line.\nMiniMapSymbolView - scrollbar part representing current view.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minimap_disable (globally) or vim.b.minimap_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nUsage\n\nMappings\nThis module doesn’t make mappings, only provides functions for users to map manually. Here is how one &lt;Leader&gt; set of mappings can be constructed:\nvim.keymap.set('n', '&lt;Leader&gt;mc', MiniMap.close)\nvim.keymap.set('n', '&lt;Leader&gt;mf', MiniMap.toggle_focus)\nvim.keymap.set('n', '&lt;Leader&gt;mo', MiniMap.open)\nvim.keymap.set('n', '&lt;Leader&gt;mr', MiniMap.refresh)\nvim.keymap.set('n', '&lt;Leader&gt;ms', MiniMap.toggle_side)\nvim.keymap.set('n', '&lt;Leader&gt;mt', MiniMap.toggle)\n\n\nHow automatic refresh works\nAutomatic refresh is done by calling MiniMap.refresh() when appropriate events occur. It is done with specially chosen parts argument value (to avoid unnecessary computations). For example, when only cursor has moved (CursorMoved), only scrollbar is updated; so no recomputation of integrations or line encoding is done.\nTo avoid visual clutter, automatic refresh is done only in normal buffers and help pages (i.e. with ‘buftype’ being empty or “help”)\nWhen you think content is not up to date, try one of these:\n\nCall MiniMap.refresh() manually. Make mapping to make it easier.\nSave current buffer, for example with :write.\nExit and enter Normal mode (if your Neovim version supports ModeChanged).\n\n\n\n\n\nsetup()\n\nMiniMap.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniMap.config.\n\n\nUsage\nrequire('mini.map').setup() -- use default config\n-- OR\nrequire('mini.map').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniMap.config\n\n\nDefaults\nMiniMap.config = {\n  -- Highlight integrations (none by default)\n  integrations = nil,\n\n  -- Symbols used to display data\n  symbols = {\n    -- Encode symbols. See `:h MiniMap.config` for specification and\n    -- `:h MiniMap.gen_encode_symbols` for pre-built ones.\n    -- Default: solid blocks with 3x2 resolution.\n    encode = nil,\n\n    -- Scrollbar parts for view and line. Use empty string to disable any.\n    scroll_line = '█',\n    scroll_view = '┃',\n  },\n\n  -- Window options\n  window = {\n    -- Whether window is focusable in normal way (with `wincmd` or mouse)\n    focusable = false,\n\n    -- Side to stick ('left' or 'right')\n    side = 'right',\n\n    -- Whether to show count of multiple integration highlights\n    show_integration_count = true,\n\n    -- Total width\n    width = 10,\n\n    -- Value of 'winblend' option\n    winblend = 25,\n\n    -- Z-index\n    zindex = 10,\n  },\n}\n\n\nSymbols\nOptions in config.symbols define characters used to display various information in map window.\n\nEncode symbols\nThe config.symbols.encode option defines which characters are used to encode source buffer lines. For details of encode algorithm, see MiniMap.encode_strings().\nThis option should be a table with the following structure:\n\n&lt;resolution&gt; field - table containing &lt;row&gt; and &lt;col&gt; elements with row and column resolution of each symbol. This defines encoding structure and number of needed encode symbols.\nNumerical fields 1, 2, …, 2^(row_resolution * col_resolution). Each symbol represents a (row_resolution, col_resolution) boolean mask (true for non-whitespace, false for whitespace), created as (reversed) binary digit: true as 1; false as 0. Traversing left-right, top-bottom (top-left is lowest bit, bottom-right - highest). So first symbol encodes a complete whitespace, last - complete non-whitespace.\n\nIf nil (default), output of MiniMap.gen_encode_symbols.block() with '3x2' identifier is used.\nExample: { ‘1’, ‘2’, ‘3’, ‘4’, resolution = { row = 1, col = 2 } }. This will encode two characters in each input row. So a string '  a  aaa' will be encoded as '1234'.\nThere are pre-built generators of encode symbols:\n\nMiniMap.gen_encode_symbols.block()\nMiniMap.gen_encode_symbols.dot()\nMiniMap.gen_encode_symbols.shade()\n\n\n\nScrollbar symbols\nOptions config.symbols.scroll_line and config.symbols.scroll_view define strings used to represent current line and current view inside map window. Can have any length, map window content will adjust.\nIf supplied window width is small enough so that only (part of) of scrollbar can be shown, it is called a “pure scrollbar”. The behavior differs slightly from normal map window. See “Pure scrollbar config” later section.\nSome suggestions for scrollbar symbols:\n\nView-line pairs: ‘▒’ and ‘█’.\nLine - ‘🮚’, ‘▶’.\nView - ‘╎’, ‘┋’, ‘┋’.\n\n\n\n\nIntegrations\nOption config.integrations is an array of integrations. Each one is used to define map line highlights representing some important lines in source buffer. If nil (default), no integrations are used.\nEach integration should be a callable returning an array with data about source buffer lines it wants to highlight. Each array element should be a table with &lt;line&gt; (source buffer line number) and &lt;hl_group&gt; (string with highlight group name) keys. Note: line number outside of source buffer count will be converted to a nearest appropriate one.\nExample output of single integration:\n{\n  { line = 1, hl_group = 'Search' },\n  { line = 2, hl_group = 'Operator' },\n  { line = 9, hl_group = 'Search'}\n}\nConversion to map highlights is done on a “first seen” basis: actual highlight group applied to a map line is taken from the first integration output convertible to that map line. Other outputs with same map line (after conversion) contribute to integration count shown between scrollbar and encoded lines (if config.window.show_integration_count is true).\nPrevious example output with default '3x2' resolution will add hl-Search highlight on map lines 1 and 3, and show integration count 2 on first line.\nEvery element of integrations array is called one by one from start to end with their outputs appended to end of single array. This means that more important integrations should be placed in the beginning of an array, as this will make them have higher priority in case other integrations will highlight same map line.\nExample of using config.integrations:\nlocal map = require('mini.map')\nmap.setup({\n  integrations = {\n    map.gen_integration.builtin_search(),\n    map.gen_integration.diff(),\n    map.gen_integration.diagnostic(),\n  },\n})\n\n\nWindow config\nOption config.window defines some properties of map window.\nwindow.focusable - whether to allow focusing on map window with other methods beside MiniMap.toggle_focus() (like :wincmd, CTRL-W, or mouse). Default: false.\nwindow.side - which side to stick map window: 'left' or 'right' (default).\nwindow.show_integration_count - whether to show integration count between scrollbar and encoded lines. Integration count is a number of integration outputs which were converted to same map line. When true, adds single cell column with numbers from 2 to 9 and character ‘+’ indicating count greater than 9. Count 1 is not shown, because it is redundant to highlighted map line. Default: true.\nwindow.width - width of floating window, including scrollbar and integration count column. Default: 10.\nwindow.winblend - value of ‘winblend’ of floating window. Value 0 makes it completely non-transparent, 100 - completely transparent (content is still visible, but with slightly different highlights).\nwindow.zindex - z-index of floating window. Default: 10.\n\n\nPure scrollbar config\n“Pure scrollbar” is a configuration when window width is not enough to show encoded content. It has following differences from default “map” approach:\n\nIt doesn’t perform line encoding with MiniMap.encode_strings() but instead uses encoding with fixed number of lines (equal to window height).\nIntegration highlights are not computed.\n\nConfig:\nrequire('mini.map').setup({\n  -- Customize `symbols` to your liking\n\n  window = {\n    -- Set this to the maximum width of your scroll symbols\n    width = 1,\n\n    -- Set this to your liking. Try values 0, 25, 50, 75, 100\n    winblend = 100,\n\n    -- Don't need extra column\n    show_integration_count = false,\n  }\n})\n\n\n\n\ncurrent\n\nMiniMap.current\n\nTable with information about current state of map\nAt least these keys are supported:\n\n&lt;buf_data&gt; - table with buffer identifiers. Field &lt;map&gt; contains identifier of a buffer used to display map. Field &lt;source&gt; - buffer identifier which content map is displaying (i.e. source buffer).\n&lt;win_data&gt; - table of window identifiers used to display map in certain tabpage. Keys: tabpage identifier. Values: window identifier.\n&lt;opts&gt; - current options used to control map display. Same structure as MiniMap.config. Takes precedence over global and buffer-local configs. Is reset when last map window is closed with MiniMap.close().\n\n\n\n\nencode_strings()\n\nMiniMap.encode_strings({strings}, {opts})\n\nEncode strings\nThis takes arbitrary array of strings and computes its non-whitespace outline. Output is an array of strings with configurable array length, string width, and symbols representing encoding.\nEach encode symbol is assumed to have resolution within which it can convey binary information. For example, resolution 3x2 (row resolution 3, column - 2) means that each symbol can encode 3 rows and 2 columns of binary data. Here it is used to encode non-whitespace mask. See more in “Encode symbols” section of MiniMap.config.\nEncoding has the following steps:\n\nConvert strings to boolean mask: 2d boolean array with each row representing a string. Element in every row subarray is true if respective (possibly multibyte) character in a string is not a whitespace, false otherwise. Note: tabs are expanded into ‘tabstop’ spaces.\nRescale to appropriate dimensions:\n\nEach output dimension is just enough to encode all input strings, but not more than supplied dimensions (opts.n_rows * resolution.row and opts.n_cols * resolution.col respectively).\nIf input dimensions are too big to fit inside output, perform grid downscaling with loss of information. Input boolean mask is divided into 2d-bins with as equal as possible dimensions. Each bin then converted into single boolean value: true if bin contains at least one true element, false otherwise. This leads to a whitespace output meaning that all entries in a bin are whitespace, while non-whitespace output means that some entry is non-whitespace.\n\nConvert boolean mask to symbol strings:\n\nInput rescaled boolean mask is divided into bins with dimensions of symbol resolution (assuming false outer padding).\nEach bin with resolution dimensions is transformed into encode symbol. Single convertible (resolution.row, resolution.col) boolean mask is treated as (reversed) binary digit: true as 1; false as 0. Traversing left-right, top-bottom (top-left is lowest bit, bottom-right - highest).\n\n\nExample:\nAssume the output should have 3 rows of symbols each with width 2. Encode symbols are ’ ‘,’▌‘,’▐‘,’█’ with 1x2 resolution.\nAssume input strings:\naaaaa\n b b\n\n d d\ne e\nSteps:\n\nConvert to boolean mask (each row is a boolean array, “t”/“f” ~ true/false, empty spots are equivalent to being false):\nttttt\nftft\n\nftft\ntft\nRescale. Output dimensions are n_rows * resolution.row = 3 * 1 = 3 rows and n_cols * resolution.col = 2 * 2 = 4. It creates as equal as possible grid with 3 rows and 4 columns and converts bins to single booleans. Result:\ntttt\ntftf\nttff\nConvert to symbols. It makes 1x2 bins, treats their input as (reversed) binary digits (ff=00=0, tf=10=1, ft=01=2, tt=11=3) and takes corresponding symbols from supplied options (value plus 1). Result:\n██\n▌▌\n█\n\n\nParameters\n{strings} (table) Array of arbitrary strings.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;n_rows&gt; - number of rows in output encoding. If too big, will be truncated to be maximum needed to encode all input strings (taking into account symbols row resolution). Default: math.huge.\n&lt;n_cols&gt; - width of every encoding string. If too big, will be truncated to be maximum needed to encode all input strings (taking into account symbols column resolution). Default: math.huge.\n&lt;symbols&gt; - array of symbols with extra resolution field. See “Encode symbols” section of MiniMap.config for more details. Default: output of MiniMap.gen_encode_symbols.block() with '3x2' identifier.\n\n\n\nReturn\n(table) Array of encoded strings.\n\n\n\n\nopen()\n\nMiniMap.open({opts})\n\nOpen map window\nThis creates and shows map window in current tabpage. It basically has two steps:\n\nIf not already done, create map buffer (used to set lines and other visual indicators) and map window.\nCall MiniMap.refresh().\n\n\nParameters\n{opts} (table|nil) Options used to define map configuration. Same structure as MiniMap.config. Will have effect until at least one tabpage has opened map window. Default values are taken in the following order:\n\nFrom opts field of MiniMap.current.\nFrom vim.b.minimap_config.\nFrom MiniMap.config.\n\n\n\n\n\nrefresh()\n\nMiniMap.refresh({opts}, {parts})\n\nRefresh map window\nThis function serves two purposes:\n\nUpdate current map configuration via opts.\nUpdate parts of displayed content via parts.\n\n\nParameters\n{opts} (table|nil) Options used to define map configuration. Same structure as MiniMap.config. Will have effect until at least one tabpage has opened map window. Default values are taken in the following order:\n\nFrom opts field of MiniMap.current.\nFrom vim.b.minimap_config.\nFrom MiniMap.config.\n\n{parts} (table|nil) Which parts to update. Recognised keys with boolean values (all true by default):\n\n&lt;integrations&gt; - whether to update integration highlights.\n&lt;lines&gt; - whether to update map lines.\n&lt;scrollbar&gt; - whether to update scrollbar.\n\n\n\n\n\nclose()\n\nMiniMap.close()\n\nClose map window\nAlso resets opts field of MiniMap.current after closing last map window (among possibly several tabpages).\n\n\n\ntoggle()\n\nMiniMap.toggle({opts})\n\nToggle map window\nOpen if not shown in current tabpage, close otherwise.\n\nParameters\n{opts} (table|nil) Input for MiniMap.open().\n\n\n\n\ntoggle_focus()\n\nMiniMap.toggle_focus({use_previous_cursor})\n\nToggle focus to/from map window\nWhen not inside map window, put cursor inside map window; otherwise put cursor in previous window with source buffer.\nWhen cursor is moving inside map window (but not just after focusing), view of source window is updated to show first line convertible to current map line. This allows quick targeted source buffer exploration.\nThere are at least these extra methods to focus back from map window:\n\nPress &lt;CR&gt; to accept current explored position in source buffer. Equivalent to calling this function with false argument.\nPress &lt;Esc&gt; to go back to original position prior focusing on map window. Equivalent to calling this function with true argument.\n\n\nParameters\n{use_previous_cursor} (boolean|nil) Whether to focus on source window at original cursor position (the one prior focusing on map window).\n\n\n\n\ntoggle_side()\n\nMiniMap.toggle_side()\n\nToggle side of map window\nA small convenience wrapper for calling MiniMap.refresh() to change the side of map window.\n\n\n\ngen_encode_symbols\n\nMiniMap.gen_encode_symbols\n\nGenerate encode symbols\nThis is a table with function elements. Call to actually get encode symbols.\nEach element takes a string resolution identifier of a form 'rxc' (like '3x2') where r is a row resolution of each symbol (how many rows of binary data it can encode) and c is a column resolution (how many columns it can encode).\n\n\n\ngen_encode_symbols.block()\n\nMiniMap.gen_encode_symbols.block({id})\n\nGenerate block encode symbols\nOutputs use solid block to encode binary data. Example: ‘🬗’, ‘▟’, ‘█’.\n\nParameters\n{id} (string) Resolution identifier. Available values: '1x2', '2x1', '2x2', '3x2' (default in ‘mini.map’).\n\n\n\n\ngen_encode_symbols.dot()\n\nMiniMap.gen_encode_symbols.dot({id})\n\nGenerate dot encode symbols\nOutputs use dots to encode binary data. Example: ‘⡪’, ‘⣼’, ‘⣿’.\n\nParameters\n{id} (string) Resolution identifier. Available values: '4x2', '3x2'.\n\n\n\n\ngen_encode_symbols.shade()\n\nMiniMap.gen_encode_symbols.shade({id})\n\nGenerate shade encode symbols\nOutputs use whole cell shades to encode binary data. They use same set of characters (‘░’, ‘▒’, ‘▒’, ’▓), but with different resolution.\n\nParameters\n{id} (string) Resolution identifier. Available values: '1x2', '2x1'.\n\n\n\n\ngen_integration\n\nMiniMap.gen_integration\n\nGenerate integrations\nThis is a table with function elements. Call to actually get encode symbols.\nEach element takes a table defining highlight groups used for to highlight map lines.\n\n\n\ngen_integration.builtin_search()\n\nMiniMap.gen_integration.builtin_search({hl_groups})\n\nBuiltin search\nHighlight lines with matches of current builtin search (like with /, ?, etc.). Integration count reflects number of actual matches.\nIt prompts integration highlighting update on every change of ‘hlsearch’ (see OptionSet) or v:hlsearch. Note that it is not happening for some keys:\n\nAfter starting search with n, N, star, or #. To enable highlight update on this keys, make custom mappings. Like this:\nfor _, key in ipairs({ 'n', 'N', '*', '#' }) do\n  local rhs = key ..\n    '&lt;Cmd&gt;lua MiniMap.refresh({}, {lines = false, scrollbar = false})&lt;CR&gt;'\n  vim.keymap.set('n', key, rhs)\nend\n\n\nParameters\n{hl_groups} (table|nil) Table defining highlight groups. Can have the following fields:\n\n&lt;search&gt; - highlight group for search matches. Default: hl-Search.\n\n\n\n\n\ngen_integration.diagnostic()\n\nMiniMap.gen_integration.diagnostic({hl_groups})\n\nBuiltin diagnostic\nHighlight lines with matches of current diagnostic items. Items are computed with vim.diagnostic.get() for current (source) buffer.\nIt prompts integration highlighting update on every DiagnosticChanged event. Diagnostic items with higher severity (see vim.diagnostic.severity) have higher highlight priority (errors will be shown over all others, etc.).\n\nParameters\n{hl_groups} (table|nil) Table defining highlight groups. Supplied fields also define which diagnostic severity to highlight. Can have the following fields:\n\n&lt;error&gt; - highlight group for error items. Default: hl-DiagnosticFloatingError.\n&lt;warn&gt; - highlight group for warning items. Default: nil (not shown).\n&lt;info&gt; - highlight group for info items. Default: nil (not shown).\n&lt;hint&gt; - highlight group for hint items. Default: nil (not shown).\n\n\n\nUsage\n-- Show all diagnostic levels\nlocal map = require('mini.map')\nlocal diagnostic_integration = map.gen_integration.diagnostic({\n  error = 'DiagnosticFloatingError',\n  warn  = 'DiagnosticFloatingWarn',\n  info  = 'DiagnosticFloatingInfo',\n  hint  = 'DiagnosticFloatingHint',\n})\nmap.setup({ integrations = { diagnostic_integration } })\n\n\n\n\ngen_integration.diff()\n\nMiniMap.gen_integration.diff({hl_groups})\n\nGeneral diff hunks from mini.diff\nHighlight lines which are part of current diff. Requires ‘mini.diff’ as dependency.\n\nParameters\n{hl_groups} (table|nil) Table defining highlight groups. If nil (not supplied), this status is not highlighted. Can have the following fields:\n\n&lt;add&gt; - group name for “add” hunks. Default: “MiniDiffSignAdd”.\n&lt;change&gt; - group name for “change” hunks. Default: “MiniDiffSignChange”.\n&lt;delete&gt; - group name for “delete” hunks. Default: “MiniDiffSignDelete”.\n\n\n\n\n\ngen_integration.gitsigns()\n\nMiniMap.gen_integration.gitsigns({hl_groups})\n\nHunks from ‘lewis6991/gitsigns.nvim’\nHighlight lines which have non-trivial Git status. Requires lewis6991/gitsigns.nvim.\n\nParameters\n{hl_groups} (table|nil) Table defining highlight groups. If nil (not supplied), this status is not highlighted. Can have the following fields:\n\n&lt;add&gt; - group name for added lines. Default: “GitSignsAdd”.\n&lt;change&gt; - group name for changed lines. Default: “GitSignsChange”.\n&lt;delete&gt; - group name for deleted lines. Default: “GitSignsDelete”."
  },
  {
    "objectID": "mini.nvim/doc/mini-statusline.html",
    "href": "mini.nvim/doc/mini-statusline.html",
    "title": "mini.statusline documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.statusline Statusline\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nDefine own custom statusline structure for active and inactive windows. This is done with a function which should return string appropriate for ‘statusline’. Its code should be similar to default one with structure:\n\nCompute string data for every section you want to be displayed.\nCombine them in groups with MiniStatusline.combine_groups().\n\nBuilt-in active mode indicator with colors.\nSections can hide information when window is too narrow (specific window width is configurable per section).\n\n\nDependencies\nSuggested dependencies (provide extra functionality, will work without them):\n\nNerd font (to support extra icons).\nEnabled mini.icons module for MiniStatusline.section_fileinfo(). Falls back to using ‘nvim-tree/nvim-web-devicons’ plugin or shows nothing.\nEnabled mini.git module for MiniStatusline.section_git(). Falls back to using ‘lewis6991/gitsigns.nvim’ plugin or shows nothing.\nEnabled mini.diff module for MiniStatusline.section_diff(). Falls back to using ‘lewis6991/gitsigns.nvim’ plugin or shows nothing.\n\n\n\nSetup\nThis module needs a setup with require('mini.statusline').setup({}) (replace {} with your config table). It will create global Lua table MiniStatusline which you can use for scripting or manually (with :lua MiniStatusline.*).\nSee MiniStatusline.config for config structure and default values. For some content examples, see MiniStatusline-example-content.\nYou can override runtime config settings locally to buffer inside vim.b.ministatusline_config which should have same structure as MiniStatusline.config. See mini.nvim-buffer-local-config for more details.\n\n\nHighlight groups\nHighlight depending on mode (second MiniStatusline.section_mode() output):\n\nMiniStatuslineModeNormal - Normal mode.\nMiniStatuslineModeInsert - Insert mode.\nMiniStatuslineModeVisual - Visual mode.\nMiniStatuslineModeReplace - Replace mode.\nMiniStatuslineModeCommand - Command mode.\nMiniStatuslineModeOther - other modes (like Terminal, etc.).\n\nHighlight used in default statusline:\n\nMiniStatuslineDevinfo - for “dev info” group (MiniStatusline.section_git() and MiniStatusline.section_diagnostics()).\nMiniStatuslineFilename - for MiniStatusline.section_filename() section.\nMiniStatuslineFileinfo - for MiniStatusline.section_fileinfo() section.\n\nOther groups:\n\nMiniStatuslineInactive - highliting in not focused window.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable (show empty statusline), set vim.g.ministatusline_disable (globally) or vim.b.ministatusline_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nExample content\nExample content\n\nDefault content\nThis function is used as default value for active content:\nfunction()\n  local mode, mode_hl = MiniStatusline.section_mode({ trunc_width = 120 })\n  local git           = MiniStatusline.section_git({ trunc_width = 40 })\n  local diff          = MiniStatusline.section_diff({ trunc_width = 75 })\n  local diagnostics   = MiniStatusline.section_diagnostics({ trunc_width = 75 })\n  local lsp           = MiniStatusline.section_lsp({ trunc_width = 75 })\n  local filename      = MiniStatusline.section_filename({ trunc_width = 140 })\n  local fileinfo      = MiniStatusline.section_fileinfo({ trunc_width = 120 })\n  local location      = MiniStatusline.section_location({ trunc_width = 75 })\n  local search        = MiniStatusline.section_searchcount({ trunc_width = 75 })\n\n  return MiniStatusline.combine_groups({\n    { hl = mode_hl,                  strings = { mode } },\n    { hl = 'MiniStatuslineDevinfo',  strings = { git, diff, diagnostics, lsp } },\n    '%&lt;', -- Mark general truncate point\n    { hl = 'MiniStatuslineFilename', strings = { filename } },\n    '%=', -- End left alignment\n    { hl = 'MiniStatuslineFileinfo', strings = { fileinfo } },\n    { hl = mode_hl,                  strings = { search, location } },\n  })\nend\n\n\nShow boolean options\nTo compute section string for boolean option use variation of this code snippet inside content function (you can modify option itself, truncation width, short and long displayed names):\nlocal spell = vim.wo.spell and (MiniStatusline.is_truncated(120) and 'S' or 'SPELL') or ''\nHere x and y or z is a common Lua way of doing ternary operator: if x is true-ish then return y, if not - return z.\n\n\n\n\nsetup()\n\nMiniStatusline.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniStatusline.config.\n\n\nUsage\nrequire('mini.statusline').setup() -- use default config\n-- OR\nrequire('mini.statusline').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniStatusline.config\n\n\nDefaults\nMiniStatusline.config = {\n  -- Content of statusline as functions which return statusline string. See\n  -- `:h statusline` and code of default contents (used instead of `nil`).\n  content = {\n    -- Content for active window\n    active = nil,\n    -- Content for inactive window(s)\n    inactive = nil,\n  },\n\n  -- Whether to use icons by default\n  use_icons = true,\n}\n\n\n\n\nactive()\n\nMiniStatusline.active()\n\nCompute content for active window\n\n\n\ninactive()\n\nMiniStatusline.inactive()\n\nCompute content for inactive window\n\n\n\ncombine_groups()\n\nMiniStatusline.combine_groups({groups})\n\nCombine groups of sections\nEach group can be either a string or a table with fields hl (group’s highlight group) and strings (strings representing sections).\nGeneral idea of this function is as follows;\n\nString group is used as is (useful for special strings like %&lt; or %=).\nEach table group has own highlighting in hl field (if missing, the previous one is used) and string parts in strings field. Non-empty strings from strings are separated by one space. Non-empty groups are separated by two spaces (one for each highlighting).\n\n\nParameters\n{groups} (table) Array of groups.\n\n\nReturn\n(string) String suitable for ‘statusline’.\n\n\n\n\nis_truncated()\n\nMiniStatusline.is_truncated({trunc_width})\n\nDecide whether to truncate\nThis basically computes window width and compares it to trunc_width: if window is smaller then truncate; otherwise don’t. Don’t truncate by default.\nUse this to manually decide if section needs truncation or not.\n\nParameters\n{trunc_width} (number|nil) Truncation width. If nil, output is false.\n\n\nReturn\n(boolean) Whether to truncate.\n\n\n\n\nsection_mode()\n\nMiniStatusline.section_mode({args})\n\nSection for Vim mode()\nShort output is returned if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments.\n\n\nReturn\n(...) Section string and mode’s highlight group.\n\n\n\n\nsection_git()\n\nMiniStatusline.section_git({args})\n\nSection for Git information\nShows Git summary from mini.git (should be set up; recommended). To tweak formatting of what data is shown, modify buffer-local summary string directly as described in MiniGit-examples.\nIf ‘mini.git’ is not set up, section falls back on ‘lewis6991/gitsigns’ data or showing empty string.\nEmpty string is returned if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments. Use args.icon to supply your own icon.\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_diff()\n\nMiniStatusline.section_diff({args})\n\nSection for diff information\nShows diff summary from mini.diff (should be set up; recommended). To tweak formatting of what data is shown, modify buffer-local summary string directly as described in MiniDiff-diff-summary.\nIf ‘mini.diff’ is not set up, section falls back on ‘lewis6991/gitsigns’ data or showing empty string.\nEmpty string is returned if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments. Use args.icon to supply your own icon.\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_diagnostics()\n\nMiniStatusline.section_diagnostics({args})\n\nSection for Neovim’s builtin diagnostics\nShows nothing if diagnostics is disabled, no diagnostic is set, or for short output. Otherwise uses vim.diagnostic.get() to compute and show number of errors (‘E’), warnings (‘W’), information (‘I’), and hints (‘H’).\nShort output is returned if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments. Use args.icon to supply your own icon. Use args.signs to use custom signs per severity level name. For example:\n{ ERROR = '!', WARN = '?', INFO = '@', HINT = '*' }\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_lsp()\n\nMiniStatusline.section_lsp({args})\n\nSection for attached LSP servers\nShows number of LSP servers (each as separate “+” character) attached to current buffer or nothing if none is attached. Nothing is shown if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments. Use args.icon to supply your own icon.\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_filename()\n\nMiniStatusline.section_filename({args})\n\nSection for file name\nShow full file name or relative in short output.\nShort output is returned if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments.\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_fileinfo()\n\nMiniStatusline.section_fileinfo({args})\n\nSection for file information\nShows ‘filetype’, ‘fileencoding’ / ‘encoding’, ‘fileformat’, and buffer size. Short output has only non-empty ‘filetype’ and is returned if window width is lower than args.trunc_width or buffer is not normal (as per ‘buftype’).\nBuffer size is computed based on current text, not file’s saved version.\nIf config.use_icons is true and icon provider is present (see “Dependencies” section in mini.statusline), shows icon near the filetype.\n\nParameters\n{args} (table) Section arguments.\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_location()\n\nMiniStatusline.section_location({args})\n\nSection for location inside buffer\nShow location inside buffer in the form:\n\nNormal: '&lt;cursor line&gt;|&lt;total lines&gt;│&lt;cursor column&gt;|&lt;total columns&gt;'\nShort: '&lt;cursor line&gt;│&lt;cursor column&gt;'\n\nShort output is returned if window width is lower than args.trunc_width.\n\nParameters\n{args} (table) Section arguments.\n\n\nReturn\n(string) Section string.\n\n\n\n\nsection_searchcount()\n\nMiniStatusline.section_searchcount({args})\n\nSection for current search count\nShow the current status of searchcount(). Empty output is returned if window width is lower than args.trunc_width, search highlighting is not on (see v:hlsearch), or if number of search result is 0.\nargs.options is forwarded to searchcount(). By default it recomputes data on every call which can be computationally expensive (although still usually on 0.1 ms order of magnitude). To prevent this, supply args.options = { recompute = false }.\n\nParameters\n{args} (table) Section arguments.\n\n\nReturn\n(string) Section string."
  },
  {
    "objectID": "mini.nvim/doc/mini-sessions.html",
    "href": "mini.nvim/doc/mini-sessions.html",
    "title": "mini.sessions documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.sessions Session management\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nRead, write, and delete sessions. Uses :mksession (meaning ‘sessionoptions’ is fully respected). This is intended as a drop-in Lua replacement for mhinz/vim-startify session management (works out of the box with sessions created by it). Implements both global (from configured directory) and local (from current directory) sessions.\nKey design ideas:\n\nSessions are represented by readable files (results of applying :mksession). There are two kinds of sessions:\n\nGlobal: any file inside a configurable directory.\nLocal: configurable file inside current working directory (getcwd()).\n\nAll session files are detected during MiniSessions.setup() and during relevant actions (read, delete, select) with file names as session names (including possible extension).\nNo automated new session creation. Use MiniSessions.write() manually.\nStore information about detected sessions in separate table (MiniSessions.detected) and operate only on it. Meaning if this information changes, there will be no effect until next detection. To avoid confusion, don’t directly use :mksession / :source for writing / reading session files.\n\nFeatures:\n\nAutoread default session (local if detected, else latest written global) if Neovim was called without intention to show something else.\nAutowrite currently read session before leaving it (quit Neovim or read another session).\nConfigurable severity level of all actions.\n\n\nSetup\nThis module needs a setup with require('mini.sessions').setup({}) (replace {} with your config table). It will create global Lua table MiniSessions which you can use for scripting or manually (with :lua MiniSessions.*).\nSee MiniSessions.config for config structure and default values.\nThis module doesn’t benefit from buffer local configuration, so using vim.b.minisessions_config will have no effect here.\n\n\nDisabling\nTo disable core functionality, set vim.g.minisessions_disable (globally) or vim.b.minisessions_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniSessions.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniSessions.config.\n\n\nUsage\nrequire('mini.sessions').setup() -- use default config\n-- OR\nrequire('mini.sessions').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniSessions.config\n\n\nDefaults\nMiniSessions.config = {\n  -- Whether to read default session if Neovim opened without file arguments\n  autoread = false,\n\n  -- Whether to write currently read session before leaving it\n  autowrite = true,\n\n  -- Directory where global sessions are stored (use `''` to disable)\n  directory = --&lt;\"session\" subdir of user data directory from |stdpath()|&gt;,\n\n  -- File for local session (use `''` to disable)\n  file = 'Session.vim',\n\n  -- Whether to force possibly harmful actions (meaning depends on function)\n  force = { read = false, write = true, delete = false },\n\n  -- Hook functions for actions. Default `nil` means 'do nothing'.\n  -- Takes table with active session data as argument.\n  hooks = {\n    -- Before successful action\n    pre = { read = nil, write = nil, delete = nil },\n    -- After successful action\n    post = { read = nil, write = nil, delete = nil },\n  },\n\n  -- Whether to print session path after action\n  verbose = { read = false, write = true, delete = true },\n}\n\n\n\n\ndetected\n\nMiniSessions.detected\n\nTable of detected sessions. Keys represent session name. Values are tables with session information that currently has these fields (but subject to change):\n\n&lt;modify_time&gt; (number) modification time (see getftime()) of session file.\n&lt;name&gt; (string) name of session (should be equal to table key).\n&lt;path&gt; (string) full path to session file.\n&lt;type&gt; (string) type of session (‘global’ or ‘local’).\n\n\n\n\nread()\n\nMiniSessions.read({session_name}, {opts})\n\nRead detected session\nWhat it does:\n\nIf there is an active session and autowrite is true in MiniSessions.config, write it with MiniSessions.write().\nDelete all current buffers with :bwipeout. This is needed to correctly restore buffers from target session. If force is not true, checks beforehand for unsaved listed buffers and stops if there is any.\nSource session with supplied name.\n\n\nParameters\n{session_name} (string|nil) Name of detected session file to read. Default: nil for default session: local (if detected) or latest session (see MiniSessions.get_latest()).\n{opts} (table|nil) Table with options. Current allowed keys:\n\n&lt;force&gt; (whether to delete unsaved buffers; default: MiniSessions.config.force.read).\n&lt;verbose&gt; (whether to print session path after action; default MiniSessions.config.verbose.read).\n&lt;hooks&gt; (a table with &lt;pre&gt; and &lt;post&gt; function hooks to be executed with session data argument before and after successful read; overrides MiniSessions.config.hooks.pre.read and MiniSessions.config.hooks.post.read).\n\n\n\n\n\nwrite()\n\nMiniSessions.write({session_name}, {opts})\n\nWrite session\nWhat it does:\n\nCheck if file for supplied session name already exists. If it does and force is not true, then stop.\nWrite session with :mksession to a file named session_name. Its directory is determined based on type of session:\n\nIt is at location v:this_session if session_name is nil and there is currently read session.\nIt is current working directory (getcwd()) if session_name is equal to MiniSessions.config.file (represents local session).\nIt is MiniSessions.config.directory otherwise (represents global session).\n\nUpdate MiniSessions.detected.\n\n\nParameters\n{session_name} (string|nil) Name of session file to write. Default: nil for currently read session (v:this_session).\n{opts} (table|nil) Table with options. Current allowed keys:\n\n&lt;force&gt; (whether to ignore existence of session file; default: MiniSessions.config.force.write).\n&lt;verbose&gt; (whether to print session path after action; default MiniSessions.config.verbose.write).\n&lt;hooks&gt; (a table with &lt;pre&gt; and &lt;post&gt; function hooks to be executed with session data argument before and after successful write; overrides MiniSessions.config.hooks.pre.write and MiniSessions.config.hooks.post.write).\n\n\n\n\n\ndelete()\n\nMiniSessions.delete({session_name}, {opts})\n\nDelete detected session\nWhat it does:\n\nCheck if session name is a current one. If yes and force is not true, then stop.\nDelete session.\nUpdate MiniSessions.detected.\n\n\nParameters\n{session_name} (string|nil) Name of detected session file to delete. Default: nil for name of currently read session (taken from v:this_session).\n{opts} (table|nil) Table with options. Current allowed keys:\n\n&lt;force&gt; (whether to allow deletion of current session; default: MiniSessions.config.force.delete).\n&lt;verbose&gt; (whether to print session path after action; default MiniSessions.config.verbose.delete).\n&lt;hooks&gt; (a table with &lt;pre&gt; and &lt;post&gt; function hooks to be executed with session data argument before and after successful delete; overrides MiniSessions.config.hooks.pre.delete and MiniSessions.config.hooks.post.delete).\n\n\n\n\n\nselect()\n\nMiniSessions.select({action}, {opts})\n\nSelect session interactively and perform action\nNote: this uses vim.ui.select() function. For more user-friendly experience, override it (for example, see MiniPick.ui_select()).\n\nParameters\n{action} (string|nil) Action to perform. Should be one of “read” (default), “write”, or “delete”.\n{opts} (table|nil) Options for specified action.\n\n\n\n\nget_latest()\n\nMiniSessions.get_latest()\n\nGet name of latest detected session\nLatest session is the session with the latest modification time determined by getftime().\n\nReturn\n(string|nil) Name of latest session or nil if there is no sessions."
  },
  {
    "objectID": "mini.nvim/doc/mini-bracketed.html",
    "href": "mini.nvim/doc/mini-bracketed.html",
    "title": "mini.bracketed documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.bracketed Go forward/backward with square brackets\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nConfigurable Lua functions to go forward/backward to a certain target. Each function can be customized with:\n\nDirection. One of “forward”, “backward”, “first” (forward starting from first one), “last” (backward starting from last one).\nNumber of times to go.\nWhether to wrap on edges (going forward on last one goes to first).\nSome other target specific options.\n\nMappings using square brackets. They are created using configurable target suffix and can be selectively disabled.\nEach mapping supports [count]. Mappings are created in Normal mode; for targets which move cursor in current buffer also Visual and Operator-pending (with dot-repeat) modes are supported.\nUsing lower-suffix and upper-suffix (lower and upper case suffix) for a single target the following mappings are created:\n\n[ + upper-suffix : go first.\n[ + lower-suffix : go backward.\n] + lower-suffix : go forward.\n] + upper-suffix : go last.\n\nSupported targets (for more information see help for corresponding Lua function):\n\n\n\n\nTarget\nMappings\nLua function\n\n\n\n\nBuffer\n[B [b ]b ]B\nMiniBracketed.buffer()\n\n\nComment block\n[C [c ]c ]C\nMiniBracketed.comment()\n\n\nConflict marker\n[X [x ]x ]X\nMiniBracketed.conflict()\n\n\nDiagnostic\n[D [d ]d ]D\nMiniBracketed.diagnostic()\n\n\nFile on disk\n[F [f ]f ]F\nMiniBracketed.file()\n\n\nIndent change\n[I [i ]i ]I\nMiniBracketed.indent()\n\n\nJump inside current buffer\n[J [j ]j ]J\nMiniBracketed.jump()\n\n\nLocation from location-list\n[L [l ]l ]L\nMiniBracketed.location()\n\n\nOld files\n[O [o ]o ]O\nMiniBracketed.oldfile()\n\n\nQuickfix entry from Quickfix\n[Q [q ]q ]Q\nMiniBracketed.quickfix()\n\n\nTree-sitter node and parents\n[T [t ]t ]T\nMiniBracketed.treesitter()\n\n\nUndo from linear history\n[U [u ]u ]U\nMiniBracketed.undo()\n\n\nWindow in current tab\n[W [w ]w ]W\nMiniBracketed.window()\n\n\nYank entry over put region\n[Y [y ]y ]Y\nMiniBracketed.yank()\n\n\n\nNotes:\n\nThe undo target remaps u and CTRL-R keys to register undo state after undo and redo respectively. If this conflicts with your setup, either disable undo target or make your remaps after calling MiniBracketed.setup(). To use undo target, remap your undo/redo keys to call MiniBracketed.register_undo_state() after the action.\n\n\nSetup\nThis module needs a setup with require('mini.bracketed').setup({}) (replace {} with your config table). It will create global Lua table MiniBracketed which you can use for scripting or manually (with :lua MiniBracketed.*).\nSee MiniBracketed.config for available config settings.\nYou can override runtime config settings (like target options) locally to buffer inside vim.b.minibracketed_config which should have same structure as MiniBracketed.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\ntpope/vim-unimpaired:\n\nSupports buffer, conflict, file, location, and quickfix targets mostly via built-in commands (like :bprevious, etc.) without configuration.\nSupports files from argument list and tags. This module does not.\nDoesn’t support most other this module’s targets (comment, indent, …).\n\nmini.indentscope:\n\nTarget MiniBracketed.indent() target can go to “first” and “last” indent change. It also can go not only to line with smaller indent, but also bigger or different one.\nMappings from ‘mini.indentscope’ have more flexibility in computation of indent scope, like how to treat empty lines near border or whether to compute indent at cursor.\n\n\n\n\nDisabling\nTo disable, set vim.g.minibracketed_disable (globally) or vim.b.minibracketed_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniBracketed.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniBracketed.config.\n\n\nUsage\nrequire('mini.bracketed').setup() -- use default config\n-- OR\nrequire('mini.bracketed').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniBracketed.config\n\n\nDefaults\nMiniBracketed.config = {\n  -- First-level elements are tables describing behavior of a target:\n  --\n  -- - &lt;suffix&gt; - single character suffix. Used after `[` / `]` in mappings.\n  --   For example, with `b` creates `[B`, `[b`, `]b`, `]B` mappings.\n  --   Supply empty string `''` to not create mappings.\n  --\n  -- - &lt;options&gt; - table overriding target options.\n  --\n  -- See `:h MiniBracketed.config` for more info.\n\n  buffer     = { suffix = 'b', options = {} },\n  comment    = { suffix = 'c', options = {} },\n  conflict   = { suffix = 'x', options = {} },\n  diagnostic = { suffix = 'd', options = {} },\n  file       = { suffix = 'f', options = {} },\n  indent     = { suffix = 'i', options = {} },\n  jump       = { suffix = 'j', options = {} },\n  location   = { suffix = 'l', options = {} },\n  oldfile    = { suffix = 'o', options = {} },\n  quickfix   = { suffix = 'q', options = {} },\n  treesitter = { suffix = 't', options = {} },\n  undo       = { suffix = 'u', options = {} },\n  window     = { suffix = 'w', options = {} },\n  yank       = { suffix = 'y', options = {} },\n}\n\n\nOptions\nEach entry configures target with the same name and can have data configuring mapping suffix and target options.\nExample of configuration:\nrequire('mini.bracketed').setup({\n  -- Map [N, [n, ]n, ]N for conflict marker like in 'tpope/vim-unimpaired'\n  conflict = { suffix = 'n' },\n\n  -- Make diagnostic advance only by errors\n  diagnostic = { options = { severity = vim.diagnostic.severity.ERROR } },\n\n  -- Disable creation of mappings for `indent` target (for example,\n  -- in favor of ones from |mini.indentscope|)\n  indent = { suffix = '' },\n\n  -- Disable mappings for `window` target in favor of custom ones\n  window = { suffix = '' },\n})\n\n-- Create custom `window` mappings\nlocal map = vim.keymap.set\nmap('n', '&lt;Leader&gt;wH', \"&lt;Cmd&gt;lua MiniBracketed.window('first')&lt;CR&gt;\")\nmap('n', '&lt;Leader&gt;wh', \"&lt;Cmd&gt;lua MiniBracketed.window('backward')&lt;CR&gt;\")\nmap('n', '&lt;Leader&gt;wl', \"&lt;Cmd&gt;lua MiniBracketed.window('forward')&lt;CR&gt;\")\nmap('n', '&lt;Leader&gt;wL', \"&lt;Cmd&gt;lua MiniBracketed.window('last')&lt;CR&gt;\")\n\nSuffix\nThe suffix key is used to create target mappings.\nSupply empty string to disable mapping creation for that particular target. To create a completely different mapping (like with &lt;Leader&gt;) use target function manually.\nUsing lower-suffix and upper-suffix (lower and upper case suffix) for a single target the following mappings are created:\n\n[ + upper-suffix : go first.\n[ + lower-suffix : go backward.\n] + lower-suffix : go forward.\n] + upper-suffix : go last.\n\nWhen supplied with a non-letter, only forward/backward mappings are created.\n\n\nOptions\nThe options key is directly forwarded as opts to corresponding Lua function.\n\n\n\n\n\nbuffer()\n\nMiniBracketed.buffer({direction}, {opts})\n\nListed buffer\nGo to next/previous listed buffer. Order by their number (see bufnr()).\nDirection “forward” increases number, “backward” - decreases.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\ncomment()\n\nMiniBracketed.comment({direction}, {opts})\n\nComment block\nGo to next/previous comment block. Only linewise comments using ‘commentsring’ are recognized.\nDirection “forward” increases line number, “backward” - decreases.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n&lt;add_to_jumplist&gt; (boolean) - Whether to add current position to jumplist. Default: false.\n&lt;block_side&gt; (string) - which side of comment block to use. One of “near” (default; use nearest side), “start” (use first line), “end” (use last line), “both” (use both first and last lines).\n\n\n\n\n\nconflict()\n\nMiniBracketed.conflict({direction}, {opts})\n\nGit conflict marker\nGo to next/previous lines containing Git conflict marker. That is, if it starts with “&lt;&lt;&lt;&lt;&lt;&lt;&lt;”, “&gt;&gt;&gt;&gt;&gt;&gt;&gt;”, or is “=======”.\nDirection “forward” increases line number, “backward” - decreases.\nNotes:\n\nUsing this target in Operator-pending mode allows the following approach at resolving merge conflicts:\n\nPlace cursor on ======= line.\nExecute one of these: d]x[xdd (choose upper part) or d[x]xdd (choose lower part).\n\n\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n&lt;add_to_jumplist&gt; (boolean) - Whether to add current position to jumplist. Default: false.\n\n\n\n\n\ndiagnostic()\n\nMiniBracketed.diagnostic({direction}, {opts})\n\nDiagnostic\nGo to next/previous diagnostic. This is mostly similar to built-in vim.diagnostic.jump() (on Neovim&lt;0.11 it is vim.diagnostic.goto_next() and vim.diagnostic.goto_prev()) which has an interface and behavior consistent with other methods of the module.\nDirection “forward” increases line number, “backward” - decreases.\nNotes:\n\nUsing severity option, this target can be used in mappings like “go to next/previous error” (), etc. Using code similar to this:\nlocal severity_error = vim.diagnostic.severity.ERROR\n-- Use these inside custom mappings\nMiniBracketed.diagnostic('forward', { severity = severity_error })\nMiniBracketed.diagnostic('backward', { severity = severity_error })\n\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n&lt;float&gt; (boolean|table) - control floating window after movement. For available values see vim.diagnostic.goto_next().\n&lt;severity&gt; (string|table) - which severity to use. For available values see diagnostic-severity.\n\n\n\n\n\nfile()\n\nMiniBracketed.file({direction}, {opts})\n\nFile on disk\nGo to next/previous file on disk alphabetically. Files are taken from directory of file in current buffer (or current working directory if buffer doesn’t contain a readable file). Only first-level files are used, i.e. it doesn’t go inside subdirectories.\nDirection “forward” goes forward alphabetically, “backward” - backward.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\nindent()\n\nMiniBracketed.indent({direction}, {opts})\n\nIndent change\nGo to next/previous line with different indent (see indent()). Can be used to go to lines with smaller, bigger, or different indent.\nNotes:\n\nDirections “first” and “last” work differently from most other targets for performance reasons. They are essentially “backward” and “forward” with very big n_times option.\nFor similar reasons, wrap is not supported.\nBlank line inherit indent from near non-blank line in direction of movement.\n\nDirection “forward” increases line number, “backward” - decreases.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;add_to_jumplist&gt; (boolean) - Whether to add current position to jumplist. Default: false.\n&lt;change_type&gt; (string) - which type of indent change to use. One of “less” (default; smaller indent), “more” (bigger indent), “diff” (different indent).\n\n\n\n\n\njump()\n\nMiniBracketed.jump({direction}, {opts})\n\nJump inside current buffer\nGo to next/previous jump from jumplist which is inside current buffer.\nNotes:\n\nThere are no Visual mode mappings due to implementation problems.\n\nDirection “forward” increases jump number, “backward” - decreases.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\nlocation()\n\nMiniBracketed.location({direction}, {opts})\n\nLocation from location list\nGo to next/previous location from location-list. This is similar to :lfirst, :lprevious, :lnext, and :llast but with support of wrapping around edges and [count] for “first”/“last” direction.\nDirection “forward” increases location number, “backward” - decreases.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\noldfile()\n\nMiniBracketed.oldfile({direction}, {opts})\n\nOld files from previous and current sessions\nGo to older/newer readable file either from previous session (see v:oldfiles) or the current one (updated automatically after MiniBracketed.setup() call).\nDirection “forward” goes to more recent files, “backward” - to older.\nNotes:\n\nIn current session it tracks only normal buffers (see ‘buftype’) for some readable file.\nNo new file is tracked when advancing this target. Only after buffer change is done not through this target (like with MiniBracketed.buffer()), it updates recency of last advanced and new buffers.\n\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\nquickfix()\n\nMiniBracketed.quickfix({direction}, {opts})\n\nQuickfix from quickfix list\nGo to next/previous entry from quickfix list. This is similar to :cfirst, :cprevious, :cnext, and :clast but with support of wrapping around edges and [count] for “first”/“last” direction.\nDirection “forward” increases location number, “backward” - decreases.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\ntreesitter()\n\nMiniBracketed.treesitter({direction}, {opts})\n\nTree-sitter node\nGo to end/start of current tree-sitter node and its parents (except root).\nNotes:\n\nRequires loaded tree-sitter parser in the current buffer.\nDirections “first” and “last” work differently from most other targets for performance reasons. They are essentially “backward” and “forward” with very big n_times option.\nFor similar reasons, wrap is not supported.\n\nDirection “forward” moves cursor forward to node’s end, “backward” - backward to node’s start.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;add_to_jumplist&gt; (boolean) - Whether to add current position to jumplist. Default: false.\n\n\n\n\n\nundo()\n\nMiniBracketed.undo({direction}, {opts})\n\nUndo along a tracked linear history\nIn a nutshell:\n\nKeys u and CTRL-R (although remapped) can be used as usual, but every their execution new state is recorded in this module’s linear undo history.\nAdvancing this target goes along linear undo history revealing undo states in order they actually appeared.\nOne big difference with built-in methods is that tracked linear history can repeat undo states (not consecutively, though).\n\nNeovim’s default way of managing undo history is through branches (see undo-branches). Basically it means that if you undo several changes and then make new ones, it creates new undo branch while usually (see ‘undolevels’) saving previous buffer states in another branch. While there are commands to navigate by time of undo state creation (like :earlier and :later), there is no intuitive way to cycle through them. Existing g- and g+ cycle through undo states based on their creation time, which often gets confusing really guickly in extensively edited buffer.\nThis undo() target provides a way to cycle through linear undo history in order states actually appeared. It does so by registering any new undo states plus every time MiniBracketed.register_undo_state() is called. To have more “out of the box” experience, u and CTRL-R are remapped to call it after they perform their undo/redo.\nExample:\nTo show more clearly the difference between advancing this target and using built-in functionality, here is an example:\n\nCreate undo history in a new buffer (:new):\n\nEnter one two three text.\nDelete first word with daw and undo the change with u.\nDelete second word with daw and undo the change with u.\nDelete third word with daw and undo the change with u.\n\nNow try one of the following (each one after performing previous steps in separate new buffer):\n\nPress u. It goes back to empty buffer. Press &lt;C-R&gt; twice and it goes to the latest change (one two). No way to get to other states (like two three or one three) with these two keys.\nPress g-. It goes to an empty buffer. Press g+ 4 times. It cycles through all available undo states in order they were created.\nFinally, press [u. It goes back to one two - state which was previously visited by the user. Another [u restores one two three. Use ]U to go to latest visited undo state.\n\n\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\nregister_undo_state()\n\nMiniBracketed.register_undo_state()\n\nRegister state for undo target\nUse this function to add current undo state to this module’s linear undo history. It is used in MiniBracketed.setup() to remap u and CTRL-R keys to add their new state to linear undo history.\n\n\n\nwindow()\n\nMiniBracketed.window({direction}, {opts})\n\nNormal window\nGo to next/previous normal window. Order by their number (see winnr()).\nDirection “forward” increases window number, “backward” - decreases.\nOnly normal (non-floating) windows are used.\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n\n\n\n\n\nyank()\n\nMiniBracketed.yank({direction}, {opts})\n\nReplace “latest put region” with yank history entry\nAfter MiniBracketed.setup() is called, on every yank/delete/change operation (technically, every trigger of TextYankPost event) the object of operation is added to yank history. Advancing this target will replace the region of latest put operation with entry from yank history.\nBy default works best if called right after text paste (like with p or P).\nTo better detect “latest put region”, use MiniBracketed.register_put_region() as described later.\nDirection “forward” goes to newer yank history entry, “backward” - to older.\nExample:\n\nType one two three.\nYank each word with yiw.\nCreate new line and press p. This should paste three.\nType [y. This should replace latest three with two.\n\n\nLatest put region\n“Latest put region” is (in order of decreasing priority):\n\nThe one from latest advance of this target.\nThe one registered by user with MiniBracketed.register_put_region().\nThe one taken from [‘ and [’]](https://neovim.io/doc/user/helptag.html?tag=’]) marks.\n\nFor users there are these approaches to manage which region will be used:\n\nDo nothing. In this case region between [ / ] marks will always be used for first yank advance. Although doable, this has several drawbacks: it will use latest yanked or changed region or the entire buffer if marks are not set. If remember to advance this target only after recent put operation, this should work as expected.\nRemap common put operations to use MiniBracketed.register_put_region(). After that, only regions from mapped put operations will be used for first advance. Example of custom mappings (note use of :map-expression):\nlocal put_keys = { 'p', 'P' }\nfor _, lhs in ipairs(put_keys) do\n  local rhs = 'v:lua.MiniBracketed.register_put_region(\"' .. lhs .. '\")'\n  vim.keymap.set({ 'n', 'x' }, lhs, rhs, { expr = true })\nend\n\n\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: true.\n&lt;operators&gt; (table) - array of operator names (“c”, “d”, or “y”) for which yank entry should be used to advance. For example, use { \"y\" } to advance only by entries actually resulted from yank operation with y. Default: { 'c', 'd', 'y' }.\n\n\n\n\n\nregister_put_region()\n\nMiniBracketed.register_put_region({put_key})\n\nRegister “latest put region”\nThis function should be called after put register becomes relevant (v:register is appropriately set) but before put operation takes place ([‘ and [’]](https://neovim.io/doc/user/helptag.html?tag=’]) marks become relevant).\nDesigned to be used in a user-facing expression mapping (see :map-expression). For mapping examples see MiniBracketed.yank().\n\nParameters\n{put_key} (string) Put keys to be remapped.\n\n\nReturn\n(string) Returns put_key for a better usage inside expression mappings.\n\n\n\n\nadvance()\n\nMiniBracketed.advance({iterator}, {direction}, {opts})\n\nAdvance iterator\nThis is the main function which performs any forward/backward/first/last advance in this module. Its basic idea is to take iterator (object containing information about current state and how to go to next/previous one) and go in certain direction until needed/allowed.\nNotes:\n\nDirections “first” and “last” are convenience wrappers for “forward” and “backward” with pre-setting initial state to start_edge and end_edge.\nIterators next() and prev() methods should be able to handle nil as input.\nThis function only returns new state and doesn’t modify iterator.state.\n\n\nParameters\n{iterator} (table) Table:\n\nMethods:\n\n&lt;next&gt; - given state, return state in forward direction (no wrap).\n&lt;prev&gt; - given state, return state in backward direction (no wrap).\n\nFields:\n\n&lt;state&gt; - object describing current state.\n&lt;start_edge&gt; (optional) - object with forward(start_edge) describing first state. If nil, can’t wrap forward or use direction “first”.\n&lt;end_edge&gt; (optional) - object with backward(end_edge) describing last state. If nil, can’t wrap backward or use direction “last”.\n\n\n{direction} (string) Direction. One of “first”, “backward”, “forward”, “last”.\n{opts} (table|nil) Options with the following keys:\n\n&lt;n_times&gt; (number) - number of times to go in input direction. Default: v:count1.\n&lt;wrap&gt; (boolean) - whether to wrap around edges when next() or prev() return nil. Default: true.\n\n\n\nReturn\n(any) Result state. If nil, could not reach any valid result state."
  },
  {
    "objectID": "mini.nvim/doc/mini-pairs.html",
    "href": "mini.nvim/doc/mini-pairs.html",
    "title": "mini.pairs documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.pairs Autopairs\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nFunctionality to work with two “paired” characters conditional on cursor’s neighborhood (character to its left and character to its right).\nUsage should be through making appropriate mappings using MiniPairs.map() or in MiniPairs.setup() (for global mapping), MiniPairs.map_buf() (for buffer mapping).\nPairs get automatically registered for special &lt;BS&gt; (all configured modes) and &lt;CR&gt; (only Insert mode) mappings. Pressing the key inside pair will delete whole pair and insert extra blank line inside pair respectively. Note: these mappings are autocreated if they do not override existing ones.\n\nWhat it doesn’t do:\n\nProvide smart behavior, like based on bracket balance. The default behavior is to almost always perform an action (insert pair, jump over). Manually press i_CTRL-V before a character to explicitly insert it (and only it).\nIt doesn’t support multiple characters as “open” and “close” symbols. Use snippets for that.\nIt doesn’t support dependency on filetype. Use i_CTRL-V to insert single symbol or autocmd command or ‘after/ftplugin’ approach to:\n\n:lua MiniPairs.map_buf(0, 'i', &lt;*&gt;, &lt;pair_info&gt;) - make new mapping for ’&lt;*&gt;’ in current buffer.\n:lua MiniPairs.unmap_buf(0, 'i', &lt;*&gt;, &lt;pair&gt;) - unmap key &lt;*&gt; while unregistering &lt;pair&gt; pair in current buffer. Note: this reverts mapping done by MiniPairs.map_buf(). If mapping was done with MiniPairs.map(), unmap for buffer in usual Neovim manner: inoremap &lt;buffer&gt; &lt;*&gt; &lt;*&gt; (this maps &lt;*&gt; key to do the same it does by default).\nDisable module for buffer (see ‘Disabling’ section).\n\n\n\nSetup\nThis module needs a setup with require('mini.pairs').setup({}) (replace {} with your config table). It will create global Lua table MiniPairs which you can use for scripting or manually (with :lua MiniPairs.*).\nSee MiniPairs.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minipairs_config will have no effect here.\n\n\nExample mappings\n-- Register quotes inside `config` of `MiniPairs.setup()`\nmappings = {\n  ['\"'] = { register = { cr = true } },\n  [\"'\"] = { register = { cr = true } },\n}\n\n-- Insert `&lt;&gt;` pair if `&lt;` is typed at line start, don't register for &lt;CR&gt;\nlocal lt_opts = {\n  action = 'open',\n  pair = '&lt;&gt;',\n  neigh_pattern = '\\r.',\n  register = { cr = false },\n}\nMiniPairs.map('i', '&lt;', lt_opts)\n\nlocal gt_opts = { action = 'close', pair = '&lt;&gt;', register = { cr = false } }\nMiniPairs.map('i', '&gt;', gt_opts)\n\n-- Create symmetrical `$$` pair only in Tex files\nlocal map_tex = function()\n  MiniPairs.map_buf(0, 'i', '$', { action = 'closeopen', pair = '$$' })\nend\nvim.api.nvim_create_autocmd(\n  'FileType',\n  { pattern = 'tex', callback = map_tex }\n)\n\n\nNotes\n\nMake sure to make proper mapping of &lt;CR&gt; in order to support completion plugin of your choice:\n\nFor mini.completion see ‘Helpful key mappings’ section.\nFor current implementation of “hrsh7th/nvim-cmp” there is no need to make custom mapping. You can use default setup, which will confirm completion selection if popup is visible and expand pair otherwise.\n\nHaving mapping in terminal mode can conflict with:\n\nAutopairing capabilities of interpretators (ipython, radian).\nVim mode of terminal itself.\n\n\n\n\nDisabling\nTo disable, set vim.g.minipairs_disable (globally) or vim.b.minipairs_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniPairs.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniPairs.config.\n\n\nUsage\nrequire('mini.pairs').setup() -- use default config\n-- OR\nrequire('mini.pairs').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniPairs.config\n\n\nDefaults\nMiniPairs.config = {\n  -- In which modes mappings from this `config` should be created\n  modes = { insert = true, command = false, terminal = false },\n\n  -- Global mappings. Each right hand side should be a pair information, a\n  -- table with at least these fields (see more in |MiniPairs.map()|):\n  -- - &lt;action&gt; - one of \"open\", \"close\", \"closeopen\".\n  -- - &lt;pair&gt; - two character string for pair to be used.\n  -- By default pair is not inserted after `\\`, quotes are not recognized by\n  -- &lt;CR&gt;, `'` does not insert pair after a letter.\n  -- Only parts of tables can be tweaked (others will use these defaults).\n  -- Supply `false` instead of table to not map particular key.\n  mappings = {\n    ['('] = { action = 'open', pair = '()', neigh_pattern = '[^\\\\].' },\n    ['['] = { action = 'open', pair = '[]', neigh_pattern = '[^\\\\].' },\n    ['{'] = { action = 'open', pair = '{}', neigh_pattern = '[^\\\\].' },\n\n    [')'] = { action = 'close', pair = '()', neigh_pattern = '[^\\\\].' },\n    [']'] = { action = 'close', pair = '[]', neigh_pattern = '[^\\\\].' },\n    ['}'] = { action = 'close', pair = '{}', neigh_pattern = '[^\\\\].' },\n\n    ['\"'] = { action = 'closeopen', pair = '\"\"', neigh_pattern = '[^\\\\].',   register = { cr = false } },\n    [\"'\"] = { action = 'closeopen', pair = \"''\", neigh_pattern = '[^%a\\\\].', register = { cr = false } },\n    ['`'] = { action = 'closeopen', pair = '``', neigh_pattern = '[^\\\\].',   register = { cr = false } },\n  },\n}\n\n\n\n\nmap()\n\nMiniPairs.map({mode}, {lhs}, {pair_info}, {opts})\n\nMake global mapping\nThis is a wrapper for nvim_set_keymap() but instead of right hand side of mapping (as string) it expects table with pair information.\nUsing this function instead of nvim_set_keymap() allows automatic registration of pairs which will be recognized by &lt;BS&gt; and &lt;CR&gt;. It also infers mapping description from pair_info.\n\nParameters\n{mode} (string) mode for nvim_set_keymap().\n{lhs} (string) lhs for nvim_set_keymap().\n{pair_info} (table) Table with pair information. Fields:\n\n&lt;action&gt; - one of “open” for MiniPairs.open(), “close” for MiniPairs.close(), or “closeopen” for MiniPairs.closeopen().\n&lt;pair&gt; - two character string to be used as argument for action function. Can contain multibyte characters.\n&lt;neigh_pattern&gt; - optional ‘two character’ neighborhood pattern to be used as argument for action function. Note: neighborhood might contain multiple characters. Default: '..' (no restriction from neighborhood).\n&lt;register&gt; - optional table with information about whether this pair will be recognized by &lt;BS&gt; (in MiniPairs.bs()) and/or &lt;CR&gt; (in MiniPairs.cr()). Should have boolean fields &lt;bs&gt; and &lt;cr&gt; (both true by default).\n\n{opts} (table|nil) Optional table opts for nvim_set_keymap(). Elements expr and noremap won’t be recognized (true by default).\n\n\n\n\nmap_buf()\n\nMiniPairs.map_buf({buffer}, {mode}, {lhs}, {pair_info}, {opts})\n\nMake buffer mapping\nThis is a wrapper for nvim_buf_set_keymap() but instead of string right hand side of mapping it expects table with pair information similar to one in MiniPairs.map().\nUsing this function instead of nvim_buf_set_keymap() allows automatic registration of pairs which will be recognized by &lt;BS&gt; and &lt;CR&gt;. It also infers mapping description from pair_info.\n\nParameters\n{buffer} (number) buffer for nvim_buf_set_keymap().\n{mode} (string) mode for nvim_buf_set_keymap().\n{lhs} (string) lhs for nvim_buf_set_keymap().\n{pair_info} (table) Table with pair information.\n{opts} (table|nil) Optional table opts for nvim_buf_set_keymap(). Elements expr and noremap won’t be recognized (true by default).\n\n\n\n\nunmap()\n\nMiniPairs.unmap({mode}, {lhs}, {pair})\n\nRemove global mapping\nA wrapper for nvim_del_keymap() which registers supplied pair.\n\nParameters\n{mode} (string) mode for nvim_del_keymap().\n{lhs} (string) lhs for nvim_del_keymap().\n{pair} (string) Pair which should be unregistered from both &lt;BS&gt; and &lt;CR&gt;. Should be explicitly supplied to avoid confusion. Supply '' to not unregister pair.\n\n\n\n\nunmap_buf()\n\nMiniPairs.unmap_buf({buffer}, {mode}, {lhs}, {pair})\n\nRemove buffer mapping\nWrapper for nvim_buf_del_keymap() which also unregisters supplied pair.\nNote: this only reverts mapping done by MiniPairs.map_buf(). If mapping was done with MiniPairs.map(), revert to default behavior for buffer:\n-- Map `X` key to do the same it does by default\nvim.keymap.set('i', 'X', 'X', { buffer = true })\n\nParameters\n{buffer} (number) buffer for nvim_buf_del_keymap().\n{mode} (string) mode for nvim_buf_del_keymap().\n{lhs} (string) lhs for nvim_buf_del_keymap().\n{pair} (string) Pair which should be unregistered from both &lt;BS&gt; and &lt;CR&gt;. Should be explicitly supplied to avoid confusion. Supply '' to not unregister pair.\n\n\n\n\nopen()\n\nMiniPairs.open({pair}, {neigh_pattern})\n\nProcess “open” symbols\nUsed as :map-&lt;expr&gt; mapping for “open” symbols in asymmetric pair (‘(’, ‘[’, etc.). If neighborhood doesn’t match supplied pattern, function results into “open” symbol. Otherwise, it pastes whole pair and moves inside pair with &lt;Left&gt;.\nUsed inside MiniPairs.map() and MiniPairs.map_buf() for an actual mapping.\n\nParameters\n{pair} (string) String with two characters representing pair.\n{neigh_pattern} (string|nil) Pattern for two neighborhood characters. Character “ indicates line start,”” - line end.\n\n\nReturn\n(string) Keys performing “open” action.\n\n\n\n\nclose()\n\nMiniPairs.close({pair}, {neigh_pattern})\n\nProcess “close” symbols\nUsed as :map-&lt;expr&gt; mapping for “close” symbols in asymmetric pair (‘)’, ‘]’, etc.). If neighborhood doesn’t match supplied pattern, function results into “close” symbol. Otherwise it jumps over symbol to the right of cursor (with &lt;Right&gt;) if it is equal to “close” one and inserts it otherwise.\nUsed inside MiniPairs.map() and MiniPairs.map_buf() for an actual mapping.\n\nParameters\n{pair} (string) String with two characters representing pair.\n{neigh_pattern} (string|nil) Pattern for two neighborhood characters. Character “ indicates line start,”” - line end.\n\n\nReturn\n(string) Keys performing “close” action.\n\n\n\n\ncloseopen()\n\nMiniPairs.closeopen({pair}, {neigh_pattern})\n\nProcess “closeopen” symbols\nUsed as :map-&lt;expr&gt; mapping for ‘symmetrical’ symbols (like ” and ‘) It tries to perform ’closeopen action’: move over right character (with &lt;Right&gt;) if it is equal to second character from pair or conditionally paste pair otherwise (with MiniPairs.open()).\nUsed inside MiniPairs.map() and MiniPairs.map_buf() for an actual mapping.\n\nParameters\n{pair} (string) String with two characters representing pair.\n{neigh_pattern} (string|nil) Pattern for two neighborhood characters. Character “ indicates line start,”” - line end.\n\n\nReturn\n(string) Keys performing “closeopen” action.\n\n\n\n\nbs()\n\nMiniPairs.bs({key})\n\nProcess &lt;BS&gt;\nUsed as :map-&lt;expr&gt; mapping for &lt;BS&gt; in Insert mode. It removes whole pair (via executing &lt;Del&gt; after input key) if neighborhood is equal to a whole pair recognized for current buffer. Pair is recognized for current buffer if it is registered for global or current buffer mapping. Pair is registered as a result of calling MiniPairs.map() or MiniPairs.map_buf().\nMapped by default inside MiniPairs.setup().\nThis can be used to modify other Insert mode keys to respect neighborhood pair. Examples:\nlocal map_bs = function(lhs, rhs)\n  vim.keymap.set('i', lhs, rhs, { expr = true, replace_keycodes = false })\nend\n\nmap_bs('&lt;C-h&gt;', 'v:lua.MiniPairs.bs()')\nmap_bs('&lt;C-w&gt;', 'v:lua.MiniPairs.bs(\"\\23\")')\nmap_bs('&lt;C-u&gt;', 'v:lua.MiniPairs.bs(\"\\21\")')\n\nParameters\n{key} (string|nil) Key to use. Default: '&lt;BS&gt;'.\n\n\nReturn\n(string) Keys performing “backspace” action.\n\n\n\n\ncr()\n\nMiniPairs.cr({key})\n\nProcess i_&lt;CR&gt;\nUsed as :map-&lt;expr&gt; mapping for &lt;CR&gt; in insert mode. It puts “close” symbol on next line (via &lt;CR&gt;&lt;C-o&gt;O) if neighborhood is equal to a whole pair recognized for current buffer. Pair is recognized for current buffer if it is registered for global or current buffer mapping. Pair is registered as a result of calling MiniPairs.map() or MiniPairs.map_buf().\nNote: some relevant mode changing events are temporarily ignored (with ‘eventignore’) to counter effect of using i_CTRL-O.\nMapped by default inside MiniPairs.setup().\n\nParameters\n{key} (string|nil) Key to use. Default: '&lt;CR&gt;'.\n\n\nReturn\n(string) Keys performing “new line” action."
  },
  {
    "objectID": "mini.nvim/doc/mini-base16.html",
    "href": "mini.nvim/doc/mini-base16.html",
    "title": "mini.base16 documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.base16 Base16 colorscheme creation\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFast implementation of chriskempson/base16 color scheme (with Copyright (C) 2012 Chris Kempson) adapted for modern Neovim Lua plugins. Extra features:\n\nConfigurable automatic support of cterm colors (see highlight-cterm).\nOpinionated palette generator based only on background and foreground colors.\n\nSupported highlight groups:\n\nBuilt-in Neovim LSP and diagnostic.\nPlugins (either with explicit definition or by verification that default highlighting works appropriately):\n\nnvim-mini/mini.nvim\nakinsho/bufferline.nvim\nanuvyklack/hydra.nvim\nDanilaMihailov/beacon.nvim\nfolke/lazy.nvim\nfolke/noice.nvim\nfolke/todo-comments.nvim\nfolke/trouble.nvim\nfolke/which-key.nvim\nggandor/leap.nvim\nggandor/lightspeed.nvim\nglepnir/dashboard-nvim\nglepnir/lspsaga.nvim\nHiPhish/rainbow-delimiters.nvim\nhrsh7th/nvim-cmp\njustinmk/vim-sneak\nibhagwan/fzf-lua\nkevinhwang91/nvim-bqf\nkevinhwang91/nvim-ufo\nlewis6991/gitsigns.nvim\nlukas-reineke/indent-blankline.nvim\nMeanderingProgrammer/render-markdown.nvim\nneoclide/coc.nvim\nNeogitOrg/neogit\nnvim-lualine/lualine.nvim\nnvim-neo-tree/neo-tree.nvim\nnvim-telescope/telescope.nvim\nnvim-tree/nvim-tree.lua\nOXY2DEV/helpview.nvim\nOXY2DEV/markview.nvim\nphaazon/hop.nvim\nrcarriga/nvim-dap-ui\nrcarriga/nvim-notify\nrlane/pounce.nvim\nromgrk/barbar.nvim\nstevearc/aerial.nvim\nwilliamboman/mason.nvim\n\n\n\nSetup\nThis module needs a setup with require('mini.base16').setup({}) (replace {} with your config table). It will create global Lua table MiniBase16 which you can use for scripting or manually (with :lua MiniBase16.*).\nSee MiniBase16.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minibase16_config will have no effect here.\nExample:\nrequire('mini.base16').setup({\n  palette = {\n    base00 = '#112641',\n    base01 = '#3a475e',\n    base02 = '#606b81',\n    base03 = '#8691a7',\n    base04 = '#d5dc81',\n    base05 = '#e2e98f',\n    base06 = '#eff69c',\n    base07 = '#fcffaa',\n    base08 = '#ffcfa0',\n    base09 = '#cc7e46',\n    base0A = '#46a436',\n    base0B = '#9ff895',\n    base0C = '#ca6ecf',\n    base0D = '#42f7ff',\n    base0E = '#ffc4ff',\n    base0F = '#00a5c5',\n  },\n  use_cterm = true,\n  plugins = {\n    default = false,\n    ['nvim-mini/mini.nvim'] = true,\n  },\n})\n\n\nNotes\n\nThis is used to create some of plugin’s color schemes (see MiniBase16-color-schemes).\nUsing setup() doesn’t actually create a :colorscheme. It basically creates a coordinated set of highlight-groups. To create your own theme:\n\nPut “myscheme.lua” file (name after your chosen theme name) inside any “colors” directory reachable from ‘runtimepath’ (“colors” inside your Neovim config directory is usually enough).\nInside “myscheme.lua” call require('mini.base16').setup() with your palette and only after that set g:colors_name to “myscheme”.\n\n\n\n\n\n\nColor schemes\n\nBase16 colorschemes\nThis module comes with several pre-built color schemes. Each of them is a mini.base16 theme created with faster version of the following Lua code:\nrequire('mini.base16').setup({ palette = palette, use_cterm = true })\nActivate them as regular :colorscheme (for example, :colorscheme minischeme).\n\nminischeme\nminischeme\nBlue and yellow main colors with high contrast and saturation palette. Palettes are:\n-- For dark 'background':\nMiniBase16.mini_palette('#112641', '#e2e98f', 75)\n\n-- For light 'background':\nMiniBase16.mini_palette('#e2e5ca', '#002a83', 75)\n\n\nminicyan\nminicyan\nCyan and grey main colors with moderate contrast and saturation palette. Palettes are:\n-- For dark 'background':\nMiniBase16.mini_palette('#0A2A2A', '#D0D0D0', 50)\n\n-- For light 'background':\nMiniBase16.mini_palette('#C0D2D2', '#262626', 80)\n\n\n\n\n\nsetup()\n\nMiniBase16.setup({config})\n\nModule setup\nSetup is done by applying base16 palette to enable colorscheme. Highlight groups make an extended set from original base16-vim plugin. It is a good idea to have config.palette respect the original styling principles.\nBy default only ‘gui highlighting’ (see highlight-gui and ‘termguicolors’) is supported. To support ‘cterm highlighting’ (see highlight-cterm) supply config.use_cterm argument in one of the formats:\n\ntrue to auto-generate from palette (as closest colors).\nTable with similar structure to palette but having terminal colors (integers from 0 to 255) instead of hex strings.\n\n\nParameters\n{config} (table) Module config table. See MiniBase16.config.\n\n\nUsage\nrequire('mini.base16').setup({}) -- replace {} with your config table\n                                 -- needs `palette` field present\n\n\n\n\nconfig\n\nMiniBase16.config\n\n\nDefaults\nMiniBase16.config = {\n  -- Table with names from `base00` to `base0F` and values being strings of\n  -- HEX colors with format \"#RRGGBB\". NOTE: this should be explicitly\n  -- supplied in `setup()`.\n  palette = nil,\n\n  -- Whether to support cterm colors. Can be boolean, `nil` (same as\n  -- `false`), or table with cterm colors. See `setup()` documentation for\n  -- more information.\n  use_cterm = nil,\n\n  -- Plugin integrations. Use `default = false` to disable all integrations.\n  -- Also can be set per plugin (see |MiniBase16.config|).\n  plugins = { default = true },\n}\n\n\nPlugin integrations\nconfig.plugins defines for which supported plugins highlight groups will be created. Limiting number of integrations slightly decreases startup time. It is a table with boolean (true/false) values which are applied as follows:\n\nIf plugin name (as listed in mini.base16) has entry, it is used.\nOtherwise config.plugins.default is used.\n\nExample which will load only “mini.nvim” integration:\nrequire('mini.base16').setup({\n  palette = require('mini.base16').mini_palette('#112641', '#e2e98f', 75),\n  plugins = {\n    default = false,\n    ['nvim-mini/mini.nvim'] = true,\n  }\n})\n\n\n\n\nmini_palette()\n\nMiniBase16.mini_palette({background}, {foreground}, {accent_chroma})\n\nCreate ‘mini’ palette\nCreate base16 palette based on the HEX (string ‘#RRGGBB’) colors of main background and foreground with optional setting of accent chroma (see details).\n\nAlgorithm design\n\nMain operating color space is CIELCh(uv) which is a cylindrical representation of a perceptually uniform CIELUV color space. It defines color by three values: lightness L (values from 0 to 100), chroma (positive values), and hue (circular values from 0 to 360 degrees). Useful converting tool: https://www.easyrgb.com/en/convert.php\nThere are four important lightness values: background, foreground, focus (around the middle of background and foreground, leaning towards foreground), and edge (extreme lightness closest to foreground).\nFirst four colors have the same chroma and hue as background but lightness progresses from background towards focus.\nSecond four colors have the same chroma and hue as foreground but lightness progresses from foreground towards edge in such a way that ‘base05’ color is main foreground color.\nThe rest eight colors are accent colors which are created in pairs\n\nEach pair has same hue from set of hues ‘most different’ to background and foreground hues (if respective chorma is positive).\nAll colors have the same chroma equal to accent_chroma (if not provided, chroma of foreground is used, as they will appear next to each other). Note: this means that in case of low foreground chroma, it is a good idea to set accent_chroma manually. Values from 30 (low chorma) to 80 (high chroma) are common.\nWithin pair there is base lightness (equal to foreground lightness) and alternative (equal to focus lightness). Base lightness goes to colors which will be used more frequently in code: base08 (variables), base0B (strings), base0D (functions), base0E (keywords). How exactly accent colors are mapped to base16 palette is a result of trial and error. One rule of thumb was: colors within one hue pair should be more often seen next to each other. This is because it is easier to distinguish them and seems to be more visually appealing. That is why base0D and base0F have same hues because they usually represent functions and delimiter (brackets included).\n\n\n\n\nParameters\n{background} (string) Background HEX color (formatted as #RRGGBB).\n{foreground} (string) Foreground HEX color (formatted as #RRGGBB).\n{accent_chroma} (number) Optional positive number (usually between 0 and 100). Default: chroma of foreground color.\n\n\nReturn\n(table) Table with base16 palette.\n\n\nUsage\nlocal p = require('mini.base16').mini_palette('#112641', '#e2e98f', 75)\nrequire('mini.base16').setup({ palette = p })\n\n\n\n\nrgb_palette_to_cterm_palette()\n\nMiniBase16.rgb_palette_to_cterm_palette({palette})\n\nConverts palette with RGB colors to terminal colors\nUseful for caching use_cterm variable to increase speed.\n\nParameters\n{palette} (table) Table with base16 palette (same as in MiniBase16.config.palette).\n\n\nReturn\n(table) Table with base16 palette using highlight-cterm."
  },
  {
    "objectID": "mini.nvim/doc/mini-colors.html",
    "href": "mini.nvim/doc/mini-colors.html",
    "title": "mini.colors documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.colors Tweak and save any color scheme\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nCreate colorscheme object: either manually (MiniColors.as_colorscheme()) or by querying present color schemes (including currently active one; see MiniColors.get_colorscheme()).\nInfer data about color scheme and/or modify based on it:\n\nAdd transparency by removing background color (requires transparency in terminal emulator).\nInfer cterm attributes (cterm-colors) based on gui colors making it compatible with ‘notermguicolors’.\nResolve highlight group links (:highlight-link).\nCompress by removing redundant highlight groups.\nExtract palette of used colors and/or infer terminal colors (terminal-config) based on it.\n\nModify colors to better fit your taste and/or goals (see more in MiniColors-colorscheme-methods):\n\nApply any function to color hex string.\nUpdate channels (like lightness, saturation, hue, temperature, red, green, blue, etc.; see more in MiniColors-channels). Use either own function or one of the implemented methods:\n\nAdd value to channel or multiply it by coefficient. Like “add 10 to saturation of every color” or “multiply saturation by 2” to make colors more saturated (less gray).\nInvert. Like “invert lightness” to convert between dark/light theme.\nSet to one or more values (picks closest to current one). Like “set to one or two hues” to make mono- or dichromatic color scheme.\nRepel from certain source(s) with stronger effect for closer values. Like “repel from hue 30” to remove red color from color scheme. Repel hue (how much is removed) is configurable.\n\nSimulate color vision deficiency.\n\nOnce color scheme is ready, either apply it to see effects right away or write it into a Lua file as a fully functioning separate color scheme.\nExperiment interactively with a feedback (MiniColors.interactive()).\nAnimate transition between color schemes either with MiniColors.animate() or with :Colorscheme user command.\nConvert within supported color spaces (MiniColors.convert()):\n\nHex string.\n8-bit number (terminal colors).\nRGB.\nOklab, Oklch, Okhsl (https://bottosson.github.io/posts/oklab/).\n\n\nNotes:\n\nThere is a collection of MiniColors-recipes with code snippets for some common tasks.\nThere is no goal to support as many color spaces as possible, only the already present ones.\n\n\nTweak quick start\n\nExecute :lua require('mini.colors').interactive().\nExperiment by writing calls to exposed color scheme methods and applying them with &lt;M-a&gt;. For more information, see MiniColors-colorscheme-methods and MiniColors-recipes.\nIf you are happy with result, write color scheme with &lt;M-w&gt;. If not, reset to initial color scheme with &lt;M-r&gt;.\nIf only some highlight groups can be made better, adjust them manually inside written color scheme file.\n\n\n\nSetup\nThis module doesn’t need setup, but it can be done to improve usability. Setup with require('mini.colors').setup({}) (replace {} with your config table). It will create global Lua table MiniColors which you can use for scripting or manually (with :lua MiniColors.*).\nSee MiniColors.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minicolors_config will have no effect here.\n\n\nComparisons\n\nrktjmp/lush.nvim:\n\nOriented towards tweaking separate highlight groups, while ‘mini.colors’ is more designed to work with color scheme as a whole.\nUses HSL and HSLuv color spaces, while ‘mini.colors’ uses Oklab, Oklch, and Okhsl which have slightly better perceptual uniformity properties.\nDoesn’t have functionality to infer and repair missing data in color scheme (like cterm attributes, terminal colors, transparency, etc.), while ‘mini.colors’ does.\nDoesn’t implement animation of color scheme transition, while ‘mini.colors’ does.\n\nlifepillar/vim-colortemplate:\n\nComparisons are similar to that of ‘rktjmp/lush.nvim’.\n\ntjdevries/colorbuddy.nvim:\n\nComparisons are similar to that of ‘rktjmp/lush.nvim’.\n\n\n\n\n\n\nRecipes\nAll following code snippets assume to be executed inside interactive buffer (MiniColors.interactive()). They are directly copy-pasteable.\nTo apply single method to current color scheme, use\n:lua MiniColors.get_colorscheme():&lt;method goes here&gt;:apply().\nRecipes:\n\nTweak lightness:\n-- Invert dark/light color scheme to be light/dark\nchan_invert('lightness', { gamut_clip = 'cusp' })\n\n-- Ensure constant contrast ratio\nchan_set('lightness', 15, { filter = 'bg' })\nchan_set('lightness', 85, { filter = 'fg' })\nTweak saturation:\n-- Make background colors less saturated and foreground - more\nchan_add('saturation', -20, { filter = 'bg' })\nchan_add('saturation', 20,  { filter = 'fg' })\n\n-- Convert to grayscale\nchan_set('saturation', 0)\nTweak hue:\n-- Create monochromatic variant (this uses green color)\nchan_set('hue', 135)\n\n-- Create dichromatic variant (this uses Neovim-themed hues)\nchan_set('hue', { 140, 245 })\nTweak temperature:\n-- Invert temperature (make cold theme become warm and vice versa)\nchan_invert('temperature')\n\n-- Make background colors colder and foreground warmer\nchan_add('temperature', -40, { filter = 'bg' })\nchan_add('temperature', 40,  { filter = 'fg' })\nCounter color vision deficiency (try combinations of these to see which one works best for you):\n\nImprove text saturation contrast (usually the best starting approach):\nchan_set('saturation', { 10, 90 }, { filter = 'fg' })\nRemove certain hues from all colors (use 30 for red, 90 for yellow, 135 for green, 270 for blue):\n-- Repel red color\nchan_repel('hue', 30, 45)\nForce equally spaced palette (remove ones with which you know you have trouble):\n-- Might be a good choice for red-green color blindness\nchan_set('hue', { 90, 180, 270})\n\n-- Might be a good choice for blue-yellow color blindness\nchan_set('hue', { 0, 90, 180 })\nInverting temperature or pressure can sometimes improve readability:\nchan_invert('temperature')\nchan_invert('pressure')\nIf all hope is lost, hue random generation might help if you are lucky:\nchan_modify('hue', function() return math.random(0, 359) end)\n\nFor color scheme creators use MiniColors-colorscheme:simulate_cvd() to simulate various color vision deficiency types to see how color scheme would look in the eyes of color blind person.\n\n\n\n\nColor spaces\nColor space is a way to quantitatively describe a color. In this module color spaces are used both as source for MiniColors-channels and inputs for MiniColors.convert()\nList of supported color spaces (along with their id in parenthesis):\n\n8-bit (8-bit) - integer between 16 and 255. Usually values 0-15 are also supported, but they depend on terminal emulator theme which is not reliable. See https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit .\nHex (hex) - string of the form “#xxxxxx” where x is a hexadecimal number.\nRGB (rgb) - table with numeric fields r (red), g (green), b (blue). Visible range is from 0 to 255.\nOklab (oklab) - table with fields l (lightness; numeric in [0; 100]), a, b (both are unbounded numeric; visible range is usually between -30 to 30). Field l describes how light is color; a - how “green-red” it is; b - how “blue-yellow” it is.\nOklch (oklch) - table with fields l (same as in Oklab), c (chroma; positive numeric, visible range usually lower than 32), h (nil for grays or periodic numeric in [0, 360)). Field c describes how colorful a color is; h is a value of “true color” on color circle/wheel. NOTE: gray colors, being achromatic by nature, don’t have hue.\nOkhsl (okhsl) - Oklch but with c replaced by s (saturation; numeric in [0; 100]). Field s describes a percent of chroma relative to maximum visible chroma for the particular lightness and hue combination. Note, that mathematical model used to compute maximum visible chroma is approximate which might lead to inaccuracies for highly saturated colors with relatively low or high lightness.\n\nSources for Oklab/Oklch/Okhsl:\n\nhttps://bottosson.github.io/posts/oklab/ - initial derivation and introduction of Oklab and Oklch.\nhttps://bottosson.github.io/misc/colorpicker - interactive color picker. Great way for a hands-on introduction to concepts of lightness, chroma, saturation, and hue.\n\nNote that Oklab/Oklch/Okhsl use channel normalization for l, a, b, c, s that is more oriented towards integer numbers (according to the above sources). Some implementations (like in CSS) are more oriented towards [0; 1] range or percentages. Adjust accordingly by dividing/multiplying output by 100. Also use adjust_lightness = false in MiniColors.convert().\n\nGamut clip\nMiniColors-gamut-clip\nIn Neovim highlight group colors are usually specified by their red, green, and blue values from 0 to 255 in the form of HEX string (see gui-colors). Although plenty, these are not all possible colors.\nWhen performing color manipulation using MiniColors-colorscheme-methods, it is possible to end up with “impossible” color (which can’t be directly converted to HEX string). For example, inverting lightness of color “#fce094” will lead to a color { l = 10, c = 10, h = 90 } in Oklch space, i.e. “dark yellow” which is impossible to show in HEX.\nGamut clipping is an action of converting color outside of visible gamut (colors representable with HEX string) to be inside it while preserving certain perceptual characteristics as much as possible.\nGamut clipping in this module is done inside Oklch color space. The goal is to preserve hue as much as possible while manipulating lightness and/or chroma.\nList of supported gamut clip methods (along with their id in parenthesis):\n\nClip chroma ('chroma') - reduce chroma while preserving lightness until color is inside visible gamut. Default method.\nClip lightness ('lightness') - reduce lightness while preserving chroma until color is inside visible gamut.\nClip according to “cusp” ('cusp') - reduce both lightness and chroma in a compromise way depending on hue. Cusp is a color with the highest chroma inside slice of visible gamut with the same hue (hue leaf). It is called that way because the slice has a roughly triangular shape with points at (0, 0) - (0, 100) - “cusp” in (chroma, lightness) coordinates. Gamut clipping using “cusp” as reference is done by changing color towards (0, cusp_lightness) point (gray with lightness equal to that of a current cusp) until color is inside visible gamut.\n\nIn short:\n\nUsually 'chroma' is enough.\nIf colors are too desaturated - try 'cusp'.\nIf still not colorful enough - try 'lightness'.\n\nNotes:\n\nCurrently implemented formulas are approximate (by design; to reduce code complexity) so there might be problems for highly saturated colors with relatively low or high lightness.\n\n\n\n\n\nChannels\nA color channel is a number describing one particular aspect of a color. It is usually direct or modified coordinate of a color space. See MiniColors-color-spaces for information on color spaces.\nList of supported channels (along with their id in parenthesis):\n\nLightness (lightness) - corrected l component of Oklch. Describes how light is a color. Ranges from 0 (black dark) to 100 (white light).\nChroma (chroma) - c component of Oklch. Describes how colorful is a color in absolute units. Ranges from 0 (gray) to infinity (more like around 30 in practice).\nSaturation (saturation) - s component of Okhsl. Describes how colorful is color in relative units. Ranges from 0 (gray) to 100 (maximum saturation for a given lightness-hue pair).\nHue (hue) - h component of Oklch. Describes “true color value” (like red/green/blue) as a number. It is a periodic value from 0 (included) to 360 (not included). Best perceived as a degree on a color circle/wheel.\nApproximate values for common color names:\n\n0 - pink.\n30 - red.\n60 - orange.\n90 - yellow.\n135 - green.\n180 - cyan.\n225 - light blue.\n270 - blue.\n315 - magenta/purple.\n\nTemperature (temperature) - circular distance from current hue to hue 270 angle (blue). Ranges from 0 (cool) to 180 (hot) anchored at hues 270 (blue) and 90 (yellow). Similar to b channel but tries to preserve chroma.\nPressure (pressure) - circular distance from current hue to hue 180. Ranges from 0 (low; green-ish) to 180 (high; red-ish) anchored at hues 180 and 0. Similar to a channel but tries to preserve chroma. Not widely used; added to have something similar to temperature.\na (a) - a component of Oklab. Describes how “green-red” a color is. Can have any value. Negative values are “green-ish”, positive - “red-ish”.\nb (b) - b component of Oklab. Describes how “blue-yellow” a color is. Can have any value. Negative values are “blue-ish”, positive - “yellow-ish”.\nRed (red) - r component of RGB. Describes how much red a color has. Ranges from 0 (no red) to 255 (full red).\nGreen (green) - g component of RGB. Describes how much green a color has. Ranges from 0 (no green) to 255 (full green).\nBlue (blue) - b component of RGB. Describes how much blue a color has. Ranges from 0 (no blue) to 255 (full blue).\n\n\n\n\nColorscheme\nColorscheme object is a central structure of this module. It contains all data relevant to colors in fields and provides methods to modify it.\nCreate colorscheme object manually with MiniColors.as_colorscheme():\nMiniColors.as_colorscheme({\n  name = 'my_cs',\n  groups = {\n    Normal   = { fg = '#dddddd', bg = '#222222' },\n    SpellBad = { sp = '#dd2222', undercurl = true },\n  },\n  terminal = { [0] = '#222222', [1] = '#dd2222' },\n})\nGet any registered color scheme (including currently active) as colorscheme object with MiniColors.get_colorscheme():\n-- Get current color scheme\nMiniColors.get_colorscheme()\n\n-- Get registered color scheme by name\nMiniColors.get_colorscheme('minischeme', { new_name = 'maxischeme' })\n\nClass\n{Colorscheme}\nMiniColors-colorscheme-fields\n\n\nFields\n{name} (string|nil) Name of the color scheme (as in g:colors_name).\n{groups} (table|nil) Table with highlight groups data. Keys are group names appropriate for name argument of nvim_set_hl(), values - tables appropriate for its val argument. Note: gui colors are accepted only in short form (fg, bg, sp).\n{terminal} (table|nil) Table with terminal colors data (terminal-config). Keys are numbers from 0 to 15, values - strings representing color (hex string or plain color name; see nvim_get_color_by_name()).\n\n\nMethods\nMiniColors-colorscheme-methods\nNotes about all methods:\n\nThey never modify underlying colorscheme object instead returning deep copy with modified fields.\nThey accept self colorscheme object as first argument meaning they should be called with : notation (like cs:method()).\n\nExample calling methods:\n-- Get current color scheme, set hue of colors to 135, infer cterm\n-- attributes and apply\nlocal cs = MiniColors.get_colorscheme()\ncs:chan_set('hue', 135):add_cterm_attributes():apply()\n\nadd_cterm_attributes()\nMiniColors-colorscheme:add_cterm_attributes()\nInfer cterm-colors based on present gui-colors. It updates ctermbg/ctermfg based on fg/bg by approximating in perceptually uniform distance in Oklab space (MiniColors-color-spaces).\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;force&gt; (boolean) - Whether to replace already present cterm attributes with inferred ones. Default: true.\n\n\n\n\nadd_terminal_colors()\nMiniColors-colorscheme:add_terminal_colors()\nInfer terminal colors (terminal-config) based on colorscheme palette (see MiniColors-colorscheme:get_palette()). It updates terminal field based on color scheme’s palette by picking the most appropriate entry to represent terminal color. Colors from 0 to 7 are attempted to be black, red, green, yellow, blue, magenta, cyan, white. Colors from 8 to 15 are the same as from 0 to 7.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;force&gt; (boolean) - Whether to replace already present terminal colors with inferred ones. Default: true.\n&lt;palette_args&gt; (table) - MiniColors-colorscheme:get_palette() arguments.\n\n\n\n\nadd_transparency()\nMiniColors-colorscheme:add_transparency()\nAdd transparency by removing background from a certain highlight groups. Requires actual transparency from terminal emulator to see background image. Has no effect on linked groups; use MiniColors-colorscheme:resolve_links() explicitly before applying transparency.\n\nParameters\n{opts} (table|nil) Options. Possible fields can be used to configure which sets of highlight groups to update:\n\n&lt;general&gt; (boolean) - general groups (like Normal). Default: true.\n&lt;float&gt; (boolean) - built-in groups for floating windows. Default: false.\n&lt;statuscolumn&gt; (boolean) - groups related to ‘statuscolumn’ (signcolumn, numbercolumn, foldcolumn, DiagnosticSignXxx, and XxxMsg groups). Also updates groups for all currently defined signs. Default: false.\n&lt;statusline&gt; (boolean) - built-in groups for ‘statusline’. Default: false.\n&lt;tabline&gt; (boolean) - built-in groups for ‘tabline’. Default: false.\n&lt;winbar&gt; (boolean) - built-in groups for ‘winbar’. Default: false.\n\n\n\n\napply()\nMiniColors-colorscheme:apply()\nApply colorscheme:\n\nSet g:colors_name to a name field.\nApply highlight groups in a groups field.\nSet terminal colors from a terminal field.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;clear&gt; (boolean) - whether to execute :hi-clear first. Default: true.\n\n\n\n\nchan_add()\nMiniColors-colorscheme:chan_add()\nAdd value to a channel (see MiniColors-channels).\n\nParameters\n{channel} (string) One of supported MiniColors-channels.\n{value} (number) Number to add (can be negative).\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function|string) - filter colors to update. Possible values:\n\nString representing target attributes. One of 'fg', 'bg', 'sp', 'term' (only terminal colors).\nCallable with signature as in MiniColors-colorscheme:color_modify(). Default: nil to update all colors.\n\n&lt;gamut_clip&gt; (string) - gamut clipping method. One of 'chroma', 'lightness', 'cusp'. See MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\n\nchan_invert()\nMiniColors-colorscheme:chan_invert()\nInvert value in a channel (see MiniColors-channels).\nNotes:\n\nMost Oklab/Oklch inversions are not exactly invertible: applying it twice might lead to slightly different colors depending on gamut clip method (MiniColors-gamut-clip) like smaller chroma with default 'chroma' method.\n\n\nParameters\n{channel} (string) One of supported MiniColors-channels.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function|string) - filter colors to update. Possible values:\n\nString representing target attributes. One of 'fg', 'bg', 'sp', 'term' (only terminal colors).\nCallable with signature as in MiniColors-colorscheme:color_modify(). Default: nil to update all colors.\n\n&lt;gamut_clip&gt; (string) - gamut clipping method. One of 'chroma', 'lightness', 'cusp'. See MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\n\nchan_modify()\nMiniColors-colorscheme:chan_modify()\nModify channel with a callable.\n\nParameters\n{channel} (string) One of supported MiniColors-channels.\n{f} (function) - callable which defines modification. Should take current value of a channel and return a new one.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function|string) - filter colors to update. Possible values:\n\nString representing target attributes. One of 'fg', 'bg', 'sp', 'term' (only terminal colors).\nCallable with signature as in MiniColors-colorscheme:color_modify(). Default: nil to update all colors.\n\n&lt;gamut_clip&gt; (string) - gamut clipping method. One of 'chroma', 'lightness', 'cusp'. See MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\n\nchan_multiply()\nMiniColors-colorscheme:chan_multiply()\nMultiply value of a channel (see MiniColors-channels).\n\nParameters\n{channel} (string) One of supported MiniColors-channels.\n{coef} (number) Number to multiply with (can be negative).\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function|string) - filter colors to update. Possible values:\n\nString representing target attributes. One of 'fg', 'bg', 'sp', 'term' (only terminal colors).\nCallable with signature as in MiniColors-colorscheme:color_modify(). Default: nil to update all colors.\n\n&lt;gamut_clip&gt; (string) - gamut clipping method. One of 'chroma', 'lightness', 'cusp'. See MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\n\nchan_repel()\nMiniColors-colorscheme:chan_repel()\nRepel from certain sources.\nGiven an array of repel centers (sources) and repel degree (coef) add to current channel value some amount (“nudge”) with the following properties:\n\nNudges from several sources are added together.\nNudge is directly proportional to coef: bigger coef means bigger nudge.\nNudge is inversely proportional to the distance between current value and source: for positive coef bigger distance means smaller nudge, i.e. repel effect weakens with distance.\nWith positive coef nudges close to source are computed in a way to remove whole [source - coef; source + coef] range.\nNegative coef results into attraction to source. Nudges in [source - coef; source + coef] range are computed to completely collapse it into source.\n\nExamples:\n-- Repel hue from red color removing hue in range from 20 to 40\nchan_repel('hue', 30, 10)\n\n-- Attract hue to red color collapsing [20; 40] range into 30.\nchan_repel('hue', 30, -10)\n\nParameters\n{channel} (string) One of supported MiniColors-channels.\n{sources} (table|number) Single or multiple source from which to repel.\n{coef} (number) Repel degree (can be negative to attract).\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function|string) - filter colors to update. Possible values:\n\nString representing target attributes. One of 'fg', 'bg', 'sp', 'term' (only terminal colors).\nCallable with signature as in MiniColors-colorscheme:color_modify(). Default: nil to update all colors.\n\n&lt;gamut_clip&gt; (string) - gamut clipping method. One of 'chroma', 'lightness', 'cusp'. See MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\n\nchan_set()\nMiniColors-colorscheme:chan_set()\nSet channel to certain value(s). This can be used to ensure that channel has value(s) only within supplied set. If more than one is supplied, closest element to current value is used.\n\nParameters\n{channel} (string) One of supported MiniColors-channels.\n{values} (table|number) Single or multiple values to set.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function|string) - filter colors to update. Possible values:\n\nString representing target attributes. One of 'fg', 'bg', 'sp', 'term' (only terminal colors).\nCallable with signature as in MiniColors-colorscheme:color_modify(). Default: nil to update all colors.\n\n&lt;gamut_clip&gt; (string) - gamut clipping method. One of 'chroma', 'lightness', 'cusp'. See MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\n\ncolor_modify()\nMiniColors-colorscheme:color_modify()\nModify all colors with a callable. It should return new color value (hex string or nil to remove attribute) base on the following input:\n\nCurrent color as hex string.\nData about the color: a table with fields:\n\n&lt;attr&gt; - one of 'fg', 'bg', 'sp', and 'term' for terminal color.\n&lt;name&gt; - name of color source. Either a name of highlight group or string of the form terminal_color_x for terminal color (as in terminal-config).\n\n\nExample:\n-- Set to '#dd2222' all foreground colors for groups starting with \"N\"\ncolor_modify(function(hex, data)\n  if data.attr == 'fg' and data.name:find('^N') then\n    return '#dd2222'\n  end\n  return hex\nend)\n\nParameters\n{f} (function) Callable returning new color value.\n\n\n\ncompress()\nMiniColors-colorscheme:compress()\nRemove redundant highlight groups. These are one of the two kinds:\n\nHaving values identical to ones after :hi-clear (meaning they usually don’t add new information).\nComing from a curated list of plugins with highlight groups usually not worth keeping around. Current list of such plugins:\n\nnvim-tree/nvim-web-devicons\nnorcalli/nvim-colorizer.lua\n\n\nThis method is useful to reduce size of color scheme before writing into the file with MiniColors-colorscheme:write().\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;plugins&gt; (boolean) - whether to remove highlight groups from a curated list of plugins. Default: true.\n\n\n\n\nget_palette()\nMiniColors-colorscheme:get_palette()\nGet commonly used colors. This basically counts number of all color occurrences and filter out rare ones.\nIt is usually a good idea to apply both MiniColors-colorscheme:compress() and MiniColors-colorscheme:resolve_links() before applying this.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;threshold&gt; (number) - relative threshold for groups to keep. A group is not included in output if it has less than this many occurrences relative to a total number of colors. Default: 0.01.\n\n\n\n\nresolve_links()\nMiniColors-colorscheme:resolve_links()\nResolve links (:highlight-link). This makes all highlight groups with link attribute have data from a linked one.\nNotes:\n\nResolves nested links.\nIf some group is linked to a group missing in current colorscheme object, it is not resolved.\n\n\n\nsimulate_cvd()\nMiniColors-colorscheme:simulate_cvd()\nSimulate color vision deficiency (CVD, color blindness). This is basically a wrapper using MiniColors.simulate_cvd() as a part of call to MiniColors-colorscheme:color_modify() method.\n\nParameters\n{cvd_type} (string) One of 'protan', 'deutan', 'tritan', 'mono'.\n{severity} (number|nil) Severity of CVD, number between 0 and 1. Default: 1.\n\n\n\nwrite()\nMiniColors-colorscheme:write()\nWrite color scheme to a file. It will be a Lua script readily usable as a regular color scheme. Useful to both save results of color scheme tweaking and making local snapshot of some other color scheme.\nSourcing this file on startup usually leads to a better performance that sourcing initial color scheme, as it is essentially a conditioned :hi-clear call followed by a series of nvim_set_hl() calls.\nDefault writing location is a “colors” directory of your Neovim config directory (see base-directories). After writing, it should be available for sourcing with :colorscheme or :Colorscheme.\nName of the file by default is taken from name field ('mini_colors' is used if it is nil). If color scheme with this name already exists, it appends prefix based on current time to make it unique.\nNotes:\n\nIf colors were updated, it is usually a good idea to infer cterm attributes with MiniColors-colorscheme:add_cterm_attributes() prior to writing.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;compress&gt; (boolean) - whether to call MiniColors-colorscheme:compress() prior to writing. Default: true.\n&lt;name&gt; (string|nil) - basename of written file. Default: nil to infer from name field.\n&lt;directory&gt; (string) - directory to where file should be saved. Default: “colors” subdirectory of Neovim home config (stdpath(\"config\")).\n\n\n\n\n\n\n\nsetup()\n\nMiniColors.setup({config})\n\nModule setup\n\n:Colorscheme\n:Colorscheme\nCalling this function creates a :Colorscheme user command. It takes one or more registered color scheme names and performs animated transition between them (starting from currently active color scheme). It uses MiniColors.animate() with default options.\n\n\nParameters\n{config} (table|nil) Module config table. See MiniColors.config.\n\n\nUsage\nrequire('mini.colors').setup() -- use default config\n-- OR\nrequire('mini.colors').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniColors.config\n\n\nDefaults\nMiniColors.config = {}\n\n\n\n\nas_colorscheme()\n\nMiniColors.as_colorscheme({x})\n\nCreate colorscheme object\n\nParameters\n{x} (table) Table to be transformed into MiniColors-colorscheme object.\n\n\nReturn\n(table) Copy of x transformed into a colorscheme object.\n\n\n\n\nget_colorscheme()\n\nMiniColors.get_colorscheme({name}, {opts})\n\nGet colorscheme object from registered color scheme\n\nParameters\n{name} (string|nil) Name of color scheme to use. If nil (default) creates colorscheme object based on currently active data (g:colors_name, highlight groups, terminal colors). If string, converts color scheme with that name to a colorscheme object.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;new_name&gt; (string|nil) - new name of colorscheme object.\n\n\n\nReturn\n(table) Colorscheme object (MiniColors-colorscheme).\n\n\n\n\ninteractive()\n\nMiniColors.interactive({opts})\n\nStart interactive experiments\nCreate a special buffer in which user can write plain Lua code to tweak color scheme and apply to get visual feedback.\n\nGeneral principles\n\nInitial colorscheme object is fixed to interactive buffer on its creation.\nThere are special buffer convenience mappings:\n\nApply (source) current buffer content.\nReset color scheme (make initial colorscheme the current one).\nWrite to a file the result of applying current buffer content. This sources current content and calls MiniColors-colorscheme:write().\nQuit interactive buffer.\n\nUser is expected to iteratively tweak color scheme by writing general Lua code in interactive buffer and applying it using convenience mapping.\nApplication of interactive buffer is essentially these steps:\n\nExpose self as initial colorscheme object on any application. It is always the same for every application.\nExpose initial colorscheme methods as standalone functions. So instead of writing self = self:add_transparency() user can only write add_transparency().\nSource buffer content as plain Lua code.\n\n\nExample of interactive buffer content:\nchan_modify('hue', function() return math.random(0, 359) end)\nsimulate_cvd('protan')\nadd_cterm_attributes()\nadd_terminal_colors()\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;colorscheme&gt; (table|nil) - MiniColors-colorscheme object to be used as initial colorscheme for executed code. By default uses current color scheme.\n&lt;mappings&gt; table - buffer mappings for actions. Possible fields:\n\n&lt;Apply&gt; (string) - apply buffer code. Default: '&lt;M-a&gt;'.\n&lt;Reset&gt; (string) - apply initial color scheme as is. Default: '&lt;M-r&gt;'.\n&lt;Quit&gt; (string) - close interactive buffer. Default: '&lt;M-q&gt;'.\n&lt;Write&gt; (string) - write result of buffer code into a file. Prompts for file name with vim.ui.input() and then uses MiniColors-colorscheme:write() with other options being default. Default: '&lt;M-w&gt;'.\n\n\n\n\n\n\nanimate()\n\nMiniColors.animate({cs_array}, {opts})\n\nAnimate color scheme change\nStart from currently active color scheme and loop through cs_array.\nPowers :Colorscheme user command created in MiniColors.setup().\n\nParameters\n{cs_array} (table) Array of MiniColors-colorscheme objects.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;transition_steps&gt; (number) - number of intermediate steps to show during transition between two color schemes. Bigger values result in smoother visual feedback but require more computational power. Default: 25.\n&lt;transition_duration&gt; (number) - number of milliseconds to spend showing transition. Default: 1000.\n&lt;show_duration&gt; (number) - number of milliseconds to show intermediate color schemes (all but last in cs_array). Default: 1000.\n\n\n\n\n\nconvert()\n\nMiniColors.convert({x}, {to_space}, {opts})\n\nConvert between color spaces\nFor a list of supported colors spaces see MiniColors-color-spaces.\n\nParameters\n{x} (table|string|number|nil) Color to convert from. Its color space is inferred automatically.\n{to_space} (string) Id of allowed color space.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;adjust_lightness&gt; (boolean) - whether to adjust lightness value to have a more uniform progression from 0 to 100. Set false for results more compatible with some other Oklab/Oklch implementations (like in CSS). Source: “Intermission - a new lightness estimate for Oklab” section of https://bottosson.github.io/posts/colorpicker Default: true.\n&lt;gamut_clip&gt; (string) - method for MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\nReturn\n(table|string|number|nil) Color in space to_space or nil if input is nil.\n\n\n\n\nmodify_channel()\n\nMiniColors.modify_channel({x}, {channel}, {f}, {opts})\n\nModify channel\n\nParameters\n{x} (table|string|number|nil) Color which channel will be modified. Color space is inferred automatically.\n{channel} (string) One of supported MiniColors-channels.\n{f} (function) Callable which defines modification. Should take current value of a channel and return a new one.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;gamut_clip&gt; (string) - method for MiniColors-gamut-clip. Default: 'chroma'.\n\n\n\nReturn\n(string|nil) Hex string of color with modified channel or nil if input is nil.\n\n\n\n\nsimulate_cvd()\n\nMiniColors.simulate_cvd({x}, {cvd_type}, {severity})\n\nSimulate color vision deficiency\n\nParameters\n{x} (table|string|number|nil) Color to convert from. Its color space is inferred automatically.\n{cvd_type} (string) Type of CVD. One of 'protan', 'deutan', or 'mono' (equivalent to converting to graysacle).\n{severity} (number|nil) Severity of CVD. A number between 0 and 1 (default).\n\n\nReturn\n(string|nil) Hex string of simulated color or nil if input is nil."
  },
  {
    "objectID": "mini.nvim/doc/mini-ai.html",
    "href": "mini.nvim/doc/mini-ai.html",
    "title": "mini.ai documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.ai Extend and create a/i textobjects\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nEnhance some builtin text-objects (like a(, a), a’, and more), create new ones (like a*, a&lt;Space&gt;, af, a?, and more), and allow user to create their own.\nFeatures:\n\nCustomizable creation of a/i textobjects using Lua patterns and functions. Supports:\n\nDot-repeat.\nv:count.\nDifferent search methods (see MiniAi.config).\nConsecutive application (update selection without leaving Visual mode).\nAliases for multiple textobjects.\n\nComprehensive builtin textobjects (see more in MiniAi-builtin-textobjects):\n\nBalanced brackets (with and without whitespace) plus alias.\nBalanced quotes plus alias.\nFunction call.\nArgument.\nTag.\nDerived from user prompt.\nDefault for anything but Latin letters (to fall back to text-objects).\n\nFor more textobjects see MiniExtra.gen_ai_spec.\nMotions for jumping to left/right edge of textobject.\nSet of specification generators to tweak some builtin textobjects (see MiniAi.gen_spec).\nTreesitter textobjects (through MiniAi.gen_spec.treesitter() helper).\n\nThis module works by defining mappings for both a and i in Visual and Operator-pending mode. After typing, they wait for single character user input treated as textobject identifier and apply resolved textobject specification (fall back to other mappings if can’t find proper textobject id). For more information see MiniAi-textobject-specification and MiniAi-algorithm.\nKnown issues which won’t be resolved:\n\nSearch for builtin textobjects is done mostly using Lua patterns (regex-like approach). Certain amount of false positives is to be expected.\nDuring search for builtin textobjects there is no distinction if it is inside string or comment. For example, in the following case there will be wrong match for a function call: f(a = \")\", b = 1).\n\nGeneral rule of thumb: any instrument using available parser for document structure (like treesitter) will usually provide more precise results. This module has builtins mostly for plain text textobjects which are useful most of the times (like “inside brackets”, “around quotes/underscore”, etc.). For advanced use cases define function specification for custom textobjects.\nWhat it doesn’t (and probably won’t) do:\n\nHave special operators to specially handle whitespace (like I and A in ‘targets.vim’). Whitespace handling is assumed to be done inside textobject specification (like i( and i) handle whitespace differently).\n\n\nSetup\nThis module needs a setup with require('mini.ai').setup({}) (replace {} with your config table). It will create global Lua table MiniAi which you can use for scripting or manually (with :lua MiniAi.*).\nSee MiniAi.config for available config settings.\nYou can override runtime config settings (like config.custom_textobjects) locally to buffer inside vim.b.miniai_config which should have same structure as MiniAi.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nComparisons\n\nwellle/targets.vim:\n\nHas limited support for creating own textobjects: it is constrained to pre-defined detection rules. ‘mini.ai’ allows creating own rules via Lua patterns and functions (see MiniAi-textobject-specification).\nDoesn’t provide any programmatical API for getting information about textobjects. ‘mini.ai’ does it via MiniAi.find_textobject().\nHas no implementation of “moving to edge of textobject”. ‘mini.ai’ does it via MiniAi.move_cursor() and g[ and g] default mappings.\nBoth implement the notion of manual “next”/“last” search directions.\nImplements A, I operators. ‘mini.ai’ does not by design: it is assumed to be a property of textobject, not operator.\nDoesn’t implement “function call” and “user prompt” textobjects. ‘mini.ai’ does (with f and ? identifiers).\nHas limited support for “argument” textobject. Although it works in most situations, it often misdetects commas as argument separator (like if it is inside quotes or {}). ‘mini.ai’ deals with these cases.\n\nnvim-treesitter/nvim-treesitter-textobjects:\n\nAlong with textobject functionality provides a curated and maintained set of popular textobject queries for many languages (which can power MiniAi.gen_spec.treesitter() functionality).\nBoth support working with treesitter-directives allowing more fine-tuned textobjects.\nImplements only textobjects based on treesitter.\nDoesn’t support v:count.\nDoesn’t support multiple search method (basically, only ‘cover’).\nDoesn’t support consecutive application of target textobject.\n\n\n\n\nDisabling\nTo disable, set vim.g.miniai_disable (globally) or vim.b.miniai_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nBuiltin textobjects\nThis table describes all builtin textobjects along with what they represent. Explanation:\n\nKey represents the textobject identifier: single character which should be typed after a/i.\nName is a description of textobject.\nExample line contains a string for which examples are constructed. The * denotes the cursor position.\na/i describe inclusive region representing a and i textobjects. Use numbers in separators for easier navigation.\n2a/2i describe either 2a/2i (support for v:count) textobjects or a/i textobject followed by another a/i textobject (consecutive application leads to incremental selection).\n\nExample: typing va) with cursor on * leads to selection from column 2 to column 12. Another typing a) changes selection to [1; 13]. Also, besides visual selection, any operator can be used or g[/g] motions to move to left/right edge of a textobject.\n┌───┬───────────────┬──────────────────┬────────┬────────┬────────┬────────┐\n│Key│     Name      │   Example line   │   a    │   i    │   2a   │   2i   │\n├───┴───────────────┴──────────────────┴────────┴────────┴────────┴────────┤\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ ( │  Balanced ()  │ (( *a (bb) ))    │        │        │        │        │\n│ [ │  Balanced []  │ [[ *a [bb] ]]    │ [2;12] │ [4;10] │ [1;13] │ [2;12] │\n│ { │  Balanced {}  │ {{ *a {bb} }}    │        │        │        │        │\n│ &lt; │  Balanced &lt;&gt;  │ &lt;&lt; *a &lt;bb&gt; &gt;&gt;    │        │        │        │        │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ ) │  Balanced ()  │ (( *a (bb) ))    │        │        │        │        │\n│ ] │  Balanced []  │ [[ *a [bb] ]]    │        │        │        │        │\n│ } │  Balanced {}  │ {{ *a {bb} }}    │ [2;12] │ [3;11] │ [1;13] │ [2;12] │\n│ &gt; │  Balanced &lt;&gt;  │ &lt;&lt; *a &lt;bb&gt; &gt;&gt;    │        │        │        │        │\n│ b │  Alias for    │ [( *a {bb} )]    │        │        │        │        │\n│   │  ), ], or }   │                  │        │        │        │        │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ \" │  Balanced \"   │ \"*a\" \" bb \"      │        │        │        │        │\n│ ' │  Balanced '   │ '*a' ' bb '      │        │        │        │        │\n│ ` │  Balanced `   │ `*a` ` bb `      │ [1;4]  │ [2;3]  │ [6;11] │ [7;10] │\n│ q │  Alias for    │ '*a' \" bb \"      │        │        │        │        │\n│   │  \", ', or `   │                  │        │        │        │        │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ ? │  User prompt  │ e*e o e o o      │ [3;5]  │ [4;4]  │ [7;9]  │ [8;8]  │\n│   │(typed e and o)│                  │        │        │        │        │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ t │      Tag      │ &lt;x&gt;&lt;y&gt;*a&lt;/y&gt;&lt;/x&gt; │ [4;12] │ [7;8]  │ [1;16] │ [4;12] │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ f │ Function call │ f(a, g(*b, c) )  │ [6;13] │ [8;12] │ [1;15] │ [3;14] │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ a │   Argument    │ f(*a, g(b, c) )  │ [3;5]  │ [3;4]  │ [5;14] │ [7;13] │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈1234567890123456┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│   │    Default    │ aa_*b__cc___     │ [4;7]  │ [4;5]  │ [8;12] │ [8;9]  │\n│   │   (typed _)   │                  │        │        │        │        │\n└───┴───────────────┴──────────────────┴────────┴────────┴────────┴────────┘\nNotes:\n\nAll examples assume default config.search_method.\nOpen brackets differ from close brackets by how they treat inner edge whitespace for i textobject: open ignores it, close - includes.\nDefault textobject is activated for identifiers which are not Latin letters. They are designed to be treated as separators, so include only right edge in a textobject. To include both edges, use custom textobjects (see MiniAi-textobject-specification and MiniAi.config). Note:\n\nWhen cursor is exactly on the identifier character while there are two matching candidates on both left and right, the resulting region with smaller width is preferred.\n\n\n\n\n\nGlossary\nNote: this is similar to MiniSurround-glossary.\n\nREGION\nTable representing region in a buffer. Fields:\n\n&lt;from&gt; and &lt;to&gt; for inclusive start and end positions (&lt;to&gt; might be nil to describe empty region). Each position is also a table with line &lt;line&gt; and column &lt;col&gt; (both start at 1).\n&lt;vis_mode&gt; for which Visual mode will be used to select textobject. See opts argument of MiniAi.select_textobject(). One of 'v', 'V', '\\22' (escaped '&lt;C-v&gt;').\n\nExamples:\n{ from = { line = 1, col = 1 }, to = { line = 2, col = 1 } }\n\n-- Forced linewise mode\n{\n  from = { line = 1, col = 1 }, to = { line = 2, col = 1 },\n  vis_mode = 'V',\n}\n\n-- Empty region\n{ from = { line = 10, col = 10 } }\n\n\nPATTERN\nString describing Lua pattern.\n\n\nSPAN\nInterval inside a string (end-exclusive). Like [1, 5). Equal from and to edges describe empty span at that point.\nSpan A = [a1, a2) covers B = [b1, b2) if every element of B is within A (a1 &lt;= b &lt; a2). It also is described as “B is nested inside A”.\n\n\nNESTED PATTERN\nArray of patterns aimed to describe nested spans.\n\n\nSPAN MATCHES NESTED PATTERN\nIf there is a sequence of consecutively nested spans each matching corresponding pattern within substring of previous span (or input string for first span). Example:\n-- Nested patterns for balanced `()` with inner space\n{ '%b()', '^. .* .$' }\n\n-- Example input string (with columns underneath for easier reading):\n   \"( ( () ( ) ) )\"\n--  12345678901234\nHere are all matching spans [1, 15) and [3, 13). Both [5, 7) and [8, 10) match first pattern but not second. All other combinations of ( and ) don’t match first pattern (not balanced).\n\n\nCOMPOSED PATTERN\nArray with each element describing possible pattern (or array of them) at that place. Composed pattern basically defines all possible combinations of nested pattern (their cartesian product). Examples:\n\nEither balanced () or balanced [] but both with inner edge space:\n-- Composed pattern\n{ { '%b()', '%b[]' }, '^. .* .$' }\n\n-- Composed pattern expanded into equivalent array of nested patterns\n{ '%b()', '^. .* .$' } -- and\n{ '%b[]', '^. .* .$' }\nEither “balanced () with inner edge space” or “balanced [] with no inner edge space”, both with 5 or more characters:\n-- Composed pattern\n{ { { '%b()', '^. .* .$' }, { '%b[]', '^.[^ ].*[^ ].$' } }, '.....' }\n\n-- Composed pattern expanded into equivalent array of nested patterns\n{ '%b()', '^. .* .$', '.....' } -- and\n{ '%b[]', '^.[^ ].*[^ ].$', '.....' }\n\n\n\nSPAN MATCHES COMPOSED PATTERN\nIf it matches at least one nested pattern from expanded composed pattern.\n\n\n\n\nTextobject specification\nTextobject specification has a structure of composed pattern (see MiniAi-glossary) with two differences:\n\nLast pattern(s) should have even number of empty capture groups denoting how the last string should be processed to extract a or i textobject:\n\nZero captures mean that whole string represents both a and i. Example: xxx will define textobject matching string xxx literally.\nTwo captures represent i textobject inside of them. a - whole string. Example: x()x()x defines a textobject to be xxx, i - middle x.\nFour captures define a textobject inside captures 1 and 4, i - inside captures 2 and 3. Example: x()()x()x() defines a textobject to be last xx, i - middle x.\n\nAllows callable objects (see vim.is_callable()) in certain places (enables more complex textobjects in exchange of increase in configuration complexity and computations):\n\nIf specification itself is a callable, it will be called with the same arguments as MiniAi.find_textobject() and should return one of:\n\nComposed pattern. Useful for implementing user input. Example of simplified variant of textobject for function call with name taken from user prompt:\nfunction()\n  local left_edge = vim.pesc(vim.fn.input('Function name: '))\n  return { left_edge .. '%b()', '^.-%(().*()%)$' }\nend\nSingle output region. Useful to allow full control over textobject. Will be taken as is. Example of returning whole buffer:\nfunction()\n  local from = { line = 1, col = 1 }\n  local to = {\n    line = vim.fn.line('$'),\n    col = math.max(vim.fn.getline('$'):len(), 1)\n  }\n  return { from = from, to = to, vis_mode = 'V' }\nend\nArray of output region(s). Useful for incorporating other instruments, like treesitter (see MiniAi.gen_spec.treesitter()). The best region will be picked in the same manner as with composed pattern (respecting options n_lines, search_method, etc.). Example of selecting “best” line with display width more than 80:\nfunction(_, _, _)\n  local res = {}\n  for i = 1, vim.api.nvim_buf_line_count(0) do\n    local cur_line = vim.fn.getline(i)\n    if vim.fn.strdisplaywidth(cur_line) &gt; 80 then\n      local region = {\n        from = { line = i, col = 1 },\n        to = { line = i, col = cur_line:len() },\n      }\n      table.insert(res, region)\n    end\n  end\n  return res\nend\n\nIf there is a callable instead of assumed string pattern, it is expected to have signature (line, init) and behave like pattern:find(). It should return two numbers representing span in line next after or at init (nil if there is no such span). !IMPORTANT NOTE!: it means that output’s from shouldn’t be strictly to the left of init (it will lead to infinite loop). Not allowed as last item (as it should be pattern with captures). Example of matching only balanced parenthesis with big enough width:\n{\n  '%b()',\n  function(s, init)\n    if init &gt; 1 or s:len() &lt; 5 then return end\n    return 1, s:len()\n  end,\n  '^.().*().$'\n}\n\n\nMore examples:\n-- Pair of balanced brackets from set (used for builtin `b` identifier):\n{ { '%b()', '%b[]', '%b{}' }, '^.().*().$' }\n\n-- Imitate word ignoring digits and punctuation (only for Latin alphabet):\n{ '()()%f[%w]%w+()[ \\t]*()' }\n\n-- Word with camel case support (also supports only Latin alphabet):\n{\n  {\n    '%u[%l%d]+%f[^%l%d]',\n    '%f[%S][%l%d]+%f[^%l%d]',\n    '%f[%P][%l%d]+%f[^%l%d]',\n    '^[%l%d]+%f[^%l%d]',\n  },\n  '^().*()$'\n}\n\n-- Number:\n{ '%f[%d]%d+' }\n\n-- Date in 'YYYY-MM-DD' format:\n{ '()%d%d%d%d%-%d%d%-%d%d()' }\n\n-- Lua block string:\n{ '%[%[().-()%]%]' }\nSee MiniAi.gen_spec for function wrappers to create commonly used textobject specifications.\n\n\n\nAlgorithm\nSearch for the textobjects relies on these principles:\n\nIt uses same input data as described in MiniAi.find_textobject(), i.e. whether it is a or i textobject, its identifier, reference region, etc.\nTextobject specification is constructed based on textobject identifier (see MiniAi-textobject-specification).\nGeneral search is done by converting some 2d buffer region (neighborhood of reference region) into 1d string (each line is appended with \\n). Then search for a best span matching textobject specification is done inside string (see MiniAi-glossary). After that, span is converted back into 2d region. Note: first search is done inside reference region lines, and only after that - inside its neighborhood within config.n_lines (see MiniAi.config).\nThe best matching span is chosen by iterating over all spans matching textobject specification and comparing them with “current best”. Comparison also depends on reference region (tighter covering is better, otherwise closer is better) and search method (if span is even considered).\nExtract span based on extraction pattern (last item in nested pattern).\nIf task is to perform a consecutive search (opts.n_times is greater than 1), steps are repeated with current best match becoming reference region. One such additional step is also done if final region is equal to reference region (this enables consecutive application).\n\nNotes:\n\nIteration over all matched spans is done in depth-first fashion with respect to nested pattern.\nIt is guaranteed that span is compared only once.\nFor the sake of increasing functionality, during iteration over all matching spans, some Lua patterns in composed pattern are handled specially.\n\n%bxx (xx is two identical characters). It denotes balanced pair of identical characters and results into “paired” matches. For example, %b\"\" for \"aa\" \"bb\" would match \"aa\" and \"bb\", but not middle \" \".\nx.-y (x and y are different strings). It results only in matches with smallest width. For example, e.-o for e e o o will result only in middle e o. Note: it has some implications for when parts have quantifiers (like +, etc.), which usually can be resolved with frontier pattern %f[] (see examples in MiniAi-textobject-specification).\n\n\n\n\n\nsetup()\n\nMiniAi.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniAi.config.\n\n\nUsage\nrequire('mini.ai').setup() -- use default config\n-- OR\nrequire('mini.ai').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniAi.config\n\n\nDefaults\nMiniAi.config = {\n  -- Table with textobject id as fields, textobject specification as values.\n  -- Also use this to disable builtin textobjects. See |MiniAi.config|.\n  custom_textobjects = nil,\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Main textobject prefixes\n    around = 'a',\n    inside = 'i',\n\n    -- Next/last textobjects\n    -- NOTE: These override built-in LSP selection mappings on Neovim&gt;=0.12\n    -- Map LSP selection manually to use it (see `:h MiniAi.config`)\n    around_next = 'an',\n    inside_next = 'in',\n    around_last = 'al',\n    inside_last = 'il',\n\n    -- Move cursor to corresponding edge of `a` textobject\n    goto_left = 'g[',\n    goto_right = 'g]',\n  },\n\n  -- Number of lines within which textobject is searched\n  n_lines = 50,\n\n  -- How to search for object (first inside current line, then inside\n  -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',\n  -- 'cover_or_nearest', 'next', 'prev', 'nearest'.\n  search_method = 'cover_or_next',\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}\n\n\nCustom textobjects\nUser can define own textobjects by supplying config.custom_textobjects. It should be a table with keys being single character textobject identifier (supported by getcharstr()) and values - textobject specification (see MiniAi-textobject-specification).\nGeneral recommendations:\n\nThis can be used to override builtin ones (MiniAi-builtin-textobjects). Supply non-valid input (not in specification format) to disable module’s builtin textobject in favor of external or Neovim’s builtin mapping.\nKeys should use character representation which can be getcharstr() output. For example, '\\r' and not '&lt;CR&gt;'.\n\nExamples:\nrequire('mini.ai').setup({\n  custom_textobjects = {\n    -- Tweak argument textobject\n    a = require('mini.ai').gen_spec.argument({ brackets = { '%b()' } }),\n\n    -- Disable brackets alias in favor of builtin block textobject\n    b = false,\n\n    -- Now `vax` should select `xxx` and `vix` - middle `x`\n    x = { 'x()x()x' },\n\n    -- Whole buffer\n    g = function()\n      local from = { line = 1, col = 1 }\n      local to = {\n        line = vim.fn.line('$'),\n        col = math.max(vim.fn.getline('$'):len(), 1)\n      }\n      return { from = from, to = to }\n    end\n  }\n})\n\n-- Use `vim.b.miniai_config` to customize per buffer\n-- Example of specification useful for Markdown files:\nlocal spec_pair = require('mini.ai').gen_spec.pair\nvim.b.miniai_config = {\n  custom_textobjects = {\n    ['*'] = spec_pair('*', '*', { type = 'greedy' }),\n    ['_'] = spec_pair('_', '_', { type = 'greedy' }),\n  },\n}\nThere are more example specifications in MiniAi-textobject-specification.\n\n\nSearch method\nValue of config.search_method defines how best match search is done. Based on its value, one of the following matches will be selected:\n\nCovering match. Left/right edge is before/after left/right edge of reference region.\nPrevious match. Left/right edge is before left/right edge of reference region.\nNext match. Left/right edge is after left/right edge of reference region.\nNearest match. Whichever is closest among previous and next matches.\n\nPossible values are:\n\n'cover' - use only covering match. Don’t use either previous or next; report that there is no textobject found.\n'cover_or_next' (default) - use covering match. If not found, use next.\n'cover_or_prev' - use covering match. If not found, use previous.\n'cover_or_nearest' - use covering match. If not found, use nearest.\n'next' - use next match.\n'prev' - use previous match.\n'nearest' - use nearest match.\n\nNote: search is first performed on the reference region lines and only after failure - on the whole neighborhood defined by config.n_lines. This means that with config.search_method not equal to 'cover', “prev” or “next” textobject will end up as search result if they are found on first stage although covering match might be found in bigger, whole neighborhood. This design is based on observation that most of the time operation is done within reference region lines (usually cursor line).\nHere is an example of what a) textobject is based on a value of 'config.search_method' when cursor is inside bbb word:\n\n'cover': (a) bbb (c) -&gt; none\n'cover_or_next': (a) bbb (c) -&gt; (c)\n'cover_or_prev': (a) bbb (c) -&gt; (a)\n'cover_or_nearest': depends on cursor position. For first and second b - as in cover_or_prev (as previous match is nearer), for third - as in cover_or_next (as next match is nearer).\n'next': (a) bbb (c) -&gt; (c). Same outcome for (bbb).\n'prev': (a) bbb (c) -&gt; (a). Same outcome for (bbb).\n'nearest': depends on cursor position (same as in 'cover_or_nearest').\n\n\n\nMappings\nMappings around_next / inside_next and around_last / inside_last are essentially around / inside but using search method 'next' and 'prev'.\nNOTE: with default config, built-in LSP mappings v_an and v_in on Neovim&gt;=0.12 are overridden. Either use different around_next / inside_next keys or map manually using vim.lsp.buf.selection_range(). For example:\nlocal map_lsp_selection = function(lhs, desc)\n  local s = vim.startswith(desc, 'Increase') and 1 or -1\n  local rhs = function() vim.lsp.buf.selection_range(s * vim.v.count1) end\n  vim.keymap.set('x', lhs, rhs, { desc = desc })\nend\nmap_lsp_selection('&lt;Leader&gt;ls', 'Increase selection')\nmap_lsp_selection('&lt;Leader&gt;lS', 'Decrease selection')\n\n\n\n\nfind_textobject()\n\nMiniAi.find_textobject({ai_type}, {id}, {opts})\n\nFind textobject region\n\nParameters\n{ai_type} (string) One of 'a' or 'i'.\n{id} (string) Single character string representing textobject id. It is used to get specification which is later used to compute textobject region. Note: if specification is a function, it is called with all present arguments (opts is populated with default arguments).\n{opts} (table|nil) Options. Possible fields:\n\n&lt;n_lines&gt; - Number of lines within which textobject is searched. Default: config.n_lines (see MiniAi.config).\n&lt;n_times&gt; - Number of times to perform a consecutive search. Each one is done with reference region being previous found textobject region. Default: 1.\n&lt;reference_region&gt; - region to try to cover (see MiniAi-glossary). It is guaranteed that output region will not be inside or equal to this one. Default: empty region at cursor position.\n&lt;search_method&gt; - Search method. Default: config.search_method.\n\n\n\nReturn\n(table|nil) Region of textobject or nil if no textobject different from opts.reference_region was consecutively found opts.n_times times.\n\n\n\n\nmove_cursor()\n\nMiniAi.move_cursor({side}, {ai_type}, {id}, {opts})\n\nMove cursor to edge of textobject\n\nParameters\n{side} (string) One of 'left' or 'right'.\n{ai_type} (string) One of 'a' or 'i'.\n{id} (string) Single character string representing textobject id.\n{opts} (table|nil) Same as in MiniAi.find_textobject(). opts.n_times means number of actual jumps (important when cursor already on the potential jump spot).\n\n\n\n\ngen_spec\n\nMiniAi.gen_spec\n\nGenerate common textobject specifications\nThis is a table with function elements. Call to actually get specification.\nExample:\nlocal gen_spec = require('mini.ai').gen_spec\nrequire('mini.ai').setup({\n  custom_textobjects = {\n    -- Tweak argument to be recognized only inside `()` between `;`\n    a = gen_spec.argument({ brackets = { '%b()' }, separator = ';' }),\n\n    -- Tweak function call to not detect dot in function name\n    f = gen_spec.function_call({ name_pattern = '[%w_]' }),\n\n    -- Function definition (needs treesitter queries with these captures)\n    F = gen_spec.treesitter({ a = '@function.outer', i = '@function.inner' }),\n\n    -- Make `|` select both edges in non-balanced way\n    ['|'] = gen_spec.pair('|', '|', { type = 'non-balanced' }),\n  }\n})\n\n\n\ngen_spec.argument()\n\nMiniAi.gen_spec.argument({opts})\n\nArgument specification\nArgument textobject (has default a identifier) is a region inside balanced bracket between allowed not excluded separators. Use this function to tweak how it works.\nExamples:\n\nargument({ brackets = { '%b()' } }) will search for an argument only inside balanced ().\nargument({ separator = '[,;]' }) will treat both , and ; as separators.\nargument({ exclude_regions = { '%b()' } }) will exclude separators which are inside balanced () (inside outer brackets).\n\n\nParameters\n{opts} (table|nil) Options. Allowed fields:\n\n&lt;brackets&gt; - array of patterns for outer balanced brackets. Default: { '%b()', '%b[]', '%b{}' } (any (), [], or {} can enclose arguments).\n&lt;separator&gt; - separator pattern. Default: ','. One of the practical usages of this option is to include whitespace around character to be a part of separator. For example, '%s*,%s*' will treat as separator not only ‘,’, but its possible surrounding whitespace. This has both positive and negative effects. On one hand, daa executed over the first argument will delete whitespace after first comma, leading to a more expected outcome. On the other hand it is ambiguous which argument is picked when cursor is over whitespace near the character separator.\n&lt;exclude_regions&gt; - array with patterns for regions inside which separators will be ignored. Default: { '%b\"\"', \"%b''\", '%b()', '%b[]', '%b{}' } (separators inside balanced quotes or brackets are ignored).\n\n\n\n\n\ngen_spec.function_call()\n\nMiniAi.gen_spec.function_call({opts})\n\nFunction call specification\nFunction call textobject (has default f identifier) is a region with some characters followed by balanced (). Use this function to tweak how it works.\nExample:\n\nfunction_call({ name_pattern = '[%w_]' }) will recognize function name with only alphanumeric or underscore (not dot).\n\n\nParameters\n{opts} (table|nil) Options. Allowed fields:\n\n&lt;name_pattern&gt; - string pattern of character set allowed in function name. Default: '[%w_%.]' (alphanumeric, underscore, or dot). Note: should be enclosed in [].\n\n\n\n\n\ngen_spec.pair()\n\nMiniAi.gen_spec.pair({left}, {right}, {opts})\n\nPair specification\nUse it to define textobject for region surrounded with left from left and right from right. The a textobject includes both edges, i - excludes them.\nRegion can be one of several types (controlled with opts.type). All examples are for default search method, a textobject, and use '_' as both left and right:\n\nNon-balanced ({ type = 'non-balanced' }), default. Equivalent to using x.-y as first pattern. Example: on line ‘a_b_c’ it consecutively matches ‘a’, ‘b’, ‘c’.\nBalanced ({ type = 'balanced' }). Equivalent to using %bxy as first pattern. Example: on line ‘a_b_c’ it consecutively matches ‘a’, ‘c’. Note: both left and right should be single character.\nGreedy ({ type = 'greedy' }). Like non-balanced but will select maximum consecutive left and right edges. Example: on line ’__a_b’ it consecutively selects ‘a’ and ’__b_’. Note: both left and right should be single character.\n\n\nParameters\n{left} (string) Left edge.\n{right} (string) Right edge.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;type&gt; - Type of a pair. One of 'non-balanced' (default), 'balanced', 'greedy'.\n\n\n\n\n\ngen_spec.treesitter()\n\nMiniAi.gen_spec.treesitter({ai_captures}, {opts})\n\nTreesitter specification\nThis is a specification in function form. When called with a pair of treesitter captures, it returns a specification function outputting an array of regions that match corresponding (a or i) capture.\nIn order for this to work, apart from working treesitter parser for desired language, user should have a reachable language-specific ‘textobjects’ query (see vim.treesitter.query.get()). The most straightforward way for this is to have ‘textobjects.scm’ query file with treesitter captures stored in some recognized path. This is primarily designed to be compatible with plugin ‘nvim-treesitter/nvim-treesitter-textobjects’, but can be used without it.\nTwo most common approaches for having a query file:\n\nInstall ‘nvim-treesitter/nvim-treesitter-textobjects’. It has curated and well maintained builtin query files for many languages with a standardized capture names, like function.outer, function.inner, etc.\nManually create file ‘after/queries//textobjects.scm’ in your $XDG_CONFIG_HOME directory. It should contain queries with captures (later used to define textobjects). See lua-treesitter-query. To verify that query file is reachable, run (example for “lua” language, output should have at least an intended file):\n:lua print(vim.inspect(vim.treesitter.query.get_files('lua','textobjects')))\n\nExample configuration for function definition textobject with ‘nvim-treesitter/nvim-treesitter-textobjects’ captures:\nlocal spec_treesitter = require('mini.ai').gen_spec.treesitter\nrequire('mini.ai').setup({\n  custom_textobjects = {\n    F = spec_treesitter({ a = '@function.outer', i = '@function.inner' }),\n    o = spec_treesitter({\n      a = { '@conditional.outer', '@loop.outer' },\n      i = { '@conditional.inner', '@loop.inner' },\n    })\n  }\n})\nNotes:\n\nBe sure that query files don’t contain unknown treesitter-directives (like #make-range!, for example). Otherwise textobject for such capture might not be found as lua-treesitter-core won’t treat them as captures. Verify with :=vim.treesitter.query.get('lang', 'textobjects') and see if the target capture is recognized as one.\nIt uses buffer’s filetype to determine query language.\nOn large files it is slower than pattern-based textobjects. Still very fast though (one search should be magnitude of milliseconds or tens of milliseconds on really large file).\n\n\nParameters\n{ai_captures} (table) Captures for a and i textobjects: table with &lt;a&gt; and &lt;i&gt; fields with captures for a and i textobjects respectively. Each value can be either a string capture (should start with '@') or an array of such captures (best among all matches will be chosen).\n{opts} (table|nil) Options. Possible values:\n\n&lt;use_nvim_treesitter&gt; - whether to try to use ‘nvim-treesitter’ plugin (if present) to do the query. It used to implement more advanced behavior and more coherent experience if ‘nvim-treesitter-textobjects’ queries are used. However, as lua-treesitter-core methods are more capable now, the option will soon be removed. Only present for backward compatibility. Default: false.\n\n\n\nReturn\n(function) Function with MiniAi.find_textobject() signature which returns array of current buffer regions representing matches for corresponding (a or i) treesitter capture.\n\n\nSee also\n\nMiniAi-textobject-specification for how this type of textobject specification is processed.\nvim.treesitter.query.get() for how query is fetched.\nQuery:iter_captures() for how all query captures are iterated in case of no ‘nvim-treesitter’.\n\n\n\n\n\ngen_spec.user_prompt()\n\nMiniAi.gen_spec.user_prompt()\n\nSpecification from user prompt\n\nAsk user for left and right textobject edges as raw strings (no pattern).\nConstruct specification for a textobject that matches from left edge string to right edge string: a includes both strings, i only insides.\n\nUsed for MiniAi-builtin-textobjects with identifier ?.\n\nReturn\n(function) Textobject specification as function.\n\n\n\n\nselect_textobject()\n\nMiniAi.select_textobject({ai_type}, {id}, {opts})\n\nVisually select textobject region\nDoes nothing if no region is found.\n\nParameters\n{ai_type} (string) One of 'a' or 'i'.\n{id} (string) Single character string representing textobject id.\n{opts} (table|nil) Same as in MiniAi.find_textobject(). Extra fields:\n\n&lt;vis_mode&gt; - One of 'v', 'V', or '\\22' (escaped version of '&lt;C-v&gt;'). Default: Latest visual mode.\n&lt;operator_pending&gt; - Whether selection is for Operator-pending mode. Used in that mode’s mappings, shouldn’t be used directly. Default: false."
  },
  {
    "objectID": "mini.nvim/doc/mini-notify.html",
    "href": "mini.nvim/doc/mini-notify.html",
    "title": "mini.notify documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.notify Show notifications\nMIT License Copyright (c) 2024 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nShow one or more highlighted notifications in a single floating window.\nManage notifications (add, update, remove, clear).\nCustom vim.notify() implementation. To adjust, use MiniNotify.make_notify() or save-restore vim.notify manually after calling MiniNotify.setup().\nAutomated show of LSP progress report.\nTrack history which can be accessed with MiniNotify.get_all() and shown with MiniNotify.show_history().\n\n\nSetup\nThis module needs a setup with require('mini.notify').setup({}) (replace {} with your config table). It will create global Lua table MiniNotify which you can use for scripting or manually (with :lua MiniNotify.*).\nSee MiniNotify.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.mininotify_config which should have same structure as MiniNotify.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nj-hui/fidget.nvim:\n\nBasic goals of providing interface for notifications are similar.\nHas more configuration options and visual effects, while this module does not (by design).\n\nrcarriga/nvim-notify:\n\nSimilar to ‘j-hui/fidget.nvim’.\n\n\n\n\nHighlight groups\n\nMiniNotifyBorder - window border.\nMiniNotifyLspProgress - notifications from built-in LSP progress report.\nMiniNotifyNormal - basic foreground/background highlighting.\nMiniNotifyTitle - window title.\n\nTo change any highlight group, set it directly with nvim_set_hl().\nNOTE: vim.notify() override after MiniNotify.make_notify() uses own highlight groups per notification level.\n\n\nDisabling\nTo disable showing notifications, set vim.g.mininotify_disable (globally) or vim.b.mininotify_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nSpecification\n\nNotification specification\nNotification is a table with the following keys:\n\n&lt;msg&gt; (string) - single string with notification message. Use \\n to delimit several lines.\n&lt;level&gt; (string) - notification level as key of vim.log.levels. Like “ERROR”, “WARN”, “INFO”, etc.\n&lt;hl_group&gt; (string) - highlight group with which notification is shown.\n&lt;data&gt; (table) - extra data to store in notification (like source, etc.).\n&lt;ts_add&gt; (number) - timestamp of when notification is added.\n&lt;ts_update&gt; (number) - timestamp of the latest notification update.\n&lt;ts_remove&gt; (number|nil) - timestamp of when notification is removed. It is nil if notification was never removed and thus considered “active”.\n\nNotes:\n\nTimestamps are compatible with strftime() and have fractional part.\n\n\n\n\n\nsetup()\n\nMiniNotify.setup({config})\n\nModule setup\nThis will also:\n\nSet vim.notify() custom implementation (see MiniNotify.make_notify()).\nClean the history. Use MiniNotify.setup(MiniNotify.config) to force clean history while preserving the config.\n\n\nParameters\n{config} (table|nil) Module config table. See MiniNotify.config.\n\n\nUsage\nrequire('mini.notify').setup() -- use default config\n-- OR\nrequire('mini.notify').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniNotify.config\n\n\nDefaults\nMiniNotify.config = {\n  -- Content management\n  content = {\n    -- Function which formats the notification message\n    -- By default prepends message with notification time\n    format = nil,\n\n    -- Function which orders notification array from most to least important\n    -- By default orders first by level and then by update timestamp\n    sort = nil,\n  },\n\n  -- Notifications about LSP progress\n  lsp_progress = {\n    -- Whether to enable showing\n    enable = true,\n\n    -- Notification level\n    level = 'INFO',\n\n    -- Duration (in ms) of how long last message should be shown\n    duration_last = 1000,\n  },\n\n  -- Window options\n  window = {\n    -- Floating window config\n    config = {},\n\n    -- Maximum window width as share (between 0 and 1) of available columns\n    max_width_share = 0.382,\n\n    -- Value of 'winblend' option\n    winblend = 25,\n  },\n}\n\n\nContent\nconfig.content defines how notifications are shown.\ncontent.format is a function which takes single notification object (see MiniNotify-specification) and returns a string to be used directly when showing notification. Default: nil for MiniNotify.default_format().\ncontent.sort is a function which takes array of notification objects (see MiniNotify-specification) and returns an array of such objects. It can be used to define custom order and/or filter for notifications which are shown simultaneously. Note: Input contains notifications before applying content.format. Default: nil for MiniNotify.default_sort().\nExample:\nrequire('mini.notify').setup({\n  content = {\n    -- Use notification message as is for LSP progress\n    format = function(notif)\n      if notif.data.source == 'lsp_progress' then return notif.msg end\n      return MiniNotify.default_format(notif)\n    end,\n\n    -- Show more recent notifications first\n    sort = function(notif_arr)\n      table.sort(\n        notif_arr,\n        function(a, b) return a.ts_update &gt; b.ts_update end\n      )\n      return notif_arr\n    end,\n  },\n})\n\n\nLSP progress\nconfig.lsp_progress defines automated notifications for LSP progress. It is implemented as a single updating notification per progress with all information about it. Setting up is done inside MiniNotify.setup() via vim.schedule()’ed setting of lsp-handler for “$/progress” method.\nlsp_progress.enable is a boolean indicating whether LSP progress should be shown in notifications. Can be disabled in current session. Default: true. Note: Should be true during MiniNotify.setup() call to be able to enable it in current session.\nlsp_progress.level is a level to be used in MiniNotify.add(). Default: 'INFO'.\nlsp_progress.duration_last is a number of milliseconds for the last progress report to be shown on screen before removing it. Default: 1000.\nNotes:\n\nThis respects previously set handler by saving and calling it.\nOverriding “$/progress” method of vim.lsp.handlers disables notifications.\nAll LSP progress notifications set the following fields in data:\n\n&lt;source&gt; is \"lsp_progress\".\n&lt;client_name&gt; is set to client’s name (provided by client or inferred).\n&lt;context&gt; is the latest LSP request context (ctx arg of lsp-handler).\n&lt;response&gt; is the latest LSP response (result arg of lsp-handler).\n\n\n\n\nWindow\nconfig.window defines behavior of notification window.\nwindow.config is a table defining floating window characteristics or a callable returning such table (will be called with identifier of window’s buffer already showing notifications). It should have the same structure as in nvim_open_win(). It has the following default values which show notifications in the upper right corner with upper limit on width:\n\nwidth is chosen to fit buffer content but at most window.max_width_share share of ‘columns’. To have higher maximum width, use function in config.window which computes dimensions inside of it (based on buffer content).\nheight is chosen to fit buffer content with enabled ‘wrap’ (assuming default value of width).\nanchor, col, and row are “NE”, ‘columns’, and 0 or 1 (depending on tabline).\nborder is “single”.\nzindex is 999 to be as much on top as reasonably possible.\n\nwindow.max_width_share defines maximum window width as a share of ‘columns’. Should be a number between 0 (not included) and 1. Default: 0.382.\nExample for showing notifications in bottom right corner:\nlocal win_config = function()\n  local has_statusline = vim.o.laststatus &gt; 0\n  local pad = vim.o.cmdheight + (has_statusline and 1 or 0)\n  return { anchor = 'SE', col = vim.o.columns, row = vim.o.lines - pad }\nend\nrequire('mini.notify').setup({ window = { config = win_config } })\nwindow.winblend defines ‘winblend’ value for notification window. Default: 25.\n\n\n\n\nmake_notify()\n\nMiniNotify.make_notify({opts})\n\nMake vim.notify wrapper\nCalling this function creates an implementation of vim.notify() powered by this module. General idea is to show notification as soon as safely possible (see vim.schedule_wrap()) and remove it after a configurable amount of time.\nAll notifications set source = \"vim.notify\" in their data field.\nThis is used with default options inside MiniNotify.setup(). To adjust, call manually after setup(). For example, to show errors longer:\nrequire('mini.notify').setup()\nvim.notify = MiniNotify.make_notify({ ERROR = { duration = 10000 } })\nTo preserve original vim.notify:\nlocal notify_orig = vim.notify\nrequire('mini.notify').setup()\nvim.notify = notify_orig\n\nParameters\n{opts} (table|nil) Options to configure behavior of notification level (as in MiniNotify.add()). Fields are the same as names of vim.log.levels with values being tables with possible fields:\n\n&lt;duration&gt; (number) - duration (in ms) of how much a notification should be shown. If 0 or negative, notification is not shown at all.\n&lt;hl_group&gt; (string) - highlight group of notification. Only data different to default can be supplied.\n\nDefault:\n{\n  ERROR = { duration = 5000, hl_group = 'DiagnosticError'  },\n  WARN  = { duration = 5000, hl_group = 'DiagnosticWarn'   },\n  INFO  = { duration = 5000, hl_group = 'DiagnosticInfo'   },\n  DEBUG = { duration = 0,    hl_group = 'DiagnosticHint'   },\n  TRACE = { duration = 0,    hl_group = 'DiagnosticOk'     },\n  OFF   = { duration = 0,    hl_group = 'MiniNotifyNormal' },\n}\n\n\n\n\nadd()\n\nMiniNotify.add({msg}, {level}, {hl_group}, {data})\n\nAdd notification\nAdd notification to history. It is considered “active” and is shown. To hide, call MiniNotify.remove() with identifier this function returns.\nExample:\nlocal id = MiniNotify.add('Hello', 'WARN', 'Comment')\nvim.defer_fn(function() MiniNotify.remove(id) end, 1000)\n\nParameters\n{msg} (string) Notification message.\n{level} (string|nil) Notification level as key of vim.log.levels. Default: 'INFO'.\n{hl_group} (string|nil) Notification highlight group. Default: 'MiniNotifyNormal'.\n{data} (table|nil) Extra data to store in the notification. Default: {}.\n\n\nReturn\n(number) Notification identifier.\n\n\n\n\nupdate()\n\nMiniNotify.update({id}, {new})\n\nUpdate active notification\nModify contents of active notification.\n\nParameters\n{id} (number) Identifier of currently active notification as returned by MiniNotify.add().\n{new} (table) Table with contents to update. Keys should be as non-timestamp fields of MiniNotify-specification and values - new content values. If present, field data is updated as is. Use MiniNotify.get() together with vim.tbl_deep_extend() to change only part of it.\n\n\n\n\nremove()\n\nMiniNotify.remove({id})\n\nRemove notification\nIf notification is active, make it not active (by setting ts_remove field). If not active, do nothing.\n\nParameters\n{id} (number|nil) Identifier of previously added notification. If it is not, nothing is done (silently).\n\n\n\n\nclear()\n\nMiniNotify.clear()\n\nRemove all active notifications\nHide all active notifications and stop showing window (if shown).\n\n\n\nrefresh()\n\nMiniNotify.refresh()\n\nRefresh notification window\nMake notification window show relevant information:\n\nCreate an array of active notifications (see MiniNotify-specification).\nApply config.content.sort to an array. If output has zero notifications, make notification window to not show.\nApply config.content.format to each element of notification array and update its message.\nConstruct content from notifications and show them in a window.\n\nNote: effects are delayed if inside fast event (vim.in_fast_event()).\n\n\n\nget()\n\nMiniNotify.get({id})\n\nGet previously added notification by id\n\nParameters\n{id} (number) Identifier of notification.\n\n\nReturn\n(table) Notification object (see MiniNotify-specification).\n\n\n\n\nget_all()\n\nMiniNotify.get_all()\n\nGet all previously added notifications\nGet map of used notifications with keys being notification identifiers.\nCan be used to get only active notification objects. Example:\n-- Get active notifications\nvim.tbl_filter(\n  function(notif) return notif.ts_remove == nil end,\n  MiniNotify.get_all()\n)\n\nReturn\n(table) Map with notification object values (see MiniNotify-specification). Note: messages are taken from last valid update.\n\n\n\n\nshow_history()\n\nMiniNotify.show_history()\n\nShow history\nOpen or reuse a scratch buffer with all previously shown notifications.\nNotes:\n\nContent is ordered from oldest to newest based on latest update time.\nMessage is formatted with config.content.format.\n\n\n\n\ndefault_format()\n\nMiniNotify.default_format({notif})\n\nDefault content format\nUsed by default as config.content.format. Prepends notification message with the human readable update time and a separator.\n\nParameters\n{notif} (table) Notification object (see MiniNotify-specification).\n\n\nReturn\n(string) Formatted notification message.\n\n\n\n\ndefault_sort()\n\nMiniNotify.default_sort({notif_arr})\n\nDefault content sort\nUsed by default as config.content.sort. First sorts by notification’s level (“ERROR” &gt; “WARN” &gt; “INFO” &gt; “DEBUG” &gt; “TRACE” &gt; “OFF”; the bigger the more important); if draw - by latest update time (the later the more important).\n\nParameters\n{notif_arr} (table) Array of notifications (see MiniNotify-specification).\n\n\nReturn\n(table) Sorted array of notifications."
  },
  {
    "objectID": "mini.nvim/doc/mini-cursorword.html",
    "href": "mini.nvim/doc/mini-cursorword.html",
    "title": "mini.cursorword documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.cursorword Autohighlight word under cursor\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nAutohighlight word under cursor with customizable delay.\nCurrent word under cursor can be highlighted differently.\nHighlighting is triggered only if current cursor character is a [:keyword:].\nHighlighting stops in insert and terminal modes.\n“Word under cursor” is meant as in Vim’s &lt;cword&gt;: something user would get as ‘iw’ text object.\n\n\nSetup\nThis module needs a setup with require('mini.cursorword').setup({}) (replace {} with your config table). It will create global Lua table MiniCursorword which you can use for scripting or manually (with :lua MiniCursorword.*).\nSee MiniCursorword.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minicursorword_config which should have same structure as MiniCursorword.config. See mini.nvim-buffer-local-config for more details.\n\n\nHighlight groups\n\nMiniCursorword - highlight group of a non-current cursor word. Default: plain underline.\nMiniCursorwordCurrent - highlight group of a current word under cursor. Default: links to MiniCursorword (so :hi clear MiniCursorwordCurrent will lead to showing MiniCursorword highlight group). Note: To not highlight it, use the following Lua code:\nvim.api.nvim_set_hl(0, 'MiniCursorwordCurrent', {})\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable core functionality, set vim.g.minicursorword_disable (globally) or vim.b.minicursorword_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes. Note: after disabling there might be highlighting left; it will be removed after next highlighting update.\nModule-specific disabling:\n\nDon’t show highlighting if cursor is on the word that is in a blocklist of current filetype. In this example, blocklist for “lua” is “local” and “require” words, for “javascript” - “import”:\n_G.cursorword_blocklist = function()\n  local curword = vim.fn.expand('&lt;cword&gt;')\n  local filetype = vim.bo.filetype\n\n  -- Add any disabling global or filetype-specific logic here\n  local blocklist = {}\n  if filetype == 'lua' then\n    blocklist = { 'local', 'require' }\n  elseif filetype == 'javascript' then\n    blocklist = { 'import' }\n  end\n\n  vim.b.minicursorword_disable = vim.tbl_contains(blocklist, curword)\nend\n\n-- Make sure to add this autocommand *before* calling module's `setup()`.\nvim.cmd('au CursorMoved * lua _G.cursorword_blocklist()')\n\n\n\n\n\nsetup()\n\nMiniCursorword.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniCursorword.config.\n\n\nUsage\nrequire('mini.cursorword').setup() -- use default config\n-- OR\nrequire('mini.cursorword').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniCursorword.config\n\n\nDefaults\nMiniCursorword.config = {\n  -- Delay (in ms) between when cursor moved and when highlighting appeared\n  delay = 100,\n}"
  },
  {
    "objectID": "mini.nvim/doc/mini-surround.html",
    "href": "mini.nvim/doc/mini-surround.html",
    "title": "mini.surround documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.surround Surround actions\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFast and feature-rich surrounding. Can be configured to have experience similar to tpope/vim-surround (see MiniSurround-vim-surround-config).\nFeatures:\n\nActions (text editing actions are dot-repeatable out of the box and respect [count]) with configurable mappings:\n\nAdd surrounding with sa (in visual mode or on motion).\nDelete surrounding with sd.\nReplace surrounding with sr.\nFind surrounding with sf or sF (move cursor right or left).\nHighlight surrounding with sh.\n\nSurrounding is identified by a single character as both “input” (in delete and replace start, find, and highlight) and “output” (in add and replace end):\n\n‘f’ - function call (string of alphanumeric symbols or ’_’ or ‘.’ followed by balanced ‘()’). In “input” finds function call, in “output” prompts user to enter function name.\n‘t’ - tag. In “input” finds tag with same identifier, in “output” prompts user to enter tag name with possible attributes.\nAll symbols in brackets ‘()’, ‘[]’, ‘{}’, ‘&lt;&gt;“. In”input’ represents balanced brackets (open - with whitespace pad, close - without), in “output” - left and right parts of brackets.\n‘?’ - interactive. Prompts user to enter left and right parts.\nAll other single character identifiers (supported by getcharstr()) represent surrounding with identical left and right parts.\n\nConfigurable search methods to find not only covering but possibly next, previous, or nearest surrounding. See more in MiniSurround.config.\nAll actions involving finding surrounding (delete, replace, find, highlight) can be used with suffix that changes search method to find previous/last. See more in MiniSurround.config.\n\nKnown issues which won’t be resolved:\n\nSearch for surrounding is done using Lua patterns (regex-like approach). So certain amount of false positives should be expected.\nWhen searching for “input” surrounding, there is no distinction if it is inside string or comment. So in this case there will be not proper match for a function call: ‘f(a = “)”, b = 1)’.\nTags are searched using regex-like methods, so issues are inevitable. Overall it is pretty good, but certain cases won’t work. Like self-nested tags won’t match correctly on both ends: ‘&lt;a&gt;&lt;a&gt;&lt;/a&gt;&lt;/a&gt;’.\n\n\nSetup\nThis module needs a setup with require('mini.surround').setup({}) (replace {} with your config table). It will create global Lua table MiniSurround which you can use for scripting or manually (with :lua MiniSurround.*).\nSee MiniSurround.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minisurround_config which should have same structure as MiniSurround.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nExample usage\nRegular mappings:\n\nsaiw) - add (sa) for inner word (iw) parenthesis ()).\nsaiw?[[&lt;CR&gt;]]&lt;CR&gt; - add (sa) for inner word (iw) interactive surrounding (?): [[ for left and ]] for right.\n2sdf - delete (sd) second (2) surrounding function call (f).\nsr)tdiv&lt;CR&gt; - replace (sr) surrounding parenthesis ()) with tag (t) with identifier ‘div’ (div&lt;CR&gt; in command line prompt).\nsff - find right (sf) part of surrounding function call (f).\nsh} - highlight (sh) for a brief period of time surrounding curly brackets (}).\n\nExtended mappings (temporary force “prev”/“next” search methods):\n\nsdnf - delete (sd) next (n) function call (f).\nsrlf( - replace (sr) last (l) function call (f) with padded bracket (().\n2sfnt - find (sf) second (2) next (n) tag (t).\n2shl} - highlight (sh) last (l) second (2) curly bracket (}).\n\n\n\nComparisons\n\ntpope/vim-surround:\n\n‘vim-surround’ has completely different, with other focus set of default mappings, while ‘mini.surround’ has a more coherent set.\n‘mini.surround’ supports dot-repeat, customized search path (see MiniSurround.config), customized specifications (see MiniSurround-surrounding-specification) allowing usage of tree-sitter queries (see MiniSurround.gen_spec.input.treesitter()), highlighting and finding surrounding, “last”/“next” extended mappings. While ‘vim-surround’ does not.\n\nmachakann/vim-sandwich:\n\nBoth have same keybindings for common actions (add, delete, replace).\nOtherwise same differences as with ‘tpope/vim-surround’ (except dot-repeat because ‘vim-sandwich’ supports it).\n\nkylechui/nvim-surround:\n\n‘nvim-surround’ is designed after ‘tpope/vim-surround’ with same default mappings and logic, while ‘mini.surround’ has mappings similar to ‘machakann/vim-sandwich’.\n‘mini.surround’ has more flexible customization of input surrounding (with composed patterns, region pair(s), search methods).\n‘mini.surround’ supports [count] in both input and output surrounding (see MiniSurround-count-with-actions) while ‘nvim-surround’ doesn’t.\n‘mini.surround’ supports “last”/“next” extended mappings.\n\nmini.ai:\n\nBoth use similar logic for finding target: textobject in ‘mini.ai’ and surrounding pair in ‘mini.surround’. While ‘mini.ai’ uses extraction pattern for separate a and i textobjects, ‘mini.surround’ uses it to select left and right surroundings (basically a difference between a and i textobjects).\nSome builtin specifications are slightly different:\n\nQuotes in ‘mini.ai’ are balanced, in ‘mini.surround’ they are not.\nThe ‘mini.surround’ doesn’t have argument surrounding.\nDefault behavior in ‘mini.ai’ selects one of the edges into a textobject, while ‘mini.surround’ - both.\n\n\n\n\n\nHighlight groups\n\nMiniSurround - highlighting of requested surrounding.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minisurround_disable (globally) or vim.b.minisurround_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nBuiltin surroundings\nThis table describes all builtin surroundings along with what they represent. Explanation:\n\nKey represents the surrounding identifier: single character which should be typed after action mappings (see “Mappings” in MiniSurround.config).\nName is a description of surrounding.\nExample line contains a string for which examples are constructed. The * denotes the cursor position over a character.\nDelete shows the result of typing sd followed by surrounding identifier. It aims to demonstrate “input” surrounding which is also used in replace with sr (surrounding id is typed first), highlight with sh, find with sf and sF.\nReplace shows the result of typing sr! followed by surrounding identifier (with possible follow up from user). It aims to demonstrate “output” surrounding which is also used in adding with sa (followed by textobject/motion or in Visual mode).\n\nExample: typing sd) with cursor on * (covers a character) changes line !( *a (bb) )! into ! aa (bb) !. Typing sr!) changes same initial line into (( aa (bb) )).\n┌───┬───────────────┬───────────────┬─────────────┬─────────────────┐\n│Key│     Name      │  Example line │    Delete   │     Replace     │\n├───┴───────────────┴───────────────┴─────────────┴─────────────────┤\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ ( │  Balanced ()  │ !( *a (bb) )! │  !aa (bb)!  │ ( ( aa (bb) ) ) │\n│ [ │  Balanced []  │ ![ *a [bb] ]! │  !aa [bb]!  │ [ [ aa [bb] ] ] │\n│ { │  Balanced {}  │ !{ *a {bb} }! │  !aa {bb}!  │ { { aa {bb} } } │\n│ &lt; │  Balanced &lt;&gt;  │ !&lt; *a &lt;bb&gt; &gt;! │  !aa &lt;bb&gt;!  │ &lt; &lt; aa &lt;bb&gt; &gt; &gt; │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ ) │  Balanced ()  │ !( *a (bb) )! │ ! aa (bb) ! │ (( aa (bb) ))   │\n│ ] │  Balanced []  │ ![ *a [bb] ]! │ ! aa [bb] ! │ [[ aa [bb] ]]   │\n│ } │  Balanced {}  │ !{ *a {bb} }! │ ! aa {bb} ! │ {{ aa {bb} }}   │\n│ &gt; │  Balanced &lt;&gt;  │ !&lt; *a &lt;bb&gt; &gt;! │ ! aa &lt;bb&gt; ! │ &lt;&lt; aa &lt;bb&gt; &gt;&gt;   │\n│ b │  Alias for    │ !( *a {bb} )! │ ! aa {bb} ! │ (( aa {bb} ))   │\n│   │  ), ], or }   │               │             │                 │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ q │  Alias for    │ !'aa'*a'aa'!  │ !'aaaaaa'!  │ \"'aa'aa'aa'\"    │\n│   │  \", ', or `   │               │             │                 │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ ? │  User prompt  │ !e * o!       │ ! a !       │ ee a oo         │\n│   │(typed e and o)│               │             │                 │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ t │      Tag      │ !&lt;x&gt;*&lt;/x&gt;!    │ !a!         │ &lt;y&gt;&lt;x&gt;a&lt;/x&gt;&lt;/y&gt; │\n│   │               │               │             │ (typed y)       │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│ f │ Function call │ !f(*a, bb)!   │ !aa, bb!    │ g(f(*a, bb))    │\n│   │               │               │             │ (typed g)       │\n├┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n│   │    Default    │ !_a*a_!       │ !aaa!       │ __aaa__         │\n│   │   (typed _)   │               │             │                 │\n└┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘\nNotes:\n\nAll examples assume default config.search_method.\nOpen brackets differ from close brackets by how they treat inner edge whitespace: open includes it left and right parts, close does not.\nOutput value of b alias is same as ). For q alias - same as \".\nDefault surrounding is activated for all characters which are not configured surrounding identifiers. Notes:\n\nDue to special handling of underlying x.-x Lua pattern (see MiniSurround-search-algorithm), it doesn’t really support non-trivial [count] for “cover” search method.\nWhen cursor is exactly on the identifier character while there are two matching candidates on both left and right, the one resulting in region with smaller width is preferred.\n\n\n\n\n\nGlossary\nNote: this is similar to MiniAi-glossary.\n\nREGION\nTable representing region in a buffer. Fields: &lt;from&gt; and &lt;to&gt; for inclusive start and end positions (&lt;to&gt; might be nil to describe empty region). Each position is also a table with line &lt;line&gt; and column &lt;col&gt; (both start at 1). Examples:\n{ from = { line = 1, col = 1 }, to = { line = 2, col = 1 } }\n\n-- Empty region\n{ from = { line = 10, col = 10 } }\n\n\nREGION PAIR\nTable representing regions for left and right surroundings. Fields: &lt;left&gt; and &lt;right&gt; with regions. Example:\n{\n  left  = { from = { line = 1, col = 1 }, to = { line = 1, col = 1 } },\n  right = { from = { line = 1, col = 3 } },\n}\n\n\nPATTERN\nString describing Lua pattern.\n\n\nSPAN\nInterval inside a string (end-exclusive). Like [1, 5). Equal from and to edges describe empty span at that point.\nSpan A = [a1, a2) covers B = [b1, b2) if every element of B is within A (a1 &lt;= b &lt; a2). It also is described as “B is nested inside A”.\n\n\nNESTED PATTERN\nArray of patterns aimed to describe nested spans.\n\n\nSPAN MATCHES NESTED PATTERN\nIf there is a sequence of consecutively nested spans each matching corresponding pattern within substring of previous span (or input string for first span). Example:\n-- Nested patterns for balanced `()` with inner space\n{ '%b()', '^. .* .$' }\n\n-- Example input string (with columns underneath for easier reading):\n   \"( ( () ( ) ) )\"\n--  12345678901234\nHere are all matching spans [1, 15) and [3, 13). Both [5, 7) and [8, 10) match first pattern but not second. All other combinations of ( and ) don’t match first pattern (not balanced).\n\n\nCOMPOSED PATTERN\nArray with each element describing possible pattern (or array of them) at that place. Composed pattern basically defines all possible combinations of nested pattern (their cartesian product). Examples:\n\nEither balanced () or balanced [] but both with inner edge space:\n-- Composed pattern\n{ { '%b()', '%b[]' }, '^. .* .$' }\n\n-- Composed pattern expanded into equivalent array of nested patterns\n{ '%b()', '^. .* .$' } -- and\n{ '%b[]', '^. .* .$' }\nEither “balanced () with inner edge space” or “balanced [] with no inner edge space”, both with 5 or more characters:\n-- Composed pattern\n{ { { '%b()', '^. .* .$' }, { '%b[]', '^.[^ ].*[^ ].$' } }, '.....' }\n\n-- Composed pattern expanded into equivalent array of nested patterns\n{ '%b()', '^. .* .$', '.....' } -- and\n{ '%b[]', '^.[^ ].*[^ ].$', '.....' }\n\n\n\nSPAN MATCHES COMPOSED PATTERN\nIf it matches at least one nested pattern from expanded composed pattern.\n\n\n\n\nSurrounding specification\nSurround specification is a table with keys:\n\n&lt;input&gt; - defines how to find and extract surrounding for “input” operations (like delete). See more in “Input surrounding” section.\n&lt;output&gt; - defines what to add on left and right for “output” operations (like add). See more in “Output surrounding” section.\n\nExample of surround info for builtin ) identifier:\n{\n  input = { '%b()', '^.().*().$' },\n  output = { left = '(', right = ')' }\n}\n\nInput surrounding\nSpecification for input surrounding has a structure of composed pattern (see MiniSurround-glossary) with two differences:\n\nLast pattern(s) should have two or four empty capture groups denoting how the last string should be processed to extract surrounding parts:\n\nTwo captures represent left part from start of string to first capture and right part - from second capture to end of string. Example: a()b()c defines left surrounding as ‘a’, right - ‘c’.\nFour captures define left part inside captures 1 and 2, right part - inside captures 3 and 4. Example: a()()b()c() defines left part as empty, right part as ‘c’.\n\nAllows callable objects (see vim.is_callable()) in certain places (enables more complex surroundings in exchange of increase in configuration complexity and computations):\n\nIf specification itself is a callable, it will be called without arguments and should return one of:\n\nComposed pattern. Useful for implementing user input. Example of simplified variant of input surrounding for function call with name taken from user prompt:\nfunction()\n  local left_edge = vim.pesc(vim.fn.input('Function name: '))\n  return { left_edge .. '%b()', '^.-%(().*()%)$' }\nend\nSingle region pair (see MiniSurround-glossary). Useful to allow full control over surrounding. Will be taken as is. Example of returning first and last lines of a buffer:\nfunction()\n  local n_lines = vim.fn.line('$')\n  return {\n    left = {\n      from = { line = 1, col = 1 },\n      to = { line = 1, col = vim.fn.getline(1):len() }\n    },\n    right = {\n      from = { line = n_lines, col = 1 },\n      to = { line = n_lines, col = vim.fn.getline(n_lines):len() }\n    },\n  }\nend\nArray of region pairs. Useful for incorporating other instruments, like treesitter (see MiniSurround.gen_spec.input.treesitter()). The best region pair will be picked in the same manner as with composed pattern (respecting options n_lines, search_method, etc.) using output region (from start of left region to end of right region). Example using edges of “best” line with display width more than 80:\nfunction()\n  local make_line_region_pair = function(n)\n    local left = { line = n, col = 1 }\n    local right = { line = n, col = vim.fn.getline(n):len() }\n    return {\n      left = { from = left, to = left },\n      right = { from = right, to = right },\n    }\n  end\n\n  local res = {}\n  for i = 1, vim.fn.line('$') do\n    if vim.fn.getline(i):len() &gt; 80 then\n      table.insert(res, make_line_region_pair(i))\n    end\n  end\n  return res\nend\n\nIf there is a callable instead of assumed string pattern, it is expected to have signature (line, init) and behave like pattern:find(). It should return two numbers representing span in line next after or at init (nil if there is no such span). !IMPORTANT NOTE!: it means that output’s from shouldn’t be strictly to the left of init (it will lead to infinite loop). Not allowed as last item (as it should be pattern with captures). Example of matching only balanced parenthesis with big enough width:\n{\n  '%b()',\n  function(s, init)\n    if init &gt; 1 or s:len() &lt; 5 then return end\n    return 1, s:len()\n  end,\n  '^.().*().$'\n}\n\n\nMore examples:\n-- Pair of balanced brackets from set (used for builtin `b` identifier)\n{ { '%b()', '%b[]', '%b{}' }, '^.().*().$' }\n\n-- Lua block string\n{ '%[%[().-()%]%]' }\nSee MiniSurround.gen_spec for function wrappers to create commonly used surrounding specifications.\n\n\nOutput surrounding\nSpecification for output can be either a table with &lt;left&gt; and &lt;right&gt; fields, or a callable returning such table (will be called with no arguments). Strings can contain new lines character “” to add multiline parts.\nExamples:\n-- Lua block string\n{ left = '[[', right = ']]' }\n\n-- Brackets on separate lines (indentation is not preserved)\n{ left = '(\\n', right = '\\n)' }\n\n-- Function call\nfunction()\n  local function_name = MiniSurround.user_input('Function name')\n  return { left = function_name .. '(', right = ')' }\nend\n\n\n\n\nCount with actions\n[count] is supported by all actions in the following ways:\n\nIn add, two types of [count] is supported in Normal mode: [count1]sa[count2][textobject]. The [count1] defines how many times left and right parts of output surrounding will be repeated and [count2] is used for textobject. In Visual mode [count] is treated as [count1]. Example: 2sa3aw) and v3aw2sa) will result into textobject 3aw being surrounded by (( and )).\nIn delete/replace/find/highlight [count] means “find n-th surrounding and execute operator on it”. Example: 2sd) on line (a(b(c)b)a) with cursor on c will result into (ab(c)ba) (and not in (abcba) if it would have meant “delete n times”).\n\n\n\n\nSearch algorithm\nSearch for the input surrounding relies on these principles:\n\nInput surrounding specification is constructed based on surrounding identifier (see MiniSurround-surrounding-specification).\nGeneral search is done by converting some 2d buffer region (neighborhood of reference region) into 1d string (each line is appended with \\n). Then search for a best span matching specification is done inside string (see MiniSurround-glossary). After that, span is converted back into 2d region. Note: first search is done inside reference region lines, and only after that - inside its neighborhood within config.n_lines (see MiniSurround.config).\nThe best matching span is chosen by iterating over all spans matching surrounding specification and comparing them with “current best”. Comparison also depends on reference region (tighter covering is better, otherwise closer is better) and search method (if span is even considered).\nExtract pair of spans (for left and right regions in region pair) based on extraction pattern (last item in nested pattern).\nFor [count] greater than 1, steps are repeated with current best match becoming reference region. One such additional step is also done if final region is equal to reference region.\n\nNotes:\n\nIteration over all matched spans is done in depth-first fashion with respect to nested pattern.\nIt is guaranteed that span is compared only once.\nFor the sake of increasing functionality, during iteration over all matching spans, some Lua patterns in composed pattern are handled specially.\n\n%bxx (xx is two identical characters). It denotes balanced pair of identical characters and results into “paired” matches. For example, %b\"\" for \"aa\" \"bb\" would match \"aa\" and \"bb\", but not middle \" \".\nx.-y (x and y are different strings). It results only in matches with smallest width. For example, e.-o for e e o o will result only in middle e o. Note: it has some implications for when parts have quantifiers (like +, etc.), which usually can be resolved with frontier pattern %f[].\n\n\n\n\n\nsetup()\n\nMiniSurround.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniSurround.config.\n\n\nUsage\nrequire('mini.surround').setup() -- use default config\n-- OR\nrequire('mini.surround').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniSurround.config\n\n\nDefaults\nMiniSurround.config = {\n  -- Add custom surroundings to be used on top of builtin ones. For more\n  -- information with examples, see `:h MiniSurround.config`.\n  custom_surroundings = nil,\n\n  -- Duration (in ms) of highlight when calling `MiniSurround.highlight()`\n  highlight_duration = 500,\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    add = 'sa', -- Add surrounding in Normal and Visual modes\n    delete = 'sd', -- Delete surrounding\n    find = 'sf', -- Find surrounding (to the right)\n    find_left = 'sF', -- Find surrounding (to the left)\n    highlight = 'sh', -- Highlight surrounding\n    replace = 'sr', -- Replace surrounding\n\n    suffix_last = 'l', -- Suffix to search with \"prev\" method\n    suffix_next = 'n', -- Suffix to search with \"next\" method\n  },\n\n  -- Number of lines within which surrounding is searched\n  n_lines = 20,\n\n  -- Whether to respect selection type:\n  -- - Place surroundings on separate lines in linewise mode.\n  -- - Place surroundings on each line in blockwise mode.\n  respect_selection_type = false,\n\n  -- How to search for surrounding (first inside current line, then inside\n  -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',\n  -- 'cover_or_nearest', 'next', 'prev', 'nearest'. For more details,\n  -- see `:h MiniSurround.config`.\n  search_method = 'cover',\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}\n\n\nMappings\nconfig.mappings defines what mappings are set up for particular actions. By default it uses “prefix style” left hand side starting with “s” (for “surround”): sa - “surround add”, sd - “surround delete”, etc.\nNote: if any of the mappings start with “s” (as is by default), it is mapped to &lt;Nop&gt; to prevent accidental trigger of built-in s (can happen if there is a long enough delay between pressing “s” and the next key). Use cl instead.\n\n\nCustom surroundings\nUser can define own surroundings by supplying config.custom_surroundings. It should be a table with keys being single character surrounding identifier (supported by getcharstr()) and values - surround specification (see MiniSurround-surrounding-specification).\nGeneral recommendations:\n\nIn config.custom_surroundings only some data can be defined (like only output). Other fields will be taken from builtin surroundings.\nFunction returning surround info at &lt;input&gt; or &lt;output&gt; fields of specification is helpful when user input is needed (like asking for function name). Use input() or MiniSurround.user_input(). Return nil to stop any current surround operation.\nKeys should use character representation which can be getcharstr() output. For example, '\\r' and not '&lt;CR&gt;'.\n\nExamples of using config.custom_surroundings (see more examples at MiniSurround.gen_spec):\nlocal surround = require('mini.surround')\nsurround.setup({\n  custom_surroundings = {\n    -- Make `)` insert parts with spaces. `input` pattern stays the same.\n    [')'] = { output = { left = '( ', right = ' )' } },\n\n    -- Use function to compute surrounding info\n    ['*'] = {\n      input = function()\n        local n_star = MiniSurround.user_input('Number of * to find')\n        local many_star = string.rep('%*', tonumber(n_star) or 1)\n        return { many_star .. '().-()' .. many_star }\n      end,\n      output = function()\n        local n_star = MiniSurround.user_input('Number of * to output')\n        local many_star = string.rep('*', tonumber(n_star) or 1)\n        return { left = many_star, right = many_star }\n      end,\n    },\n  },\n})\n\n-- Create custom surrounding for Lua's block string `[[...]]`\n-- Use this inside autocommand or 'after/ftplugin/lua.lua' file\nvim.b.minisurround_config = {\n  custom_surroundings = {\n    s = {\n      input = { '%[%[().-()%]%]' },\n      output = { left = '[[', right = ']]' },\n    },\n  },\n}\n\n\nRespect selection type\nBoolean option config.respect_selection_type controls whether to respect selection type when adding and deleting surrounding. When enabled:\n\nLinewise adding places surroundings on separate lines while indenting surrounded lines ones.\nDeleting surroundings which look like they were the result of linewise adding will act to revert it: delete lines with surroundings and dedent surrounded lines ones.\nBlockwise adding places surroundings on whole edges, not only start and end of selection. Note: it doesn’t really work outside of text and in presence of multibyte characters; and probably won’t due to implementation difficulties.\n\n\n\nSearch method\nValue of config.search_method defines how best match search is done. Based on its value, one of the following matches will be selected:\n\nCovering match. Left/right edge is before/after left/right edge of reference region.\nPrevious match. Left/right edge is before left/right edge of reference region.\nNext match. Left/right edge is after left/right edge of reference region.\nNearest match. Whichever is closest among previous and next matches.\n\nPossible values are:\n\n'cover' (default) - use only covering match. Don’t use either previous or next; report that there is no surrounding found.\n'cover_or_next' - use covering match. If not found, use next.\n'cover_or_prev' - use covering match. If not found, use previous.\n'cover_or_nearest' - use covering match. If not found, use nearest.\n'next' - use next match.\n'previous' - use previous match.\n'nearest' - use nearest match.\n\nNote: search is first performed on the reference region lines and only after failure - on the whole neighborhood defined by config.n_lines. This means that with config.search_method not equal to 'cover', “previous” or “next” surrounding will end up as search result if they are found on first stage although covering match might be found in bigger, whole neighborhood. This design is based on observation that most of the time operation is done within reference region lines (usually cursor line).\nHere is an example of how replacing ) with ] surrounding is done based on a value of 'config.search_method' when cursor is inside bbb word:\n\n'cover': (a) bbb (c) -&gt; (a) bbb (c) (with message)\n'cover_or_next': (a) bbb (c) -&gt; (a) bbb [c]\n'cover_or_prev': (a) bbb (c) -&gt; [a] bbb (c)\n'cover_or_nearest': depends on cursor position. For first and second b - as in cover_or_prev (as previous match is nearer), for third - as in cover_or_next (as next match is nearer).\n'next': (a) bbb (c) -&gt; (a) bbb [c]. Same outcome for (bbb).\n'prev': (a) bbb (c) -&gt; [a] bbb (c). Same outcome for (bbb).\n'nearest': depends on cursor position (same as in 'cover_or_nearest').\n\n\n\nSearch suffixes\nTo provide more searching possibilities, ‘mini.surround’ creates extended mappings force “prev” and “next” methods for particular search. It does so by appending mapping with certain suffix: config.mappings.suffix_last for mappings which will use “prev” search method, config.mappings.suffix_next\n\n“next” search method.\n\nNotes:\n\nIt creates new mappings only for actions involving surrounding search: delete, replace, find (right and left), highlight.\nAll new mappings behave the same way as if config.search_method is set to certain search method. They preserve dot-repeat support, respect [count].\nSupply empty string to disable creation of corresponding set of mappings.\n\nExample with default values (n for suffix_next, l for suffix_last) and initial line (aa) (bb) (cc).\n\nTyping sdn) with cursor inside (aa) results into (aa) bb (cc).\nTyping sdl) with cursor inside (cc) results into (aa) bb (cc).\nTyping 2srn)] with cursor inside (aa) results into (aa) (bb) [cc].\n\n\n\nSetup similar to ‘tpope/vim-surround’\nMiniSurround-vim-surround-config\nThis module is primarily designed after ‘machakann/vim-sandwich’. To get behavior closest to ‘tpope/vim-surround’ (but not identical), use this setup:\nrequire('mini.surround').setup({\n  mappings = {\n    add = 'ys',\n    delete = 'ds',\n    find = '',\n    find_left = '',\n    highlight = '',\n    replace = 'cs',\n\n    -- Add this only if you don't want to use extended mappings\n    suffix_last = '',\n    suffix_next = '',\n  },\n  search_method = 'cover_or_next',\n})\n\n-- Remap adding surrounding to Visual mode selection\nvim.keymap.del('x', 'ys')\nvim.keymap.set('x', 'S', [[:&lt;C-u&gt;lua MiniSurround.add('visual')&lt;CR&gt;]], { silent = true })\n\n-- Make special mapping for \"add surrounding for line\"\nvim.keymap.set('n', 'yss', 'ys_', { remap = true })\n\n\n\n\nadd()\n\nMiniSurround.add({mode})\n\nAdd surrounding\nNo need to use it directly, everything is setup in MiniSurround.setup().\n\nParameters\n{mode} (string) Mapping mode (normal by default).\n\n\n\n\ndelete()\n\nMiniSurround.delete()\n\nDelete surrounding\nNo need to use it directly, everything is setup in MiniSurround.setup().\n\n\n\nreplace()\n\nMiniSurround.replace()\n\nReplace surrounding\nNo need to use it directly, everything is setup in MiniSurround.setup().\n\n\n\nfind()\n\nMiniSurround.find()\n\nFind surrounding\nNo need to use it directly, everything is setup in MiniSurround.setup().\n\n\n\nhighlight()\n\nMiniSurround.highlight()\n\nHighlight surrounding\nNo need to use it directly, everything is setup in MiniSurround.setup().\n\n\n\nupdate_n_lines()\n\nMiniSurround.update_n_lines()\n\nUpdate MiniSurround.config.n_lines from user input\nMapping example:\nvim.keymap.set('n', 'sn', '&lt;Cmd&gt;lua MiniSurround.update_n_lines()&lt;CR&gt;')\n\n\n\nuser_input()\n\nMiniSurround.user_input({prompt}, {text})\n\nAsk user for input\nThis is mainly a wrapper for input() which allows empty string as input, cancelling with &lt;Esc&gt; and &lt;C-c&gt;, and slightly modifies prompt. Use it to ask for input inside function custom surrounding (see MiniSurround.config).\n\n\n\ngen_spec\n\nMiniSurround.gen_spec\n\nGenerate common surrounding specifications\nThis is a table with two sets of generator functions: &lt;input&gt; and &lt;output&gt; (currently empty). Each is a table with function values generating corresponding surrounding specification.\n\nSee also\nMiniAi.gen_spec\n\n\n\n\ngen_spec.input.treesitter()\n\nMiniSurround.gen_spec.input.treesitter({captures}, {opts})\n\nTreesitter specification for input surrounding\nThis is a specification in function form. When called with a pair of treesitter captures, it returns a specification function outputting an array of region pairs derived from &lt;outer&gt; and &lt;inner&gt; captures. It first searches for all matched nodes of outer capture and then completes each one with the biggest match of inner capture inside that node (if any). The result region pair is a difference between regions of outer and inner captures.\nIn order for this to work, apart from working treesitter parser for desired language, user should have a reachable language-specific ‘textobjects’ query (see vim.treesitter.query.get()). The most straightforward way for this is to have ‘textobjects.scm’ query file with treesitter captures stored in some recognized path. This is primarily designed to be compatible with plugin ‘nvim-treesitter/nvim-treesitter-textobjects’, but can be used without it.\nTwo most common approaches for having a query file:\n\nInstall ‘nvim-treesitter/nvim-treesitter-textobjects’. It has curated and well maintained builtin query files for many languages with a standardized capture names, like call.outer, call.inner, etc.\nManually create file ‘after/queries//textobjects.scm’ in your $XDG_CONFIG_HOME directory. It should contain queries with captures (later used to define surrounding parts). See lua-treesitter-query. To verify that query file is reachable, run (example for “lua” language, output should have at least an intended file):\n:lua print(vim.inspect(vim.treesitter.query.get_files('lua','textobjects')))\n\nExample configuration for function definition textobject with ‘nvim-treesitter/nvim-treesitter-textobjects’ captures:\nlocal ts_input = require('mini.surround').gen_spec.input.treesitter\nrequire('mini.surround').setup({\n  custom_surroundings = {\n    -- Use tree-sitter to search for function call\n    f = {\n      input = ts_input({ outer = '@call.outer', inner = '@call.inner' })\n    },\n  }\n})\nNotes:\n\nBe sure that query files don’t contain unknown treesitter-directives (like #make-range!, for example). Otherwise surrounding with such captures might not be found as lua-treesitter-core won’t treat them as captures. Verify with :=vim.treesitter.query.get('lang', 'textobjects') and see if the target capture is recognized as one.\nIt uses buffer’s filetype to determine query language.\nOn large files it is slower than pattern-based textobjects. Still very fast though (one search should be magnitude of milliseconds or tens of milliseconds on really large file).\n\n\nParameters\n{captures} (table) Captures for outer and inner parts of region pair: table with &lt;outer&gt; and &lt;inner&gt; fields with captures for outer ([left.form; right.to]) and inner ((left.to; right.from) both edges exclusive, i.e. they won’t be a part of surrounding) regions. Each value should be a string capture starting with '@'.\n{opts} (table|nil) Options. Possible values:\n\n&lt;use_nvim_treesitter&gt; - whether to try to use ‘nvim-treesitter’ plugin (if present) to do the query. It used to implement more advanced behavior and more coherent experience if ‘nvim-treesitter-textobjects’ queries are used. However, as lua-treesitter-core methods are more capable now, the option will soon be removed. Only present for backward compatibility. Default: false.\n\n\n\nReturn\n(function) Function which returns array of current buffer region pairs representing differences between outer and inner captures.\n\n\nSee also\n\nMiniSurround-surrounding-specification for how this type of surrounding specification is processed.\nvim.treesitter.query.get() for how query is fetched.\nQuery:iter_captures() for how all query captures are iterated in case of no ‘nvim-treesitter’.\nMiniAi.gen_spec.treesitter() for similar ‘mini.ai’ generator."
  },
  {
    "objectID": "mini.nvim/doc/mini-jump2d.html",
    "href": "mini.nvim/doc/mini-jump2d.html",
    "title": "mini.jump2d documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.jump2d Jump within visible lines\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nJump within visible lines via iterative label filtering.\nFeatures:\n\nMake jump by iterative filtering of possible, equally considered jump spots until there is only one. Filtering is done by typing a label character that is visualized at jump spot.\nCustomizable (see MiniJump2d.config):\n\nWay of computing possible jump spots with opinionated default.\nCharacters used to label jump spots during iterative filtering.\nVisual effects: how many steps ahead to show; dim lines with spots.\nAction hooks to be executed at certain events during jump.\nAllowed windows: current and/or not current.\nAllowed lines: whether to process blank or folded lines, lines before/at/after cursor line, etc. Example: user can configure to look for spots only inside current window at or after cursor line. Example: user can configure to look for word starts only inside current window at or after cursor line with ‘j’ and ‘k’ labels performing some action after jump.\n\nWorks in Visual and Operator-pending (with dot-repeat) modes.\nPreconfigured ways of computing jump spots (see MiniJump2d.builtin_opts):\n\nStarts of lines.\nStarts of words.\nSingle character from user input.\nVariable length query from user input.\n\nWorks with multibyte characters.\n\nGeneral overview of how jump is intended to be performed:\n\nLock eyes on desired location (“spot”) recognizable by future jump. Should be within visible lines at place where cursor can be placed.\nInitiate jump. Either by custom keybinding or with a call to MiniJump2d.start() (allows customization options). This will highlight all possible jump spots with their labels (letters from “a” to “z” by default). For more details, read MiniJump2d.start() and MiniJump2d.config.\nType character that appeared over desired location. If its label was unique, jump is performed. If it wasn’t unique, possible jump spots are filtered to those having the same label character.\nRepeat previous step until there is only one possible jump spot or type &lt;CR&gt; to jump to first available jump spot. Typing anything else stops jumping without moving cursor.\n\n\nSetup\nThis module needs a setup with require('mini.jump2d').setup({}) (replace {} with your config table). It will create global Lua table MiniJump2d which you can use for scripting or manually (with :lua MiniJump2d.*).\nSee MiniJump2d.config for available config settings.\nYou can override runtime config settings locally to buffer inside vim.b.minijump2d_config which should have same structure as MiniJump2d.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nExample usage\n\nModify default jumping to use only current window at or after cursor line:\nrequire('mini.jump2d').setup({\n  allowed_lines = { cursor_before = false },\n  allowed_windows = { not_current = false },\n})\nJump to line start using combination of options supplied in MiniJump2d.config and MiniJump2d.builtin_opts.line_start:\n:lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)\nJump to a single character typed after executing this command:\n:lua MiniJump2d.start(MiniJump2d.builtin_opts.single_character)\nSee more examples in MiniJump2d.start() and MiniJump2d.builtin_opts.\n\n\n\nComparisons\n\nphaazon/hop.nvim:\n\nBoth are fast, customizable, and extensible (user can write their own ways to define jump spots).\n‘hop.nvim’ visualizes all steps at once. While this module can show configurable number of steps ahead.\nBoth have several builtin ways to specify type of jump (word start, line start, one character or query based on user input). ‘hop.nvim’ does that by exporting many targeted Neovim commands, while this module has preconfigured basic options leaving others to customization with Lua code (see MiniJump2d.builtin_opts).\n‘hop.nvim’ computes labels (called “hints”) differently. Contrary to this module deliberately not having preference of one jump spot over another, ‘hop.nvim’ uses specialized algorithm that produces sequence of keys in a slightly biased manner: some sequences are intentionally shorter than the others (leading to fewer average keystrokes). They are put near cursor (by default) and highlighted differently. Final order of sequences is based on distance to the cursor.\n‘mini.jump2d’ has opinionated default algorithm of computing jump spots. See MiniJump2d.default_spotter().\n\n\n\n\nHighlight groups\n\nMiniJump2dSpot - highlighting of jump spot’s next step. By default it uses label with highest contrast while not being too visually demanding: white on black for dark ‘background’, black on white for light. If it doesn’t suit your liking, try couple of these alternatives (or choose your own, of course):\n-- Reverse underlying colors (mostly *very* visible in any colorscheme)\nvim.api.nvim_set_hl(0, 'MiniJump2dSpot', { reverse = true })\n\n-- Bold italic\nvim.api.nvim_set_hl(0, 'MiniJump2dSpot', { bold = true, italic = true })\n\n-- Red undercurl\nvim.api.nvim_set_hl(0, 'MiniJump2dSpot', { sp = 'Red', undercurl = true })\nMiniJump2dSpotUnique - highlighting of jump spot’s next step if it has unique label. By default links to MiniJump2dSpot.\nMiniJump2dSpotAhead - highlighting of jump spot’s future steps. By default similar to MiniJump2dSpot but with less contrast and visibility.\nMiniJump2dDim - highlighting of lines with at least one jump spot. Make it non-bright in order for jump spot labels to be more visible. By default linked to Comment highlight group.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minijump2d_disable (globally) or vim.b.minijump2d_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniJump2d.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniJump2d.config.\n\n\nUsage\nrequire('mini.jump2d').setup() -- use default config\n-- OR\nrequire('mini.jump2d').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniJump2d.config\n\n\nDefaults\nMiniJump2d.config = {\n  -- Function producing jump spots (byte indexed) for a particular line.\n  -- For more information see |MiniJump2d.start()|.\n  -- If `nil` (default) - use |MiniJump2d.default_spotter()|\n  spotter = nil,\n\n  -- Characters used for labels of jump spots (in supplied order)\n  labels = 'abcdefghijklmnopqrstuvwxyz',\n\n  -- Options for visual effects\n  view = {\n    -- Whether to dim lines with at least one jump spot\n    dim = false,\n\n    -- How many steps ahead to show. Set to big number to show all steps.\n    n_steps_ahead = 0,\n  },\n\n  -- Which lines are used for computing spots\n  allowed_lines = {\n    blank = true, -- Blank line (not sent to spotter even if `true`)\n    cursor_before = true, -- Lines before cursor line\n    cursor_at = true, -- Cursor line\n    cursor_after = true, -- Lines after cursor line\n    fold = true, -- Start of fold (not sent to spotter even if `true`)\n  },\n\n  -- Which windows from current tabpage are used for visible lines\n  allowed_windows = {\n    current = true,\n    not_current = true,\n  },\n\n  -- Functions to be executed at certain events\n  hooks = {\n    before_start = nil, -- Before jump start\n    after_jump = nil, -- After jump was actually done\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    start_jumping = '&lt;CR&gt;',\n  },\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}\n\n\nSpotter function\nActual computation of possible jump spots is done through spotter function. It should have the following arguments:\n\nline_num is a line number inside buffer.\nargs - table with additional arguments:\n\n{win_id} - identifier of a window where input line number is from.\n{win_id_init} - identifier of a window which was current when MiniJump2d.start() was called.\n\n\nIts output is a list of byte-indexed positions that should be considered as possible jump spots for this particular line in this particular window. Note: for a more aligned visualization this list should be (but not strictly necessary) sorted increasingly.\nNote: spotter function is always called with win_id window being “temporary current” (see nvim_win_call()). This allows using builtin Vimscript functions that operate only inside current window.\n\n\nView\nOption view.n_steps_ahead controls how many steps ahead to show along with the currently required label. Those future steps are shown with different (less visible) highlight group (“MiniJump2dSpotAhead”). Usually it is a good idea to use this with a spotter which doesn’t result into many jump spots (like, for example, MiniJump2d.builtin_opts.word_start). Default is 0 to not show anything ahead as it reduces visual noise.\nOption view.dim controls whether to dim lines with at least one jump spot. Dimming is done by applying “MiniJump2dDim” highlight group to the whole line.\n\n\nAllowed lines\nOption allowed_lines controls which lines will be used for computing possible jump spots:\n\nIf blank or fold is true, it is possible to jump to first column of blank line (determined by prevnonblank()) or first folded one (determined by foldclosed()) respectively. Otherwise they are skipped. These lines are not processed by spotter function even if the option is true.\nIf cursor_before, (cursor_at, cursor_after) is true, lines before (at, after) cursor line of all processed windows are forwarded to spotter function. Otherwise, they don’t. This allows control of jump “direction”.\n\n\n\nHooks\nFollowing hook functions can be used to further tweak jumping experience:\n\nbefore_start - called without arguments first thing when jump starts. One of the possible use cases is to ask for user input and update spotter function with it.\nafter_jump - called after jump was actually done. Useful to make post-adjustments (like move cursor to first non-whitespace character).\n\n\n\n\n\nstart()\n\nMiniJump2d.start({opts})\n\nStart jumping\nCompute possible jump spots, visualize them and wait for iterative filtering.\n\nFirst computation of possible jump spots\n\nProcess allowed windows (current and/or not current; controlled by allowed_windows option) by visible lines from top to bottom. For each one see if it is allowed (controlled by allowed_lines option). If not allowed, then do nothing. If allowed and should be processed by spotter, process it.\nApply spotter function from spotter option for each appropriate line and concatenate outputs. This means that eventual order of jump spots aligns with lexicographical order within “window id” - “line number” - “position in spotter output” tuples.\nFor each possible jump compute its label: a single character from labels option used to filter jump spots. Each possible label character might be used more than once to label several “consecutive” jump spots. It is done in an optimal way under assumption of no preference of one spot over another. Basically, it means “use all labels at each step of iterative filtering as equally as possible”.\n\n\n\nVisualization\nCurrent label for each possible jump spot is shown at that position overriding everything underneath it.\n\n\nIterative filtering\nLabels of possible jump spots are computed in order to use them as equally as possible.\nExample:\n\nWith abc as labels option, initial labels for 10 possible jumps are “aaaabbbccc”. As there are 10 spots which should be “coded” with 3 symbols, at least 2 symbols need 3 steps to filter them out. With current implementation those are always the “first ones”.\nAfter typing a, it filters first four jump spots and recomputes its labels to be “aabc”.\nAfter typing a again, it filters first two spots and recomputes its labels to be “ab”.\nAfter typing either a or b it filters single spot and makes jump.\n\nWith default 26 labels for most real-world cases 2 steps is enough for default spotter function. Rarely 3 steps are needed with several windows.\n\n\nParameters\n{opts} (table|nil) Configuration of jumping, overriding global and buffer local values. Has the same structure as MiniJump2d.config without &lt;mappings&gt; field. Extra allowed fields:\n\n&lt;hl_group&gt; - highlight group for first step. Default: \"MiniJump2dSpot\".\n&lt;hl_group_ahead&gt; - highlight group for second and later steps. Default: \"MiniJump2dSpotAhead\".\n&lt;hl_group_dim&gt; - highlight group for dimming used lines. Default: \"MiniJump2dDim\".\n&lt;hl_group_unique&gt; - highlight group for unique next step. Default: \"MiniJump2dSpotUnique\".\n\n\n\nUsage\n-- Start default jumping\nMiniJump2d.start()\n\n-- Jump to word start\nMiniJump2d.start(MiniJump2d.builtin_opts.word_start)\n\n-- Jump to single character from user input (follow by typing one character)\nMiniJump2d.start(MiniJump2d.builtin_opts.single_character)\n\n-- Jump to first character of punctuation group only inside current window\n-- which is placed at cursor line; visualize with `Search`\nMiniJump2d.start({\n  spotter = MiniJump2d.gen_spotter.pattern('%p+'),\n  allowed_lines = { cursor_before = false, cursor_after = false },\n  allowed_windows = { not_current = false },\n  hl_group = 'Search'\n})\n\n\nSee also\nMiniJump2d.config\n\n\n\n\nstop()\n\nMiniJump2d.stop()\n\nStop jumping\n\n\n\ngen_spotter\n\nMiniJump2d.gen_spotter\n\nGenerate spotter\nThis is a table with function elements. Call to actually get a spotter.\n\n\n\ngen_spotter.pattern()\n\nMiniJump2d.gen_spotter.pattern({pattern}, {side})\n\nGenerate spotter for Lua pattern\n\nParameters\n{pattern} (string|nil) Lua pattern. Default: '[^%s%p]+' which matches group of “non-whitespace non-punctuation characters” (basically a way of saying “group of alphanumeric characters” that works with multibyte characters).\n{side} (string|nil) Which side of pattern match should be considered as jumping spot. Should be one of ‘start’ (start of match, default), ‘end’ (inclusive end of match), or ‘none’ (match for spot is done manually inside pattern with plain () matching group).\n\n\nReturn\n(function) Spotter function.\n\n\nUsage\n-- Match any punctuation\nMiniJump2d.gen_spotter.pattern('%p')\n\n-- Match first from line start non-whitespace character\nMiniJump2d.gen_spotter.pattern('^%s*%S', 'end')\n\n-- Match start of last word\nMiniJump2d.gen_spotter.pattern('[^%s%p]+[%s%p]-$', 'start')\n\n-- Match letter followed by another letter (example of manual matching\n-- inside pattern)\nMiniJump2d.gen_spotter.pattern('%a()%a', 'none')\n\n\n\n\ngen_spotter.vimpattern()\n\nMiniJump2d.gen_spotter.vimpattern({pattern})\n\nGenerate spotter for Vimscript pattern\n\nParameters\n{pattern} (string|nil) Vimscript pattern. Default: \\k\\+ to match group of “keyword characters” (see ‘iskeyword’).\n\n\nReturn\n(function) Spotter function.\n\n\nUsage\n-- Match start of a keyword\nMiniJump2d.gen_spotter.vimpattern('\\\\k\\\\+')\n\n-- Match end of a keyword\nMiniJump2d.gen_spotter.vimpattern('\\\\k*\\\\zs\\\\k')\n\n\n\n\ngen_spotter.union()\n\nMiniJump2d.gen_spotter.union({…})\n\nGenerate union of spotters\n\nParameters\n{…} (any) Each argument should be a valid spotter. See MiniJump2d.config for more details.\n\n\nReturn\n(function) Spotter producing union of spots.\n\n\nUsage\n-- Match start and end of non-blank character groups:\nlocal nonblank_start = MiniJump2d.gen_spotter.pattern('%S+', 'start')\nlocal nonblank_end = MiniJump2d.gen_spotter.pattern('%S+', 'end')\nlocal spotter = MiniJump2d.gen_spotter.union(nonblank_start, nonblank_end)\n\n\n\n\ndefault_spotter()\n\nMiniJump2d.default_spotter\n\nDefault spotter function\nSpot is possible for jump if it is one of the following:\n\nStart or end of non-whitespace character group.\nAlphanumeric character followed or preceded by punctuation (useful for snake case names).\nStart of uppercase character group (useful for camel case names). Usually only Latin alphabet is recognized due to Lua patterns shortcomings.\n\nThese rules are derived in an attempt to balance between two intentions:\n\nAllow as much useful jumping spots as possible.\nMake labeled jump spots easily distinguishable.\n\nUsually takes from 2 to 3 keystrokes to get to destination.\n\n\n\nbuiltin_opts\n\nMiniJump2d.builtin_opts\n\nTable with builtin opts values for MiniJump2d.start()\nEach element of table is itself a table defining one or several options for MiniJump2d.start(). Read help description to see which options it defines (like in MiniJump2d.builtin_opts.line_start).\n\nUsage\n-- Using `MiniJump2d.builtin_opts.line_start` as example:\n-- Command\n:lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)\n\n-- Custom mapping\nvim.keymap.set(\n  'n', '&lt;CR&gt;',\n  '&lt;Cmd&gt;lua MiniJump2d.start(MiniJump2d.builtin_opts.line_start)&lt;CR&gt;'\n)\n\n-- Inside `MiniJump2d.setup()` (make sure to use all defined options)\nlocal jump2d = require('mini.jump2d')\nlocal jump_line_start = jump2d.builtin_opts.line_start\njump2d.setup({\n  spotter = jump_line_start.spotter,\n  hooks = { after_jump = jump_line_start.hooks.after_jump }\n})\n\n\n\n\nbuiltin_opts.default\n\nMiniJump2d.builtin_opts.default\n\nJump with MiniJump2d.default_spotter()\nDefines spotter.\n\n\n\nbuiltin_opts.line_start\n\nMiniJump2d.builtin_opts.line_start\n\nJump to line start\nDefines spotter and hooks.after_jump.\n\n\n\nbuiltin_opts.word_start\n\nMiniJump2d.builtin_opts.word_start\n\nJump to word start\nRespects ‘iskeyword’ when computing word start.\nDefines spotter.\n\n\n\nbuiltin_opts.single_character\n\nMiniJump2d.builtin_opts.single_character\n\nJump to single character taken from user input\nDefines spotter, allowed_lines.blank, allowed_lines.fold, and hooks.before_start.\n\n\n\nbuiltin_opts.query\n\nMiniJump2d.builtin_opts.query\n\nJump to query taken from user input\nDefines spotter, allowed_lines.blank, allowed_lines.fold, and hooks.before_start."
  },
  {
    "objectID": "mini.nvim/doc/mini-test.html",
    "href": "mini.nvim/doc/mini-test.html",
    "title": "mini.test documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.test Test Neovim plugins\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nTest action is defined as a named callable entry of a table.\nHelper for creating child Neovim process which is designed to be used in tests (including taking and verifying screenshots). See MiniTest.new_child_neovim() and MiniTest.expect.reference_screenshot().\nHierarchical organization of tests with custom hooks, parametrization, and user data. See MiniTest.new_set().\nEmulation of lunarmodules/busted interface (describe, it, etc.).\nPredefined small yet usable set of expectations (assert-like functions). See MiniTest.expect.\nCustomizable definition of what files should be tested.\nTest case filtering. There are predefined wrappers for testing a file (MiniTest.run_file()) and case at a location like current cursor position (MiniTest.run_at_location()).\nCustomizable reporter of output results. There are two predefined ones:\n\nMiniTest.gen_reporter.buffer() for interactive usage.\nMiniTest.gen_reporter.stdout() for headless Neovim.\n\nCustomizable project specific testing script.\nWorks on Unix (Linux, MacOS, etc.) and Windows.\n\nWhat it doesn’t support:\n\nParallel execution. Due to idea of limiting implementation complexity.\nMocks, stubs, etc. Use child Neovim process and manually override what is needed. Reset child process it afterwards.\n“Overly specific” expectations. Tests for (no) equality and (absence of) errors usually cover most of the needs. Adding new expectations is a subject to weighing its usefulness against additional implementation complexity. Use MiniTest.new_expectation() to create custom ones.\n\nFor more information see:\n\n‘TESTING.md’ file for a hands-on introduction based on examples.\nCode of this plugin’s tests. Consider it to be an example of intended way to use ‘mini.test’ for test organization and creation.\n\n\nWorkflow\n\nOrganize tests in separate files. Each test file should return a test set (explicitly or implicitly by using “busted” style functions).\nWrite test actions as callable entries of test set. Use child process inside test actions (see MiniTest.new_child_neovim()) and builtin expectations (see MiniTest.expect).\nRun tests. This does two steps:\n\nCollect. This creates single hierarchical test set, flattens into array of test cases (see MiniTest-test-case) while expanding with parametrization, and possibly filters them.\nExecute. This safely calls hooks and main test actions in specified order while allowing reporting progress in asynchronous fashion. Detected errors means test case fail; otherwise - pass.\n\n\n\n\nSetup\nThis module needs a setup with require('mini.test').setup({}) (replace {} with your config table). It will create global Lua table MiniTest which you can use for scripting or manually (with :lua MiniTest.*).\nSee MiniTest.config for available config settings.\nYou can override runtime config settings locally to buffer inside vim.b.minitest_config which should have same structure as MiniTest.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nComparisons\n\nTesting infrastructure from nvim-lua/plenary.nvim:\n\nExecutes each file in separate headless Neovim process with customizable ‘init.vim’ file. While ‘mini.test’ executes everything in current Neovim process encouraging writing tests with help of manually managed child Neovim process (see MiniTest.new_child_neovim()).\nTests are expected to be written with embedded simplified versions of ‘lunarmodules/busted’ and ‘lunarmodules/luassert’. While ‘mini.test’ uses concepts of test set (see MiniTest.new_set()) and test case (see MiniTest-test-case). It also can emulate bigger part of “busted” framework.\nHas single way of reporting progress (shows result after every case without summary). While ‘mini.test’ can have customized reporters with defaults for interactive and headless usage (provide more compact and user-friendly summaries).\nAllows parallel execution, while ‘mini.test’ does not.\nAllows making mocks, stubs, and spies, while ‘mini.test’ does not in favor of manually overwriting functionality in child Neovim process.\n\n\nAlthough ‘mini.test’ supports emulation of “busted style” testing, it will be more stable to use its designed approach of defining tests (with MiniTest.new_set() and explicit table fields). Couple of reasons:\n\n“Busted” syntax doesn’t support full capabilities offered by ‘mini.test’. Mainly it is about parametrization and supplying user data to test sets.\nIt is an emulation, not full support. So some subtle things might not work the way you expect.\n\nSome hints for converting from ‘plenary.nvim’ tests to ‘mini.test’:\n\nRename files from “spec.lua” to ”test.lua” and put them in “tests” directory.\nReplace assert calls with ‘mini.test’ expectations. See MiniTest.expect.\nCreate main test set T = MiniTest.new_set() and eventually return it.\nMake new sets (MiniTest.new_set()) from describe blocks. Convert before_each() and after_each to pre_case and post_case hooks.\nMake test cases from it blocks.\n\n\n\nHighlight groups\n\nMiniTestEmphasis - emphasis highlighting. By default it is a bold text.\nMiniTestFail - highlighting of failed cases. By default it is a bold text with vim.g.terminal_color_1 color (red).\nMiniTestPass - highlighting of passed cases. By default it is a bold text with vim.g.terminal_color_2 color (green).\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minitest_disable (globally) or vim.b.minitest_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniTest.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniTest.config.\n\n\nUsage\nrequire('mini.test').setup() -- use default config\n-- OR\nrequire('mini.test').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniTest.config\n\n\nDefaults\nMiniTest.config = {\n  -- Options for collection of test cases. See `:h MiniTest.collect()`.\n  collect = {\n    -- Temporarily emulate functions from 'busted' testing framework\n    -- (`describe`, `it`, `before_each`, `after_each`, and more)\n    emulate_busted = true,\n\n    -- Function returning array of file paths to be collected.\n    -- Default: all Lua files in 'tests' directory starting with 'test_'.\n    find_files = function()\n      return vim.fn.globpath('tests', '**/test_*.lua', true, true)\n    end,\n\n    -- Predicate function indicating if test case should be executed\n    filter_cases = function(case) return true end,\n  },\n\n  -- Options for execution of test cases. See `:h MiniTest.execute()`.\n  execute = {\n    -- Table with callable fields `start()`, `update()`, and `finish()`\n    reporter = nil,\n\n    -- Whether to stop execution after first error\n    stop_on_error = false,\n  },\n\n  -- Path (relative to current directory) to script which handles project\n  -- specific test running\n  script_path = 'scripts/minitest.lua',\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}\n\n\n\n\ncurrent\n\nMiniTest.current\n\nTable with information about current state of test execution\nUse it to examine result of MiniTest.execute(). It is reset at the beginning of every call.\nAt least these keys are supported:\n\n&lt;all_cases&gt; - array with all cases being currently executed. Basically, an input of MiniTest.execute().\n&lt;case&gt; - currently executed test case. See MiniTest-test-case. Use it to customize execution output (like adding custom notes, etc).\n\n\n\n\nnew_set()\n\nMiniTest.new_set({opts}, {tbl})\n\nCreate test set\nTest set is one of the two fundamental data structures. It is a table that defines hierarchical test organization as opposed to sequential organization with MiniTest-test-case.\nAll its elements are one of three categories:\n\nA callable (object that can be called; function or table with __call metatble entry) is considered to define a test action. It will be called with “current arguments” (result of all nested parametrize values, read further). If it throws error, test has failed.\nA test set (output of this function) defines nested structure. Its options during collection (see MiniTest.collect()) will be extended with options of this (parent) test set.\nAny other elements are considered helpers and don’t directly participate in test structure.\n\nSet options allow customization of test collection and execution (more details in opts description):\n\nhooks - table with elements that will be called without arguments at predefined stages of test execution.\nparametrize - array defining different arguments with which main test actions will be called. Any non-trivial parametrization will lead to every element (even nested) be “multiplied” and processed with every element of parametrize. This allows handling many different combination of tests with little effort.\ndata - table with user data that will be forwarded to cases. Primary objective is to be used for customized case filtering.\n\nNotes:\n\nPreferred way of adding elements is by using syntax T[name] = element. This way order of added elements will be preserved. Any other way won’t guarantee any order.\nSupplied options opts are stored in opts field of metatable (getmetatable(set).opts).\n\n\nParameters\n{opts} (table|nil) Allowed options:\n\n&lt;hooks&gt; - table with fields:\n\n&lt;pre_once&gt; - executed before first filtered node.\n&lt;pre_case&gt; - executed before each case (even nested).\n&lt;post_case&gt; - executed after each case (even nested).\n&lt;post_once&gt; - executed after last filtered node.\n\n&lt;parametrize&gt; - array where each element is itself an array of parameters to be appended to “current parameters” of callable fields. Note: don’t use plain {} as it is equivalent to “parametrization into zero cases”, so no cases will be collected from this set. Calling test actions with no parameters is equivalent to {{}} or not supplying parametrize option at all.\n&lt;data&gt; - user data to be forwarded to cases. Can be used for a more granular filtering.\n&lt;n_retry&gt; - number of times to retry each case until success. Default: 1.\n\n{tbl} (table|nil) Initial test items (possibly nested). Will be executed without any guarantees on order.\n\n\nReturn\n(table) A single test set.\n\n\nUsage\n-- Use with defaults\nT = MiniTest.new_set()\nT['works'] = function() MiniTest.expect.equality(1, 1) end\n\n-- Use with custom options. This will result into two actual cases: first\n-- will pass, second - fail after two attempts.\nT['nested'] = MiniTest.new_set({\n  hooks = { pre_case = function() _G.x = 1 end },\n  parametrize = { { 1 }, { 2 } },\n  n_retry = 2,\n})\n\nT['nested']['works'] = function(x) MiniTest.expect.equality(_G.x, x) end\n\n\n\n\nTest case\nTest case\nAn item of sequential test organization, as opposed to hierarchical with test set (see MiniTest.new_set()). It is created as result of test collection with MiniTest.collect() to represent all necessary information of test execution.\nExecution of test case goes by the following rules:\n\nCall functions in order:\n\nAll elements of hooks.pre from first to last without arguments.\nField test with arguments unpacked from args. If execution fails, retry it (along with hooks that come from pre_case and post_case) at most n_retry times until first success (if any).\nAll elements of hooks.post from first to last without arguments.\n\nError in any call gets appended to exec.fails, meaning error in any hook will lead to test fail.\nState (exec.state) is changed before every call and after last call.\n\n\nClass\n{Test-case}\n\n\nFields\n{args} (table) Array of arguments with which test will be called.\n{data} (table) User data: all fields of opts.data from nested test sets.\n{desc} (table) Description: array of fields from nested test sets.\n{exec} (table|nil) Information about test case execution. Value of nil means that this particular case was not (yet) executed. Has following fields:\n\n&lt;fails&gt; - array of strings with failing information.\n&lt;notes&gt; - array of strings with non-failing information.\n&lt;state&gt; - state of test execution. One of:\n\n‘Executing ’ (during execution).\n‘Pass’ (no fails, no notes).\n‘Pass with notes’ (no fails, some notes).\n‘Fail’ (some fails, no notes).\n‘Fail with notes’ (some fails, some notes).\n\n\n{hooks} (table) Hooks to be executed as part of test case. Has fields:\n\n&lt;pre&gt; and &lt;post&gt; - arrays of functions to be consecutively executed before and after every execution of test.\n&lt;pre_source&gt; and &lt;post_source&gt; - arrays of strings with sources of corresponding elements in &lt;pre&gt; and &lt;post&gt; arrays. Source is one of \"once\" (for pre_once and post_once hooks) and \"case\" (for pre_case and post_case hooks).\n\n{test} (function|table) Main callable object representing test action.\n\n\n\n\nskip()\n\nMiniTest.skip({msg})\n\nSkip the rest of current case\nNotes:\n\nWhen called inside test case, stops execution while adding message to notes.\nWhen called inside pre_case hook, registers skip at the start of its test case. Calling in other hooks has no effect.\nCurrently implemented as a specially handled type of error.\n\n\nParameters\n{msg} (string|nil) Message to be added to current case notes.\n\n\n\n\nadd_note()\n\nMiniTest.add_note({msg})\n\nAdd note to currently executed test case\nAppends msg to exec.notes field of case in MiniTest.current.\n\nParameters\n{msg} (string) Note to add.\n\n\n\n\nfinally()\n\nMiniTest.finally({f})\n\nRegister callable execution after current callable\nCan be used several times inside hooks and main test callable of test case.\n\nParameters\n{f} (function|table) Callable to be executed after current callable is finished executing (regardless of whether it ended with error or not).\n\n\n\n\nrun()\n\nMiniTest.run({opts})\n\nRun tests\n\nTry executing project specific script at path opts.script_path. If successful (no errors), then stop.\nCollect cases with MiniTest.collect() and opts.collect.\nExecute collected cases with MiniTest.execute() and opts.execute.\n\n\nParameters\n{opts} (table|nil) Options with structure similar to MiniTest.config. Absent values are inferred from there.\n\n\n\n\nrun_file()\n\nMiniTest.run_file({file}, {opts})\n\nRun specific test file\nBasically a MiniTest.run() wrapper with custom collect.find_files option.\n\nParameters\n{file} (string|nil) Path to test file. By default a path of current buffer.\n{opts} (table|nil) Options for MiniTest.run().\n\n\n\n\nrun_at_location()\n\nMiniTest.run_at_location({location}, {opts})\n\nRun case(s) covering location\nTry filtering case(s) covering location, meaning that definition of its main test action (as taken from builtin debug.getinfo) is located in specified file and covers specified line. Note that it can result in multiple cases if they come from parametrized test set (see parametrize option in MiniTest.new_set()).\nBasically a MiniTest.run() wrapper with custom collect.find_files option.\n\nParameters\n{location} (table|nil) Table with fields &lt;file&gt; (path to file) and &lt;line&gt; (line number in that file). Default is taken from current cursor position.\n\n\n\n\ncollect()\n\nMiniTest.collect({opts})\n\nCollect test cases\nOverview of collection process:\n\nIf opts.emulate_busted is true, temporary make special global functions (removed at the end of collection). They can be used inside test files to create hierarchical structure of test cases.\nSource each file from array output of opts.find_files. It should output a test set (see MiniTest.new_set()) or nil (if “busted” style is used; test set is created implicitly).\nCombine all test sets into single set with fields equal to its file path.\nConvert from hierarchical test configuration to sequential: from single test set to array of test cases (see MiniTest-test-case). Conversion is done in the form of “for every table element do: for every parametrize element do: …”. Details:\n\nIf element is a callable, construct test case with it being main test action. Description is appended with key of element in current test set table. Hooks, arguments, and data are taken from “current nested” ones. Add case to output array.\nIf element is a test set, process it in similar, recursive fashion. The “current nested” information is expanded:\n\nargs is extended with “current element” from parametrize.\ndesc is appended with element key.\nhooks are appended to their appropriate places. *_case hooks will be inserted closer to all child cases than hooks from parent test sets: pre_case at end, post_case at start.\ndata is extended via vim.tbl_deep_extend().\n\nAny other element is not processed.\n\nFilter array with opts.filter_cases. Note that input case doesn’t contain all hooks, as *_once hooks will be added after filtration.\nAdd *_once hooks to appropriate cases.\n\n\nParameters\n{opts} (table|nil) Options controlling case collection. Possible fields:\n\n&lt;emulate_busted&gt; - whether to emulate ‘lunarmodules/busted’ interface. It emulates these global functions: describe, it, setup, teardown,\n\nbefore_each, after_each. Use MiniTest.skip() instead of pending()\n\nand MiniTest.finally() instead of finally.\n&lt;find_files&gt; - function which when called without arguments returns array with file paths. Each file should be a Lua file returning single test set or nil.\n&lt;filter_cases&gt; - function which when called with single test case (see MiniTest-test-case) returns false if this case should be filtered out; true otherwise.\n\n\n\nReturn\n(table) Array of test cases ready to be used by MiniTest.execute().\n\n\n\n\nexecute()\n\nMiniTest.execute({cases}, {opts})\n\nExecute array of test cases\nOverview of execution process:\n\nReset all_cases in MiniTest.current with cases input.\nCall reporter.start(cases) (if present).\nExecute each case in natural array order (aligned with their integer keys). Set MiniTest.current.case to currently executed case. Detailed test case execution is described in MiniTest-test-case. After any state change (including case retry attempts), call reporter.update(case_num) (if present), where case_num is an integer key of current test case.\nCall reporter.finish() (if present).\n\nNotes:\n\nExecution is done in asynchronous fashion with scheduling. This allows making meaningful progress report during execution.\nThis function doesn’t return anything. Instead, it updates cases in place with proper exec field. Use all_cases at MiniTest.current to look at execution result.\n\n\nParameters\n{cases} (table) Array of test cases (see MiniTest-test-case).\n{opts} (table|nil) Options controlling case collection. Possible fields:\n\n&lt;reporter&gt; - table with possible callable fields start, update, finish. Default: MiniTest.gen_reporter.buffer() in interactive usage and MiniTest.gen_reporter.stdout() in headless usage.\n&lt;stop_on_error&gt; - whether to stop execution (see MiniTest.stop()) after first error. Default: false.\n\n\n\n\n\nstop()\n\nMiniTest.stop({opts})\n\nStop test execution\n\nParameters\n{opts} (table|nil) Options with fields:\n\n&lt;close_all_child_neovim&gt; - whether to close all child neovim processes created with MiniTest.new_child_neovim(). Default: true.\n\n\n\n\n\nis_executing()\n\nMiniTest.is_executing()\n\nCheck if tests are being executed\n\nReturn\n(boolean)\n\n\n\n\nexpect\n\nMiniTest.expect\n\nTable with expectation functions\nEach function has the following behavior:\n\nSilently returns true if expectation is fulfilled.\nThrows an informative error with information helpful for debugging.\n\nMostly designed to be used within ‘mini.test’ framework.\n\nUsage\nlocal x = 1 + 1\nMiniTest.expect.equality(x, 2) -- passes\nMiniTest.expect.equality(x, 1) -- fails\n\n\n\n\nexpect.equality()\n\nMiniTest.expect.equality({left}, {right})\n\nExpect equality of two objects\nEquality is tested via vim.deep_equal().\n\nParameters\n{left} (any) First object.\n{right} (any) Second object.\n\n\n\n\nexpect.no_equality()\n\nMiniTest.expect.no_equality({left}, {right})\n\nExpect no equality of two objects\nEquality is tested via vim.deep_equal().\n\nParameters\n{left} (any) First object.\n{right} (any) Second object.\n\n\n\n\nexpect.error()\n\nMiniTest.expect.error({f}, {pattern}, {…})\n\nExpect function call to raise error\n\nParameters\n{f} (function|table) Callable to be tested for raising error.\n{pattern} (string|nil) Pattern which error message should match. Use nil or empty string to not test for pattern matching.\n{…} (any) Extra arguments with which f will be called.\n\n\n\n\nexpect.no_error()\n\nMiniTest.expect.no_error({f}, {…})\n\nExpect function call to not raise error\n\nParameters\n{f} (function|table) Callable to be tested for raising error.\n{…} (any) Extra arguments with which f will be called.\n\n\n\n\nexpect.reference_screenshot()\n\nMiniTest.expect.reference_screenshot({screenshot}, {path}, {opts})\n\nExpect equality to reference screenshot\n\nParameters\n{screenshot} (table|nil) Array with screenshot information. Usually an output of child.get_screenshot() (see MiniTest-child-neovim-get_screenshot()). If nil, expectation passed.\n{path} (string|nil) Path to reference screenshot. If nil, constructed automatically in directory opts.directory from current case info and total number of times it was called inside current case. If there is no file at path, it is created with content of screenshot.\n{opts} (table|nil) Options:\n\n&lt;force&gt; (boolean) - whether to forcefully create reference screenshot. Temporary useful during test writing. Default: false.\n&lt;ignore_text&gt; (boolean|table) - whether to ignore all or some text lines. If true - ignore all, if number array - ignore text of those lines, if false - do not ignore any. Default: false.\n&lt;ignore_attr&gt; (boolean|table) - whether to ignore all or some attr lines. If true - ignore all, if number array - ignore attr of those lines, if false - do not ignore any. Default: false.\n&lt;directory&gt; (string) - directory where automatically constructed path is located. Default: “tests/screenshots”.\n\n\n\n\n\nnew_expectation()\n\nMiniTest.new_expectation({subject}, {predicate}, {fail_context})\n\nCreate new expectation function\nHelper for writing custom functions with behavior similar to other methods of MiniTest.expect.\n\nParameters\n{subject} (string|function|table) Subject of expectation. If callable, called with expectation input arguments to produce string value.\n{predicate} (function|table) Predicate callable. Called with expectation input arguments. Output false or nil means failed expectation.\n{fail_context} (string|function|table) Information about fail. If callable, called with expectation input arguments to produce string value.\n\n\nReturn\n(function) Expectation function.\n\n\nUsage\nlocal expect_truthy = MiniTest.new_expectation(\n  'truthy',\n  function(x) return x end,\n  function(x) return 'Object: ' .. vim.inspect(x) end\n)\n\n\n\n\ngen_reporter\n\nMiniTest.gen_reporter\n\nTable with pre-configured report generators\nEach element is a function which returns reporter - table with callable start, update, and finish fields.\n\n\n\ngen_reporter.buffer()\n\nMiniTest.gen_reporter.buffer({opts})\n\nGenerate buffer reporter\nThis is a default choice for interactive (not headless) usage. Opens a window with dedicated non-terminal buffer and updates it with throttled redraws.\nOpened buffer has the following helpful Normal mode mappings:\n\n&lt;Esc&gt; - stop test execution if executing (see MiniTest.is_executing() and MiniTest.stop()). Close window otherwise.\nq - same as &lt;Esc&gt; for convenience and compatibility.\n\nGeneral idea:\n\nGroup cases by concatenating first opts.group_depth elements of case description (desc field). Groups by collected files if using default values.\nIn start() show some stats to know how much is scheduled to be executed.\nIn update() show symbolic overview of current group and state of current case. Each symbol represents one case and its state:\n\n? - case didn’t finish executing.\no - pass.\nO - pass with notes.\nx - fail.\nX - fail with notes.\n\nIn finish() show all fails and notes ordered by case.\n\n\nParameters\n{opts} (table|nil) Table with options. Used fields:\n\n&lt;group_depth&gt; - number of first elements of case description (can be zero) used for grouping. Higher values mean higher granularity of output. Default: 1.\n&lt;throttle_delay&gt; - minimum number of milliseconds to wait between redrawing. Reduces screen flickering but not amount of computations. Default: 10.\n&lt;window&gt; - definition of window to open. Can take one of the forms:\n\nCallable. It is called expecting output to be target window id (current window is used if output is nil). Use this to open in “normal” window (like function() vim.cmd('vsplit') end).\nTable. Used as config argument in nvim_open_win(). Default: table for centered floating window.\n\n\n\n\n\n\ngen_reporter.stdout()\n\nMiniTest.gen_reporter.stdout({opts})\n\nGenerate stdout reporter\nThis is a default choice for headless usage. Writes to stdout. Uses coloring ANSI escape sequences to make pretty and informative output (should work in most modern terminals and continuous integration providers).\nIt has same general idea as MiniTest.gen_reporter.buffer() with slightly less output (it doesn’t overwrite previous text) to overcome typical terminal limitations.\n\nParameters\n{opts} (table|nil) Table with options. Used fields:\n\n&lt;group_depth&gt; - number of first elements of case description (can be zero) used for grouping. Higher values mean higher granularity of output. Default: 1.\n&lt;quit_on_finish&gt; - whether to quit after finishing test execution. Default: true.\n\n\n\n\n\nnew_child_neovim()\n\nMiniTest.new_child_neovim()\n\nCreate child Neovim process\nThis creates an object designed to be a fundamental piece of ‘mini.test’ methodology. It can start/stop/restart a separate (child) Neovim process (headless, but fully functioning) together with convenience helpers to interact with it through RPC messages.\nFor more information see MiniTest-child-neovim.\n\nReturn\n(MiniTest.child) Object of MiniTest-child-neovim.\n\n\nUsage\n-- Initiate\nlocal child = MiniTest.new_child_neovim()\nchild.start()\n\n-- Use API functions\nchild.api.nvim_buf_set_lines(0, 0, -1, true, { 'Line inside child Neovim' })\n\n-- Execute Lua code, Vimscript commands, etc.\nchild.lua('_G.n = 0')\nchild.cmd('au CursorMoved * lua _G.n = _G.n + 1')\nchild.type_keys('l')\nprint(child.lua_get('_G.n')) -- Should be 1\n\n-- Use other `vim.xxx` Lua wrappers (executed inside child process)\nvim.b.aaa = 'current process'\nchild.b.aaa = 'child process'\nprint(child.lua_get('vim.b.aaa')) -- Should be 'child process'\n\n-- Always stop process after it is not needed\nchild.stop()\n\n\n\n\nChild neovim\nChild class\nIt offers a great set of tools to write reliable and reproducible tests by allowing to use fresh process in any test action. Interaction with it is done through RPC protocol.\nAlthough quite flexible, at the moment it has certain limitations:\n\nDoesn’t allow using functions or userdata for child’s both inputs and outputs. Usual solution is to move computations from current Neovim process to child process. Use child.lua() and child.lua_get() for that.\nWhen writing tests, it is common to end up with “hanging” process: it stops executing without any output. Most of the time it is because Neovim process is “blocked”, i.e. it waits for user input and won’t return from other call (like child.api.nvim_exec_lua()). Common causes are active hit-enter-prompt (increase prompt height to a bigger value) or Operator-pending mode (exit it). To mitigate this experience, most helpers will throw an error if its immediate execution will lead to hanging state. Also in case of hanging state try child.api_notify instead of child.api.\n\nNotes:\n\nAn important type of field is a “redirection table”. It acts as a convenience wrapper for corresponding vim.* table. Can be used both to return and set values. Examples:\n\nchild.api.nvim_buf_line_count(0) will execute vim.api.nvim_buf_line_count(0) inside child process and return its output to current process.\nchild.bo.filetype = 'lua' will execute vim.bo.filetype = 'lua' inside child process. They still have same limitations listed above, so are not perfect. In case of a doubt, use child.lua().\n\nAlmost all methods use vim.rpcrequest() (i.e. wait for call to finish and then return value). See for *_notify variant to use vim.rpcnotify().\nAll fields and methods should be called with ., not :.\n\n\nClass\n{MiniTest.child}\n\n\nFields\n{start} (function) Start child process. See MiniTest-child-neovim-start().\n{stop} (function) Stop current child process.\n{restart} (function) Restart child process: stop if running and then start a new one. Takes same arguments as child.start() but uses values from most recent start() call as defaults.\n{type_keys} (function) Emulate typing keys. See MiniTest-child-neovim-type_keys(). Doesn’t check for blocked state.\n{cmd} (function) Execute Vimscript code from a string. A wrapper for nvim_exec() without capturing output.\n{cmd_capture} (function) Execute Vimscript code from a string and capture output. A wrapper for nvim_exec() with capturing output.\n{lua} (function) Execute Lua code. A wrapper for nvim_exec_lua().\n{lua_notify} (function) Execute Lua code without waiting for output.\n{lua_get} (function) Execute Lua code and return result. A wrapper for nvim_exec_lua() but prepends string code with return.\n{lua_func} (function) Execute Lua function and return it’s result. Function will be called with all extra parameters (second one and later). Note: usage of upvalues (data from outside function scope) is not allowed.\n{is_blocked} (function) Check whether child process is blocked.\n{is_running} (function) Check whether child process is currently running.\n{ensure_normal_mode} (function) Ensure normal mode.\n{get_screenshot} (function) Returns table with two “2d arrays” of single characters representing what is displayed on screen and how it looks. Has opts table argument for optional configuratnion.\n{job} (table|nil) Information about current job. If nil, child is not running.\n{api} (table) Redirection table for vim.api. Doesn’t check for blocked state.\n{api_notify} (table) Same as api, but uses vim.rpcnotify().\n{diagnostic} (table) Redirection table for vim.diagnostic.\n{fn} (table) Redirection table for vim.fn.\n{highlight} (table) Redirection table for vim.highlight.\n{hl} (table) Redirection table for vim.hl.\n{json} (table) Redirection table for vim.json.\n{loop} (table) Redirection table for vim.loop.\n{lsp} (table) Redirection table for vim.lsp (lsp-core).\n{mpack} (table) Redirection table for vim.mpack.\n{spell} (table) Redirection table for vim.spell.\n{treesitter} (table) Redirection table for vim.treesitter (lua-treesitter-core).\n{ui} (table) Redirection table for vim.ui. Currently of no use because it requires sending function through RPC, which is impossible at the moment.\n{fs} (table) Redirection table for vim.fs.\n{g} (table) Redirection table for vim.g.\n{b} (table) Redirection table for vim.b.\n{w} (table) Redirection table for vim.w.\n{t} (table) Redirection table for vim.t.\n{v} (table) Redirection table for vim.v.\n{env} (table) Redirection table for vim.env.\n{o} (table) Redirection table for vim.o.\n{go} (table) Redirection table for vim.go.\n{bo} (table) Redirection table for vim.bo.\n{wo} (table) Redirection table for vim.wo.\n\n\n\n\nChild neovim start()\n\nchild.start({args}, {opts})\n\nStart child process and connect to it. Won’t work if child is already running.\n\nParameters\n{args} (table) Array with arguments for executable. Will be prepended with the following default arguments (see startup-options):\n{ '--clean', '-n', '--listen', &lt;some address&gt;,\n  '--headless', '--cmd', 'set lines=24 columns=80' }\n{opts} (table|nil) Options:\n\n&lt;nvim_executable&gt; - name of Neovim executable. Default: v:progpath.\n&lt;connection_timeout&gt; - stop trying to connect after this amount of milliseconds. Default: 5000.\n\n\n\nUsage\nchild = MiniTest.new_child_neovim()\n\n-- Start default clean Neovim instance\nchild.start()\n\n-- Start with custom 'init.lua' file\nchild.start({ '-u', 'scripts/minimal_init.lua' })\n\n\n\n\nChild neovim type_keys()\n\nchild.type_keys({wait}, {…})\n\nBasically a wrapper for nvim_input() applied inside child process. Differences:\n\nCan wait after each group of characters.\nRaises error if typing keys resulted into error in child process (i.e. its v:errmsg was updated).\nKey ‘&lt;’ as separate entry may not be escaped as ‘&lt;LT&gt;’.\n\n\nParameters\n{wait} (number|nil) Number of milliseconds to wait after each entry. May be omitted, in which case no waiting is done.\n{…} (string|table&lt;number,string&gt;) Separate entries for nvim_input(), after which wait will be applied. Can be either string or array of strings.\n\n\nUsage\n-- All of these type keys 'c', 'a', 'w'\nchild.type_keys('caw')\nchild.type_keys('c', 'a', 'w')\nchild.type_keys('c', { 'a', 'w' })\n\n-- Waits 5 ms after `c` and after 'w'\nchild.type_keys(5, 'c', { 'a', 'w' })\n\n-- Special keys can also be used\nchild.type_keys('i', 'Hello world', '&lt;Esc&gt;')\n\n\n\n\nChild neovim get_screenshot()\n\nchild.get_screenshot({opts})\n\nCompute what is displayed on (default TUI) screen and how it is displayed. This basically calls screenstring() and screenattr() for every visible cell (row from 1 to ‘lines’, column from 1 to ‘columns’).\nNotes:\n\nTo make output more portable and visually useful, outputs of screenattr() are coded with single character symbols. Those are taken from 94 characters (ASCII codes between 33 and 126), so there will be duplicates in case of more than 94 different ways text is displayed on screen.\n\n\nParameters\n{opts} (table|nil) Options. Possieble fields:\n\n&lt;redraw&gt; (boolean) - whether to call :redraw prior to computing screenshot. Default: true.\n\n\n\nReturn\n(table|nil) Screenshot table with the following fields:\n\n&lt;text&gt; - “2d array” (row-column) of single characters displayed at particular cells.\n&lt;attr&gt; - “2d array” (row-column) of symbols representing how text is displayed (basically, “coded” appearance/highlighting). They should be used only in relation to each other: same/different symbols for two cells mean same/different visual appearance. Note: there will be false positives if there are more than 94 different attribute values. It also can be used with tostring() to convert to single string (used for writing to reference file). It results into two visual parts (separated by empty line), for text and attr. Each part has “ruler” above content and line numbers for each line. Returns nil if couldn’t get a reasonable screenshot.\n\n\n\nUsage\nlocal screenshot = child.get_screenshot()\n\n-- Show character displayed row=3 and column=4\nprint(screenshot.text[3][4])\n\n-- Convert to string\ntostring(screenshot)"
  },
  {
    "objectID": "mini.nvim/doc/mini-deps.html",
    "href": "mini.nvim/doc/mini-deps.html",
    "title": "mini.deps documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.deps Plugin manager\nMIT License Copyright (c) 2024 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nManage plugins utilizing Git and built-in packages with these actions:\n\nAdd plugin to current session, download if absent. See MiniDeps.add().\nUpdate with/without confirm, with/without parallel download of new data. See MiniDeps.update().\nDelete unused plugins with/without confirm. See MiniDeps.clean().\nGet / set / save / load snapshot. See MiniDeps.snap_*() functions.\n\nAll main actions are available both as Lua functions and user commands (see MiniDeps-commands).\nMinimal yet flexible plugin MiniDeps-plugin-specification:\n\nPlugin source.\nName of target plugin directory.\nCheckout target: branch, commit, tag, etc.\nMonitor branch to track updates without checking out.\nDependencies to be set up prior to the target plugin.\nHooks to call before/after plugin is created/changed.\n\nHelpers implementing two-stage startup: MiniDeps.now() and MiniDeps.later(). See MiniDeps-overview for how to implement basic lazy loading with them.\n\nWhat it doesn’t do:\n\nManage plugins which are developed without Git. The suggested approach is to create a separate package (see packages).\nProvide ways to completely remove or update plugin’s functionality in current session. Although this is partially doable, it can not be done in full (yet) because plugins can have untraceable side effects (autocmmands, mappings, etc.). The suggested approach is to restart Nvim.\n\nSources with more details:\n\nMiniDeps-overview\nMiniDeps-plugin-specification\nMiniDeps-commands\n\n\nDependencies\nFor most of its functionality this plugin relies on git CLI tool. See https://git-scm.com/ for more information about how to install it. Actual knowledge of Git is not required but helpful.\n\n\nSetup\nThis module needs a setup with require('mini.deps').setup({}) (replace {} with your config table). It will create global Lua table MiniDeps which you can use for scripting or manually (with :lua MiniDeps.*).\nSee MiniDeps.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minideps_config which should have same structure as MiniDeps.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nfolke/lazy.nvim:\n\nMore feature-rich and complex.\nUses table specification with dedicated functions to add plugins, while this module uses direct function call approach (calling MiniDeps.add() ensures that plugin is usable).\nUses version tags by default, while this module is more designed towards tracking branches. Using tags is possible too (see MiniDeps-overview).\n\nsavq/paq-nvim:\n\nOverall less feature-rich than this module (by design).\nUses array of plugin specifications inside setup() call to define which plugins should be installed. Requires separate :PaqInstall call to actually install them. This module ensures installation on first load.\n\njunegunn/vim-plug:\n\nWritten in Vimscript, while this module is in Lua.\nSimilar approach to defining and installing plugins as ‘savq/paq-nvim’.\nHas basic lazy-loading built-in, while this module does not (by design).\n\n\n\n\nHighlight groups\nHighlight groups are used inside confirmation buffers after default MiniDeps.update() and MiniDeps.clean().\n\nMiniDepsChangeAdded - added change (commit) during update.\nMiniDepsChangeRemoved - removed change (commit) during update.\nMiniDepsHint - various hints.\nMiniDepsInfo - various information.\nMiniDepsMsgBreaking - message for (conventional commit) breaking change.\nMiniDepsPlaceholder - placeholder when there is no valuable information.\nMiniDepsTitle - various titles.\nMiniDepsTitleError - title when plugin had errors during update.\nMiniDepsTitleSame - title when plugin has no changes to update.\nMiniDepsTitleUpdate - title when plugin has changes to update.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\n\n\nOverview\n\nDirectory structure\nThis module uses built-in packages to make plugins usable in current session. It works with “pack/deps” package inside config.path.package directory.\nBy default “opt” subdirectory is used to install optional plugins which are loaded on demand with MiniDeps.add(). Non-optional plugins in “start” subdirectory are supported but only if moved there manually after initial install. Use it if you know what you are doing.\n\n\nAdd plugin\nUse MiniDeps.add() to add plugin to current session. Supply plugin’s URL source as a string or MiniDeps-plugin-specification in general. If plugin is not present in “pack/deps” package, it will be created (a.k.a. installed) before processing anything else.\nThe recommended way of adding a plugin is by calling MiniDeps.add() in the init.lua file (make sure MiniDeps.setup() is called prior):\nlocal add = MiniDeps.add\n\n-- Add to current session (install if absent)\nadd({\n  source = 'neovim/nvim-lspconfig',\n  -- Supply dependencies near target plugin\n  depends = { 'williamboman/mason.nvim' },\n})\n\nadd({\n  source = 'nvim-treesitter/nvim-treesitter',\n  -- Use 'master' while monitoring updates in 'main'\n  checkout = 'master',\n  monitor = 'main',\n  -- Perform action after every checkout\n  hooks = { post_checkout = function() vim.cmd('TSUpdate') end },\n})\n-- Possible to immediately execute code which depends on the added plugin\nrequire('nvim-treesitter.configs').setup({\n  ensure_installed = { 'lua', 'vimdoc' },\n  highlight = { enable = true },\n})\nNOTE:\n\nTo increase performance, add() only ensures presence on disk and nothing else. In particular, it doesn’t ensure opts.checkout state. Update or modify plugin state explicitly (see later sections).\n\n\n\nLazy loading\nAny lazy-loading is assumed to be done manually by calling MiniDeps.add() at appropriate time. This module provides helpers implementing special safe two-stage loading:\n\nMiniDeps.now() safely executes code immediately. Use it to load plugins with UI necessary to make initial screen draw.\nMiniDeps.later() schedules code to be safely executed later, preserving order. Use it (with caution) for everything else which doesn’t need precisely timed effect, as it will be executed some time soon on one of the next event loops.\nlocal now, later = MiniDeps.now, MiniDeps.later\n\n-- Safely execute immediately\nnow(function() vim.cmd('colorscheme miniwinter') end)\nnow(function() require('mini.statusline').setup() end)\n\n-- Safely execute later\nlater(function() require('mini.pick').setup() end)\n\n\n\nUpdate\nTo update plugins from current session with new data from their sources, use :DepsUpdate. This will download updates (utilizing multiple cores) and show confirmation buffer. Follow instructions at its top to finish an update.\nNOTE: This updates plugins on disk which most likely won’t affect current session. Restart Nvim to have them properly loaded.\n\n\nModify\nTo change plugin’s specification (like set different checkout, etc.):\n\nUpdate corresponding MiniDeps.add() call.\nRun :DepsUpdateOffline &lt;plugin_name&gt;.\nReview changes and confirm.\nRestart Nvim.\n\nNOTE: if add() prior used a single source string, make sure to convert its argument to { source = '&lt;previous_argument&gt;', checkout = '&lt;state&gt;'}\n\n\nSnapshots\nUse :DepsSnapSave to save state of all plugins from current session into a snapshot file (see config.path.snapshot).\nUse :DepsSnapLoad to load snapshot. This will change (without confirmation) state on disk. Plugins present in both snapshot file and current session will be affected. Restart Nvim to see the effect.\nNOTE: loading snapshot does not change plugin’s specification defined inside MiniDeps.add() call. This means that next update might change plugin’s state. To make it permanent, freeze plugin in target state manually.\n\n\nFreeze\nModify plugin’s specification to have checkout pointing to a static target: tag, state (commit hash), or ‘HEAD’ (to freeze in current state).\nFrozen plugins will not receive updates. You can monitor any new changes from its source by “subscribing” to monitor branch which will be shown inside confirmation buffer after :DepsUpdate.\nExample: use checkout = 'v0.10.0' to freeze plugin at tag “v0.10.0” while monitoring new versions in the log from monitor (usually default) branch.\n\n\nRollback\nTo roll back after an unfortunate update:\n\nGet identifier of latest working state:\n\nUse :DepsShowLog to see update log, look for plugin’s name, and copy identifier listed as “State before:”.\nSee previously saved snapshot file for plugin’s name and copy identifier next to it.\n\nFreeze plugin at that state while monitoring appropriate branch. Revert to previous shape of MiniDeps.add() call to resume updating.\n\n\n\nRemove\n\nMake sure that target plugin is not registered in current session. Usually it means removing corresponding MiniDeps.add() call.\nRun :DepsClean. This will show confirmation buffer with a list of plugins to be deleted from disk. Follow instructions at its top to finish cleaning.\n\nAlternatively, manually delete plugin’s directory from “pack/deps” package.\n\n\n\n\nPlugin specification\nEach plugin dependency is managed based on its specification (a.k.a. “spec”). See MiniDeps-overview for some examples.\nSpecification can be a single string which is inferred as:\n\nPlugin &lt;name&gt; if it doesn’t contain “/”.\nPlugin &lt;source&gt; otherwise.\n\nPrimarily, specification is a table with the following fields:\n\n&lt;source&gt; (string|nil) - field with URI of plugin source used during creation or update. Can be anything allowed by git clone. Default: nil to rely on source set up during install. Notes:\n\nIt is required for creating plugin, but can be omitted afterwards.\nAs the most common case, URI of the format “user/repo” (if it contains valid characters) is transformed into “https://github.com/user/repo”.\n\n&lt;name&gt; (string|nil) - directory basename of where to put plugin source. It is put in “pack/deps/opt” subdirectory of config.path.package. Default: basename of &lt;source&gt; if it is present, otherwise should be provided explicitly.\n&lt;checkout&gt; (string|nil) - checkout target used to set state during update. Can be anything supported by git checkout - branch, commit, tag, etc. Default: nil for default branch (usually “main” or “master”).\n&lt;monitor&gt; (string|nil) - monitor branch used to track new changes from different target than checkout. Should be a name of present Git branch. Default: nil for default branch (usually “main” or “master”).\n&lt;depends&gt; (table|nil) - array of plugin specifications (strings or tables) to be added prior to the target. Default: nil for no dependencies.\n&lt;hooks&gt; (table|nil) - table with callable hooks to call on certain events. Possible hook names:\n\n&lt;pre_install&gt; - before creating plugin directory.\n&lt;post_install&gt; - after creating plugin directory (before :packadd).\n&lt;pre_checkout&gt; - before making change in existing plugin.\n&lt;post_checkout&gt; - after making change in existing plugin. Each hook is executed with the following table as an argument:\n&lt;path&gt; (string) - absolute path to plugin’s directory (might not yet exist on disk).\n&lt;source&gt; (string) - resolved &lt;source&gt; from spec.\n&lt;name&gt; (string) - resolved &lt;name&gt; from spec. Default: nil for no hooks.\n\n\n\n\n\nCommands\nNote: Most commands have a Lua function alternative which they rely on. Like :DepsAdd uses MiniDeps.add(), etc.\n\n:DepsAdd\n:DepsAdd with user/repo argument makes plugin https://github.com/user/repo available in the current session (also creates it, if it is not present). :DepsAdd name adds already installed plugin name to current session. Accepts only single string compatible with MiniDeps-plugin-specification. To add plugin in every session, put MiniDeps.add() in init.lua.\n\n\n:DepsUpdate\n:DepsUpdate synchronizes plugins with their session specifications and updates them with new changes from sources. It shows confirmation buffer in a separate tabpage with information about an upcoming update to review and (selectively) apply. See MiniDeps.update() for more info.\n:DepsUpdate name updates plugin name. Any number of names is allowed.\n:DepsUpdate! and :DepsUpdate! name update without confirmation. You can see what was done in the log file afterwards (:DepsShowLog).\n\n\n:DepsUpdateOffline\n:DepsUpdateOffline is same as :DepsUpdate but doesn’t download new updates from sources. Useful to only synchronize plugin specification in code and on disk without unnecessary downloads.\n\n\n:DepsShowLog\n:DepsShowLog opens log file to review.\n\n\n:DepsClean\n:DepsClean deletes plugins from disk not added to current session. It shows confirmation buffer in a separate tabpage with information about an upcoming deletes to review and (selectively) apply. See MiniDeps.clean() for more info.\n:DepsClean! deletes plugins without confirmation.\n\n\n:DepsSnapSave\n:DepsSnapSave creates snapshot file in default location (see MiniDeps.config). :DepsSnapSave path creates snapshot file at path.\n\n\n:DepsSnapLoad\n:DepsSnapLoad loads snapshot file from default location (see MiniDeps.config). :DepsSnapLoad path loads snapshot file at path.\n\n\n\n\nsetup()\n\nMiniDeps.setup({config})\n\nModule setup\nCalling this function creates user commands described in MiniDeps-commands.\n\nParameters\n{config} (table|nil) Module config table. See MiniDeps.config.\n\n\nUsage\nrequire('mini.deps').setup() -- use default config\n-- OR\nrequire('mini.deps').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniDeps.config\n\n\nDefaults\nMiniDeps.config = {\n  -- Parameters of CLI jobs\n  job = {\n    -- Number of parallel threads to use. Default: 80% of all available.\n    n_threads = nil,\n\n    -- Timeout (in ms) for each job before force quit\n    timeout = 30000,\n  },\n\n  -- Paths describing where to store data\n  path = {\n    -- Directory for built-in package.\n    -- All plugins are actually stored in 'pack/deps' subdirectory.\n    package = vim.fn.stdpath('data') .. '/site',\n\n    -- Default file path for a snapshot\n    snapshot = vim.fn.stdpath('config') .. '/mini-deps-snap',\n\n    -- Log file\n    log = vim.fn.stdpath('log') .. '/mini-deps.log'\n  },\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}\n\n\nJob\nconfig.job defines how CLI jobs are run.\njob.n_threads is a maximum number of parallel jobs used when needed. Default: 80% of all available.\njob.timeout is a duration (in ms) from job start until it is forced to stop. Default: 30000.\n\n\nPaths\nconfig.path defines main paths used in this module.\npath.package is a string with path inside which “pack/deps” package is stored (see MiniDeps-overview). Default: “site” subdirectory of “data” standard path (see stdpath()).\npath.snapshot is a string with default path for snapshot. See :DepsSnapSave and :DepsSnapLoad. Default: “mini-deps-snap” file in “config” standard path (see stdpath()).\npath.log is a string with path containing log of operations done by module. In particular, it contains all changes done after making an update. Default: “mini-deps.log” file in “log” standard path (see stdpath()).\n\n\nSilent\nconfig.silent is a boolean controlling whether to suppress non-error feedback. Default: false.\n\n\n\n\nadd()\n\nMiniDeps.add({spec}, {opts})\n\nAdd plugin to current session\n\nProcess specification by expanding dependencies into single spec array.\nEnsure plugin is present on disk along with its dependencies by installing (in parallel) absent ones:\n\nExecute opts.hooks.pre_install.\nUse git clone to clone plugin from its source URI into “pack/deps/opt”.\nSet state according to opts.checkout.\nExecute opts.hooks.post_install.\n\nRegister spec(s) in current session.\nMake sure plugin(s) can be used in current session (see :packadd).\nIf not during startup and is needed, source all “after/plugin/” scripts.\n\nNotes:\n\nPresence of plugin is checked by its name which is the same as the name of its directory inside “pack/deps” package (see MiniDeps-overview).\nTo increase performance, this function only ensures presence on disk and nothing else. In particular, it doesn’t ensure opts.checkout state. Use MiniDeps.update() or :DepsUpdateOffline explicitly.\nAdding plugin several times updates its session specs.\n\n\nParameters\n{spec} (table|string) Plugin specification. See MiniDeps-plugin-specification.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;bang&gt; (boolean) - whether to use :packadd! instead of plain :packadd.\n\n\n\n\n\nupdate()\n\nMiniDeps.update({names}, {opts})\n\nUpdate plugins\n\nSynchronize specs with state of plugins on disk (set source, etc.).\nInfer data before downloading updates.\nIf not offline, download updates (in parallel).\nInfer data after downloading updates.\nIf update is forced, apply all changes immediately while updating log file (at config.path.log; use :DepsShowLog to review). Otherwise show confirmation buffer with instructions on how to proceed.\n\n\nParameters\n{names} (table|nil) Array of plugin names to update. Default: all plugins from current session (see MiniDeps.get_session()).\n{opts} (table|nil) Options. Possible fields:\n\n&lt;force&gt; (boolean) - whether to force update without confirmation. Default: false.\n&lt;offline&gt; (boolean) - whether to skip downloading updates from sources. Default: false.\n\n\n\n\n\nclean()\n\nMiniDeps.clean({opts})\n\nClean plugins\n\nCompute absent plugins: not registered in current session (see MiniDeps.get_session()) but present on disk in dedicated “pack/deps” package (inside config.path.package).\nIf cleaning is forced, delete all absent plugins from disk. Otherwise show confirmation buffer with instructions on how to proceed.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;force&gt; (boolean) - whether to force delete without confirmation. Default: false.\n\n\n\n\n\nsnap_get()\n\nMiniDeps.snap_get()\n\nCompute snapshot\n\nReturn\n(table) A snapshot table: plugin names as keys and state as values. All plugins in current session are processed.\n\n\n\n\nsnap_set()\n\nMiniDeps.snap_set({snap})\n\nApply snapshot\nNotes:\n\nChecking out states from snapshot does not update session plugin spec (checkout field in particular). Among others, it means that next call to MiniDeps.update() might override the result of this function. To make changes permanent, set checkout spec field to state from snapshot.\n\n\nParameters\n{snap} (table) A snapshot table: plugin names as keys and state as values. Only plugins in current session are processed.\n\n\n\n\nsnap_save()\n\nMiniDeps.snap_save({path})\n\nSave snapshot\n\nParameters\n{path} (string|nil) A valid path on disk where to write snapshot computed with MiniDeps.snap_get(). Default: config.path.snapshot.\n\n\n\n\nsnap_load()\n\nMiniDeps.snap_load({path})\n\nLoad snapshot file\nNotes from MiniDeps.snap_set() also apply here.\n\nParameters\n{path} (string|nil) A valid path on disk from where to read snapshot. Default: config.path.snapshot.\n\n\n\n\nget_session()\n\nMiniDeps.get_session()\n\nGet session\nPlugin is registered in current session if it either:\n\nWas added with MiniDeps.add() (preserving order of calls).\nIs a “start” plugin and present in ‘runtimpath’.\n\n\nReturn\n(table) Array with specifications of all plugins registered in current session.\n\n\n\n\nnow()\n\nMiniDeps.now({f})\n\nExecute function now\nSafely execute function immediately. Errors are shown with vim.notify() later, after all queued functions (including with MiniDeps.later()) are executed, thus not blocking execution of next code in file.\nAssumed to be used as a first step during two-stage config execution to load plugins immediately during startup. See MiniDeps-overview.\n\nParameters\n{f} (function) Callable to execute.\n\n\n\n\nlater()\n\nMiniDeps.later({f})\n\nExecute function later\nQueue function to be safely executed later without blocking execution of next code in file. All queued functions are guaranteed to be executed in order they were added. Errors are shown with vim.notify() after all queued functions are executed.\nAssumed to be used as a second step during two-stage config execution to load plugins “lazily” after startup. See MiniDeps-overview.\n\nParameters\n{f} (function) Callable to execute."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MINI",
    "section": "",
    "text": "Modular Independent Neovim  Improvements \n\n\nmini.nvim\n\n\nModules\nDocumentation\nChange log\n\n\nMiniMax\n\n\nConfigs\nChange log\n\n\nBlog"
  },
  {
    "objectID": "mini.nvim/doc/mini-starter.html",
    "href": "mini.nvim/doc/mini-starter.html",
    "title": "mini.starter documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.starter Start screen\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nDisplayed items are fully customizable both in terms of what they do and how they look (with reasonable defaults). Item selection can be done using prefix query with instant visual feedback.\nKey design ideas:\n\nAll available actions are defined inside items. Each item should have the following info:\n\n&lt;action&gt; - function or string for vim.cmd() which is executed when item is chosen. Empty string result in placeholder “inactive” item.\n&lt;name&gt; - string which will be displayed and used for choosing.\n&lt;section&gt; - string representing to which section item belongs. There are pre-configured whole sections in MiniStarter.sections.\n\nConfigure what items are displayed by supplying an array which can be normalized to an array of items. Read about how supplied items are normalized in MiniStarter.refresh().\nModify the final look by supplying content hooks: functions which take buffer content (see MiniStarter.get_content()) and identifier as input while returning buffer content as output. There are pre-configured content hook generators in MiniStarter.gen_hook.\nChoosing an item can be done in two ways:\n\nType prefix query to filter item by matching its name (ignoring case). Displayed information is updated after every typed character. For every item its unique prefix is highlighted.\nUse Up/Down arrows and hit Enter.\n\nAllow multiple simultaneously open Starter buffers.\n\nWhat is doesn’t do:\n\nIt doesn’t support fuzzy query for items. And probably will never do.\n\n\nSetup\nThis module needs a setup with require('mini.starter').setup({}) (replace {} with your config table). It will create global Lua table MiniStarter which you can use for scripting or manually (with :lua MiniStarter.*).\nSee MiniStarter.config for config structure and default values. For some configuration examples (including one similar to ‘vim-startify’ and ‘dashboard-nvim’), see MiniStarter-example-config.\nYou can override runtime config settings locally to buffer inside vim.b.ministarter_config which should have same structure as MiniStarter.config. See mini.nvim-buffer-local-config for more details. Note: vim.b.ministarter_config is copied to Starter buffer from current buffer allowing full customization.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nHighlight groups\n\nMiniStarterCurrent - current item.\nMiniStarterFooter - footer units.\nMiniStarterHeader - header units.\nMiniStarterInactive - inactive item.\nMiniStarterItem - item name.\nMiniStarterItemBullet - units from MiniStarter.gen_hook.adding_bullet().\nMiniStarterItemPrefix - unique query for item.\nMiniStarterSection - section units.\nMiniStarterQuery - current query in active items.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable core functionality, set vim.g.ministarter_disable (globally) or vim.b.ministarter_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nExample config\n\nSimilar to ‘mhinz/vim-startify’\nlocal starter = require('mini.starter')\nstarter.setup({\n  evaluate_single = true,\n  items = {\n    starter.sections.builtin_actions(),\n    starter.sections.recent_files(10, false),\n    starter.sections.recent_files(10, true),\n    -- Use this if you set up 'mini.sessions'\n    starter.sections.sessions(5, true)\n  },\n  content_hooks = {\n    starter.gen_hook.adding_bullet(),\n    starter.gen_hook.indexing('all', { 'Builtin actions' }),\n    starter.gen_hook.padding(3, 2),\n  },\n})\n\n\nSimilar to ‘glepnir/dashboard-nvim’\nlocal starter = require('mini.starter')\nstarter.setup({\n  items = {\n    starter.sections.telescope(),\n  },\n  content_hooks = {\n    starter.gen_hook.adding_bullet(),\n    starter.gen_hook.aligning('center', 'center'),\n  },\n})\n\n\nDemo of capabilities\nlocal my_items = {\n  { name = 'Echo random number', action = 'lua print(math.random())', section = 'Section 1' },\n  function()\n    return {\n      { name = 'Item #1 from function', action = [[echo 'Item #1']], section = 'From function' },\n      { name = 'Placeholder (always inactive) item', action = '', section = 'From function' },\n      function()\n        return {\n          name = 'Item #1 from double function',\n          action = [[echo 'Double function']],\n          section = 'From double function',\n        }\n      end,\n    }\n  end,\n  { name = [[Another item in 'Section 1']], action = 'lua print(math.random() + 10)', section = 'Section 1' },\n}\n\nlocal footer_n_seconds = (function()\n  local timer = vim.loop.new_timer()\n  local n_seconds = 0\n  timer:start(0, 1000, vim.schedule_wrap(function()\n    if vim.bo.filetype ~= 'ministarter' then\n      timer:stop()\n      return\n    end\n    n_seconds = n_seconds + 1\n    MiniStarter.refresh()\n  end))\n\n  return function()\n    return 'Number of seconds since opening: ' .. n_seconds\n  end\nend)()\n\nlocal hook_top_pad_10 = function(content)\n  -- Pad from top\n  for _ = 1, 10 do\n    -- Insert at start a line with single content unit\n    table.insert(content, 1, { { type = 'empty', string = '' } })\n  end\n  return content\nend\n\nlocal starter = require('mini.starter')\nstarter.setup({\n  items = my_items,\n  footer = footer_n_seconds,\n  content_hooks = { hook_top_pad_10 },\n})\n\n\n\n\nLifecycle\n\nOpen with MiniStarter.open(). It includes creating buffer with appropriate options, mappings, behavior; call to MiniStarter.refresh(); issue MiniStarterOpened User event.\nWait for user to choose an item. This is done using following logic:\n\nTyping any character from MiniStarter.config.query_updaters leads to updating query. Read more in MiniStarter.add_to_query().\n&lt;BS&gt; deletes latest character from query.\n&lt;Down&gt;/&lt;Up&gt;, &lt;C-n&gt;/&lt;C-p&gt;, &lt;M-j&gt;/&lt;M-k&gt; move current item.\n&lt;CR&gt; executes action of current item.\n&lt;C-c&gt; closes Starter buffer.\n\nEvaluate current item when appropriate (after &lt;CR&gt; or when there is a single item and MiniStarter.config.evaluate_single is true). This executes item’s action.\n\n\n\n\nsetup()\n\nMiniStarter.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniStarter.config.\n\n\nUsage\nrequire('mini.starter').setup() -- use default config\n-- OR\nrequire('mini.starter').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniStarter.config\n\n\nDefaults\nMiniStarter.config = {\n  -- Whether to open Starter buffer on VimEnter. Not opened if Neovim was\n  -- started with intent to show something else.\n  autoopen = true,\n\n  -- Whether to evaluate action of single active item\n  evaluate_single = false,\n\n  -- Items to be displayed. Should be an array with the following elements:\n  -- - Item: table with &lt;action&gt;, &lt;name&gt;, and &lt;section&gt; keys.\n  -- - Function: should return one of these three categories.\n  -- - Array: elements of these three types (i.e. item, array, function).\n  -- If `nil` (default), default items will be used (see |mini.starter|).\n  items = nil,\n\n  -- Header to be displayed before items. Converted to single string via\n  -- `tostring` (use `\\n` to display several lines). If function, it is\n  -- evaluated first. If `nil` (default), polite greeting will be used.\n  header = nil,\n\n  -- Footer to be displayed after items. Converted to single string via\n  -- `tostring` (use `\\n` to display several lines). If function, it is\n  -- evaluated first. If `nil` (default), default usage help will be shown.\n  footer = nil,\n\n  -- Array  of functions to be applied consecutively to initial content.\n  -- Each function should take and return content for Starter buffer (see\n  -- |mini.starter| and |MiniStarter.get_content()| for more details).\n  content_hooks = nil,\n\n  -- Characters to update query. Each character will have special buffer\n  -- mapping overriding your global ones. Be careful to not add `:` as it\n  -- allows you to go into command mode.\n  query_updaters = 'abcdefghijklmnopqrstuvwxyz0123456789_-.',\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}\n\n\n\n\nopen()\n\nMiniStarter.open({buf_id})\n\nOpen Starter buffer\n\nCreate buffer if necessary and move into it.\nSet buffer options. Note that settings are done with :noautocmd to achieve a massive speedup.\nSet buffer mappings. Besides basic mappings (described inside “Lifecycle of Starter buffer” of mini.starter), map every character from MiniStarter.config.query_updaters to add itself to query with MiniStarter.add_to_query().\nPopulate buffer with MiniStarter.refresh().\nIssue custom MiniStarterOpened event to allow acting upon opening Starter buffer. Use it with autocmd User MiniStarterOpened &lt;your command&gt;.\n\nNote: to fully use it in autocommand, use autocmd-nested. Example:\nlocal starter_open = function() MiniStarter.open() end\nlocal au_opts = { nested = true, callback = starter_open }\nvim.api.nvim_create_autocmd('TabNewEntered', au_opts)\n\nParameters\n{buf_id} (number|nil) Identifier of existing valid buffer (see bufnr()) to open inside. Default: create a new one.\n\n\n\n\nrefresh()\n\nMiniStarter.refresh({buf_id})\n\nRefresh Starter buffer\n\nNormalize MiniStarter.config.items:\n\nFlatten: recursively (in depth-first fashion) parse its elements. If function is found, execute it and continue with parsing its output (this allows deferring item collection up until it is actually needed). If proper item is found (table with fields action, name, section), add it to output.\nSort: order first by section and then by item id (both in order of appearance).\n\nNormalize MiniStarter.config.header and MiniStarter.config.footer to be multiple lines by splitting at \\n. If function - evaluate it first.\nMake initial buffer content (see MiniStarter.get_content() for a description of what a buffer content is). It consist from content lines with single content unit:\n\nFirst lines contain strings of normalized header.\nBody is for normalized items. Section names have own lines preceded by empty line.\nLast lines contain separate strings of normalized footer.\n\nSequentially apply hooks from MiniStarter.config.content_hooks to content. All hooks are applied with (content, buf_id) signature. Output of one hook serves as first argument to the next.\nGather final items from content with MiniStarter.content_to_items().\nConvert content to buffer lines with MiniStarter.content_to_lines() and add them to buffer.\nAdd highlighting of content units.\nPosition cursor.\nMake current query. This results into some items being marked as “inactive” and updating highlighting of current query on “active” items.\n\nNote: this function is executed on every VimResized to allow more responsive behavior.\n\nParameters\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer.\n\n\n\n\nclose()\n\nMiniStarter.close({buf_id})\n\nClose Starter buffer\n\nParameters\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer.\n\n\n\n\nsections\n\nMiniStarter.sections\n\nTable of pre-configured sections\n\n\n\nsections.builtin_actions()\n\nMiniStarter.sections.builtin_actions()\n\nSection with builtin actions\n\nReturn\n(table) Array of items.\n\n\n\n\nsections.sessions()\n\nMiniStarter.sections.sessions({n}, {recent})\n\nSection with mini.sessions sessions\nSessions are taken from MiniSessions.detected. Notes:\n\nIf it shows “‘mini.sessions’ is not set up”, it means that you didn’t call require('mini.sessions').setup().\nIf it shows “There are no detected sessions in ‘mini.sessions’”, it means that there are no sessions at the current sessions directory. Either create session or supply different directory where session files are stored (see MiniSessions.setup()).\nLocal session (if detected) is always displayed first.\n\n\nParameters\n{n} (number|nil) Number of returned items. Default: 5.\n{recent} (boolean|nil) Whether to use recent sessions (instead of alphabetically by name). Default: true.\n\n\nReturn\n(function) Function which returns array of items.\n\n\n\n\nsections.recent_files()\n\nMiniStarter.sections.recent_files({n}, {current_dir}, {show_path})\n\nSection with most recently used files\nFiles are taken from v:oldfiles.\n\nParameters\n{n} (number|nil) Number of returned items. Default: 5.\n{current_dir} (boolean|nil) Whether to return files only from current working directory and its subdirectories. Default: false.\n{show_path} (boolean|function|nil) Whether to append file name with its path. If callable, will be called with full path and should return string to be directly appended to file name. Default: true.\n\n\nReturn\n(function) Function which returns array of items.\n\n\n\n\nsections.pick()\n\nMiniStarter.sections.pick()\n\nSection with mini.pick pickers\nNotes:\n\nAll actions require ‘mini.pick’ module of ‘mini.nvim’.\n“Command history”, “Explorer”, and “Visited paths” items require mini.extra module of ‘mini.nvim’.\n“Visited paths” items requires mini.visits module of ‘mini.nvim’.\n\n\nReturn\n(function) Function which returns array of items.\n\n\n\n\nsections.telescope()\n\nMiniStarter.sections.telescope()\n\nSection with basic Telescope pickers relevant to start screen\nNotes:\n\nAll actions require nvim-telescope/telescope.nvim.\n“Browser” item requires nvim-telescope/telescope-file-browser.nvim.\n\n\nReturn\n(function) Function which returns array of items.\n\n\n\n\ngen_hook\n\nMiniStarter.gen_hook\n\nTable with pre-configured content hook generators\nEach element is a function which returns content hook. So to use them inside MiniStarter.setup(), call them.\n\n\n\ngen_hook.padding()\n\nMiniStarter.gen_hook.padding({left}, {top})\n\nHook generator for padding\nOutput is a content hook which adds constant padding from left and top. This allows tweaking the screen position of buffer content.\n\nParameters\n{left} (number|nil) Number of empty spaces to add to start of each content line. Default: 0.\n{top} (number|nil) Number of empty lines to add to start of content. Default: 0.\n\n\nReturn\n(function) Content hook.\n\n\n\n\ngen_hook.adding_bullet()\n\nMiniStarter.gen_hook.adding_bullet({bullet}, {place_cursor})\n\nHook generator for adding bullet to items\nOutput is a content hook which adds supplied string to be displayed to the left of item.\n\nParameters\n{bullet} (string|nil) String to be placed to the left of item name. Default: “░”.\n{place_cursor} (boolean|nil) Whether to place cursor on the first character of bullet when corresponding item becomes current. Default: true.\n\n\nReturn\n(function) Content hook.\n\n\n\n\ngen_hook.indexing()\n\nMiniStarter.gen_hook.indexing({grouping}, {exclude_sections})\n\nHook generator for indexing items\nOutput is a content hook which adds unique index to the start of item’s name. It results into shortening queries required to choose an item (at expense of clarity).\n\nParameters\n{grouping} (string|nil) One of “all” (number indexing across all sections) or “section” (letter-number indexing within each section). Default: “all”.\n{exclude_sections} (table|nil) Array of section names (values of section element of item) for which index won’t be added. Default: {}.\n\n\nReturn\n(function) Content hook.\n\n\n\n\ngen_hook.aligning()\n\nMiniStarter.gen_hook.aligning({horizontal}, {vertical})\n\nHook generator for aligning content\nOutput is a content hook which independently aligns content horizontally and vertically. Window width and height are taken from first window in current tabpage displaying the Starter buffer.\nBasically, this computes left and top pads for MiniStarter.gen_hook.padding() such that output lines would appear aligned in certain way.\n\nParameters\n{horizontal} (string|nil) One of “left”, “center”, “right”. Default: “left”.\n{vertical} (string|nil) One of “top”, “center”, “bottom”. Default: “top”.\n\n\nReturn\n(function) Content hook.\n\n\n\n\nget_content()\n\nMiniStarter.get_content({buf_id})\n\nGet content of Starter buffer\nGenerally, buffer content is a table in the form of “2d array” (or rather “2d list” because number of elements can differ):\n\nEach element represents content line: an array with content units to be displayed in one buffer line.\nEach content unit is a table with at least the following elements:\n\n“type” - string with type of content. Something like “item”, “section”, “header”, “footer”, “empty”, etc.\n“string” - which string should be displayed. May be an empty string.\n“hl” - which highlighting should be applied to content string. May be nil for no highlighting.\n\n\nSee MiniStarter.content_to_lines() for converting content to buffer lines and MiniStarter.content_to_items() - to list of parsed items.\nNotes:\n\nContent units with type “item” also have item element with all information about an item it represents. Those elements are used directly to create an array of items used for query.\n\n\nParameters\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer.\n\n\n\n\ncontent_coords()\n\nMiniStarter.content_coords({content}, {predicate})\n\nHelper to iterate through content\nBasically, this traverses content “2d array” (in depth-first fashion; top to bottom, left to right) and returns “coordinates” of units for which predicate is true-ish.\n\nParameters\n{content} (table|nil) Content “2d array”. Default: content of current buffer.\n{predicate} (function|string|nil) Predictate to filter units. If it is:\n\nFunction, then it is evaluated with unit as input.\nString, then it checks unit to have this type (allows easy getting of units with some type).\nnil, all units are kept.\n\n\n\nReturn\n(table) Array of resulting units’ coordinates. Each coordinate is a table with &lt;line&gt; and &lt;unit&gt; keys. To retrieve actual unit from coordinate c, use content[c.line][c.unit].\n\n\n\n\ncontent_to_lines()\n\nMiniStarter.content_to_lines({content})\n\nConvert content to buffer lines\nOne buffer line is made by concatenating string element of units within same content line.\n\nParameters\n{content} (table|nil) Content “2d array”. Default: content of current buffer.\n\n\nReturn\n(table) Array of strings for each buffer line.\n\n\n\n\ncontent_to_items()\n\nMiniStarter.content_to_items({content})\n\nConvert content to items\nParse content (in depth-first fashion) and retrieve each item from item element of content units with type “item”. This also:\n\nComputes some helper information about how item will be actually displayed (after MiniStarter.content_to_lines()) and minimum number of prefix characters needed for a particular item to be queried single.\nModifies item’s name element taking it from corresponding string element of content unit. This allows modifying item’s name at the stage of content hooks (like, for example, in MiniStarter.gen_hook.indexing()).\n\n\nParameters\n{content} (table|nil) Content “2d array”. Default: content of current buffer.\n\n\nReturn\n(table) Array of items.\n\n\n\n\neval_current_item()\n\nMiniStarter.eval_current_item({buf_id})\n\nEvaluate current item\nNote that it resets current query before evaluation, as it is rarely needed any more.\n\nParameters\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer.\n\n\n\n\nupdate_current_item()\n\nMiniStarter.update_current_item({direction}, {buf_id})\n\nUpdate current item\nThis makes next (with respect to direction) active item to be current.\n\nParameters\n{direction} (string) One of “next” or “previous”.\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer.\n\n\n\n\nadd_to_query()\n\nMiniStarter.add_to_query({char}, {buf_id})\n\nAdd character to current query\n\nUpdate current query by appending char to its end (only if it results into at least one active item) or delete latest character if char is nil.\nRecompute status of items: “active” if its name starts with new query, “inactive” otherwise.\nUpdate highlighting: whole strings for “inactive” items, current query for “active” items.\n\n\nParameters\n{char} (string|nil) Single character to be added to query. If nil, deletes latest character from query.\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer.\n\n\n\n\nset_query()\n\nMiniStarter.set_query({query}, {buf_id})\n\nSet current query\n\nParameters\n{query} (string|nil) Query to be set (only if it results into at least one active item). Default: nil for setting query to empty string, which essentially resets query.\n{buf_id} (number|nil) Buffer identifier of a valid Starter buffer. Default: current buffer."
  },
  {
    "objectID": "mini.nvim/doc/mini-extra.html",
    "href": "mini.nvim/doc/mini-extra.html",
    "title": "mini.extra documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.extra Extra ‘mini.nvim’ functionality\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nExtra useful functionality which is not essential enough for other ‘mini.nvim’ modules to include directly.\nFeatures:\n\nVarious pickers for mini.pick:\n\nBuilt-in diagnostic (MiniExtra.pickers.diagnostic()).\nFile explorer (MiniExtra.pickers.explorer()).\nGit branches/commits/files/hunks (MiniExtra.pickers.git_hunks(), etc.).\nCommand/search/input history (MiniExtra.pickers.history()).\nLSP references/symbols/etc. (MiniExtra.pickers.lsp()).\nTree-sitter nodes (MiniExtra.pickers.treesitter()).\nAnd much more. See MiniExtra.pickers for more.\n\nVarious textobject specifications for mini.ai. See MiniExtra.gen_ai_spec.\nVarious highlighters for mini.hipatterns. See MiniExtra.gen_highlighter.\n\nNotes:\n\nThis module requires only those ‘mini.nvim’ modules which are needed for a particular functionality: ‘mini.pick’ for pickers, etc.\n\n\nSetup\nThis module needs a setup with require('mini.extra').setup({}) (replace {} with your config table). It will create global Lua table MiniExtra which you can use for scripting or manually (with :lua MiniExtra.*).\nSee MiniExtra.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.miniextra_config will have no effect here.\n\n\nComparisons\n\nnvim-telescope/telescope.nvim:\n\nWith MiniExtra.pickers, ‘mini.pick’ is reasonably on par when it comes to built-in pickers.\n\nibhagwan/fzf-lua:\n\nSame as ‘nvim-telescope/telescope.nvim’.\n\n\n\n\n\n\nsetup()\n\nMiniExtra.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniExtra.config.\n\n\nUsage\nrequire('mini.extra').setup() -- use default config\n-- OR\nrequire('mini.extra').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniExtra.config\n\n\nDefaults\nMiniExtra.config = {}\n\n\n\n\ngen_ai_spec\n\nMiniExtra.gen_ai_spec\n\nmini.ai textobject specification generators\nThis is a table with function elements. Call to actually get specification.\nAssumed to be used as part of MiniAi.setup(). Example:\nlocal gen_ai_spec = require('mini.extra').gen_ai_spec\nrequire('mini.ai').setup({\n  custom_textobjects = {\n    B = gen_ai_spec.buffer(),\n    D = gen_ai_spec.diagnostic(),\n    I = gen_ai_spec.indent(),\n    L = gen_ai_spec.line(),\n    N = gen_ai_spec.number(),\n  },\n})\n\n\n\ngen_ai_spec.buffer()\n\nMiniExtra.gen_ai_spec.buffer()\n\nCurrent buffer textobject\nNotes:\n\na textobject selects all lines in a buffer.\ni textobject selects all lines except blank lines at start and end.\n\n\nReturn\n(function) Function implementing MiniAi-textobject-specification.\n\n\n\n\ngen_ai_spec.diagnostic()\n\nMiniExtra.gen_ai_spec.diagnostic({severity})\n\nCurrent buffer diagnostic textobject\nNotes:\n\nBoth a and i textobjects return vim.diagnostic.get() output for the current buffer. It is modified to fit MiniAi-textobject-specification.\n\n\nParameters\n{severity} (any) Which severity to use. Forwarded to vim.diagnostic.get(). Default: nil to use all diagnostic entries.\n\n\nReturn\n(function) Function implementing MiniAi-textobject-specification.\n\n\n\n\ngen_ai_spec.indent()\n\nMiniExtra.gen_ai_spec.indent()\n\nCurrent buffer indent scopes textobject\nIndent scope is a set of consecutive lines with the following properties:\n\nLines above first and below last are non-blank. They are called borders.\nThere is at least one non-blank line in a set.\nAll non-blank lines between borders have strictly greater indent (perceived leading space respecting ‘tabstop’) than either of borders.\n\nNotes:\n\na textobject selects scope including borders.\ni textobject selects the scope charwise.\nDifferences with MiniIndentscope.textobject():\n\nThis textobject always treats blank lines on top and bottom of i textobject as part of it, while ‘mini.indentscope’ can configure that.\nThis textobject can select non-covering scopes, while ‘mini.indentscope’ can not (by design).\nIn this textobject scope computation is done only by “casting rays” from top to bottom and not in both ways as in ‘mini.indentscope’. This works in most common scenarios and doesn’t work only if indent of of the bottom border is expected to be larger than the top.\n\n\n\nReturn\n(function) Function implementing MiniAi-textobject-specification. It returns array of regions representing all indent scopes in the buffer ordered increasingly by the start line.\n\n\n\n\ngen_ai_spec.line()\n\nMiniExtra.gen_ai_spec.line()\n\nCurrent line textobject\nNotes:\n\na textobject selects whole line.\ni textobject selects line after initial indent.\n\n\nReturn\n(function) Function implementing MiniAi-textobject-specification.\n\n\n\n\ngen_ai_spec.number()\n\nMiniExtra.gen_ai_spec.number()\n\nNumber textobject\nNotes:\n\na textobject selects a whole number possibly preceded with “-” and possibly followed by decimal part (dot and digits).\ni textobject selects consecutive digits.\n\n\nReturn\n(function) Function implementing MiniAi-textobject-specification.\n\n\n\n\ngen_highlighter\n\nMiniExtra.gen_highlighter\n\nmini.hipatterns highlighter generators\nThis is a table with function elements. Call to actually get specification.\nAssumed to be used as part of MiniHipatterns.setup(). Example:\nlocal hi_words = require('mini.extra').gen_highlighter.words\nrequire('mini.hipatterns').setup({\n  highlighters = {\n    todo = hi_words({ 'TODO', 'Todo', 'todo' }, 'MiniHipatternsTodo'),\n  },\n})\n\n\n\ngen_highlighter.words()\n\nMiniExtra.gen_highlighter.words({words}, {group}, {extmark_opts})\n\nHighlight words\nNotes:\n\nWords should start and end with alphanumeric symbol (latin letter or digit).\nWords will be highlighted only in full and not if part bigger word, i.e. there should not be alphanumeric symbol before and after it.\n\n\nParameters\n{words} (table) Array of words to highlight. Will be matched as is, not as Lua pattern.\n{group} (string|function) Proper group field for highlighter. See MiniHipatterns.config.\n{extmark_opts} (any) Proper extmark_opts field for highlighter. See MiniHipatterns.config.\n\n\n\n\npickers\n\nMiniExtra.pickers\n\nmini.pick pickers\nA table with ‘mini.pick’ pickers (which is a hard dependency). Notes:\n\nAll have the same signature:\n\n&lt;local_opts&gt; - optional table with options local to picker.\n&lt;opts&gt; - optional table with options forwarded to MiniPick.start().\n\nAll of them are automatically registered in MiniPick.registry inside both MiniExtra.setup() or MiniPick.setup() (only one is enough).\nAll use default versions of MiniPick-source.preview, MiniPick-source.choose, and MiniPick-source.choose_marked if not stated otherwise. Shown text and MiniPick-source.show are targeted to the picked items.\n\nExamples of usage:\n\nAs Lua code: MiniExtra.pickers.buf_lines().\nWith :Pick command: :Pick buf_lines scope='current' Note: this requires calling MiniExtra.setup().\n\n\n\n\npickers.buf_lines()\n\nMiniExtra.pickers.buf_lines({local_opts}, {opts})\n\nBuffer lines picker\nPick from buffer lines. Notes:\n\nLoads all target buffers which are currently unloaded.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - one of “all” (normal listed buffers) or “current”. Default: “all”.\n&lt;preserve_order&gt; (boolean) - whether to preserve original order during query. Default: false.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.colorschemes()\n\nMiniExtra.pickers.colorschemes({local_opts}, {opts})\n\nColor scheme picker\nPick and apply color scheme. Preview temporarily applies item’s color scheme and shows how selected highlight groups look. Canceling reverts to color scheme before picker start:\n\nWith MiniColors-colorscheme:apply() if mini.colors was available.\nWith :colorscheme if g:colors_name was available.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;names&gt; (table) - array of color scheme names to pick from. Default: all available color schemes.\n&lt;preview_hl_groups&gt; (table) - array of highlight groups to show in preview window. Default: all defined highlight groups in alphabetical order.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.commands()\n\nMiniExtra.pickers.commands({local_opts}, {opts})\n\nNeovim commands picker\nPick from Neovim built-in (Ex-commands) and user-commands. Notes:\n\nPreview shows information about the command (if available).\nChoosing either executes command (if reliably known that it doesn’t need arguments) or populates Command line with the command.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Not used at the moment.\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.diagnostic()\n\nMiniExtra.pickers.diagnostic({local_opts}, {opts})\n\nBuilt-in diagnostic picker\nPick from vim.diagnostic using vim.diagnostic.get().\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;get_opts&gt; (table) - options for vim.diagnostic.get(). Can be used to limit severity or namespace. Default: {}.\n&lt;scope&gt; (string) - one of “all” (available) or “current” (buffer). Default: “all”.\n&lt;sort_by&gt; (string) - sort priority. One of “severity”, “path”, “none”. Default: “severity”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.explorer()\n\nMiniExtra.pickers.explorer({local_opts}, {opts})\n\nFile explorer picker\nExplore file system and open file. Notes:\n\nChoosing a directory navigates inside it, changing picker’s items and current working directory.\nQuery and preview work as usual (not only move_next/move_prev can be used).\nPreview works for any item.\n\nExamples:\n\nMiniExtra.pickers.explorer()\n:Pick explorer cwd='..' - open explorer in parent directory.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;cwd&gt; (string) - initial directory to explore. Should be a valid directory path. Default: nil for current-directory.\n&lt;filter&gt; (function) - callable predicate to filter items to show. Will be called for every item and should return true if it should be shown. Each item is a table with the following fields:\n\n&lt;fs_type&gt; (string) - path type. One of “directory” or “file”.\n&lt;path&gt; (string) - item path.\n&lt;text&gt; (string) - shown text (path’s basename).\n\n&lt;sort&gt; (function) - callable item sorter. Will be called with array of items (each element with structure as described above) and should return sorted array of items.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.git_branches()\n\nMiniExtra.pickers.git_branches({local_opts}, {opts})\n\nGit branches picker\nPick from Git branches using git branch. Notes:\n\nRequires executable git.\nRequires target path to be part of git repository.\nPresent for exploration and navigation purposes. Doing any Git operations is suggested to be done in a dedicated Git client and is not planned.\nOn choose opens scratch buffer with branch’s history.\n\nExamples:\n\nMiniExtra.pickers.git_branches({ scope = 'local' }) - local branches of the current-directory parent Git repository.\n:Pick git_branches path='%' - all branches of the current file parent Git repository.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;path&gt; (string|nil) - target path for Git operation (if required). Also used to find Git repository inside which to construct items. Default: nil for root of Git repository containing current-directory.\n&lt;scope&gt; (string) - branch scope to show. One of “all”, “local”, “remotes”. Default: “all”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.git_commits()\n\nMiniExtra.pickers.git_commits({local_opts}, {opts})\n\nGit commits picker\nPick from Git commits using git log. Notes:\n\nRequires executable git.\nRequires target path to be part of git repository.\nPresent for exploration and navigation purposes. Doing any Git operations is suggested to be done in a dedicated Git client and is not planned.\nOn choose opens scratch buffer with commit’s diff.\n\nExamples:\n\nMiniExtra.pickers.git_commits() - all commits from parent Git repository of current-directory.\nMiniExtra.pickers.git_commits({ path = 'subdir' }) - commits affecting files from ‘subdir’ subdirectory.\n:Pick git_commits path='%' commits affecting current file.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;path&gt; (string|nil) - target path for Git operation (if required). Also used to find Git repository inside which to construct items. Default: nil for root of Git repository containing current-directory.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.git_files()\n\nMiniExtra.pickers.git_files({local_opts}, {opts})\n\nGit files picker\nPick from Git files using git ls-files. Notes:\n\nRequires executable git.\nRequires target path to be part of git repository.\nPresent for exploration and navigation purposes. Doing any Git operations is suggested to be done in a dedicated Git client and is not planned.\n\nExamples:\n\nMiniExtra.pickers.git_files({ scope = 'ignored' }) - ignored files from parent Git repository of current-directory.\n:Pick git_files path='subdir' scope='modified' - files from ‘subdir’ subdirectory which are ignored by Git.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;path&gt; (string|nil) - target path for Git operation (if required). Also used to find Git repository inside which to construct items. Default: nil for root of Git repository containing current-directory.\n&lt;scope&gt; (string) - files scope to show. One of\n\n“tracked” (--cached Git flag).\n“modified” (--modified Git flag).\n“untracked” (--others Git flag).\n“ignored” (--ignored Git flag).\n“deleted” (--deleted Git flag). Default: “tracked”.\n\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.git_hunks()\n\nMiniExtra.pickers.git_hunks({local_opts}, {opts})\n\nGit hunks picker\nPick from Git hunks using git diff. Notes:\n\nRequires executable git.\nRequires target path to be part of git repository.\nPresent for exploration and navigation purposes. Doing any Git operations is suggested to be done in a dedicated Git client and is not planned.\nOn choose navigates to hunk’s first change.\n\nExamples:\n\nMiniExtra.pickers.git_hunks({ scope = 'staged' }) - staged hunks from parent Git repository of current-directory.\n:Pick git_hunks path='%' n_context=0 - hunks from current file computed with no context.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;n_context&gt; (number) - number of context lines to show in hunk’s preview. Default: 3.\n&lt;path&gt; (string|nil) - target path for Git operation (if required). Also used to find Git repository inside which to construct items. Default: nil for root of Git repository containing current-directory.\n&lt;scope&gt; (string) - hunks scope to show. One of “unstaged” or “staged”. Default: “unstaged”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.hipatterns()\n\nMiniExtra.pickers.hipatterns({local_opts}, {opts})\n\nMatches from ‘mini.hipatterns’ picker\nPick from mini.hipatterns matches using MiniHipatterns.get_matches(). Notes:\n\nRequires ‘mini.hipatterns’.\nHighlighter identifier is highlighted with its highlight group.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - one of “all” (buffers with enabled ‘mini.hipatterns’) or “current” (buffer). Default: “all”.\n&lt;highlighters&gt; (table|nil) - highlighters for which to find matches. Forwarded to MiniHipatterns.get_matches(). Default: nil.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.history()\n\nMiniExtra.pickers.history({local_opts}, {opts})\n\nNeovim history picker\nPick from output of :history. Use &lt;C-e&gt; to edit current match in Command line.\nNotes:\n\nHas no preview.\nChoosing action depends on scope:\n\nFor “cmd” / “:” scopes, the command is executed.\nFor “search” / “/” / “?” scopes, search is redone.\nFor other scopes nothing is done (but chosen item is still returned).\n\n&lt;C-e&gt; only works for “cmd” / “:” / “search” / “/” / “?” scopes.\n\nExamples:\n\nCommand history: MiniExtra.pickers.history({ scope = ':' })\nSearch history: :Pick history scope='/'\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - any allowed {name} flag of :history command. Note: word abbreviations are not allowed. Default: “all”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.hl_groups()\n\nMiniExtra.pickers.hl_groups({local_opts}, {opts})\n\nHighlight groups picker\nPick and preview highlight groups. Notes:\n\nItem line is colored with same highlight group it represents.\nPreview shows highlight’s definition (as in :highlight with {group-name}).\nChoosing places highlight definition in Command line to update and apply.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Not used at the moment.\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.keymaps()\n\nMiniExtra.pickers.keymaps({local_opts}, {opts})\n\nNeovim keymaps picker\nPick and preview data about Neovim keymaps. Notes:\n\nItem line contains data about keymap mode, whether it is buffer local, its left hand side, and inferred description.\nPreview shows keymap data or callback source (if present and reachable).\nChoosing emulates pressing the left hand side of the keymap.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;mode&gt; (string) - modes to show. One of “all” or appropriate mode for nvim_set_keymap(). Default: “all”.\n&lt;scope&gt; (string) - scope to show. One of “all”, “global”, “buf”. Default: “all”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.list()\n\nMiniExtra.pickers.list({local_opts}, {opts})\n\nNeovim lists picker\nPick and navigate to elements of the following Neovim lists:\n\nquickfix list.\nlocation-list of current window.\njumplist.\nchangelist.\n\nNote: it requires explicit scope.\nExamples:\n\nMiniExtra.pickers.list({ scope = 'quickfix' }) - quickfix list.\n:Pick list scope='jump' - jump list.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - type of list to show. One of “quickfix”, “location”, “jump”, “change”. Default: nil which means explicit scope is needed.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.lsp()\n\nMiniExtra.pickers.lsp({local_opts}, {opts})\n\nLSP picker\nPick and navigate with LSP methods. Notes:\n\nNeeds an explicit scope from a list of supported ones:\n\n“declaration”.\n“definition”.\n“document_symbol”.\n“implementation”.\n“references”.\n“type_definition”.\n“workspace_symbol”.\n“workspace_symbol_live” - same as “workspace_symbol”, but with live feedback treating picker’s prompt as LSP server query. Similar to how MiniPick.builtin.grep_live() and MiniPick.builtin.grep() are related. To use regular matching, activate MiniPick-actions-refine.\n\nRelies on vim.lsp.buf methods supporting vim.lsp.LocationOpts.OnList. In particular, it means that picker is started only if LSP server returns list of locations and not a single location.\nDoesn’t return anything due to async nature of vim.lsp.buf methods.\nRequires set up mini.icons to show extra icons and highlighting in “document_symbol”, “workspace_symbol”, “workspace_symbol_live” scopes.\n\nExamples:\n\nMiniExtra.pickers.lsp({ scope = 'references' }) - references of the symbol under cursor.\n:Pick lsp scope='document_symbol' - symbols in current file.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - LSP method to use. One of the supported ones (see list above). Default: nil which means explicit scope is needed.\n&lt;symbol_query&gt; (string) - query for \"workspace_symbol\" scope. Default: empty string for all symbols (according to LSP specification).\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(nil) Nothing is returned.\n\n\n\n\npickers.marks()\n\nMiniExtra.pickers.marks({local_opts}, {opts})\n\nNeovim marks picker\nPick and preview position of Neovim marks.\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - scope to show. One of “all”, “global”, “buf”. Default: “all”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.oldfiles()\n\nMiniExtra.pickers.oldfiles({local_opts}, {opts})\n\nOld files picker\nPick from v:oldfiles entries representing readable files.\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;current_dir&gt; (boolean) - whether to return files only from current working directory and its subdirectories. Default: false.\n&lt;preserve_order&gt; (boolean) - whether to preserve original order during query. Default: false.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.options()\n\nMiniExtra.pickers.options({local_opts}, {opts})\n\nNeovim options picker\nPick and preview data about Neovim options. Notes:\n\nItem line is colored based on whether it was set (dimmed if wasn’t).\nPreview shows option value in target window and its general information.\nChoosing places option name in Command line to update and apply.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;scope&gt; (string) - options to show. One of “all”, “global”, “win”, “buf”. Default: “all”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.registers()\n\nMiniExtra.pickers.registers({local_opts}, {opts})\n\nNeovim registers picker\nPick from Neovim registers. Notes:\n\nThere is no preview (all information is in the item’s text).\nChoosing pastes content of a register: with i_CTRL-R in Insert mode, c_CTRL-R in Command-line mode, and P otherwise. Expression register quote= is reevaluated (if present) and pasted.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Not used at the moment.\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.spellsuggest()\n\nMiniExtra.pickers.spellsuggest({local_opts}, {opts})\n\nNeovim spell suggestions picker\nPick and apply spell suggestions. Notes:\n\nNo preview is available.\nChoosing replaces current word (&lt;cword&gt;) with suggestion.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;n_suggestions&gt; (number) - number of spell suggestions. Default: 25.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.treesitter()\n\nMiniExtra.pickers.treesitter({local_opts}, {opts})\n\nTree-sitter nodes picker\nPick and navigate to treesitter nodes of current buffer. Notes:\n\nRequires active tree-sitter parser in the current buffer.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Not used at the moment.\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.visit_paths()\n\nMiniExtra.pickers.visit_paths({local_opts}, {opts})\n\nVisit paths from ‘mini.visits’ picker\nPick paths from mini.visits using MiniVisits.list_paths(). Notes:\n\nRequires ‘mini.visits’.\n\nExamples:\n\nMiniExtra.pickers.visit_paths() - visits registered for current-directory and ordered by “robust frecency”.\n:Pick visit_paths cwd='' recency_weight=1 filter='core' - all visits with “core” label ordered from most to least recent.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;cwd&gt; (string) - forwarded to MiniVisits.list_paths(). Default: nil to get paths registered for current-directory.\n&lt;filter&gt; (function|string) - forwarded to MiniVisits.list_paths(). Default: nil to use all paths.\n&lt;preserve_order&gt; (boolean) - whether to preserve original order during query. Default: false.\n&lt;recency_weight&gt; (number) - forwarded to MiniVisits.gen_sort.default(). Default: 0.5 to use “robust frecency” sorting.\n&lt;sort&gt; (function) - forwarded to MiniVisits.list_paths(). Default: nil to use “robust frecency”. Note: if supplied, has precedence over recency_weight.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(any) Output of the called picker.\n\n\n\n\npickers.visit_labels()\n\nMiniExtra.pickers.visit_labels({local_opts}, {opts})\n\nVisit labels from ‘mini.visits’ picker\nPick labels from mini.visits using MiniVisits.list_labels() and MiniVisits.list_paths(). Notes:\n\nRequires ‘mini.visits’.\nPreview shows target visit paths filtered to those having previewed label.\nChoosing essentially starts MiniExtra.pickers.visit_paths() for paths with the chosen label.\n\nExamples:\n\nMiniExtra.pickers.visit_labels() - labels from visits registered for current-directory.\n:Pick visit_labels cwd='' - labels from all visits.\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;cwd&gt; (string) - forwarded to MiniVisits.list_labels(). Default: nil to get labels from visits registered for current-directory.\n&lt;filter&gt; (function|string) - forwarded to MiniVisits.list_labels(). Default: nil to use all visits.\n&lt;path&gt; (string) - forwarded to MiniVisits.list_labels(). Default: \"\" to get labels from all visits for target cwd.\n&lt;sort&gt; (function) - forwarded to MiniVisits.list_paths() for preview and choose. Default: nil to use “robust frecency”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\nReturn\n(...) Chosen path."
  },
  {
    "objectID": "mini.nvim/doc/mini-nvim.html",
    "href": "mini.nvim/doc/mini-nvim.html",
    "title": "mini.nvim documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.nvim Collection of minimal, independent and fast Lua modules\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nTable of contents\nmini.nvim is a collection of minimal, independent, and fast Lua modules dedicated to improve Neovim (version 0.9 and higher) experience. Each module can be considered as a separate sub-plugin.\nTable of contents:\n\n\n\nGeneral principles\nmini.nvim-general-principles\n\n\nModule list\nmini.nvim-module-list\n\n\nDisabling recipes\nmini.nvim-disabling-recipes\n\n\nBuffer-local config\nmini.nvim-buffer-local-config\n\n\nPlugin color schemes\nmini.nvim-color-schemes\n\n\nExtend and create a/i textobjects\nmini.ai\n\n\nAlign text interactively\nmini.align\n\n\nAnimate common Neovim actions\nmini.animate\n\n\nBase16 colorscheme creation\nmini.base16\n\n\nCommon configuration presets\nmini.basics\n\n\nGo forward/backward with square brackets\nmini.bracketed\n\n\nRemove buffers\nmini.bufremove\n\n\nShow next key clues\nmini.clue\n\n\nCommand line tweaks\nmini.cmdline\n\n\nTweak and save any color scheme\nmini.colors\n\n\nComment lines\nmini.comment\n\n\nCompletion and signature help\nmini.completion\n\n\nAutohighlight word under cursor\nmini.cursorword\n\n\nPlugin manager\nmini.deps\n\n\nWork with diff hunks\nmini.diff\n\n\nGenerate Neovim help files\nmini.doc\n\n\nExtra ‘mini.nvim’ functionality\nmini.extra\n\n\nNavigate and manipulate file system\nmini.files\n\n\nFuzzy matching\nmini.fuzzy\n\n\nGit integration\nmini.git\n\n\nHighlight patterns in text\nmini.hipatterns\n\n\nGenerate configurable color scheme\nmini.hues\n\n\nIcon provider\nmini.icons\n\n\nVisualize and work with indent scope\nmini.indentscope\n\n\nJump to next/previous single character\nmini.jump\n\n\nJump within visible lines\nmini.jump2d\n\n\nSpecial key mappings\nmini.keymap\n\n\nWindow with buffer text overview\nmini.map\n\n\nMiscellaneous functions\nmini.misc\n\n\nMove any selection in any direction\nmini.move\n\n\nShow notifications\nmini.notify\n\n\nText edit operators\nmini.operators\n\n\nAutopairs\nmini.pairs\n\n\nPick anything\nmini.pick\n\n\nSession management\nmini.sessions\n\n\nManage and expand snippets\nmini.snippets\n\n\nSplit and join arguments\nmini.splitjoin\n\n\nStart screen\nmini.starter\n\n\nStatusline\nmini.statusline\n\n\nSurround actions\nmini.surround\n\n\nTabline\nmini.tabline\n\n\nTest Neovim plugins\nmini.test\n\n\nTrailspace (highlight and remove)\nmini.trailspace\n\n\nTrack and reuse file system visits\nmini.visits\n\n\n\n\n\n\nGeneral principles\n\nDesign\nEach module is designed to solve a particular problem targeting balance between feature-richness (handling as many edge-cases as possible) and simplicity of implementation/support. Granted, not all of them ended up with the same balance, but it is the goal nevertheless.\n\n\nIndependence\nModules are independent of each other and can be run without external dependencies. Although some of them may need dependencies for full experience.\n\n\nStructure\nEach module is a submodule for a placeholder “mini” module. For example, “surround” module should be referred to as “mini.surround”. As later will be explained, this plugin can also be referred to as “MiniSurround”.\n\n\nSetup\n\nEach module you want to use should be enabled separately with require(&lt;name of module&gt;).setup({}). Possibly replace {} with your config table or omit altogether to use defaults. You can supply only parts of config, the rest will be inferred from defaults.\nCall to module’s setup() always creates a global Lua object with coherent camel-case name: require('mini.surround').setup() creates _G.MiniSurround. This allows for a simpler usage of plugin available from v:lua like v:lua.MiniSurround. Considering this, “module” and “Lua object” names can be used interchangeably: ‘mini.surround’ and ‘MiniSurround’ will mean the same thing.\nEach supplied config table (after extending with default values) is stored in config field of global object. Like MiniSurround.config.\nValues of config, which affect runtime activity, can be changed on the fly to have effect. For example, MiniSurround.config.n_lines can be changed during runtime; but changing MiniSurround.config.mappings won’t have any effect (as mappings are created once during setup()).\nIf module works best with some specific non-default option value, it is set during setup(). If the value is not essential to module’s functionality, it is done only if user or another plugin hasn’t set it beforehand (no matter the value).\n\n\n\nBuffer local configuration\nEach module can be additionally configured to use certain runtime config settings locally to buffer. See mini.nvim-buffer-local-config for more information.\n\n\nBuffer names\nAll module-related buffers are named according to the following format: mini&lt;module-name&gt;://&lt;buffer-number&gt;/&lt;useful-info&gt; (forward slashes are used on any platform; &lt;useful-info&gt; may be empty). This structure allows creating identifiable, reasonably unique, and useful buffer names. For example, mini.files buffers are created per displayed directory/file with names like minifiles://10/path/to/displayed/directory.\n\n\nDisabling\nEach module’s core functionality can be disabled globally or locally to buffer. See “Disabling” section in module’s help page for more details. See mini.nvim-disabling-recipes for common recipes.\n\n\nSilencing\nEach module can be configured to not show non-error feedback globally or locally to buffer. See “Silencing” section in module’s help for more details.\n\n\nHighlighting\nAppearance of module’s output is controlled by certain set of highlight groups (see highlight-groups). By default they usually link to some semantically close built-in highlight group. Use :highlight command or nvim_set_hl() Lua function to customize highlighting. To see a more calibrated look, use mini.hues, mini.base16, or plugin’s colorschemes.\n\n\nStability\nEach module upon release is considered to be relatively stable: both in terms of setup and functionality. Any non-bugfix backward-incompatible change will be released gradually as much as possible.\n\n\nNot filetype and language specific\nIncluding functionality which needs several filetype/language specific implementations is an explicit no-goal of this project. This is mostly due to the potential increase in maintenance to keep implementation up to date. However, any part which might need filetype/language specific tuning should be designed to allow it by letting user set proper buffer options and/or local configuration.\n\n\n\n\nModule list\n\nmini.ai - extend and create a/i textobjects (like in di( or va\"). It enhances some builtin text-objects (like a(, a), a’, and more), creates new ones (like a*, a&lt;Space&gt;, af, a?, and more), and allows user to create their own (like based on treesitter, and more). Supports dot-repeat, v:count, different search methods, consecutive application, and customization via Lua patterns or functions. Has builtins for brackets, quotes, function call, argument, tag, user prompt, and any punctuation/digit/whitespace character.\nmini.align - align text interactively (with or without instant preview). Allows rich and flexible customization of both alignment rules and user interaction. Works with charwise, linewise, and blockwise selections in both Normal mode (on textobject/motion; with dot-repeat) and Visual mode.\nmini.animate - animate common Neovim actions. Has “works out of the box” builtin animations for cursor movement, scroll, resize, window open and close. All of them can be customized and enabled/disabled independently.\nmini.base16 - fast implementation of base16 theme for manually supplied palette. Supports 30+ plugin integrations. Has unique palette generator which needs only background and foreground colors.\nmini.basics - common configuration presets. Has configurable presets for options, mappings, and autocommands. It doesn’t change option or mapping if it was manually created.\nmini.bracketed - go forward/backward with square brackets. Among others, supports variety of non-trivial targets: comments, files on disk, indent changes, tree-sitter nodes, linear undo states, yank history entries.\nmini.bufremove - buffer removing (unshow, delete, wipeout) while saving window layout.\nmini.clue - show next key clues. Implements custom key query process with customizable opt-in triggers, next key descriptions (clues), hydra-like submodes, window delay/config. Provides clue sets for some built-in concepts: g/z keys, window commands, etc.\nmini.cmdline - command line tweaks. Adds autocompletion with customizable delay, autocorrection for words with fixed candidates, and autopeek command range in a floating window with customizable context size.\nmini.colors - tweak and save any color scheme. Can create colorscheme object with methods to invert/set/modify/etc. lightness/saturation/hue/temperature/etc. of foreground/background/all colors, infer cterm attributes, add transparency, save to a file and more. Has functionality for interactive experiments and animation of transition between color schemes.\nmini.comment - fast and familiar per-line code commenting.\nmini.completion - async (with customizable ‘debounce’ delay) ‘two-stage chain completion’: first builtin LSP, then configurable fallback. Also has functionality for completion item info and function signature (both in floating window appearing after customizable delay).\nmini.cursorword - automatic highlighting of word under cursor (displayed after customizable delay). Current word under cursor can be highlighted differently.\nmini.deps - plugin manager for plugins outside of ‘mini.nvim’. Uses Git and built-in packages to install, update, clean, and snapshot plugins.\nmini.diff - visualize difference between buffer text and its reference interactively (with colored signs or line numbers). Uses Git index as default reference. Provides toggleable overview in text area, built-in apply/reset/textobject/goto mappings.\nmini.doc - generation of help files from EmmyLua-like annotations. Allows flexible customization of output via hook functions. Used for documenting this plugin.\nmini.extra - extra ‘mini.nvim’ functionality. Contains ‘mini.pick’ pickers, ‘mini.ai’ textobjects, and more.\nmini.files - navigate and manipulate file system. A file explorer with column view capable of manipulating file system by editing text. Can create/delete/rename/copy/move files/directories inside and across directories. For full experience needs enabled mini.icons module (but works without it).\nmini.fuzzy - functions for fast and simple fuzzy matching. It has not only functions to perform fuzzy matching of one string to others, but also a sorter for ‘nvim-telescope/telescope.nvim’.\nmini.git - Git integration (https://git-scm.com/). Implements tracking of Git related data (root, branch, etc.), :Git command for better integration with running Neovim instance, and various helpers to explore Git history.\nmini.hipatterns - highlight patterns in text with configurable highlighters (pattern and/or highlight group can be string or callable). Works asynchronously with configurable debounce delay.\nmini.hues - generate configurable color scheme. Takes only background and foreground colors as required arguments. Can adjust number of hues for non-base colors, saturation, accent color, plugin integration.\nmini.icons - icon provider with fixed set of highlight groups. Supports various categories, icon and style customizations, caching for performance. Integrates with Neovim’s filetype matching.\nmini.indentscope - visualize and operate on indent scope. Supports customization of debounce delay, animation style, and different granularity of options for scope computing algorithm.\nmini.jump - minimal and fast module for smarter jumping to a single character.\nmini.jump2d - minimal and fast Lua plugin for jumping (moving cursor) within visible lines via iterative label filtering. Supports custom jump targets (spots), labels, hooks, allowed windows and lines, and more.\nmini.keymap - utilities to make special key mappings: multi-step actions (with built-in steps for “smart” &lt;Tab&gt;, &lt;S-Tab&gt;, &lt;CR&gt;, &lt;BS&gt;), combos (more general version of “better escape” like behavior).\nmini.map - window with buffer text overview, scrollbar, and highlights. Allows configurable symbols for line encode and scrollbar, extensible highlight integration (with pre-built ones for builtin search, diagnostic, git line status), window properties, and more.\nmini.misc - collection of miscellaneous useful functions. Like put() and put_text() which print Lua objects to command line and current buffer respectively.\nmini.move - move any selection in any direction. Supports any Visual mode (charwise, linewise, blockwise) and Normal mode (current line) for all four directions (left, right, down, up). Respects count and undo.\nmini.notify - show one or more highlighted notifications in a single window. Provides both low-level functions (add, update, remove, clear) and maker of vim.notify() implementation. Sets up automated LSP progress updates.\nmini.operators - various text edit operators: replace, exchange, multiply, sort, evaluate. Creates mappings to operate on textobject, line, and visual selection. Supports [count] and dot-repeat.\nmini.pairs - autopairs plugin which has minimal defaults and functionality to do per-key expression mappings.\nmini.pick - general purpose interactive non-blocking picker with toggleable preview. Has fast default matching with fuzzy/exact/grouped modes. Provides most used built-in pickers for files, pattern matches, buffers, etc. For full experience needs enabled mini.icons module (but works without it).\nmini.sessions - session management (read, write, delete) which works using :mksession. Implements both global (from configured directory) and local (from current directory) sessions.\nmini.snippets - manage and expand snippets. Supports only syntax from LSP specification. Provides flexible loaders to manage snippet files, exact and fuzzy prefix matching, interactive selection, and rich interactive snippet session experience with dynamic tabstop visualization.\nmini.splitjoin - split and join arguments (regions inside brackets between allowed separators). Has customizable pre and post hooks. Works inside comments.\nmini.starter - minimal, fast, and flexible start screen. Displayed items are fully customizable both in terms of what they do and how they look (with reasonable defaults). Item selection can be done using prefix query with instant visual feedback.\nmini.statusline - minimal and fast statusline. Has ability to use custom content supplied with concise function (using module’s provided section functions) along with builtin default. For full experience needs enabled mini.diff, mini.git, and mini.icons modules (but works without any of them).\nmini.surround - fast and feature-rich surround plugin. Add, delete, replace, find, highlight surrounding (like pair of parenthesis, quotes, etc.). Supports dot-repeat, v:count, different search methods, “last”/“next” extended mappings, customization via Lua patterns or functions, and more. Has builtins for brackets, function call, tag, user prompt, and any alphanumeric/punctuation/whitespace character.\nmini.test - framework for writing extensive Neovim plugin tests. Supports hierarchical tests, hooks, parametrization, filtering (like from current file or cursor position), screen tests, “busted-style” emulation, customizable reporters, and more. Designed to be used with provided wrapper for managing child Neovim processes.\nmini.tabline - minimal tabline which always shows listed (see ‘buflisted’) buffers. Allows showing extra information section in case of multiple vim tabpages. For full experience needs enabled mini.icons module (but works without it).\nmini.trailspace - automatic highlighting of trailing whitespace with functionality to remove it.\nmini.visits - track and reuse file system visits. Tracks data about each file/directory visit (after delay) and stores it (only) locally. This can be used to get a list of “recent”/“frequent”/“frecent” visits. Allows persistently adding labels to visits enabling flexible workflow.\n\n\n\n\nDisabling recipes\nEach module’s core functionality can be disabled globally or buffer-locally by creating appropriate global or buffer-scoped variables equal to v:true. Functionality is disabled if at least one of g: or b: variables is v:true.\nVariable names have the same structure: {g,b}:mini*_disable where * is module’s lowercase name. For example, g:minianimate_disable disables mini.animate globally and b:minianimate_disable - for current buffer. Note: in this section disabling ‘mini.animate’ is used as example; everything holds for other module variables.\nConsidering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user.\n\nManual disabling\n-- Disable globally\nvim.g.minianimate_disable = true\n\n-- Disable for current buffer\nvim.b.minianimate_disable = true\n\n-- Toggle (disable if enabled, enable if disabled)\nvim.g.minianimate_disable = not vim.g.minianimate_disable -- globally\nvim.b.minianimate_disable = not vim.b.minianimate_disable -- for buffer\n\n\nAutomated disabling\nAutomated disabling is suggested to be done inside autocommands:\n-- Disable for a certain filetype (for example, \"lua\")\nlocal f = function(args) vim.b[args.buf].minianimate_disable = true end\nvim.api.nvim_create_autocmd('Filetype', { pattern = 'lua', callback = f })\n\n-- Enable only for certain filetypes (for example, \"lua\" and \"help\")\nlocal f = function(args)\n  local ft = vim.bo[args.buf].filetype\n  if ft == 'lua' or ft == 'help' then return end\n  vim.b[args.buf].minianimate_disable = true\nend\nvim.api.nvim_create_autocmd('Filetype', { callback = f })\n\n-- Disable in Visual mode\nlocal f_en = function(args) vim.b[args.buf].minianimate_disable = false end\nlocal enable_opts = { pattern = '[vV\\x16]*:*', callback = f_en }\nvim.api.nvim_create_autocmd('ModeChanged', enable_opts)\n\nlocal f_dis = function(args) vim.b[args.buf].minianimate_disable = true end\nlocal disable_opts = { pattern = '*:[vV\\x16]*', callback = f_dis }\nvim.api.nvim_create_autocmd('ModeChanged', disable_opts)\n\n-- Disable in Terminal buffer\nlocal f = function(args) vim.b[args.buf].minianimate_disable = true end\nvim.api.nvim_create_autocmd('TermOpen', { callback = f })\n\n\n\n\nBuffer local config\nEach module can be additionally configured locally to buffer by creating appropriate buffer-scoped variable with values to override. It affects only runtime options and not those used once during setup (like most mappings).\nVariable names have the same structure: b:mini*_config where * is module’s lowercase name. For example, b:minianimate_config can store information about how mini.animate will act inside current buffer. Its value should be a table with same structure as module’s config. Example:\n-- Disable scroll animation in current buffer\nvim.b.minianimate_config = { scroll = { enable = false } }\nConsidering high number of different scenarios and customization intentions, writing exact rules for module’s buffer local configuration is left to user. It is done in similar fashion to mini.nvim-disabling-recipes.\n\n\n\nColor schemes\n\nColor schemes based on mini.hues: MiniHues-color-schemes.\nColor schemes based on mini.base16: MiniBase16-color-schemes."
  },
  {
    "objectID": "mini.nvim/doc/mini-trailspace.html",
    "href": "mini.nvim/doc/mini-trailspace.html",
    "title": "mini.trailspace documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.trailspace Trailspace (highlight and remove)\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nHighlighting is done only in modifiable buffer by default, only in Normal mode, and stops in Insert mode and when leaving window.\nTrim all trailing whitespace with MiniTrailspace.trim().\nTrim all trailing empty lines with MiniTrailspace.trim_last_lines().\n\n\nSetup\nThis module needs a setup with require('mini.trailspace').setup({}) (replace {} with your config table). It will create global Lua table MiniTrailspace which you can use for scripting or manually (with :lua MiniTrailspace.*).\nSee MiniTrailspace.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minitrailspace_config which should have same structure as MiniTrailspace.config. See mini.nvim-buffer-local-config for more details.\n\n\nHighlight groups\n\nMiniTrailspace - highlight group for trailing space.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minitrailspace_disable (globally) or vim.b.minitrailspace_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes. Note: after disabling there might be highlighting left; it will be removed after next highlighting update (see events and MiniTrailspace :augroup).\n\n\n\n\nsetup()\n\nMiniTrailspace.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniTrailspace.config.\n\n\nUsage\nrequire('mini.trailspace').setup() -- use default config\n-- OR\nrequire('mini.trailspace').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniTrailspace.config\n\n\nDefaults\nMiniTrailspace.config = {\n  -- Highlight only in normal buffers (ones with empty 'buftype'). This is\n  -- useful to not show trailing whitespace where it usually doesn't matter.\n  only_in_normal_buffers = true,\n}\n\n\n\n\nhighlight()\n\nMiniTrailspace.highlight()\n\nHighlight trailing whitespace in current window\n\n\n\nunhighlight()\n\nMiniTrailspace.unhighlight()\n\nUnhighlight trailing whitespace in current window\n\n\n\ntrim()\n\nMiniTrailspace.trim()\n\nTrim trailing whitespace\n\n\n\ntrim_last_lines()\n\nMiniTrailspace.trim_last_lines()\n\nTrim last blank lines"
  },
  {
    "objectID": "mini.nvim/doc/mini-hipatterns.html",
    "href": "mini.nvim/doc/mini-hipatterns.html",
    "title": "mini.hipatterns documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.hipatterns Highlight patterns in text\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nHighlight text with configurable patterns and highlight groups (can be string or callable).\nHighlighting is updated asynchronously with configurable debounce delay.\nFunction to get matches in a buffer (see MiniHipatterns.get_matches()).\n\nSee MiniHipatterns-examples for common configuration examples.\nNotes:\n\nIt does not define any highlighters by default. Add to config.highlighters to have a visible effect.\nSometimes (especially during frequent buffer updates on same line numbers) highlighting can be outdated or not applied when it should be. This is due to asynchronous nature of updates reacting to text changes (via on_lines of nvim_buf_attach()). To make them up to date, use one of the following:\n\nScroll window (for example, with CTRL-E / CTRL-Y). This will ensure up to date highlighting inside window view.\nHide and show buffer.\nExecute :edit (if you enabled highlighting with MiniHipatterns.setup()).\nManually call MiniHipatterns.update().\n\nIf you experience flicker when typing near highlighted pattern in Insert mode, it might be due to delay configuration of mini.completion or using built-in completion. For better experience with ‘mini.completion’, make sure that its delay.completion is less than this module’s delay.text_change (which it is by default). The reason for this is (currently unresolvable) limitations of Neovim’s built-in completion implementation.\n\n\nSetup\nSetting up highlights can be done in two ways:\n\nManually for every buffer with require('mini.hipatterns').enable(). This will enable highlighting only in one particular buffer until it is unloaded (which also includes calling :edit on current file).\nGlobally with require('mini.hipatterns').setup({}) (replace {} with your config table). This will auto-enable highlighting in “normal” buffers (see ‘buftype’). Use MiniHipatterns.enable() to manually enable in other buffers. It will also create global Lua table MiniHipatterns which you can use for scripting or manually (with :lua MiniHipatterns.*).\n\nSee MiniHipatterns.config for config structure and default values.\nYou can override runtime config settings (like highlighters and delays) locally to buffer inside vim.b.minihipatterns_config which should have same structure as MiniHipatterns.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nfolke/todo-comments:\n\nOriented for “TODO”, “NOTE”, “FIXME” like patterns, while this module can work with any Lua patterns and computable highlight groups.\nHas functionality beyond text highlighting (sign placing, “telescope.nvim” extension, etc.), while this module only focuses on highlighting text.\n\nfolke/paint.nvim:\n\nMostly similar to this module, but with slightly less functionality, such as computed pattern and highlight group, asynchronous delay, etc.\n\nNvChad/nvim-colorizer.lua:\n\nOriented for color highlighting, while this module can work with any Lua patterns and computable highlight groups.\nHas more built-in color spaces to highlight, while this module out of the box provides only hex color highlighting (see MiniHipatterns.gen_highlighter.hex_color()). Other types are also possible to implement.\n\nuga-rosa/ccc.nvim:\n\nHas more than color highlighting functionality, which is compared to this module in the same way as ‘NvChad/nvim-colorizer.lua’.\n\n\n\n\nHighlight groups\n\nMiniHipatternsFixme - suggested group to use for FIXME-like patterns.\nMiniHipatternsHack - suggested group to use for HACK-like patterns.\nMiniHipatternsTodo - suggested group to use for TODO-like patterns.\nMiniHipatternsNote - suggested group to use for NOTE-like patterns.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nThis module can be disabled in three ways:\n\nGlobally: set vim.g.minihipatterns_disable to true.\nLocally for buffer permanently: set vim.b.minihipatterns_disable to true.\nLocally for buffer temporarily (until next auto-enabling event if set up with MiniHipatterns.setup()): call MiniHipatterns.disable().\n\nConsidering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nExamples\n\nCommon configuration examples\n\nSpecial words used to convey different level of attention:\nrequire('mini.hipatterns').setup({\n  highlighters = {\n    fixme = { pattern = 'FIXME', group = 'MiniHipatternsFixme' },\n    hack  = { pattern = 'HACK',  group = 'MiniHipatternsHack'  },\n    todo  = { pattern = 'TODO',  group = 'MiniHipatternsTodo'  },\n    note  = { pattern = 'NOTE',  group = 'MiniHipatternsNote'  },\n  }\n})\nTo match only when pattern appears as a standalone word, use frontier patterns %f. For example, instead of 'TODO' pattern use '%f[%w]()TODO()%f[%W]'. In this case, for example, ‘TODOING’ or ‘MYTODO’ won’t match, but ‘TODO’ and ‘TODO:’ will.\nColor hex (like #rrggbb) highlighting:\nlocal hipatterns = require('mini.hipatterns')\nhipatterns.setup({\n  highlighters = {\n    hex_color = hipatterns.gen_highlighter.hex_color(),\n  }\n})\nYou can customize which part of hex color is highlighted by using style field of input options. See MiniHipatterns.gen_highlighter.hex_color().\nColored words:\nlocal words = { red = '#ff0000', green = '#00ff00', blue = '#0000ff' }\nlocal word_color_group = function(_, match)\n  local hex = words[match]\n  if hex == nil then return nil end\n  return MiniHipatterns.compute_hex_color_group(hex, 'bg')\nend\n\nlocal hipatterns = require('mini.hipatterns')\nhipatterns.setup({\n  highlighters = {\n    word_color = { pattern = '%S+', group = word_color_group },\n  },\n})\nTrailing whitespace (if don’t want to use more specific mini.trailspace):\n{ pattern = '%f[%s]%s*$', group = 'Error' }\nCensor certain sensitive information:\nlocal censor_extmark_opts = function(_, match, _)\n  local mask = string.rep('x', vim.fn.strchars(match))\n  return {\n    virt_text = { { mask, 'Comment' } }, virt_text_pos = 'overlay',\n    priority = 200, right_gravity = false,\n  }\nend\n\nrequire('mini.hipatterns').setup({\n  highlighters = {\n    censor = {\n      pattern = 'password: ()%S+()',\n      group = '',\n      extmark_opts = censor_extmark_opts,\n    },\n  },\n})\nEnable only in certain filetypes. There are at least these ways to do it:\n\n(Suggested) With vim.b.minihipatterns_config in filetype-plugin. Basically, create “after/ftplugin/&lt;filetype&gt;.lua” file in your config directory (see $XDG_CONFIG_HOME) and define vim.b.minihipatterns_config there with filetype specific highlighters.\nThis assumes require('mini.hipatterns').setup() call.\nFor example, to highlight keywords in EmmyLua comments in Lua files, create “after/ftplugin/lua.lua” with the following content:\nvim.b.minihipatterns_config = {\n  highlighters = {\n    emmylua = { pattern = '^%s*%-%-%-()@%w+()', group = 'Special' }\n  }\n}\nUse callable pattern with condition. For example:\nrequire('mini.hipatterns').setup({\n  highlighters = {\n    emmylua = {\n      pattern = function(buf_id)\n        if vim.bo[buf_id].filetype ~= 'lua' then return nil end\n        return '^%s*%-%-%-()@%w+()'\n      end,\n      group = 'Special',\n    },\n  },\n})\n\nDisable only in certain filetypes. Enable with MiniHipatterns.setup() and set vim.b.minihipatterns_disable buffer-local variable to true for buffer you want disabled. See mini.nvim-disabling-recipes for more examples.\n\n\n\n\n\nsetup()\n\nMiniHipatterns.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniHipatterns.config.\n\n\nUsage\nrequire('mini.hipatterns').setup({}) -- replace {} with your config table\n                                     -- needs `highlighters` field present\n\n\n\n\nconfig\n\nMiniHipatterns.config\n\n\nDefaults\nMiniHipatterns.config = {\n  -- Table with highlighters (see |MiniHipatterns.config| for more details).\n  -- Nothing is defined by default. Add manually for visible effect.\n  highlighters = {},\n\n  -- Delays (in ms) defining asynchronous highlighting process\n  delay = {\n    -- How much to wait for update after every text change\n    text_change = 200,\n\n    -- How much to wait for update after window scroll\n    scroll = 50,\n  },\n}\n\n\nHighlighters\nhighlighters table defines which patterns will be highlighted by placing extmark at the match start. It might or might not have explicitly named fields, but having them is recommended and is required for proper use of vim.b.minihipatterns_config as buffer-local config. By default it is empty expecting user definition.\nEach entry defines single highlighter as a table with the following fields:\n\n&lt;pattern&gt; (string|function|table) - Lua pattern to highlight. Can be either string, callable returning the string, or an array of those. If string:\n\nIt can have submatch delimited by placing () on start and end, NOT by surrounding it with parenthesis (results in an error containing number expected, got string). Example: xx()abcd()xx will match abcd only if xx is placed before and after it.\n\nIf callable:\n\nIt will be called for every enabled buffer with its identifier as input. Should return single string pattern or nil (meaning this particular highlighter will not work in this particular buffer).\n\nIf array:\n\nEach element is matched and highlighted with the same highlight group.\n\nNote: matching does not result in overlapping (sub)matches (similarly to how cpo-c works). For example, with line xxxxxxx:\n\nPattern xxx matches columns 1-3, 4-6.\nPattern ()xx()x matches columns 1-2, 3-4, 5-6.\nPattern x()xx() matches columns 2-3, 5-6.\nPattern x()x()x matches columns 2-2, 4-4, 6-6.\n\n&lt;group&gt; (string|function) - name of highlight group to use. Can be either string or callable returning the string. If callable:\n\nIt will be called for every pattern match with the following arguments:\n\nbuf_id - buffer identifier.\nmatch - string pattern match to be highlighted.\ndata - extra table with information about the match. It has at least these fields:\n\n&lt;full_match&gt; - string with full pattern match.\n&lt;line&gt; - match line number (1-indexed).\n&lt;from_col&gt; - match starting byte column (1-indexed).\n&lt;to_col&gt; - match ending byte column (1-indexed, inclusive).\n\n\nIt can return nil meaning this particular match will not be highlighted.\n\n&lt;extmark_opts&gt; (table|function|nil) - optional extra options for nvim_buf_set_extmark(). If callable, will be called in the same way as callable &lt;group&gt; (data will also contain hl_group key with &lt;group&gt; value) and should return a table with all options for extmark (including end_row, end_col, hl_group, and priority).\n\nSee “Common use cases” section for the examples.\n\n\nDelay\ndelay is a table defining delays in milliseconds used for asynchronous highlighting process.\ndelay.text_change is used to delay highlighting updates by accumulating them (in debounce fashion). Smaller values will lead to faster response but more frequent updates. Bigger - slower response but less frequent updates.\ndelay.scroll is used to delay updating highlights in current window view during scrolling (see WinScrolled event). These updates are present to ensure up to date highlighting after scroll.\n\n\n\n\nenable()\n\nMiniHipatterns.enable({buf_id}, {config})\n\nEnable highlighting in buffer\nNotes:\n\nWith default config it will highlight nothing, as there are no default highlighters.\nBuffer highlighting is enabled until buffer is unloaded from memory or MiniHipatterns.disable() on this buffer is called.\n:edit disables this, as it is mostly equivalent to closing and opening buffer. In order for highlighting to persist after :edit, call MiniHipatterns.setup().\n\n\nParameters\n{buf_id} (number|nil) Buffer identifier in which to enable highlighting. Default: 0 for current buffer.\n{config} (table|nil) Optional buffer-local config. Should have the same structure as MiniHipatterns.config. Values will be taken in this order:\n\nFrom this config argument (if supplied).\nFrom buffer-local config in vim.b.minihipatterns_config (if present).\nFrom global config (if MiniHipatterns.setup() was called).\nFrom default values.\n\n\n\n\n\ndisable()\n\nMiniHipatterns.disable({buf_id})\n\nDisable highlighting in buffer\nNote that if MiniHipatterns.setup() was called, the effect is present until the next auto-enabling event. To permanently disable highlighting in buffer, set vim.b.minihipatterns_disable to true\n\nParameters\n{buf_id} (number|nil) Buffer identifier in which to enable highlighting. Default: 0 for current buffer.\n\n\n\n\ntoggle()\n\nMiniHipatterns.toggle({buf_id}, {config})\n\nToggle highlighting in buffer\nCall MiniHipatterns.disable() if enabled; MiniHipatterns.enable() otherwise.\n\nParameters\n{buf_id} (number|nil) Buffer identifier in which to enable highlighting. Default: 0 for current buffer.\n{config} (table|nil) Forwarded to MiniHipatterns.enable().\n\n\n\n\nupdate()\n\nMiniHipatterns.update({buf_id}, {from_line}, {to_line})\n\nUpdate highlighting in range\nWorks only in buffer with enabled highlighting. Effect takes immediately without delay.\n\nParameters\n{buf_id} (number|nil) Buffer identifier in which to enable highlighting. Default: 0 for current buffer.\n{from_line} (number|nil) Start line from which to update (1-indexed).\n{to_line} (number|nil) End line from which to update (1-indexed, inclusive).\n\n\n\n\nget_enabled_buffers()\n\nMiniHipatterns.get_enabled_buffers()\n\nGet an array of enabled buffers\n\nReturn\n(table) Array of buffer identifiers with enabled highlighting.\n\n\n\n\nget_matches()\n\nMiniHipatterns.get_matches({buf_id}, {highlighters})\n\nGet buffer matches\n\nParameters\n{buf_id} (number|nil) Buffer identifier for which to return matches. Default: nil for current buffer.\n{highlighters} (table|nil) Array of highlighter identifiers (as in highlighters field of MiniHipatterns.config) for which to return matches. Default: all available highlighters (ordered by string representation).\n\n\nReturn\n(table) Array of buffer matches which are tables with following fields:\n\n&lt;bufnr&gt; (number) - buffer identifier of a match.\n&lt;highlighter&gt; (any) - highlighter identifier which produced the match.\n&lt;lnum&gt; (number) - line number of the match start (starts with 1).\n&lt;col&gt; (number) - column number of the match start (starts with 1).\n&lt;end_lnum&gt; (number|nil) - line number of the match end (starts with 1).\n&lt;end_col&gt; (number|nil) - column number next to the match end (implements end-exclusive region; starts with 1).\n&lt;hl_group&gt; (string|nil) - name of match’s highlight group.\n\nMatches are ordered first by supplied highlighters, then by line and column of match start.\n\n\n\n\ngen_highlighter\n\nMiniHipatterns.gen_highlighter\n\nGenerate builtin highlighters\nThis is a table with function elements. Call to actually get highlighter.\n\n\n\ngen_highlighter.hex_color()\n\nMiniHipatterns.gen_highlighter.hex_color({opts})\n\nHighlight hex color string\nThis will match color hex string in format #rrggbb and highlight it according to opts.style displaying matched color.\nHighlight group is computed using MiniHipatterns.compute_hex_color_group(), so all its usage notes apply here.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;style&gt; (string) - one of:\n\n'full' - highlight background of whole hex string with it. Default.\n'#' - highlight background of only #.\n'line' - highlight underline with that color.\n'inline' - highlight text of &lt;inline_text&gt;. Note: requires Neovim&gt;=0.10.\n\n&lt;priority&gt; (number) - priority of highlighting. Default: 200.\n&lt;filter&gt; (function) - callable object used to filter buffers in which highlighting will take place. It should take buffer identifier as input and return false or nil to not highlight inside this buffer.\n&lt;inline_text&gt; (string) - string to be placed and highlighted with color to the right of match in case &lt;style&gt; is “inline”. Default: “█”.\n\n\n\nReturn\n(table) Highlighter table ready to be used as part of config.highlighters. Both pattern and group are callable.\n\n\nUsage\nlocal hipatterns = require('mini.hipatterns')\nhipatterns.setup({\n  highlighters = {\n    hex_color = hipatterns.gen_highlighter.hex_color(),\n  }\n})\n\n\n\n\ncompute_hex_color_group()\n\nMiniHipatterns.compute_hex_color_group({hex_color}, {style})\n\nCompute and create group to highlight hex color string\nNotes:\n\nThis works properly only with enabled ‘termguicolors’.\nTo increase performance, it caches highlight groups per hex_color and style combination. Needs a call to MiniHipatterns.setup() to have these groups be persistent across color scheme changes.\n\n\nParameters\n{hex_color} (string) Hex color string in format #rrggbb.\n{style|nil} (string) One of:\n\n'bg' - highlight background with hex_color and foreground with black or white (whichever is more visible). Default.\n'fg' - highlight foreground with hex_color.\n'line' - highlight underline with hex_color.\n\n\n\nReturn\n(string) Name of created highlight group appropriate to show hex_color."
  },
  {
    "objectID": "mini.nvim/doc/mini-comment.html",
    "href": "mini.nvim/doc/mini-comment.html",
    "title": "mini.comment documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.comment Comment lines\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nCommenting in Normal mode respects count and is dot-repeatable.\nComment structure by default is inferred from ‘commentstring’: either from current buffer or from locally active tree-sitter language. It can be customized via options.custom_commentstring (see MiniComment.config for details).\nAllows custom hooks before and after successful commenting.\nConfigurable options for some nuanced behavior.\n\nWhat it doesn’t do:\n\nBlock and sub-line comments. This will only support per-line commenting.\nHandle indentation with mixed tab and space.\nPreserve trailing whitespace in empty lines.\n\nNotes:\n\nTo use tree-sitter aware commenting, global value of ‘commentstring’ should be '' (empty string). This is the default value, so make sure to not set it manually to a different value.\n\n\nSetup\nThis module needs a setup with require('mini.comment').setup({}) (replace {} with your config table). It will create global Lua table MiniComment which you can use for scripting or manually (with :lua MiniComment.*).\nSee MiniComment.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minicomment_config which should have same structure as MiniComment.config. See mini.nvim-buffer-local-config for more details.\n\n\nDisabling\nTo disable core functionality, set vim.g.minicomment_disable (globally) or vim.b.minicomment_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniComment.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniComment.config.\n\n\nUsage\nrequire('mini.comment').setup() -- use default config\n-- OR\nrequire('mini.comment').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniComment.config\n\n\nDefaults\nMiniComment.config = {\n  -- Options which control module behavior\n  options = {\n    -- Function to compute custom 'commentstring' (optional)\n    custom_commentstring = nil,\n\n    -- Whether to ignore blank lines in actions and textobject\n    ignore_blank_line = false,\n\n    -- Whether to recognize as comment only lines without indent\n    start_of_line = false,\n\n    -- Whether to force single space inner padding for comment parts\n    pad_comment_parts = true,\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Toggle comment (like `gcip` - comment inner paragraph) for both\n    -- Normal and Visual modes\n    comment = 'gc',\n\n    -- Toggle comment on current line\n    comment_line = 'gcc',\n\n    -- Toggle comment on visual selection\n    comment_visual = 'gc',\n\n    -- Define 'comment' textobject (like `dgc` - delete whole comment block)\n    -- Works also in Visual mode if mapping differs from `comment_visual`\n    textobject = 'gc',\n  },\n\n  -- Hook functions to be executed at certain stage of commenting\n  hooks = {\n    -- Before successful commenting. Does nothing by default.\n    pre = function() end,\n    -- After successful commenting. Does nothing by default.\n    post = function() end,\n  },\n}\n\n\nOptions\n\nCustom commentstring\noptions.custom_commentstring can be a function customizing ‘commentstring’ option used to infer comment structure. It is called once before every commenting action with the following arguments:\n\nref_position - position at which to compute ‘commentstring’ (might be relevant for a text with locally different commenting rules). Its structure is the same as opts.ref_position in MiniComment.toggle_lines().\n\nIts output should be a valid ‘commentstring’ (string containing %s).\nIf not set or the output is nil, MiniComment.get_commentstring() is used.\nFor example, this option can be used to always use buffer ‘commentstring’ even in case of present active tree-sitter parser:\nrequire('mini.comment').setup({\n  options = {\n    custom_commentstring = function() return vim.bo.commentstring end,\n  }\n})\n\n\n\nHooks\nhooks.pre and hooks.post functions are executed before and after successful commenting action (toggle or computing textobject). They will be called with a single table argument which has the following fields:\n\n&lt;action&gt; (string) - action name. One of “toggle” (when actual toggle direction is yet unknown), “comment”, “uncomment”, “textobject”.\n&lt;line_start&gt; (number|nil) - action start line. Can be absent if yet unknown.\n&lt;line_end&gt; (number|nil) - action end line. Can be absent if yet unknown.\n&lt;ref_position&gt; (table|nil) - reference position.\n\nNotes:\n\nChanging ‘commentstring’ in hooks.pre is allowed and will take effect.\nIf hook returns false, any further action is terminated.\n\n\n\n\n\noperator()\n\nMiniComment.operator({mode})\n\nMain function to be mapped\nIt is meant to be used in expression mappings (see :map-&lt;expr&gt;) to enable dot-repeatability and commenting on range. There is no need to do this manually, everything is done inside MiniComment.setup().\nIt has a somewhat unintuitive logic (because of how expression mapping with dot-repeatability works): it should be called without arguments inside expression mapping and with argument when action should be performed.\n\nParameters\n{mode} (string|nil) Optional string with ‘operatorfunc’ mode (see g@).\n\n\nReturn\n(string|nil) ‘g@’ if called without argument, ’’ otherwise (but after performing action).\n\n\n\n\ntoggle_lines()\n\nMiniComment.toggle_lines({line_start}, {line_end}, {opts})\n\nToggle comments between two line numbers\nIt uncomments if lines are comment (every line is a comment or blank) and comments otherwise. It respects indentation and doesn’t insert trailing whitespace. Toggle commenting not in visual mode is also dot-repeatable and respects count.\n\nNotes\n\nComment structure is inferred from buffer’s ‘commentstring’ option or local language of tree-sitter parser (if active).\nCall to this function will remove all extmarks from target range.\n\n\n\nParameters\n{line_start} (number) Start line number (inclusive from 1 to number of lines).\n{line_end} (number) End line number (inclusive from 1 to number of lines).\n{opts} (table|nil) Options. Possible fields:\n\n&lt;ref_position&gt; (table) - A two-value array with { row, col } (both starting at 1) of reference position at which ‘commentstring’ value will be computed. Default: { line_start, 1 }.\n\n\n\n\n\ntextobject()\n\nMiniComment.textobject()\n\nSelect comment textobject\nThis selects all commented lines adjacent to cursor line. If ignore_blank_line option is enabled (see MiniComment.config), blank lines between commented lines are treated as part of textobject. Designed to be used with operator mode mappings (see mapmode-o).\n\n\n\nget_commentstring()\n\nMiniComment.get_commentstring({ref_position})\n\nGet ‘commentstring’\nThis function represents default approach of computing relevant ‘commentstring’ option in current buffer. Used to infer comment structure.\nIt has the following logic:\n\nIf there is an active tree-sitter parser, try to get ‘commentstring’ from the local language at ref_position.\nIf first step is not successful, use buffer’s ‘commentstring’ directly.\n\n\nParameters\n{ref_position} (table) Reference position inside current buffer at which to compute ‘commentstring’. Same structure as opts.ref_position in MiniComment.toggle_lines().\n\n\nReturn\n(string) Relevant value of ‘commentstring’."
  },
  {
    "objectID": "mini.nvim/doc/mini-fuzzy.html",
    "href": "mini.nvim/doc/mini-fuzzy.html",
    "title": "mini.fuzzy documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.fuzzy Fuzzy matching\nMIT License Copyright (c) 2021 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nMinimal and fast fuzzy matching algorithm which prioritizes match width.\nFunctions to for common fuzzy matching operations:\n\nMiniFuzzy.match().\nMiniFuzzy.filtersort().\nMiniFuzzy.process_lsp_items().\n\nGenerator of sorter (MiniFuzzy.get_telescope_sorter()) for nvim-telescope/telescope.nvim\n\n\nSetup\nThis module doesn’t need setup, but it can be done to improve usability. Setup with require('mini.fuzzy').setup({}) (replace {} with your config table). It will create global Lua table MiniFuzzy which you can use for scripting or manually (with :lua MiniFuzzy.*).\nSee MiniFuzzy.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minifuzzy_config which should have same structure as MiniFuzzy.config. See mini.nvim-buffer-local-config for more details.\n\n\nNotes\n\nCurrently there is no explicit design to work with multibyte symbols, but simple examples should work.\nSmart case is used: case insensitive if input word (which is usually a user input) is all lower case. Case sensitive otherwise.\n\n\n\n\n\nAlgorithm\nGeneral design uses only width of found match and index of first letter match. No special characters or positions (like in fzy and fzf) are used.\nGiven non-empty input word and target candidate:\n\nThe goal is to find matching between word’s letters and letters in candidate which minimizes certain score. It is assumed that order of letters in word and those matched in candidate should be the same.\nMatching is represented by matched positions: an array positions of integers with length equal to number of letters in word. The following should be always true in case of a match: candidate’s letter at index positions[i] is letters[i]for all validi`.\nMatched positions are evaluated based only on two features: their width (number of indexes between first and last positions) and first match (index of first letter match). There is a global setting cutoff for which all feature values greater than it can be considered “equally bad”.\nScore of matched positions is computed with following explicit formula: cutoff * min(width, cutoff) + min(first, cutoff). It is designed to be equivalent to first comparing widths (lower is better) and then comparing first match (lower is better). For example, if word = 'time':\n\n’_time’ (width 4) will have a better match than ‘t_ime’ (width 5).\n‘time_a’ (width 4, first 1) will have a better match than ‘a_time’ (width 4, first 3).\n\nFinal matched positions are those which minimize score among all possible matched positions of word and candidate.\n\n\n\n\nsetup()\n\nMiniFuzzy.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniFuzzy.config.\n\n\nUsage\nrequire('mini.fuzzy').setup() -- use default config\n-- OR\nrequire('mini.fuzzy').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniFuzzy.config\n\n\nDefaults\nMiniFuzzy.config = {\n  -- Maximum allowed value of match features (width and first match). All\n  -- feature values greater than cutoff can be considered \"equally bad\".\n  cutoff = 100,\n}\n\n\n\n\nmatch()\n\nMiniFuzzy.match({word}, {candidate})\n\nCompute match data\n\nParameters\n{word} (string) Input word (usually user input).\n{candidate} (string) Target word (usually with which matching is done).\n\n\nReturn\n(table) Matching information:\n\n&lt;positions&gt; (table|nil) - array with letter indexes inside candidate which matched to corresponding letters in word. It is empty array if word is empty string and nil if no match.\n&lt;score&gt; number - positive number representing how good the match is (lower is better). It is -1 if no match or word is empty string.\n\n\n\n\n\nfiltersort()\n\nMiniFuzzy.filtersort({word}, {candidate_array})\n\nFilter string array\n\nKeep only input elements which match word.\nSort from best to worst matches (based on score and index in original array, both lower is better).\n\n\nParameters\n{word} (string) String which will be searched.\n{candidate_array} (table) Lua array of strings inside which word will be searched.\n\n\nReturn\n(...) Arrays of matched candidates and their indexes in original input.\n\n\n\n\nprocess_lsp_items()\n\nMiniFuzzy.process_lsp_items({items}, {base})\n\nFuzzy matching for lsp_completion.process_items of MiniCompletion.config\n\nParameters\n{items} (table) Array with LSP ‘textDocument/completion’ response items.\n{base} (string) Word to complete.\n\n\nReturn\n(table) Array of items with text (filterText or label) fuzzy matching base.\n\n\n\n\nget_telescope_sorter()\n\nMiniFuzzy.get_telescope_sorter({opts})\n\nCustom getter for telescope.nvim sorter\nDesigned as a value for file and generic sorter of ‘telescope.nvim’.\n\nParameters\n{opts} (table|nil) Options (currently not used).\n\n\nUsage\nrequire('telescope').setup({\n  defaults = {\n    generic_sorter = require('mini.fuzzy').get_telescope_sorter\n  }\n})"
  },
  {
    "objectID": "mini.nvim/doc/mini-doc.html",
    "href": "mini.nvim/doc/mini-doc.html",
    "title": "mini.doc documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.doc Generate Neovim help files\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nKey design ideas:\n\nKeep documentation next to code by writing EmmyLua-like annotation comments. They will be parsed as is, so formatting should follow built-in guide in help-writing. However, custom hooks are allowed at many generation stages for more granular management of output help file.\nGeneration is done by processing a set of ordered files line by line. Each line can either be considered as a part of documentation block (if it matches certain configurable pattern) or not (considered to be an “afterline” of documentation block). See MiniDoc.generate() for more details.\nProcessing is done by using nested data structures (section, block, file, doc) describing certain parts of help file. See MiniDoc-data-structures for more details.\nProject specific script can be written as plain Lua file with configuratble path. See MiniDoc.generate() for more details.\n\nWhat it doesn’t do:\n\nIt doesn’t support markdown or other markup language inside annotations.\nIt doesn’t use treesitter in favor of Lua string manipulation for basic tasks (parsing annotations, formatting, auto-generating tags, etc.). This is done to manage complexity and be dependency free.\n\n\nSetup\nThis module needs a setup with require('mini.doc').setup({}) (replace {} with your config table). It will create global Lua table MiniDoc which you can use for scripting or manually (with :lua MiniDoc.*).\nSee MiniDoc.config for available config settings.\nYou can override runtime config settings locally to buffer inside vim.b.minidoc_config which should have same structure as MiniDoc.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nTips\n\nSome settings tips that might make writing annotation comments easier:\n\nSet up appropriate ‘comments’ for lua file type to respect EmmyLua-like’s --- comment leader. Value :---,:-- seems to work.\nSet up appropriate ‘formatoptions’ (see also fo-table). Consider adding j, n, q, and r flags.\nSet up appropriate ‘formatlistpat’ to help auto-formatting lists (if n flag is added to ‘formatoptions’). One suggestion (not entirely ideal) is a value ^\\s*[0-9\\-\\+\\*]\\+[\\.\\)]*\\s\\+. This reads as ‘at least one special character (digit, -, +, *) possibly followed by some punctuation (. or )) followed by at least one space is a start of list item’.\n\nProbably one of the most reliable resources for what is considered to be best practice when using this module is this whole plugin. Look at source code for the reference.\n\n\n\nComparisons\n\ntjdevries/tree-sitter-lua:\n\nIts key design is to use treesitter grammar to parse both Lua code and annotation comments. This makes it not easy to install, customize, and support.\nIt takes more care about automating output formatting (like auto indentation and line width fit). This plugin leans more to manual formatting with option to supply customized post-processing hooks.\n\n\n\n\n\n\nData structures\nData structures\nData structures are basically arrays of other structures accompanied with some fields (keys with data values) and methods (keys with function values):\n\nSection structure is an array of string lines describing one aspect (determined by section id like ‘@param’, ‘@return’, ‘@text’) of an annotation subject. All lines will be used directly in help file.\nBlock structure is an array of sections describing one annotation subject like function, table, concept.\nFile structure is an array of blocks describing certain file on disk. Basically, file is split into consecutive blocks: annotation lines go inside block, non-annotation - inside block_afterlines element of info.\nDoc structure is an array of files describing a final help file. Each string line from section (when traversed in depth-first fashion) goes directly into output file.\n\nAll structures have these keys:\n\nFields:\n\ninfo - contains additional information about current structure. For more details see next section.\nparent - table of parent structure (if exists).\nparent_index - index of this structure in its parent’s array. Useful for adding to parent another structure near current one.\ntype - string with structure type (section, block, file, doc).\n\nMethods (use them as x:method(args)):\n\ninsert(self, [index,] child) - insert child to self at position index (optional; if not supplied, child will be appended to end). Basically, a table.insert(), but adds parent and parent_index fields to child while properly updating self.\nremove(self [,index]) - remove from self element at position index. Basically, a table.remove(), but properly updates self.\nhas_descendant(self, predicate) - whether there is a descendant (structure or string) for which predicate returns true. In case of success also returns the first such descendant as second value.\nhas_lines(self) - whether structure has any lines (even empty ones) to be put in output file. For section structures this is equivalent to #self, but more useful for higher order structures.\nclear_lines(self) - remove all lines from structure. As a result, this structure won’t contribute to output help file.\n\n\nDescription of info fields per structure type:\n\nSection:\n\nid - captured section identifier. Can be empty string meaning no identifier is captured.\nline_begin - line number inside file at which section begins (-1 if not generated from file).\nline_end - line number inside file at which section ends (-1 if not generated from file).\n\nBlock:\n\nafterlines - array of strings which were parsed from file after this annotation block (up until the next block or end of file). Useful for making automated decisions about what is being documented.\nline_begin - line number inside file at which block begins (-1 if not generated from file).\nline_end - line number inside file at which block ends (-1 if not generated from file).\n\nFile:\n\npath - absolute path to a file ('' if not generated from file).\n\nDoc:\n\ninput - array of input file paths (as in MiniDoc.generate()).\noutput - output path (as in MiniDoc.generate()).\nconfig - configuration used (as in MiniDoc.generate()).\n\n\n\n\n\nsetup()\n\nMiniDoc.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniDoc.config.\n\n\nUsage\nrequire('mini.doc').setup() -- use default config\n-- OR\nrequire('mini.doc').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniDoc.config\n\n\nDefaults\nMiniDoc.config = {\n  -- Function which extracts part of line used to denote annotation.\n  -- For more information see 'Notes' in |MiniDoc.config|.\n  annotation_extractor = function(l) return string.find(l, '^%-%-%-(%S*) ?') end,\n\n  -- Identifier of block annotation lines until first captured identifier\n  default_section_id = '@text',\n\n  -- Hooks to be applied at certain stage of document life cycle. Should\n  -- modify its input in place (and not return new one).\n  hooks = {\n    -- Applied to block before anything else\n    block_pre = --&lt;function: infers header sections (tag and/or signature)&gt;,\n\n    -- Applied to section before anything else\n    section_pre = --&lt;function: replaces current aliases&gt;,\n\n    -- Applied if section has specified captured id\n    sections = {\n      ['@alias'] = --&lt;function: registers alias in MiniDoc.current.aliases&gt;,\n      ['@class'] = --&lt;function&gt;,\n      ['@diagnostic'] = --&lt;function: ignores any section content&gt;,\n      -- For most typical usage see |MiniDoc.afterlines_to_code|\n      ['@eval'] = --&lt;function: evaluates lines; replaces with their return&gt;,\n      ['@field'] = --&lt;function&gt;,\n      ['@overload'] = --&lt;function&gt;,\n      ['@param'] = --&lt;function&gt;,\n      ['@private'] = --&lt;function: registers block for removal&gt;,\n      ['@return'] = --&lt;function&gt;,\n      ['@seealso'] = --&lt;function&gt;,\n      ['@signature'] = --&lt;function: formats signature of documented object&gt;,\n      ['@tag'] = --&lt;function: turns its line in proper tag lines&gt;,\n      ['@text'] = --&lt;function: purposefully does nothing&gt;,\n      ['@toc'] = --&lt;function: clears all section lines&gt;,\n      ['@toc_entry'] = --&lt;function: registers lines for table of contents&gt;,\n      ['@type'] = --&lt;function&gt;,\n      ['@usage'] = --&lt;function&gt;,\n    },\n\n    -- Applied to section after all previous steps\n    section_post = --&lt;function: currently does nothing&gt;,\n\n    -- Applied to block after all previous steps\n    block_post = --&lt;function: does many things&gt;,\n\n    -- Applied to file after all previous steps\n    file = --&lt;function: adds separator&gt;,\n\n    -- Applied to doc after all previous steps\n    doc = --&lt;function: adds modeline&gt;,\n\n    -- Applied before output file is written. Takes lines array as argument.\n    write_pre = --&lt;function: removes delimiters at the top&gt;,\n\n    -- Applied after output help file is written. Takes doc as argument.\n    write_post = --&lt;function: various convenience actions&gt;,\n  },\n\n  -- Path (relative to current directory) to script which handles project\n  -- specific help file generation (like custom input files, hooks, etc.).\n  script_path = 'scripts/minidoc.lua',\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}\n\n\nNotes\n\nannotation_extractor takes single string line as input. Output describes what makes an input to be an annotation (if anything). It should be similar to string.find with one capture group: start and end of annotation indicator (whole part will be removed from help line) with third value being string of section id (if input describes first line of section; nil or empty string otherwise). Output should be nil if line is not part of annotation. Default value means that annotation line should:\n\nStart with --- at first column.\nAny non-whitespace after --- will be treated as new section id.\nSingle whitespace at the start of main text will be ignored.\n\nHooks are expected to be functions. Their default values might do many things which might change over time, so for more information please look at source code. Some more information can be found in MiniDoc.default_hooks.\n\n\n\n\n\ncurrent\n\nMiniDoc.current\n\nTable with information about current state of auto-generation\nIt is reset at the beginning and end of MiniDoc.generate().\nAt least these keys are supported:\n\n{aliases} - table with keys being alias name and values - alias description and single string (using \\n to separate lines).\n{eval_section} - input section of @eval section hook. Can be used for information about current block, etc.\n{toc} - array with table of contents entries. Each entry is a whole @toc_entry section.\n\n\n\n\ndefault_hooks\n\nMiniDoc.default_hooks\n\nDefault hooks\nThis is default value of MiniDoc.config.hooks. Use it if only a little tweak is needed.\nSome more insight about their behavior:\n\nDefault inference of documented object metadata (tag and object signature at the moment) is done in block_pre. Inference is based on string pattern matching, so can lead to false results, although works in most cases. It intentionally works only if first line after block has no indentation and contains all necessary information to determine if inference should happen.\nHooks for sections describing some “variable-like” object (‘@class’, ‘@field’, ‘@param’) automatically enclose first word in ‘{}’.\nHooks for sections which supposed to have “type-like” data (‘@field’, ‘@param’, ‘@return’, ‘@type’) automatically enclose first found “type-like” word and its neighbor characters in ‘(&lt;type&gt;)’ (expect false positives). Algorithm is far from being 100% correct, but seems to work with present allowed type annotation. For allowed types see https://github.com/sumneko/lua-language-server/wiki/EmmyLua-Annotations#types-and-type or, better yet, look in source code of this module.\nAutomated creation of table of contents (TOC) is done in the following way:\n\nPut section with @toc_entry id in the annotation block. Section’s lines will be registered as TOC entry.\nPut @toc section where you want to insert rendered table of contents. TOC entries will be inserted on the left, references for their respective tag section (only first, if present) on the right. Render is done in default doc hook (because it should be done after processing all files).\n\nThe write_post hook executes some actions convenient for iterative annotations writing:\n\nGenerate :helptags for directory containing output file.\nSilently reload buffer containing output file (if such exists).\nDisplay notification message about result.\n\n\n\n\n\ngenerate()\n\nMiniDoc.generate({input}, {output}, {config})\n\nGenerate help file\n\nAlgorithm\n\nMain parameters for help generation are an array of input file paths and path to output help file.\nParse all inputs:\n\nFor each file, lines are processed top to bottom in order to create an array of documentation blocks. Each line is tested whether it is an annotation by applying MiniDoc.config.annotation_extractor: if anything is extracted, it is considered to be an annotation. Annotation line goes to “current block” after removing extracted annotation indicator, otherwise - to afterlines of “current block”.\nEach block’s annotation lines are processed top to bottom. If line had captured section id, it is a first line of “current section” (first block lines are allowed to not specify section id; by default it is @text). All subsequent lines without captured section id go into “current section”.\n\nApply structure hooks (they should modify its input in place, which is possible due to ‘table nature’ of all inputs):\n\nEach block is processed by MiniDoc.config.hooks.block_pre. This is a designated step for auto-generation of sections from described annotation subject (like sections with id @tag, @type).\nEach section is processed by MiniDoc.config.hooks.section_pre.\nEach section is processed by corresponding MiniDoc.config.hooks.sections function (table key equals to section id). This is a step where most of formatting should happen (like wrap first word of @param section with { and }, append empty line to section, etc.).\nEach section is processed by MiniDoc.config.hooks.section_post.\nEach block is processed by MiniDoc.config.hooks.block_post. This is a step for processing block after formatting is done (like add first line with ---- delimiter).\nEach file is processed by MiniDoc.config.hooks.file. This is a step for adding any file-related data (like add first line with ==== delimiter).\nDoc is processed by MiniDoc.config.hooks.doc. This is a step for adding any helpfile-related data (maybe like table of contents).\n\nCollect all strings from sections in depth-first fashion (equivalent to nested “for all files -&gt; for all blocks -&gt; for all sections -&gt; for all strings -&gt; add string to output”). Strings can have \\n character indicating start of new line.\nModify collected strings with MiniDoc.config.write_pre. Takes strings from previous step as input and should return array of strings.\nWrite modified strings to output file.\nExecute MiniDoc.config.write_post hook. This is useful for showing some feedback and making actions involving newly updated help file (like generate tags, etc.).\n\n\n\nProject specific script\nIf all arguments have default nil values, first there is an attempt to source project specific script. This is basically a luafile &lt;MiniDoc.config.script_path&gt; with current Lua runtime while caching and restoring current MiniDoc.config. Its successful execution stops any further generation actions while error means proceeding generation as if no script was found.\nTypical script content might include definition of custom hooks, input and output files with eventual call to require('mini.doc').generate() (with or without arguments).\n\n\nParameters\n{input} (table|nil) Array of file paths which will be processed in supplied order. Default: all ‘.lua’ files from current directory following by all such files in these subdirectories: ‘lua/’, ‘after/’, ‘colors/’. Note: any ‘init.lua’ file is placed before other files from the same directory.\n{output} (string|nil) Path for output help file. Default: doc/&lt;current_directory&gt;.txt (designed to be used for generating help file for plugin).\n{config} (table|nil) Configuration overriding parts of MiniDoc.config.\n\n\nReturn\n(table) Document structure which was generated and used for output help file. In case MiniDoc.config.script_path was successfully used, this is a return from the latest call of this function.\n\n\n\n\nafterlines_to_code()\n\nMiniDoc.afterlines_to_code({struct})\n\nConvert afterlines to code\nThis function is designed to be used together with @eval section to automate documentation of certain values (notably default values of a table). It processes afterlines based on certain directives and makes output look like a Lua code block.\nMost common usage is by adding the following section in your annotation:\n---@eval return MiniDoc.afterlines_to_code(MiniDoc.current.eval_section)\n\nDirectives\nDirectives are special comments that are processed using Lua string pattern capabilities (so beware of false positives). Each directive should be put on its separate line. Supported directives:\n\n--minidoc_afterlines_end denotes a line at afterlines end. Only all lines before it will be considered as afterlines. Useful if there is extra code in afterlines which shouldn’t be used.\n--minidoc_replace_start &lt;replacement&gt; and --minidoc_replace_end denote lines between them which should be replaced with &lt;replacement&gt;. Useful for manually changing what should be placed in output like in case of replacing function body with something else.\n\nHere is an example. Suppose having these afterlines:\n--minidoc_replace_start {\nM.config = {\n  --minidoc_replace_end\n  param_one = 1,\n  --minidoc_replace_start param_fun = --&lt;function&gt;\n  param_fun = function(x)\n    return x + 1\n  end\n  --minidoc_replace_end\n}\n--minidoc_afterlines_end\n\nreturn M\nAfter adding @eval section those will be formatted as:\n{\n  param_one = 1,\n  param_fun = --&lt;function&gt;\n}\n\n\nParameters\n{struct} (table) Block or section structure which after lines will be converted to code.\n\n\nReturn\n(string|nil) Single string (using \\n to separate lines) describing afterlines as Lua code block in help file. If nil, input is not valid."
  },
  {
    "objectID": "mini.nvim/doc/mini-operators.html",
    "href": "mini.nvim/doc/mini-operators.html",
    "title": "mini.operators documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.operators Text edit operators\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nOperators:\n\nEvaluate text and replace with output.\nExchange text regions.\nMultiply (duplicate) text.\nReplace text with register.\nSort text.\n\nAutomated configurable mappings to operate on textobject, line, selection. Can be disabled in favor of more control with MiniOperators.make_mappings().\nAll operators support [count] and dot-repeat.\n\nSee MiniOperators-overview and MiniOperators.config for more details.\n\nSetup\nThis module needs a setup with require('mini.operators').setup({}) (replace {} with your config table). It will create global Lua table MiniOperators which you can use for scripting or manually (with :lua MiniOperators.*).\nSee MiniOperators.config for available config settings.\nYou can override runtime config settings (but not config.mappings) locally to buffer inside vim.b.minioperators_config which should have same structure as MiniOperators.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\ngbprod/substitute.nvim:\n\nHas “replace” and “exchange” variants, but not others from this module.\nHas “replace/substitute” over range functionality, while this module does not by design (it is similar to :s functionality while not offering significantly lower mental complexity).\n“Replace” highlights pasted text, while in this module it doesn’t.\n“Exchange” doesn’t work across buffers, while in this module it does.\n\nsvermeulen/vim-subversive:\n\nMain inspiration for “replace” functionality, so they are mostly similar for this operator.\nHas “replace/substitute” over range functionality, while this module does not by design.\n\ntommcdo/vim-exchange:\n\nMain inspiration for “exchange” functionality, so they are mostly similar for this operator.\nDoesn’t work across buffers, while this module does.\n\nchristoomey/vim-sort-motion:\n\nUses :sort for linewise sorting, while this module uses consistent sorting algorithm (by default, see MiniOperators.default_sort_func()).\nSorting algorithm can’t be customized, while this module allows this (see sort.func in MiniOperators.config).\nFor charwise region uses only commas as separators, while this module can also separate by semicolon or whitespace (by default, see MiniOperators.default_sort_func()).\n\n\n\n\nHighlight groups\n\nMiniOperatorsExchangeFrom - first region to exchange.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable main functionality, set vim.g.minioperators_disable (globally) or vim.b.minioperators_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nOverview\nOperator defines an action that will be performed on a textobject, motion, or visual selection (similar to d, c, etc.). When makes sense, it can also respect supplied register (like “replace” operator).\nThis module implements each operator in a separate dedicated function (like MiniOperators.replace() for “replace” operator). Each such function takes mode as argument and acts depending on it:\n\nIf mode is nil (or not explicitly supplied), it sets ‘operatorfunc’ to this dedicated function and returns g@ assuming being called from expression mapping. See :map-operator and :map-expression for more details.\nIf mode is “char”, “line”, or “block”, it acts as operatorfunc and performs action for region between [[](https://neovim.io/doc/user/helptag.html?tag=[) and |`]| marks.\nIf mode is “visual”, it performs action for region between [&lt;](https://neovim.io/doc/user/helptag.html?tag=&lt;) and |`&gt;| marks.\n\nFor more details about specific operator, see help for its function:\n\nEvaluate: MiniOperators.evaluate()\nExchange: MiniOperators.exchange()\nMultiply: MiniOperators.multiply()\nReplace: MiniOperators.replace()\nSort: MiniOperators.sort()\n\n\nMappings\nMiniOperators-mappings\nAll operators are automatically mapped during MiniOperators.setup() execution. Mappings keys are deduced from prefix field of corresponding config entry. All built-in conflicting mappings are removed (like gra, grn in Neovim&gt;=0.11). Both gx and v_gx are remapped to gX (if that is not already taken).\nFor each operator the following mappings are created:\n\nIn Normal mode to operate on textobject. Uses prefix directly.\nIn Normal mode to operate on line. Appends to prefix the last character. This aligns with operator-doubled and established patterns for operators with more than two characters, like guu, gUU, etc.\nIn Visual mode to operate on visual selection. Uses prefix directly.\n\nExample of default mappings for “replace”:\n\ngr in Normal mode for operating on textobject. Example of usage: griw replaces “inner word” with default register.\ngrr in Normal mode for operating on line. Example of usage: grr replaces current line.\ngr in Visual mode for operating on visual selection. Example of usage: viw selects “inner word” and gr replaces it.\n\nThere are two suggested ways to customize mappings:\n\nChange prefix in MiniOperators.setup() call. For example, doing\nrequire('mini.operators').setup({ replace = { prefix = 'cr' } })\nwill make mappings for cr / crr / cr instead of gr / grr / gr.\nDisable automated mapping creation by supplying empty string as prefix and use MiniOperators.make_mappings() directly. For example:\n-- Disable automated creation of \"replace\"\nlocal operators = require('mini.operators')\noperators.setup({ replace = { prefix = '' } })\n\n-- Make custom mappings\noperators.make_mappings(\n  'replace',\n  { textobject = 'cr', line = 'crr', selection = 'cr' }\n)\n\n\n\n\n\nsetup()\n\nMiniOperators.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniOperators.config.\n\n\nUsage\nrequire('mini.operators').setup() -- use default config\n-- OR\nrequire('mini.operators').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniOperators.config\n\n\nDefaults\nMiniOperators.config = {\n  -- Each entry configures one operator.\n  -- `prefix` defines keys mapped during `setup()`: in Normal mode\n  -- to operate on textobject and line, in Visual - on selection.\n\n  -- Evaluate text and replace with output\n  evaluate = {\n    prefix = 'g=',\n\n    -- Function which does the evaluation\n    func = nil,\n  },\n\n  -- Exchange text regions\n  exchange = {\n    -- NOTE: Default `gx` is remapped to `gX`\n    prefix = 'gx',\n\n    -- Whether to reindent new text to match previous indent\n    reindent_linewise = true,\n  },\n\n  -- Multiply (duplicate) text\n  multiply = {\n    prefix = 'gm',\n\n    -- Function which can modify text before multiplying\n    func = nil,\n  },\n\n  -- Replace text with register\n  replace = {\n    -- NOTE: Default `gr*` LSP mappings are removed\n    prefix = 'gr',\n\n    -- Whether to reindent new text to match previous indent\n    reindent_linewise = true,\n  },\n\n  -- Sort text\n  sort = {\n    prefix = 'gs',\n\n    -- Function which does the sort\n    func = nil,\n  }\n}\n\n\nEvaluate\nevaluate.prefix is a string used to automatically infer operator mappings keys during MiniOperators.setup(). See MiniOperators-mappings.\nevaluate.func is a function used to actually evaluate text region. If nil (default), MiniOperators.default_evaluate_func() is used.\nThis function will take content table representing selected text as input and should return array of lines as output (each item per line). Content table has fields lines, array of region lines, and submode, one of v, V, \\22 (escaped &lt;C-v&gt;) for charwise, linewise, and blockwise.\nTo customize evaluation per language, set evaluate.func in buffer-local config (vim.b.minioperators_config; see mini.nvim-buffer-local-config).\n\n\nExchange\nexchange.prefix is a string used to automatically infer operator mappings keys during MiniOperators.setup(). See MiniOperators-mappings.\nNote: default value “gx” overrides gx / v_gx. Instead they are remapped to gX (if that is not already taken). To keep using gx with built-in feature (open URL at cursor) choose different config.prefix.\nexchange.reindent_linewise is a boolean indicating whether newly put linewise text should preserve indent of replaced text. In other words, if false, regions are exchanged preserving their indents; if true - without them.\n\n\nMultiply\nmultiply.prefix is a string used to automatically infer operator mappings keys during MiniOperators.setup(). See MiniOperators-mappings.\nmultiply.func is a function used to optionally update multiplied text. If nil (default), text used as is.\nTakes content table as input (see “Evaluate” section) and should return array of lines as output.\n\n\nReplace\nreplace.prefix is a string used to automatically infer operator mappings keys during MiniOperators.setup(). See MiniOperators-mappings.\nreplace.reindent_linewise is a boolean indicating whether newly put linewise text should preserve indent of replaced text.\n\n\nSort\nsort.prefix is a string used to automatically infer operator mappings keys during MiniOperators.setup(). See MiniOperators-mappings.\nsort.func is a function used to actually sort text region. If nil (default), MiniOperators.default_sort_func() is used.\nTakes content table as input (see “Evaluate” section) and should return array of lines as output.\nExample of sort.func which asks user for custom delimiter for charwise region:\nlocal sort_func = function(content)\n  local opts = {}\n  if content.submode == 'v' then\n    -- Ask for delimiter to be treated as is (not as Lua pattern)\n    local delimiter = vim.fn.input('Sort delimiter: ')\n    -- Treat surrounding whitespace as part of split\n    opts.split_patterns = { '%s*' .. vim.pesc(delimiter) .. '%s*' }\n  end\n  return MiniOperators.default_sort_func(content, opts)\nend\n\nrequire('mini.operators').setup({ sort = { func = sort_func } })\n\n\n\n\nevaluate()\n\nMiniOperators.evaluate({mode})\n\nEvaluate text and replace with output\nIt replaces the region with the output of config.evaluate.func. By default it is MiniOperators.default_evaluate_func() which evaluates text as Lua code depending on the region submode.\n\nParameters\n{mode} (string|nil) One of nil, 'char', 'line', 'block', 'visual'.\n\n\n\n\nexchange()\n\nMiniOperators.exchange({mode})\n\nExchange text regions\nHas two-step logic:\n\nFirst call remembers the region as the one to be exchanged and highlights it with MiniOperatorsExchangeFrom highlight group.\nSecond call performs the exchange. Basically, a two substeps action: “yank both regions” and replace each one with another.\n\nNotes:\n\nUse &lt;C-c&gt; to stop exchanging after the first step.\nExchanged regions can have different (char,line,block)-wise submodes.\nWorks with most cases of intersecting regions, but not officially supported.\n\n\nParameters\n{mode} (string|nil) One of nil, 'char', 'line', 'block', 'visual'.\n\n\n\n\nmultiply()\n\nMiniOperators.multiply({mode})\n\nMultiply (duplicate) text\nCopies a region (without affecting registers) and puts it directly after.\nNotes:\n\nSupports two types of [count]: [count1]gm[count2][textobject] with default config.multiply.prefix makes [count1] copies of region defined by [count2][textobject]. Example: 2gm3aw - 2 copies of 3aw.\n[count] for “line” mapping (gmm by default) is treated as [count1] from previous note.\nAdvantages of using this instead of “yank” + “paste”:\n\nDoesn’t modify any register, while separate steps need some register to hold multiplied text.\nIn most cases separate steps would be “yank” + “move cursor” + “paste”, while “multiply” makes it at once.\n\n\n\nParameters\n{mode} (string|nil) One of nil, 'char', 'line', 'block', 'visual'.\n\n\n\n\nreplace()\n\nMiniOperators.replace({mode})\n\nReplace text with register\nNotes:\n\nSupports two types of [count]: [count1]gr[count2][textobject] with default config.replace.prefix puts [count1] contents of register over region defined by [count2][textobject]. Example: 2gr3aw - 2 register contents over 3aw.\n[count] for “line” mapping (grr by default) is treated as [count1] from previous note.\nAdvantages of using this instead of “visually select” + “paste with v_P”:\n\nAs operator it is dot-repeatable which has cumulative gain in case of multiple replacing is needed.\nCan automatically reindent.\n\n\n\nParameters\n{mode} (string|nil) One of nil, 'char', 'line', 'block', 'visual'.\n\n\n\n\nsort()\n\nMiniOperators.sort({mode})\n\nSort text\nIt replaces the region with the output of config.sort.func. By default it is MiniOperators.default_sort_func() which sorts the text depending on submode.\nNotes:\n\n“line” mapping is charwise (as there is not much sense in sorting linewise a single line). This also results into no [count] support.\n\n\nParameters\n{mode} (string|nil) One of nil, 'char', 'line', 'block', 'visual'.\n\n\n\n\nmake_mappings()\n\nMiniOperators.make_mappings({operator_name}, {lhs_tbl})\n\nMake operator mappings\n\nParameters\n{operator_name} (string) Name of existing operator from this module.\n{lhs_tbl} (table) Table with mappings keys. Should have these fields:\n\n&lt;textobject&gt; (string) - Normal mode mapping to operate on textobject.\n&lt;line&gt; (string) - Normal mode mapping to operate on line. Usually an alias for textobject mapping followed by _. For “sort” it operates charwise on whole line without left and right whitespace (as there is not much sense in sorting linewise a single line).\n&lt;selection&gt; (string) - Visual mode mapping to operate on selection.\n\nSupply empty string to not create particular mapping. Note: creating line mapping needs textobject mapping to be set.\n\n\nUsage\nrequire('mini.operators').make_mappings(\n  'replace',\n  { textobject = 'cr', line = 'crr', selection = 'cr' }\n)\n\n\n\n\ndefault_evaluate_func()\n\nMiniOperators.default_evaluate_func({content})\n\nDefault evaluate function\nEvaluate text as Lua code and return object from last line (like if last line is prepended with return if it is not already).\nBehavior depends on region submode:\n\nFor charwise and linewise regions, text evaluated as is.\nFor blockwise region, lines are evaluated per line using only first lines of outputs. This allows separate execution of lines in order to provide something different compared to linewise region.\n\n\nParameters\n{content} (table) Table with the following fields:\n\n&lt;lines&gt; (table) - array with content lines.\n&lt;submode&gt; (string) - region submode. One of 'v', 'V', '&lt;C-v&gt;' (escaped).\n\n\n\n\n\ndefault_sort_func()\n\nMiniOperators.default_sort_func({content}, {opts})\n\nDefault sort function\nSort text based on region submode:\n\nFor charwise region, split by separator pattern, sort parts, merge back with separators. Actual pattern is inferred based on the array of patterns from opts.split_patterns: whichever element is present in the text is used, preferring the earlier one if several are present. Example: sorting “c, b; a” line with default opts.split_patterns results into “b; a, c” as it is split only by comma.\nFor linewise and blockwise regions sort lines as is.\n\nNotes:\n\nSort is done with table.sort() on an array of lines, which doesn’t treat whitespace or digits specially. Use :sort for more complicated tasks.\nPattern is allowed to be an empty string in which case split results into all characters as parts.\nPad pattern in split_patterns with %s* to include whitespace into separator. Example: line “b _ a” with “” pattern will be sorted as ” a_b ” (because it is split as ”b ”, ””, ” a” ) while with “%s_%s” pattern it results into “a _ b” (split as “b”, ” _ “,”a”).\n\n\nParameters\n{content} (table) Table with the following fields:\n\n&lt;lines&gt; (table) - array with content lines.\n&lt;submode&gt; (string) - region submode. One of 'v', 'V', '&lt;C-v&gt;' (escaped).\n\n{opts} (table|nil) Options. Possible fields:\n\n&lt;compare_fun&gt; (function) - compare function compatible with table.sort(). Default: direct compare with &lt;.\n&lt;split_patterns&gt; (table) - array of split Lua patterns to be used for charwise submode. Order is important. Default: { '%s*,%s*', '%s*;%s*', '%s+', '' }."
  },
  {
    "objectID": "mini.nvim/doc/mini-splitjoin.html",
    "href": "mini.nvim/doc/mini-splitjoin.html",
    "title": "mini.splitjoin documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.splitjoin Split and join arguments\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nMappings and Lua functions that modify arguments (regions inside brackets between allowed separators) under cursor.\nSupported actions:\n\nToggle - split if arguments are on single line, join otherwise. Main supported function of the module. See MiniSplitjoin.toggle().\nSplit - make every argument separator be on end of separate line. See MiniSplitjoin.split().\nJoin - make all arguments be on single line. See MiniSplitjoin.join().\n\nMappings are dot-repeatable in Normal mode and work in Visual mode.\nCustomizable argument detection (see MiniSplitjoin.config.detect):\n\nWhich brackets can contain arguments.\nWhich strings can separate arguments.\nWhich regions are excluded when looking for separators (like inside nested brackets or quotes).\n\nCustomizable pre and post hooks for both split and join. See split and join in MiniSplitjoin.config. There are several built-in ones in MiniSplitjoin.gen_hook.\nWorks inside comments by using modified notion of indent. See MiniSplitjoin.get_indent_part().\nProvides low-level Lua functions for split and join at positions. See MiniSplitjoin.split_at() and MiniSplitjoin.join_at().\n\nNotes:\n\nSearch for arguments is done using Lua patterns (regex-like approach). Certain amount of false positives is to be expected.\nThis module is mostly designed around MiniSplitjoin.toggle(). If target split positions are on different lines, join first and then split.\nActions can be done on Visual mode selection, which mostly present as a safety route in case of incorrect detection of initial region. It uses MiniSplitjoin.get_visual_region() which treats selection as full brackets (include brackets in selection).\n\n\nSetup\nThis module needs a setup with require('mini.splitjoin').setup({}) (replace {} with your config table). It will create global Lua table MiniSplitjoin which you can use for scripting or manually (with :lua MiniSplitjoin.*).\nSee MiniSplitjoin.config for available config settings.\nYou can override runtime config settings (like action hooks) locally to buffer inside vim.b.minisplitjoin_config which should have same structure as MiniSplitjoin.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nFooSoft/vim-argwrap:\n\nMostly has the same design as this module.\nDoesn’t work inside comments, while this module does.\nHas more built-in ways to control split and join, while this module intentionally provides only handful.\n\nAndrewRadev/splitjoin.vim:\n\nMore oriented towards language-depended transformations, while this module intntionally deals with more generic text-related functionality.\n\nWansmer/treesj:\n\nOperates based on tree-sitter nodes. This is more accurate in some edge cases, but requires tree-sitter parser.\nDoesn’t work inside comments or strings.\n\n\n\n\nDisabling\nTo disable, set g:minisplitjoin_disable (globally) or b:minisplitjoin_disable (for a buffer) to v:true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nGlossary\n\nPOSITION\nTable with fields &lt;line&gt; and &lt;col&gt; containing line and column numbers respectively. Both are 1-indexed. Example: { line = 2, col = 1 }.\n\n\nREGION\nTable representing region in a buffer. Fields: &lt;from&gt; and &lt;to&gt; for inclusive start and end positions. Example:\n{ from = { line = 1, col = 1 }, to = { line = 2, col = 1 } }\n\n\n\n\nsetup()\n\nMiniSplitjoin.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniSplitjoin.config.\n\n\nUsage\nrequire('mini.splitjoin').setup() -- use default config\n-- OR\nrequire('mini.splitjoin').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniSplitjoin.config\n\n\nDefaults\nMiniSplitjoin.config = {\n  -- Module mappings. Use `''` (empty string) to disable one.\n  -- Created for both Normal and Visual modes.\n  mappings = {\n    toggle = 'gS',\n    split = '',\n    join = '',\n  },\n\n  -- Detection options: where split/join should be done\n  detect = {\n    -- Array of Lua patterns to detect region with arguments.\n    -- Default: { '%b()', '%b[]', '%b{}' }\n    brackets = nil,\n\n    -- String Lua pattern defining argument separator\n    separator = ',',\n\n    -- Array of Lua patterns for sub-regions to exclude separators from.\n    -- Enables correct detection in presence of nested brackets and quotes.\n    -- Default: { '%b()', '%b[]', '%b{}', '%b\"\"', \"%b''\" }\n    exclude_regions = nil,\n  },\n\n  -- Split options\n  split = {\n    hooks_pre = {},\n    hooks_post = {},\n  },\n\n  -- Join options\n  join = {\n    hooks_pre = {},\n    hooks_post = {},\n  },\n}\n\n\nDetection\nMiniSplitjoin.config.detect\nThe table at config.detect controls how arguments are detected using Lua patterns. General idea is to convert whole buffer into a single line, perform string search, and convert results back into 2d positions.\nExample configuration:\nrequire('mini.splitjoin').setup({\n  detect = {\n    -- Detect only inside balanced parenthesis\n    brackets = { '%b()' },\n\n    -- Allow both `,` and `;` to separate arguments\n    separator = '[,;]',\n\n    -- Make any separator define an argument\n    exclude_regions = {},\n  },\n})\n\nOuter brackets\ndetect.brackets is an array of Lua patterns used to find enclosing region. It is done by traversing whole buffer to find the smallest region matching any supplied pattern.\nDefault: nil, inferred as { '%b()', '%b[]', '%b{}' }. So an argument can be inside a balanced (), [], or {}.\nExample: brackets = { '%b()' } will search for arguments only inside balanced ().\n\n\nSeparator\ndetect.separator is a single Lua pattern defining which strings should be treated as argument separators.\nEmpty string in detect.separator will result in only surrounding brackets used as separators.\nOnly end of pattern match will be used as split/join positions.\nDefault: ','. So an argument can be separated only with comma.\nExample: separator = { '[,;]' } will treat both , and ; as separators.\n\n\nExcluded regions\ndetect.exclude_regions is an array of Lua patterns for sub-regions from which to exclude separators. Enables correct detection in case of nested brackets and quotes.\nDefault: nil; inferred as { '%b()', '%b[]', '%b{}', '%b\"\"', \"%b''\" }. So a separator can not be inside a balanced (), [], {} (representing nested argument regions) or \"\", '' (representing strings).\nExample: exclude_regions = {} will not exclude any regions. So in case of f(a, { b, c }) it will detect both commas as argument separators.\n\n\n\nHooks\nsplit.hooks_pre, split.hooks_post, join.hooks_pre, and join.hooks_post are arrays of hook functions. If empty (default) no hook is applied.\nHooks should take and return array of positions. See MiniSplitjoin-glossary.\nThey can be used to tweak actions:\n\nPre-hooks are called before action. Each is applied on the output of previous one. Input of first hook are detected split/join positions. Output of last one is actually used to perform split/join.\nPost-hooks are called after action. Each is applied on the output of previous one. Input of first hook are split/join positions from actual action plus its region’s right end as last position (for easier hook code). Output of last one is used as action return value.\n\nFor more specific details see MiniSplitjoin.split() and MiniSplitjoin.join().\nSee MiniSplitjoin.gen_hook for generating common hooks with examples.\n\n\n\n\ntoggle()\n\nMiniSplitjoin.toggle({opts})\n\nToggle arguments\nOverview:\n\nDetect region at input position: either by using supplied opts.region or by finding smallest bracketed region surrounding position. See MiniSplitjoin.config.detect for more details.\nIf region spans single line, use MiniSplitjoin.split() with found region. Otherwise use MiniSplitjoin.join().\n\n\nParameters\n{opts} (table|nil) Options. Has structure from MiniSplitjoin.config inheriting its default values.\nFollowing extra optional fields are allowed:\n\n&lt;position&gt; (table) - position at which to find smallest bracket region. See MiniSplitjoin-glossary for the structure. Default: cursor position.\n&lt;region&gt; (table) - region at which to perform action. Assumes inclusive both start at left bracket and end at right bracket. See MiniSplitjoin-glossary for the structure. Default: nil to automatically detect region.\n\n\n\nReturn\n(any) Output of chosen split() or join() action.\n\n\n\n\nsplit()\n\nMiniSplitjoin.split({opts})\n\nSplit arguments\nOverview:\n\nDetect region: either by using supplied opts.region or by finding smallest bracketed region surrounding input position (cursor position by default). See MiniSplitjoin.config.detect for more details.\nFind separator positions using separator and exclude_regions from opts. Both brackets are treated as separators. See MiniSplitjoin.config.detect for more details. Note: stop if no separator positions are found.\nModify separator positions to represent split positions. Last split position (which is inferred from right bracket) is moved one column to left so that right bracket would move on new line.\nApply all hooks from opts.split.hooks_pre. Each is applied on the output of previous one. Input of first hook is split positions from previous step. Output of last one is used as split positions in next step.\nSplit and update split positions with MiniSplitjoin.split_at().\nApply all hooks from opts.split.hooks_post. Each is applied on the output of previous one. Input of first hook is split positions from previous step plus region’s right end (for easier hook code). Output of last one is used as function return value.\n\nNote:\n\nBy design, it doesn’t detect if argument should be split, so application on arguments spanning multiple lines can lead to undesirable result.\n\n\nParameters\n{opts} (table|nil) Options. Has structure from MiniSplitjoin.config inheriting its default values.\nFollowing extra optional fields are allowed:\n\n&lt;position&gt; (table) - position at which to find smallest bracket region. See MiniSplitjoin-glossary for the structure. Default: cursor position.\n&lt;region&gt; (table) - region at which to perform action. Assumes inclusive both start at left bracket and end at right bracket. See MiniSplitjoin-glossary for the structure. Default: nil to automatically detect region.\n\n\n\nReturn\n(any) Output of last opts.split.hooks_post or nil if no split positions found. Default: return value of MiniSplitjoin.split_at() application.\n\n\n\n\njoin()\n\nMiniSplitjoin.join({opts})\n\nJoin arguments\nOverview:\n\nDetect region: either by using supplied opts.region or by finding smallest bracketed region surrounding input position (cursor position by default). See MiniSplitjoin.config.detect for more details.\nCompute join positions to be line ends of all but last region lines. Note: stop if no join positions are found.\nApply all hooks from opts.join.hooks_pre. Each is applied on the output of previous one. Input of first hook is join positions from previous step. Output of last one is used as join positions in next step.\nJoin and update join positions with MiniSplitjoin.join_at().\nApply all hooks from opts.join.hooks_post. Each is applied on the output of previous one. Input of first hook is join positions from previous step plus region’s right end for easier hook code. Output of last one is used as function return value.\n\n\nParameters\n{opts} (table|nil) Options. Has structure from MiniSplitjoin.config inheriting its default values.\nFollowing extra optional fields are allowed:\n\n&lt;position&gt; (table) - position at which to find smallest bracket region. See MiniSplitjoin-glossary for the structure. Default: cursor position.\n&lt;region&gt; (table) - region at which to perform action. Assumes inclusive both start at left bracket and end at right bracket. See MiniSplitjoin-glossary for the structure. Default: nil to automatically detect region.\n\n\n\nReturn\n(any) Output of last opts.split.hooks_post or nil of no join positions found. Default: return value of MiniSplitjoin.join_at() application.\n\n\n\n\ngen_hook\n\nMiniSplitjoin.gen_hook\n\nGenerate common hooks\nThis is a table with function elements. Call to actually get hook.\nAll generated post-hooks return updated versions of their input reflecting changes done inside hook.\nExample for lua filetype (place it in ‘lua.lua’ filetype plugin, ftplugin):\nlocal gen_hook = MiniSplitjoin.gen_hook\nlocal curly = { brackets = { '%b{}' } }\n\n-- Add trailing comma when splitting inside curly brackets\nlocal add_comma_curly = gen_hook.add_trailing_separator(curly)\n\n-- Delete trailing comma when joining inside curly brackets\nlocal del_comma_curly = gen_hook.del_trailing_separator(curly)\n\n-- Pad curly brackets with single space after join\nlocal pad_curly = gen_hook.pad_brackets(curly)\n\n-- Create buffer-local config\nvim.b.minisplitjoin_config = {\n  split = { hooks_post = { add_comma_curly } },\n  join  = { hooks_post = { del_comma_curly, pad_curly } },\n}\n\n\n\ngen_hook.pad_brackets()\n\nMiniSplitjoin.gen_hook.pad_brackets({opts})\n\nGenerate hook to pad brackets\nThis is a join post-hook. Use in join.hooks_post of MiniSplitjoin.config.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;pad&gt; (string) - pad to add after first and before last join positions. Default: ' ' (single space).\n&lt;brackets&gt; (table) - array of bracket patterns indicating on which brackets action should be made. Has same structure as brackets in MiniSplitjoin.config.detect. Default: MiniSplitjoin.config.detect.brackets.\n\n\n\nReturn\n(function) A hook which adds inner pad to first and last join positions and returns updated input join positions.\n\n\n\n\ngen_hook.add_trailing_separator()\n\nMiniSplitjoin.gen_hook.add_trailing_separator({opts})\n\nGenerate hook to add trailing separator\nThis is a split post-hook. Use in split.hooks_post of MiniSplitjoin.config.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;sep&gt; (string) - separator to add before last split position. Default: ','.\n&lt;brackets&gt; (table) - array of bracket patterns indicating on which brackets action should be made. Has same structure as brackets in MiniSplitjoin.config.detect. Default: MiniSplitjoin.config.detect.brackets.\n\n\n\nReturn\n(function) A hook which adds separator before last split position and returns updated input split positions.\n\n\n\n\ngen_hook.del_trailing_separator()\n\nMiniSplitjoin.gen_hook.del_trailing_separator({opts})\n\nGenerate hook to delete trailing separator\nThis is a join post-hook. Use in join.hooks_post of MiniSplitjoin.config.\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;sep&gt; (string) - separator to remove before last join position. Default: ','.\n&lt;brackets&gt; (table) - array of bracket patterns indicating on which brackets action should be made. Has same structure as brackets in MiniSplitjoin.config.detect. Default: MiniSplitjoin.config.detect.brackets.\n\n\n\nReturn\n(function) A hook which adds separator before last split position and returns updated input split positions.\n\n\n\n\nsplit_at()\n\nMiniSplitjoin.split_at({positions})\n\nSplit at positions\nOverview:\n\nFor each position move all characters after it to next line and make it have same indent as current one (see MiniSplitjoin.get_indent_part()). Also remove trailing whitespace at position line.\nIncrease indent of inner lines by a single pad: tab in case of ‘noexpandtab’ or shiftwidth() number of spaces otherwise.\n\nNotes:\n\nCursor is adjusted to follow text updates.\nUse output of this function to keep track of input positions.\n\n\nParameters\n{positions} (table) Array of positions at which to perform split. See MiniSplitjoin-glossary for their structure. Note: they don’t have to be ordered, but first and last ones will be used to infer lines for which indent will be increased.\n\n\nReturn\n(table) Array of new positions to where input positions were moved.\n\n\n\n\njoin_at()\n\nMiniSplitjoin.join_at({positions})\n\nJoin at positions\nOverview:\n\nFor each position join its line with the next line. Joining is done by replacing trailing whitespace of the line and indent of its next line (see MiniSplitjoin.get_indent_part()) with a pad string (single space except empty string for first and last positions). To adjust this, use hooks (for example, see MiniSplitjoin.gen_hook.pad_brackets()).\n\nNotes:\n\nCursor is adjusted to follow text updates.\nUse output of this function to keep track of input positions.\n\n\nParameters\n{positions} (table) Array of positions at which to perform join. See MiniSplitjoin-glossary for their structure. Note: they don’t have to be ordered, but first and last ones will have different pad string.\n\n\nReturn\n(table) Array of new positions to where input positions were moved.\n\n\n\n\nget_visual_region()\n\nMiniSplitjoin.get_visual_region()\n\nGet previous visual region\nGet previous visual selection using ’&lt; and ’&gt; marks in the format of region (see MiniSplitjoin-glossary). Used in Visual mode mappings.\nNote:\n\nBoth marks are included in region.\nIn linewise mode start is at column 1 and end is at line’s last character.\n\n\nReturn\n(table) A region. See MiniSplitjoin-glossary for exact structure.\n\n\n\n\nget_indent_part()\n\nMiniSplitjoin.get_indent_part({line}, {respect_comments})\n\nGet string’s indent part\n\nParameters\n{line} (string) String for which to compute indent.\n{respect_comments} (boolean|nil) Whether to respect comments as indent part. Default: true.\n\n\nReturn\n(string) Part of input representing line’s indent. Can be empty string. Use string.len() to compute indent in bytes.\n\n\n\n\noperator()\n\nMiniSplitjoin.operator({task})\n\nOperator for Normal mode mappings\nMain function to be used in expression mappings. No need to use it directly, everything is setup in MiniSplitjoin.setup().\n\nParameters\n{task} (string) Name of task."
  },
  {
    "objectID": "mini.nvim/doc/mini-icons.html",
    "href": "mini.nvim/doc/mini-icons.html",
    "title": "mini.icons documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.icons Icon provider\nMIT License Copyright (c) 2024 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nProvide icons with their highlighting via a single MiniIcons.get() for various categories: filetype, file/directory path, extension, operating system, LSP kind values. Icons and category defaults can be overridden.\nConfigurable styles: “glyph” (icon glyphs) or “ascii” (non-glyph fallback).\nFixed set of highlight groups (linked to built-in groups by default) for better blend with color scheme.\nCaching for maximum performance.\nIntegration with vim.filetype.add() and vim.filetype.match().\nMocking methods of ‘nvim-tree/nvim-web-devicons’ for better integrations with plugins outside ‘mini.nvim’. See MiniIcons.mock_nvim_web_devicons().\nTweaking built-in maps for “LSP kind” to include icons. In particular, this makes mini.completion use icons in LSP step. See MiniIcons.tweak_lsp_kind().\n\nNotes:\n\nIt is not a goal to become a collection of icons for as much use cases as possible. There are specific criteria for icon data to be included as built-in in each category (see MiniIcons.get()). The main supported category is “filetype”.\n\nRecommendations for plugin authors using ‘mini.icons’ as a dependency:\n\nCheck if _G.MiniIcons table is present (which means that user explicitly enabled ‘mini.icons’) and provide icons only if it is.\nUse MiniIcons.get() function to get icon string and more data about it.\nFor file icons prefer using full path instead of relative or only basename. It makes a difference if path matches pattern that uses parent directories. The MiniIcons.config has an example of that.\n\n\nDependencies\nSuggested dependencies:\n\nTerminal emulator that supports showing special utf8 glyphs, possibly with “overflow” view (displaying is done not in one but two visual cells). Most modern feature-rich terminal emulators support this out of the box: WezTerm, Kitty, Alacritty, iTerm2, Ghostty. Not having “overflow” feature only results into smaller icons. Not having support for special utf8 glyphs will result into seemingly random symbols (or question mark squares) instead of icon glyphs.\nFont that supports Nerd Fonts (https://www.nerdfonts.com) icons from version 3.0.0+ (in particular nf-md-* class). This should be configured on terminal emulator level either by using font patched with Nerd Fonts icons or using NerdFontsSymbolsOnly font as a fallback for glyphs that are not supported in main font.\n\nIf using terminal emulator and/or font with icon support is impossible, use config.style = 'ascii'. It will use a (less visually appealing) set of non-glyph icons.\n\n\nSetup\nThis module needs a setup with require('mini.icons').setup({}) (replace {} with your config table). It will create global Lua table MiniIcons which you can use for scripting or manually (with :lua MiniIcons.*).\nSee MiniIcons.config for config structure and default values.\n\n\nComparisons\n\nnvim-tree/nvim-web-devicons (for users):\n\nSets individual colors to each icon with separate specific highlight groups, while this modules uses fixed set of highlight groups. This makes it easier to customize in bulk and actually blend with any color scheme.\nThis module prefers richer set of nf-md-* (from “Material design” set) Nerd Fonts icons while ‘nvim-web-devicons’ mostly prefers nf-dev-* (from “devicons” set).\nSupported categories are slightly different (with much overlap).\nBoth support customization of any icon. Only this module supports customization of default ones per supported category.\nUsing this module can occasionally result in small delays when used synchronously for many times to get icons for not typical files (like in mini.files). This is due to using vim.filetype.match() fallback and is present only during first call, as value is cached for later uses.\nThis module supports different icon styles (like “ascii” for when using glyphs is not possible), while ‘nvim-web-devicons’ does not.\nThis module provides MiniIcons.mock_nvim_web_devicons() function which when called imitates installed ‘nvim-web-devicons’ plugin to support other plugins which do not provide ‘mini.icons’ yet.\n\nnvim-tree/nvim-web-devicons (for plugin developers):\n\nBoth have main “get icon” type of function:\n\nBoth return tuple of icon and highlight group strings.\nThis module always returns icon data possibly falling back to user’s configured default, while ‘nvim-web-devicons’ is able to return nil. This module’s approach is more aligned with the most common use case of always showing an icon instead or near some data. There is a third returned value indicating if output is a result of a fallback (see MiniIcons.get()).\nThis module uses vim.filetype.match() as a fallback for “file” and “extension” categories, while ‘nvim-web-devicons’ completely relies on the manually maintained tables of supported filenames and extensions. Using fallback results in a wider support and deeper integration with Neovim’s filetype detection at the cost of occasional slower first call. The difference is reduced as much as is reasonable by preferring faster file extension resolution over filetype matching.\nThis module caches all its return values resulting in really fast next same argument calls, while ‘nvim-web-devicons’ doesn’t do that.\nThis module works with full file/directory paths as input.\n\nDifferent sets of supported categories (see MiniIcons.config):\n\nBoth support “file”, “extension”, “filetype”, “operating system”. Albeit in different volumes: ‘nvim-web-devicons’ covers more cases for “operating system”, while this module has better eventual coverage for other cases.\nThis module supports “directory” and “lsp” categories.\n‘nvim-web-devicons’ covers “desktop environment” and “window management” categories. This modules does not include them due to relatively low demand.\n\n\nonsails/lspkind.nvim:\n\nProvides icons only for CompletionItemKind, while this module also has icons for SymbolKind and other non-LSP categories.\nProvides dedicated formatting function for ‘hrsh7th/nvim-cmp’ while this module intentionally does not (adding icons should be straightforward to manually implement while anything else is out of scope).\n\n\n\n\nHighlight groups\nOnly the following set of highlight groups is used as icon highlight. It is recommended that they all only define colored foreground:\n\nMiniIconsAzure - azure.\nMiniIconsBlue - blue.\nMiniIconsCyan - cyan.\nMiniIconsGreen - green.\nMiniIconsGrey - grey.\nMiniIconsOrange - orange.\nMiniIconsPurple - purple.\nMiniIconsRed - red.\nMiniIconsYellow - yellow.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\n\n\nsetup()\n\nMiniIcons.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniIcons.config.\n\n\nUsage\nrequire('mini.icons').setup() -- use default config\n-- OR\nrequire('mini.icons').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniIcons.config\n\n\nDefaults\nMiniIcons.config = {\n  -- Icon style: 'glyph' or 'ascii'\n  style = 'glyph',\n\n  -- Customize per category. See `:h MiniIcons.config` for details.\n  default   = {},\n  directory = {},\n  extension = {},\n  file      = {},\n  filetype  = {},\n  lsp       = {},\n  os        = {},\n\n  -- Control which extensions will be considered during \"file\" resolution\n  use_file_extension = function(ext, file) return true end,\n}\n\n\nStyle\nconfig.style is a string defining which icon style to use. It can be:\n\n'glyph' (default) - use glyph icons (like 󰈔 and 󰉋 ).\n'ascii' - use fallback ASCII-compatible icons. Those are computed as an upper first character of the icon’s resolved name inside its category. Examples:\nMiniIcons.get('file', 'Makefile') -- Has `'M'` as icon\nMiniIcons.get('extension', 'lua') -- Has `'L'` as icon\nMiniIcons.get('file', 'file.lua') -- Has `'L'` as icon; it is resolved to\n                                  -- come from 'lua' 'extension' category\nMiniIcons.get('file', 'myfile')   -- Has `'F'` as icon; it is resolved to\n                                  -- come from 'file' 'default' category\n\n\n\nCustomization per category\nThe following entries can be used to customize icons for supported categories:\n\nconfig.default\nconfig.directory\nconfig.extension\nconfig.file\nconfig.filetype\nconfig.lsp\nconfig.os\n\nCustomization should be done by supplying a table with &lt;glyph&gt; (icon glyph) and/or &lt;hl&gt; (name of highlight group) string fields as a value for an icon name entry. Example:\nrequire('mini.icons').setup({\n  default = {\n    -- Override default glyph for \"file\" category (reuse highlight group)\n    file = { glyph = '󰈤' },\n  },\n  extension = {\n    -- Override highlight group (not necessary from 'mini.icons')\n    lua = { hl = 'Special' },\n\n    -- Add icons for custom extension. This will also be used in\n    -- 'file' category for input like 'file.my.ext'.\n    ['my.ext'] = { glyph = '󰻲', hl = 'MiniIconsRed' },\n  },\n})\nNotes:\n\nThese customizations only take effect inside MiniIcons.setup() call. | Changing interactively via :lua MiniIcons.config.xxx = { | } does not work | for performance reasons.\nUse lower case names for categories which are matched ignoring case. See MiniIcons.get() for more details.\n\n\n\nUsing extension during file resolution\nconfig.use_file_extension is a function which can be used to control which extensions will be considered as a source of icon data during “file” category resolution (see MiniIcons.get() for more details). Default: function which always returns true (i.e. consider all extensions).\nWill be called once for the biggest suffix after dot found in the file name. The arguments will be ext (found extension; lowercase) and file (input for which icon is computed; as is). Should explicitly return true if ext is to be considered (i.e. call MiniIcons.get('extension', ext) and use its output if it is not default). Otherwise extension won’t be even considered.\nThe primary use case for this setting is to ensure that some extensions are ignored in order for resolution to reach vim.filetype.match() stage. This is needed if there is a set up filetype detection for files with recognizable extension and conflicting icons (which you want to use). Note: if problematic filetype detection involves only known in advance file names, prefer using config.file customization.\nExample:\n-- Built-in filetype detection recognizes files like \"queries/.*%.scm\"\n-- as \"query\" filetype. However, without special setup, 'mini.icons' will\n-- use \"scm\" extension to resolve as Scheme file. Here is a setup to ignore\n-- \"scm\" extension and completely rely on `vim.filetype.match()` fallback.\nrequire('mini.icons').setup({\n  -- Check last letters explicitly to account for dots in file name\n  use_file_extension = function(ext) return ext:sub(-3) ~= 'scm' end\n})\n\n-- Another common choices for extensions to ignore: \"yml\", \"json\", \"txt\".\n\n\n\n\nget()\n\nMiniIcons.get({category}, {name})\n\nGet icon data\nUsage example:\n-- Results into `icon='󰢱'`, `hl='MiniIconsAzure'`, `is_default=false`\nlocal icon, hl, is_default = MiniIcons.get('file', 'file.lua')\nNotes:\n\nAlways returns some data, even if icon name is not explicitly supported within target category. Category “default” is used as a fallback. Use third output value to check if this particular case is a result of a fallback.\nGlyphs are explicitly preferred (when reasonable) from a richer set of nf-md-* class (“Material design” set) of Nerd Fonts icons.\nOutput is cached after the first call to increase performance of next calls with same arguments. To reset cache, call MiniIcons.setup().\nTo increase first call performance for “extension” and “file” categories, add frequently used values in MiniIcons.config. They will be preferred over executing vim.filetype.match().\nMatching icon name for “file” and “directory” categories is done exactly and respecting case. Others are done ignoring case.\n\n\nParameters\n{category} (string) Category name. Supported categories:\n\n'default' - icon data used as fallback for any category. Icon names:\n\n&lt;Input&gt;: any supported category name.\n&lt;Built-in&gt;: only supported category names.\n\nExamples:\nMiniIcons.get('default', 'file')\n'directory' - icon data for directory path. Icon names:\n\n&lt;Input&gt;: any string, but only basename is used. Works with not present paths (no check is done).\n&lt;Built-in&gt;: popular directory names not tied to language/software (with few notable exceptions like Neovim, Git, etc.).\n\nExamples:\n-- All of these will result in the same output\nMiniIcons.get('directory', '.config')\nMiniIcons.get('directory', '~/.config')\nMiniIcons.get('directory', '/home/user/.config')\n\n-- Results in different output\nMiniIcons.get('directory', '.Config')\n'extension' - icon data for extension. Icon names:\n\n&lt;Input&gt;: any string (without extra dot prefix).\n&lt;Built-in&gt;: popular extensions without associated filetype plus a set for which filetype detection gives not good enough result.\n\nIcon data is attempted to be resolved in the following order:\n\nList of user configured and built-in extensions (for better results). Run :=MiniIcons.list('extension') to see them. Used also if present as suffix after the dot (widest one preferred).\nFiletype as a result of vim.filetype.match() with placeholder file name. Uses icon data from “filetype” category.\n\nExamples:\n-- All of these will result in the same output\nMiniIcons.get('extension', 'lua')\nMiniIcons.get('extension', 'LUA')\nMiniIcons.get('extension', 'my.lua')\n'file' - icon data for file path. Icon names:\n\n&lt;Input&gt;: any string. Works with not present paths (no check is done).\n&lt;Built-in&gt;: popular file names not tied to language/software (with few notable exceptions like Neovim, Git, etc.) plus a set which has recognizable extension but has special detectable filetype.\n\nIcon data is attempted to be resolved in the following order:\n\nList of user configured and built-in file names (matched to basename of the input exactly). Run :=MiniIcons.list('file') to see them.\nBasename extension:\n\nMatched directly as get('extension', ext), where ext is the widest suffix after the dot.\nConsidered only if config.use_file_extension returned true.\nOnly recognizable extensions (i.e. not default fallback) are used.\n\nFiletype as a result of vim.filetype.match() with full input (not basename) as filename. Uses icon data from “filetype” category.\n\nExamples:\n-- All of these will result in the same output\nMiniIcons.get('file', 'init.lua')\nMiniIcons.get('file', '~/.config/nvim/init.lua')\nMiniIcons.get('file', '/home/user/.config/nvim/init.lua')\n\n-- Results in different output\nMiniIcons.get('file', 'Init.lua')\nMiniIcons.get('file', 'init.LUA')\n\n-- Respects full path input in `vim.filetype.match()`\nMiniIcons.get('file', '.git/info/attributes')\n'filetype' - icon data for ‘filetype’ values. Icon names:\n\n&lt;Input&gt;: any string.\n&lt;Built-in&gt;: any filetype that is reasonably used in Neovim ecosystem. This category is intended as a widest net for supporting use cases. Users are encouraged to have a specific filetype detection set up.\n\nExamples:\nMiniIcons.get('filetype', 'lua')\nMiniIcons.get('filetype', 'help')\nMiniIcons.get('filetype', 'minifiles')\n'lsp' - icon data for various “LSP kind” values. Icon names:\n\n&lt;Input&gt;: any string.\n&lt;Built-in&gt;: only namesspace entries from LSP specification that are can be displayed to user. Like CompletionItemKind, SymbolKind, etc.\n\nExamples:\nMiniIcons.get('lsp', 'array')\nMiniIcons.get('lsp', 'keyword')\n'os' - icon data for popular operating systems. Icon names:\n\n&lt;Input&gt;: any string.\n&lt;Built-in&gt;: only operating systems which have nf-md-* class icon.\n\nExamples:\nMiniIcons.get('os', 'linux')\nMiniIcons.get('os', 'arch')\nMiniIcons.get('os', 'macos')\n\n{name} (string) Icon name within category. Use MiniIcons.list() to get icon names which are explicitly supported for specific category.\n\n\nReturn\n(...) Tuple of icon string, highlight group name it is suggested to be highlighted with, and boolean indicating whether this icon was returned as a result of fallback to default. Example:\n-- Results into `icon='󰢱'`, `hl='MiniIconsAzure'`, `is_default=false`\nlocal icon, hl, is_default = MiniIcons.get('file', 'file.lua')\n\n-- Results into `icon='󰈔'`, `hl='MiniIconsGrey'`, `is_default=true`\nlocal icon, hl, is_default = MiniIcons.get('file', 'not-supported')\n\n\n\n\nlist()\n\nMiniIcons.list({category})\n\nList explicitly supported icon names\n\nParameters\n{category} (string) Category name supported by MiniIcons.get().\n\n\nReturn\n(table) Array of icon names which are explicitly supported for category. Note, that 'file' and 'extension' categories support much more icon names via their fallback to using vim.filetype.match() with 'filetype' category.\n\n\n\n\nmock_nvim_web_devicons()\n\nMiniIcons.mock_nvim_web_devicons()\n\nMock ‘nvim-web-devicons’ module\nCall this function to mock exported functions of ‘nvim-tree/nvim-web-devicons’ plugin. It will mock all its functions which return icon data by using MiniIcons.get() equivalent.\nThis function is useful if any plugins relevant to you depend solely on ‘nvim-web-devicons’ and have not yet added an integration with ‘mini.icons’.\nFull example of usage:\nrequire('mini.icons').setup()\nMiniIcons.mock_nvim_web_devicons()\nWorks without installed ‘nvim-web-devicons’ and even with it installed (needs to be called after ‘nvim-web-devicons’ is set up).\n\n\n\ntweak_lsp_kind()\n\nMiniIcons.tweak_lsp_kind({mode})\n\nTweak built-in LSP kind names\nUpdate in place appropriate maps in vim.lsp.protocol (CompletionItemKind and SymbolKind) by using icon strings from “lsp” category. Only “numeric id to kind name” part is updated (to preserve data from original map).\nUpdating is done in one of these modes:\n\nAppend: add icon after text.\nPrepend: add icon before text (default).\nReplace: use icon instead of text.\n\nNotes:\n\nMakes mini.completion show icons, as it uses built-in protocol map.\nResults in loading whole vim.lsp module, so might add significant amount of time on startup. Call it lazily. For example, with MiniDeps.later():\nrequire('mini.icons').setup()\nMiniDeps.later(MiniIcons.tweak_lsp_kind)\n\n\nParameters\n{mode} (string|nil) One of “prepend” (default), “append”, “replace”."
  },
  {
    "objectID": "mini.nvim/doc/mini-indentscope.html",
    "href": "mini.nvim/doc/mini-indentscope.html",
    "title": "mini.indentscope documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.indentscope Visualize and work with indent scope\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nIndent scope (or just “scope”) is a maximum set of consecutive lines which contains certain reference line (cursor line by default) and every member has indent not less than certain reference indent (“indent at cursor” by default: minimum between cursor column and indent of cursor line).\nFeatures:\n\nVisualize scope with animated vertical line. It is very fast and done automatically in a non-blocking way (other operations can be performed, like moving cursor). You can customize debounce delay and animation rule.\nCustomization of scope computation options can be done on global level (in MiniIndentscope.config), for a certain buffer (using vim.b.miniindentscope_config buffer variable), or within a call (using opts variable in MiniIndentscope.get_scope()).\nCustomizable notion of a border: which adjacent lines with strictly lower indent are recognized as such. This is useful for a certain filetypes (for example, Python or plain text).\nCustomizable way of line to be considered “border first”. This is useful if you want to place cursor on function header and get scope of its body.\nThere are textobjects and motions to operate on scope. Support count and dot-repeat (in operator pending mode).\n\n\nSetup\nThis module needs a setup with require('mini.indentscope').setup({}) (replace {} with your config table). It will create global Lua table MiniIndentscope which you can use for scripting or manually (with :lua MiniIndentscope.*).\nSee MiniIndentscope.config for available config settings.\nYou can override runtime config settings locally to buffer inside vim.b.miniindentscope_config which should have same structure as MiniIndentscope.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nlukas-reineke/indent-blankline.nvim:\n\nIts main functionality is about showing static guides of indent levels.\nImplementation of ‘mini.indentscope’ is similar to ‘indent-blankline.nvim’ (using extmarks on first column to be shown even on blank lines). They can be used simultaneously, but it will lead to one of the visualizations being on top (hiding) of another.\n\n\n\n\nHighlight groups\n\nMiniIndentscopeSymbol - symbol showing on every line of scope if its indent is multiple of ‘shiftwidth’.\nMiniIndentscopeSymbolOff - symbol showing on every line of scope if its indent is not multiple of ‘shiftwidth’. Default: links to MiniIndentscopeSymbol.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable autodrawing, set vim.g.miniindentscope_disable (globally) or vim.b.miniindentscope_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nDrawing\nDraw of scope indicator is done as iterative animation. It has the following design:\n\nDraw indicator on origin line (where cursor is at) immediately. Indicator is visualized as MiniIndentscope.config.symbol placed to the right of scope’s border indent. This creates a line from top to bottom scope edges.\nDraw upward and downward concurrently per one line. Progression by one line in both direction is considered to be one step of animation.\nBefore each step wait certain amount of time, which is decided by “animation function”. It takes next and total step numbers (both are one or bigger) and returns number of milliseconds to wait before drawing next step. Comparing to a more popular “easing functions” in animation (input: duration since animation start; output: percent of animation done), it is a discrete inverse version of its derivative. Such interface proved to be more appropriate for kind of task at hand.\n\n\nSpecial cases\n\nWhen scope to be drawn intersects (same indent, ranges overlap) currently visible one (at process or finished drawing), drawing is done immediately without animation. With most common example being typing new text, this feels more natural.\nScope for the whole buffer is not drawn as it is isually redundant. Technically, it can be thought as drawn at column 0 (because border indent is -1) which is not visible.\n\n\n\n\n\nsetup()\n\nMiniIndentscope.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniIndentscope.config.\n\n\nUsage\nrequire('mini.indentscope').setup() -- use default config\n-- OR\nrequire('mini.indentscope').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniIndentscope.config\n\n\nDefaults\nMiniIndentscope.config = {\n  -- Draw options\n  draw = {\n    -- Delay (in ms) between event and start of drawing scope indicator\n    delay = 100,\n\n    -- Animation rule for scope's first drawing. A function which, given\n    -- next and total step numbers, returns wait time (in ms). See\n    -- |MiniIndentscope.gen_animation| for builtin options. To disable\n    -- animation, use `require('mini.indentscope').gen_animation.none()`.\n    animation = --&lt;function: implements constant 20ms between steps&gt;,\n\n    -- Whether to auto draw scope: return `true` to draw, `false` otherwise.\n    -- Default draws only fully computed scope (see `options.n_lines`).\n    predicate = function(scope) return not scope.body.is_incomplete end,\n\n    -- Symbol priority. Increase to display on top of more symbols.\n    priority = 2,\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Textobjects\n    object_scope = 'ii',\n    object_scope_with_border = 'ai',\n\n    -- Motions (jump to respective border line; if not present - body line)\n    goto_top = '[i',\n    goto_bottom = ']i',\n  },\n\n  -- Options which control scope computation\n  options = {\n    -- Type of scope's border: which line(s) with smaller indent to\n    -- categorize as border. Can be one of: 'both', 'top', 'bottom', 'none'.\n    border = 'both',\n\n    -- Whether to use cursor column when computing reference indent.\n    -- Useful to see incremental scopes with horizontal cursor movements.\n    indent_at_cursor = true,\n\n    -- Maximum number of lines above or below within which scope is computed\n    n_lines = 10000,\n\n    -- Whether to first check input line to be a border of adjacent scope.\n    -- Use it if you want to place cursor on function header to get scope of\n    -- its body.\n    try_as_border = false,\n  },\n\n  -- Which character to use for drawing scope indicator\n  symbol = '╎',\n}\n\n\nOptions\n\nBorder\nField border controls which line(s) with smaller indent to categorize as border. This matters for textobjects and motions. It also controls how empty lines are treated: they are included in scope only if followed by a border. Another way of looking at it is that indent of blank line is computed based on value of border option. Here is an illustration of how border works in presence of empty lines:\n                           |both|bottom|top|none|\n1|function foo()           | 0  |  0   | 0 | 0  |\n2|                         | 4  |  0   | 4 | 0  |\n3|    print('Hello world') | 4  |  4   | 4 | 4  |\n4|                         | 4  |  4   | 2 | 2  |\n5|  end                    | 2  |  2   | 2 | 2  |\nNumbers inside a table are indent values of a line computed with certain value of border. So, for example, a scope with reference line 3 and right-most column has body range depending on value of border option:\n\nborder is “both”: range is 2-4, border is 1 and 5 with indent 2.\nborder is “top”: range is 2-3, border is 1 with indent 0.\nborder is “bottom”: range is 3-4, border is 5 with indent 0.\nborder is “none”: range is 3-3, border is empty with indent nil.\n\n\n\nIndent at cursor\nField indent_at_cursor controls if cursor position should affect computation of scope. If true, reference indent is a minimum of reference line’s indent and cursor column. In main example, here how scope’s body range differs depending on cursor column and indent_at_cursor value (assuming cursor is on line 3 and it is whole buffer):\nColumn\\Option true|false\n   1 and 2    2-5 | 2-4\n 3 and more   2-4 | 2-4\n\n\nNumber of lines\nField n_lines defines MiniIndentscope.get_scope() behavior for how many lines above/below to check before iteration is stopped. Scope that reached computation limit has &lt;is_incomplete&gt; field set to true. It will also not be auto drawn with default config.draw.predicate.\nLower values will result in better overall performance in exchange for more frequent incomplete scope computation. Set to math.huge for no restriction.\n\n\nTry as border\nField try_as_border controls how to act when input line can be recognized as a border of some neighbor indent scope. In main example, when input line is 1 and can be recognized as border for inner scope, value try_as_border=true means that inner scope will be returned. Similar, for input line 5 inner scope will be returned if it is recognized as border.\n\n\n\n\n\nget_scope()\n\nMiniIndentscope.get_scope({line}, {col}, {opts})\n\nCompute indent scope\nIndent scope (or just “scope”) is a maximum set of consecutive lines which contains certain reference line (cursor line by default) and every member has indent not less than certain reference indent (“indent at column” by default). Here “indent at column” means minimum between input column value and indent of reference line. When using cursor column, this allows for a useful interactive view of nested indent scopes by making horizontal movements within line.\nOptions controlling actual computation is taken from these places in order:\n\nArgument opts. Use it to ensure independence from other sources.\nBuffer local variable vim.b.miniindentscope_config (options field). Useful to define local behavior (for example, for a certain filetype).\nGlobal options from MiniIndentscope.config.\n\n\nAlgorithm overview\n\nCompute reference “indent at column”. Reference line is an input line which might be modified to one of its neighbors if try_as_border option is true: if it can be viewed as border of some neighbor scope, it will.\nProcess upwards and downwards from reference line searching for line with indent strictly less than reference one. This is like casting rays up and down from reference line and reference indent until meeting “a wall” (character to the right of indent or buffer edge). Latest line before meeting a wall is a respective end of scope body. It always exists because reference line is a such one. Casting ray is forced to stop if it goes over opts.n_lines lines.\nBased on top and bottom lines with strictly lower indent, construct scopes’s border. The way it is computed is decided based on border option (see MiniIndentscope.config for more information).\nCompute border indent as maximum indent of border lines (or reference indent minus one in case of no border). This is used during drawing visual indicator.\n\n\n\nIndent computation\nFor every line indent is intended to be computed unambiguously:\n\nFor “normal” lines indent is an output of indent().\nIndent is -1 for imaginary lines 0 and past last line.\nFor blank and empty lines indent is computed based on previous (prevnonblank()) and next (nextnonblank()) non-blank lines. The way it is computed is decided based on border in order to not include blank lines at edge of scope’s body if there is no border there. See MiniIndentscope.config for a details example.\n\n\n\nParameters\n{line} (number|nil) Input line number (starts from 1). Can be modified to a neighbor if try_as_border is true. Default: cursor line.\n{col} (number|nil) Column number (starts from 1). Default: if indent_at_cursor option is true - cursor column from curswant of getcurpos() (allows for more natural behavior on empty lines); math.huge otherwise in order to not incorporate cursor in computation.\n{opts} (table|nil) Options to override global or buffer local ones (see MiniIndentscope.config).\n\n\nReturn\n(table) Table with scope information:\n\n&lt;body&gt; - table with &lt;top&gt; (top line of scope, inclusive), &lt;bottom&gt; (bottom line of scope, inclusive), and &lt;indent&gt; (minimum indent within scope) keys. Line numbers start at 1. Can also have &lt;is_incomplete&gt; key set to true if computation was stopped due to opts.n_lines restriction.\n&lt;border&gt; - table with &lt;top&gt; (line of top border, might be nil), &lt;bottom&gt; (line of bottom border, might be nil), and &lt;indent&gt; (indent of border) keys. Line numbers start at 1.\n&lt;buf_id&gt; - identifier of current buffer.\n&lt;reference&gt; - table with &lt;line&gt; (reference line), &lt;column&gt; (reference column), and &lt;indent&gt; (“indent at column”) keys.\n\n\n\n\n\ndraw()\n\nMiniIndentscope.draw({scope}, {opts})\n\nDraw scope manually\nScope is visualized as a vertical line within scope’s body range at column equal to border indent plus one (or body indent if border is absent). Numbering starts from one.\n\nParameters\n{scope} (table|nil) Scope. Default: output of MiniIndentscope.get_scope() with default arguments.\n{opts} (table|nil) Options. Currently supported:\n\n&lt;animation_fun&gt; - animation function for drawing. See MiniIndentscope-drawing and MiniIndentscope.gen_animation.\n&lt;priority&gt; - priority number for visualization. See priority option for nvim_buf_set_extmark().\n\n\n\n\n\nundraw()\n\nMiniIndentscope.undraw()\n\nUndraw currently visible scope manually\n\n\n\ngen_animation\n\nMiniIndentscope.gen_animation\n\nGenerate builtin animation function\nThis is a builtin source to generate animation function for usage in MiniIndentscope.config.draw.animation. Most of them are variations of common easing functions, which provide certain type of progression for revealing scope visual indicator.\nEach field corresponds to one family of progression which can be customized further by supplying appropriate arguments.\nExamples:\n\nDon’t use animation: MiniIndentscope.gen_animation.none()\nUse quadratic “out” easing with total duration of 1000 ms:\ngen_animation.quadratic({ easing = 'out', duration = 1000, unit = 'total' })\n\n\nSee also\nMiniIndentscope-drawing for more information about how drawing is done.\n\n\n\n\ngen_animation.none()\n\nMiniIndentscope.gen_animation.none()\n\nGenerate no animation\nShow indicator immediately. Same as animation function always returning 0.\n\n\n\ngen_animation.linear()\n\nMiniIndentscope.gen_animation.linear({opts})\n\nGenerate linear progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Animation function (see MiniIndentscope-drawing).\n\n\n\n\ngen_animation.quadratic()\n\nMiniIndentscope.gen_animation.quadratic({opts})\n\nGenerate quadratic progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Animation function (see MiniIndentscope-drawing).\n\n\n\n\ngen_animation.cubic()\n\nMiniIndentscope.gen_animation.cubic({opts})\n\nGenerate cubic progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Animation function (see MiniIndentscope-drawing).\n\n\n\n\ngen_animation.quartic()\n\nMiniIndentscope.gen_animation.quartic({opts})\n\nGenerate quartic progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Animation function (see MiniIndentscope-drawing).\n\n\n\n\ngen_animation.exponential()\n\nMiniIndentscope.gen_animation.exponential({opts})\n\nGenerate exponential progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Animation function (see MiniIndentscope-drawing).\n\n\n\n\nmove_cursor()\n\nMiniIndentscope.move_cursor({side}, {use_border}, {scope})\n\nMove cursor within scope\nCursor is placed on a first non-blank character of target line.\n\nParameters\n{side} (string) One of “top” or “bottom”.\n{use_border} (boolean|nil) Whether to move to border or within scope’s body. If particular border is absent, body is used.\n{scope} (table|nil) Scope to use. Default: output of MiniIndentscope.get_scope().\n\n\n\n\noperator()\n\nMiniIndentscope.operator({side}, {add_to_jumplist})\n\nFunction for motion mappings\nMove to a certain side of border. Respects count and dot-repeat (in operator-pending mode). Doesn’t move cursor for scope that is not shown (drawing indent less that zero).\n\nParameters\n{side} (string) One of “top” or “bottom”.\n{add_to_jumplist} (boolean|nil) Whether to add movement to jump list. It is true only for Normal mode mappings.\n\n\n\n\ntextobject()\n\nMiniIndentscope.textobject({use_border})\n\nFunction for textobject mappings\nRespects count and dot-repeat (in operator-pending mode). Doesn’t work for scope that is not shown (drawing indent less that zero).\n\nParameters\n{use_border} (boolean|nil) Whether to include border in textobject. When true and try_as_border option is false, allows “chaining” calls for incremental selection."
  },
  {
    "objectID": "mini.nvim/doc/mini-cmdline.html",
    "href": "mini.nvim/doc/mini-cmdline.html",
    "title": "mini.cmdline documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.cmdline Command line tweaks\nMIT License Copyright (c) 2025 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nAutocomplete with customizable delay. Enhances cmdline-completion and manual ‘wildchar’ pressing experience. Requires Neovim&gt;=0.11, though Neovim&gt;=0.12 is recommended.\nAutocorrect words as-you-type. Only words that must come from a fixed set of candidates (like commands and options) are autocorrected by default.\nAutopeek command range as-you-type. Shows a floating window with range lines along with customizable context lines.\n\nWhat it doesn’t do:\n\nCustomization of command line UI. Use vim._extui (on Neovim&gt;=0.12).\nCustomization of autocompletion candidates. They are computed via cmdline-completion.\n\n\nSetup\nThis module needs a setup with require('mini.cmdline').setup({}) (replace {} with your config table). It will create global Lua table MiniCmdline which you can use for scripting or manually (with :lua MiniCmdline.*).\nSee MiniCmdline.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minicmdline_config which should have same structure as MiniCmdline.config. See mini.nvim-buffer-local-config for more details.\n\n\nSuggested option values\nSome options are set automatically (if not set before MiniCmdline.setup()):\n\n‘wildmode’ is set to “noselect,full” for less intrusive autocompletion. Requires Neovim&gt;=0.11 and enabled config.autocomplete.\n‘wildoptions’ is set to “pum,fuzzy” to enable fuzzy matching.\n\n\n\nComparisons\n\nfolke/noice.nvim:\n\nMostly focuses on visual aspects of the Command line. This modules is aimed to improve its workflow without changing UI.\n\nnacro90/numb.nvim:\n\nDesigned to preview only a single line range defined by numbers. This module handles any form of :range and :range-offset for both one and two line ranges.\nShows target line directly in the normal window. This module uses a dedicated floating window.\n\nBuilt-in cmdline-autocompletion (on Neovim&gt;=0.12):\n\nThis module on Neovim&gt;=0.12 uses that as its base for autocompletion. Ont top of that it also provides customizable delay and predicate.\n\nBuilt-in vim._extui (on Neovim&gt;=0.12):\n\nMostly focuses on visual aspects of the Command line. This modules is aimed to improve its workflow without changing UI.\n\n\n\n\nHighlight groups\n\nMiniCmdlinePeekBorder - border of autopeek window.\nMiniCmdlinePeekLineNr - line numbers in autopeek window.\nMiniCmdlinePeekNormal - basic foreground/background of autopeek window.\nMiniCmdlinePeekSep - statuscolumn separator in autopeek window.\nMiniCmdlinePeekSign - signs in autopeek window.\nMiniCmdlinePeekTitle - title of autopeek window.\n\n\n\nDisabling\nTo disable acting in mappings, set vim.g.minicmdline_disable (globally) or vim.b.minicmdline_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniCmdline.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniCmdline.config.\n\n\nUsage\nrequire('mini.cmdline').setup() -- use default config\n-- OR\nrequire('mini.cmdline').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniCmdline.config\n\n\nDefaults\nMiniCmdline.config = {\n  -- Autocompletion: show `:h 'wildmenu'` as you type\n  autocomplete = {\n    enable = true,\n\n    -- Delay (in ms) after which to trigger completion\n    -- Neovim&gt;=0.12 is recommended for positive values\n    delay = 0,\n\n    -- Custom rule of when to trigger completion\n    predicate = nil,\n\n    -- Whether to map arrow keys for more consistent wildmenu behavior\n    map_arrows = true,\n  },\n\n  -- Autocorrection: adjust non-existing words (commands, options, etc.)\n  autocorrect = {\n    enable = true,\n\n    -- Custom autocorrection rule\n    func = nil,\n  },\n\n  -- Autopeek: show command's target range in a floating window\n  autopeek = {\n    enable = true,\n\n    -- Number of lines to show above and below range lines\n    n_context = 1,\n\n    -- Custom rule of when to show peek window\n    predicate = nil,\n\n    -- Window options\n    window = {\n      -- Floating window config\n      config = {},\n\n      -- Function to render statuscolumn\n      statuscolumn = nil,\n    },\n  },\n}\n\n\nGeneral\n\nEach feature is configured via separate table.\nUse enable = false to disable a feature.\n\n\n\nAutocomplete\nconfig.autocomplete is used to configure autocompletion: automatic show of ‘wildmenu’.\nautocomplete.delay defines a (debounce style) delay after which ‘wildchar’ is triggered to show wildmenu. Default: 0. Note: Neovim&gt;=0.12 is recommended for positive values if you want to reduce flicker (thanks to wildtrigger()).\nautocomplete.predicate defines a condition of whether to trigger completion at the current command line state. Takes a table with input data and should return true to show completion and false otherwise. Will be called before the possible delay at current command line state. Default: MiniCmdline.default_autocomplete_predicate().\nInput data fields:\n\n&lt;line&gt; (string) - current command line text. See getcmdline().\n&lt;pos&gt; (number) - current command line column. See getcmdpos().\n&lt;line_prev&gt; (string) - command line text before the latest change.\n&lt;pos_prev&gt; (number) - command line column before the latest cursor move.\n\nExample of blocking completion based on completion type (as some may be slow):\nlocal block_compltype = { shellcmd = true }\nrequire('mini.cmdline').setup({\n  autocomplete = {\n    predicate = function()\n      return not block_compltype[vim.fn.getcmdcompltype()]\n    end,\n  },\n})\nSimilar approach can be used to enable completion only for normal Ex commands. Use return vim.fn.getcmdtype() == ':' as a predicate output.\n\n\nAutocorrect\nconfig.autocorrect is used to configure autocorrection: automatic adjustment of bad words as you type them. This works only when appending text at the end of the command line. Editing already typed words does not trigger autocorrect (allows correcting the autocorrection).\nWhen to autocorrect is computed automatically based on getcmdcomplpat() after every key press: if it doesn’t add the character to completion pattern, then the pattern before the key press is attempted to be corrected. There is also an autocorrection attempt for the last word just before executing the command.\nNotes:\n\nThis is intended mostly for fixing typos and not as a shortcut for fuzzy matching. Performing the latter automatically is too intrusive. Explicitly use fuzzy completion for that (set up by default).\nDefault autocorrection is done only for words that must come from a fixed set of candidates (like commands and options) by choosing the one with the lowest string distance. See MiniCmdline.default_autocorrect_func() for details.\nWord that matches some Command-line abbreviation is not autocorrected.\nIf current command expects only a single argument (like :colorscheme), then autocorrection will happen only just before executing the command.\n\nautocorrect.func is a function that can be used to customize autocorrection. Takes a table with input data and should return a string with the correct word or nil for no autocorrection. Default: MiniCmdline.default_autocorrect_func().\nInput data fields:\n\n&lt;word&gt; (string) - word to be autocorrected. Never empty string.\n&lt;type&gt; (string) - word type. Output of getcmdcompltype().\n\n\n\nAutopeek\nconfig.autopeek is used to configure automatic peeking: show command’s target range in a floating window. The window will appear above command line and show current buffer with the focus on left and right (if present and differs from left) range lines.\nautopeek.n_context defines how many lines to show above and below the target. The range itself is visualized by default with the statuscolumn signs. Default: 1.\nautopeek.predicate defines a condition of whether to show peek window at the current command line state. Takes a table with input data and should return true to peek and false otherwise. Will be called only if it is possible to parse range from the current command line text and it is for buffer lines (no command or :command-addr is lines) Default: MiniCmdline.default_autopeek_predicate().\nInput data fields:\n\n&lt;left&gt; (number) - left range edge. Not necessarily smallest.\n&lt;right&gt; (number) - right range edge. Same as left for a single line range.\n&lt;cmd&gt; (string) - full command name. Can be empty string if no valid command is (yet) entered.\n\nautopeek.window defines behavior of a peek window. autopeek.window.config is a table defining floating window characteristics or a callable returning such table. It should have the same structure as in nvim_open_win().\nautopeek.window.statuscolumn is a special function that can be used to customize ‘statuscolumn’ value for the peek window. Takes a table with input data and should return a string to display for line v:lnum. Default: MiniCmdline.default_autopeek_statuscolumn(). Input data fields are the same as for autopeek.predicate.\nExample of showing &lt; and &gt; signs on range lines:\nfunction(data)\n  local n, l, r = vim.v.lnum, data.left, data.right\n  local s = n == l and (n == r and '* ' or '&lt; ') or n == r and '&gt; ' or ''\n  -- Needs explicit highlighting via `:h 'statusline'` syntax\n  return '%#MiniCmdlinePeekSign#' .. s\nend\nNotes:\n\nPeek window directly shows current buffer, which means that all its extmarks, virtual text, virtual lines, etc. are also shown.\nNon-zero context might work unreliably if there are virtual lines.\nPeeking intentionally hides Visual selection if Command-line mode is entered directly from it. Peeking '&lt;,'&gt; range already visualizes the selection. To disable autopeek for this case, add the following code BEFORE executing require('mini.cmdline').setup():\nlocal disable = vim.schedule_wrap(function()\n  local is_from_visual = vim.startswith(vim.fn.getcmdline(), \"'&lt;,'&gt;\")\n  MiniCmdline.config.autopeek.enable = not is_from_visual\nend)\nlocal reenable = function() MiniCmdline.config.autopeek.enable = true end\n\nvim.api.nvim_create_autocmd('CmdlineEnter', { callback = disable })\nvim.api.nvim_create_autocmd('CmdlineLeave', { callback = reenable })\n\n\n\n\n\ndefault_autocomplete_predicate()\n\nMiniCmdline.default_autocomplete_predicate({data}, {opts})\n\nDefault autocompletion predicate\n\nParameters\n{data} (table) Input autocompletion data. As described in MiniCmdline.config.\n{opts} (table|nil) Options. Reserved for future use.\n\n\nReturn\n(boolean) If command line does not (yet) contain a letter - false, otherwise - true. This makes autopeek easier to use for a numerical range.\n\n\n\n\ndefault_autocorrect_func()\n\nMiniCmdline.default_autocorrect_func({data}, {opts})\n\nDefault autocorrection function\n\nReturn input word if opts.strict_type=true and input type is not proper.\nGet candidates via opts.get_candidates(). Default: mostly via getcompletion() with empty pattern and input type. Exceptions are help and option types: both list all available candidates in their own ways.\nChoose the candidate with the lowest Damerau–Levenshtein distance (smallest number of deletion/insertion/substitution/transposition needed to transform one word into another; slightly prefers transposition). Notes:\n\nType 'command' also chooses from all valid candidate abbreviations.\nComparison is done both respecting and ignoring case.\n\n\n\nParameters\n{data} (table) Input autocorrection data. As described in MiniCmdline.config.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;strict_type&gt; (boolean) - whether to restrict output only for types which must have words from a fixed set of candidates (like command or option names). Note: does not include help type since :help already has “sophisticated algorithm” to handle typos. Default: true.\n&lt;get_candidates&gt; (function) - source of candidates. Will be called with data as argument and should return array of string candidates to choose from. Default: for most types - getcompletion() with empty pattern and input type; for help and option type - all available help tags and option names (long and short) respectively.\n\n\n\nReturn\n(string) Autocorrected word.\n\n\n\n\ndefault_autopeek_predicate()\n\nMiniCmdline.default_autopeek_predicate({data}, {opts})\n\nDefault autopeek predicate\n\nParameters\n{data} (table) Input autopeek data. As described in MiniCmdline.config.\n{opts} (table|nil) Options. Reserved for future use.\n\n\nReturn\n(boolean) If command defines :command-preview - false, otherwise - true. This makes autopeek easier to use for commands like :substitute, especially if ‘inccommand’ is set to split.\n\n\n\n\ndefault_autopeek_statuscolumn()\n\nMiniCmdline.default_autopeek_statuscolumn({data}, {opts})\n\nDefault autopeek statuscolumn\n\nShow signs next to lines depending on their relation to peeked range. Highlighted with MiniCmdlinePeekSign group.\nShow line numbers for left and right parts of the range. Highlighted with MiniCmdlinePeekLineNr group.\nSeparate statuscolumn and buffer text with dedicated separator character. Highlighted with MiniCmdlinePeekSep group.\n\nNotes:\n\nIntended to only be used as a part of ‘statuscolumn’ function, as it uses v:lnum and v:virtnum to compute the output.\n\nExample of adjusting a mid sign:\nlocal peek_stc_opts = { signs = { mid = '+' } }\nlocal peek_stc = function(data)\n  return MiniCmdline.default_autopeek_statuscolumn(data, peek_stc_opts)\nend\nrequire('mini.cmdline').setup({\n  autopeek = { window = { statuscolumn = peek_stc } },\n})\n\nParameters\n{data} (table) Input peek data. As described in MiniCmdline.config.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;signs&gt; (table) - signs to show. Possible fields:\n\n&lt;same&gt; (string) - on range if left=right. Default: '🭬'.\n&lt;left&gt; (string) - on left line. Default: '┌'.\n&lt;mid&gt; (string) - inside range. Default: '┊'.\n&lt;right&gt; (string) - on right line. Default: '└'.\n&lt;out&gt; (string) - outside of range. Default: '' (no sign).\n&lt;virt&gt; (string) - virtual line. Default: '•'.\n&lt;wrap&gt; (string) - wrapped line. Default: '↳'.\n\n&lt;sep&gt; (string) - string to put at the end to separate statuscolumn and buffer text. Default: '│'\n\nNote: Any sign and separator should have every % escaped as %% (due to its special meaning in ‘statuscolumn’)."
  },
  {
    "objectID": "mini.nvim/doc/mini-diff.html",
    "href": "mini.nvim/doc/mini-diff.html",
    "title": "mini.diff documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.diff Work with diff hunks\nMIT License Copyright (c) 2024 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nVisualize difference between buffer text and its configurable reference interactively (updates as you type). This is done per line showing whether it is inside added, changed, or deleted part of difference (called hunk). Visualization can be with customizable colored signs or line numbers.\nSpecial toggleable overlay view with more hunk details inside text area. See MiniDiff.toggle_overlay().\nCompletely configurable per buffer source(s) of reference text used to keep it up to date and define interactions with it. Can be array of sources which are attempted to attach in order. See MiniDiff-source-specification. By default uses Git source. See MiniDiff.gen_source.git().\nConfigurable mappings to manage diff hunks:\n\nApply and reset hunks inside region (selected visually or with a dot-repeatable operator).\n“Hunk range under cursor” textobject to be used as operator target.\nNavigate to first/previous/next/last hunk. See MiniDiff.goto_hunk().\n\n\nWhat it doesn’t do:\n\nProvide functionality to work directly with Git outside of visualizing and staging (applying) hunks with (default) Git source. In particular, unstaging hunks is not supported. See MiniDiff.gen_source.git().\n\nSources with more details:\n\nMiniDiff-overview\nMiniDiff-source-specification\nMiniDiff-hunk-specification\nMiniDiff-diff-summary\n\n\nSetup\nThis module needs a setup with require('mini.diff').setup({}) (replace {} with your config table). It will create global Lua table MiniDiff which you can use for scripting or manually (with :lua MiniDiff.*).\nSee MiniDiff.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minidiff_config which should have same structure as MiniDiff.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nlewis6991/gitsigns.nvim:\n\nMain inspiration for this module, so there are many similarities.\nCan display only Git hunks, while this module has extensible design.\nProvides more functionality to work with Git outside of hunks. This module does not (by design).\n\n\n\n\nHighlight groups\n\nMiniDiffSignAdd - “add” hunk lines visualization.\nMiniDiffSignChange - “change” hunk lines visualization.\nMiniDiffSignDelete - “delete” hunk lines visualization.\nMiniDiffOverAdd - added buffer text shown in overlay.\nMiniDiffOverChange - changed reference text shown in overlay.\nMiniDiffOverChangeBuf - changed buffer text shown in overlay.\nMiniDiffOverContext - context of a change shown in reference overlay.\nMiniDiffOverContextBuf - context of a change shown in buffer overlay.\nMiniDiffOverDelete - deleted reference text shown in overlay.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo temporarily disable features without relying on MiniDiff.disable(), set vim.g.minidiff_disable (globally) or vim.b.minidiff_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nOverview\n\nDiffs and hunks\nThe “diff” (short for “difference”) is a result of computing how two text strings differ from one another. This is done on per line basis, i.e. the goal is to compute sequences of lines common to both files, interspersed with groups of differing lines (called “hunks”).\nAlthough computing diff is a general concept (used on its own, in Git, etc.), this module computes difference between current text in a buffer and some reference text which is kept up to date specifically for that buffer. For example, default reference text is computed as file content in Git index. This can be customized in config.source (see MiniDiff-source-specification).\n\n\nHunk specification\nMiniDiff-hunk-specification\nHunk describes two sets (one from buffer text, one - from reference) of consecutive lines which are different. In this module hunk is stored as a table with the following fields:\n\n&lt;buf_start&gt; (number) - start of hunk buffer lines. First line is 1. Can be 0 if first reference lines are deleted.\n&lt;buf_count&gt; (number) - number of consecutive buffer lines. Can be 0 in case reference lines are deleted.\n&lt;ref_start&gt; (number) - start of hunk reference lines. First line is 1. Can be 0 if lines are added before first reference line.\n&lt;ref_count&gt; (number) - number of consecutive reference lines. Can be 0 in case buffer lines are added.\n&lt;type&gt; (string) - hunk type. Can be one of:\n\n“add” - lines are present in buffer but absent in reference.\n“change” - lines are present in both buffer and reference.\n“delete” - lines are absent in buffer but present in reference.\n\n\n\n\nLife cycle\n\nWhen entering proper (not already enabled, valid, showing text) buffer, it is attempted to be enabled for diff processing.\nDuring enabling, attempt attaching the source. This should set up how reference text is kept up to date.\nOn every text change, diff computation is scheduled in debounced fashion after customizable delay (200 ms by default).\nAfter the diff is computed, do the following:\n\nUpdate visualization based on configurable style: either by placing colored text in sign column or coloring line numbers. Colors for both styles are defined per hunk type in corresponding MiniDiffSign* highlight group (see mini.diff) and sign text for “sign” style can be configured in view.signs of MiniDiff.config.\nUpdate overlay view (if it is enabled).\nUpdate vim.b.minidiff_summary and vim.b.minidiff_summary_string buffer-local variables. These can be used, for example, in statusline.\nMiniDiff-update-event Trigger MiniDiffUpdated User event. See MiniDiff-diff-summary for example of how to use it.\n\n\nNotes:\n\nUse :edit to reset (disable and re-enable) current buffer.\nTo work with BOM bytes, set ‘bomb’ and have ucs-bom in ‘fileencodings’.\n\n\n\nOverlay\nAlong with basic visualization, there is a special view called “overlay”. Although it is meant for temporary overview of diff details and can be manually toggled via MiniDiff.toggle_overlay(), text can be changed with overlay reacting accordingly.\nIt shows more diff details inside text area:\n\nAdded buffer lines are highlighted with MiniDiffOverAdd highlight group.\nDeleted reference lines are shown as virtual lines and highlighted with MiniDiffOverDelete highlight group.\n“Change” hunks with equal number of buffer/reference lines show “word diff”. This is usually the case when options.linematch is enabled (as by default). Reference line is shown next to its buffer counterpart. Changed parts are highlighted with MiniDiffOverChange and MiniDiffOverChangeBuf in reference and buffer lines. The rest of lines have MiniDiffOverContext and MiniDiffOverContextBuf highlighting.\nChange with unequal number of buffer/reference lines is shown with reference part as virtual lines highlighted with MiniDiffOverChange group. Corresponding buffer lines are treated as context for the change and are highlighted with MiniDiffOverContextBuf group.\n\nNotes:\n\nWord diff has non-zero context width. This means if changed characters are close enough, whole range between them is also colored. This usually reduces visual noise.\nVirtual lines above line 1 (like deleted or changed lines) need manual scroll to become visible (with CTRL-Y).\n\n\n\nMappings\nThis module provides mappings for common actions with diffs, like:\n\nApply and reset hunks.\n“Hunk range under cursor” textobject.\nGo to first/previous/next/last hunk range.\n\nExamples:\n\nvip followed by gh / gH applies/resets hunks inside current paragraph. Same can be achieved in operator form ghip / gHip, which has the advantage of being dot-repeatable (see single-repeat).\ngh_ / gH_ applies/resets current line (even if it is not a full hunk).\nghgh / gHgh applies/resets hunk range under cursor.\ndgh deletes hunk range under cursor.\n[H / [h / ]h / ]H navigate cursor to the first / previous / next / last hunk range of the current buffer.\n\nMappings for some functionality are assumed to be done manually. See MiniDiff.operator().\n\n\nBuffer-local variables\nMiniDiff-diff-summary\nEach enabled buffer has the following buffer-local variables which can be used in custom statusline to show an overview of hunks in current buffer:\n\nvim.b.minidiff_summary is a table with the following fields:\n\nsource_name - name of the active source. This is the only present field if buffer’s reference text is not (yet) set.\nn_ranges - number of hunk ranges (sequences of contiguous hunks).\nadd - number of added lines.\nchange - number of changed lines.\ndelete - number of deleted lines.\n\nvim.b.minidiff_summary_string is a string representation of summary with a fixed format. Empty string if there is no reference text (yet). It is expected to be used as is. To achieve different formatting, use vim.b.minidiff_summary to construct one. The best way to do this is by overriding vim.b.minidiff_summary_string inside MiniDiff-update-event:\nlocal format_summary = function(data)\n  local summary = vim.b[data.buf].minidiff_summary\n  local t = {}\n  if summary.add &gt; 0 then table.insert(t, '+' .. summary.add) end\n  if summary.change &gt; 0 then table.insert(t, '~' .. summary.change) end\n  if summary.delete &gt; 0 then table.insert(t, '-' .. summary.delete) end\n  vim.b[data.buf].minidiff_summary_string = table.concat(t, ' ')\nend\nlocal au_opts = { pattern = 'MiniDiffUpdated', callback = format_summary }\nvim.api.nvim_create_autocmd('User', au_opts)\n\n\n\n\n\nsetup()\n\nMiniDiff.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniDiff.config.\n\n\nUsage\nrequire('mini.diff').setup() -- use default config\n-- OR\nrequire('mini.diff').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniDiff.config\n\n\nDefaults\nMiniDiff.config = {\n  -- Options for how hunks are visualized\n  view = {\n    -- Visualization style. Possible values are 'sign' and 'number'.\n    -- Default: 'number' if line numbers are enabled, 'sign' otherwise.\n    style = vim.go.number and 'number' or 'sign',\n\n    -- Signs used for hunks with 'sign' view\n    signs = { add = '▒', change = '▒', delete = '▒' },\n\n    -- Priority of used visualization extmarks\n    priority = 199,\n  },\n\n  -- Source(s) for how reference text is computed/updated/etc\n  -- Uses content from Git index by default\n  source = nil,\n\n  -- Delays (in ms) defining asynchronous processes\n  delay = {\n    -- How much to wait before update following every text change\n    text_change = 200,\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Apply hunks inside a visual/operator region\n    apply = 'gh',\n\n    -- Reset hunks inside a visual/operator region\n    reset = 'gH',\n\n    -- Hunk range textobject to be used inside operator\n    -- Works also in Visual mode if mapping differs from apply and reset\n    textobject = 'gh',\n\n    -- Go to hunk range in corresponding direction\n    goto_first = '[H',\n    goto_prev = '[h',\n    goto_next = ']h',\n    goto_last = ']H',\n  },\n\n  -- Various options\n  options = {\n    -- Diff algorithm. See `:h vim.diff()`.\n    algorithm = 'histogram',\n\n    -- Whether to use \"indent heuristic\". See `:h vim.diff()`.\n    indent_heuristic = true,\n\n    -- The amount of second-stage diff to align lines\n    linematch = 60,\n\n    -- Whether to wrap around edges during hunk navigation\n    wrap_goto = false,\n  },\n}\n\n\nView\nconfig.view contains settings for how diff hunks are visualized. Example of using custom signs:\nrequire('mini.diff').setup({\n  view = {\n    style = 'sign',\n    signs = { add = '+', change = '~', delete = '-' },\n  },\n})\nview.style is a string defining visualization style. Can be one of “sign” (as a colored sign in a sign-column) or “number” (colored line number). Default: “number” if ‘number’ option is enabled, “sign” otherwise. Note: with “sign” style it is better to have ‘signcolumn’ always shown.\nview.signs is a table with one or two character strings used as signs for corresponding (“add”, “change”, “delete”) hunks. Default: all hunks use “▒” character resulting in a contiguous colored lines.\nview.priority is a number with priority used for visualization and overlay extmarks. Default: 199 which is one less than user in vim.hl.priorities (on Neovim&lt;0.11 see vim.hl.priorities) to have higher priority than automated extmarks but not as in user enabled ones.\n\n\nSource\nMiniDiff-source-specification\nconfig.source is a table with single source or array of them. Single source defines how reference text is managed in a particular buffer. Sources in array are attempted to attach in order; call MiniDiff.disable() if none attaches.\nA single source table can have the following fields:\n\n&lt;attach&gt; (function) - callable which defines how and when reference text is updated inside a particular buffer. It is used inside MiniDiff.enable() with a buffer identifier as a single argument.\nShould execute logic which results into calling MiniDiff.set_ref_text() when reference text for buffer needs to be updated. Like inside callback for an autocommand or file watcher (see watch-file).\nFor example, default Git source watches when “.git/index” file is changed and computes reference text as the one from Git index for current file.\nCan return false to indicate that attach has failed. If attach fail can not be inferred immediately (for example, due to asynchronous execution), should explicitly call MiniDiff.fail_attach() with appropriate arguments. This is important to properly process array of sources.\nNo default value, should be always supplied.\n&lt;name&gt; (string|nil) - source name. String \"unknown\" is used if not supplied.\n&lt;detach&gt; (function|nil) - callable with cleanup action to be done when buffer is disabled. It is called inside MiniDiff.disable() with a buffer identifier as a single argument.\nIf not supplied, nothing is done during detaching.\n&lt;apply_hunks&gt; (function|nil) - callable which defines how hunks are applied. It is called with buffer identifier as first argument and array of hunks (see MiniDiff-hunk-specification) as second. It should eventually update reference text: either by explicitly calling MiniDiff.set_ref_text() or performing action triggering its call.\nFor example, default Git source computes patch based on the hunks and applies it inside file’s git repo.\nIf not supplied, applying hunks throws an error.\n\nDefault: a single MiniDiff.gen_source.git().\n\n\nDelay\nconfig.delay contains settings for delays in asynchronous processes.\ndelay.text_change is a number (in ms) defining how long to wait after latest text change (in debounced fashion) before updating diff and visualization. Default: 200.\n\n\nMappings\nconfig.mappings contains keys which are mapped during MiniDiff.setup().\nmappings.apply keys can be used to apply hunks inside visual/operator region. What exactly “apply hunks” means depends on the source and its apply_hunks(). For example, in default Git source it means stage hunks.\nmappings.reset keys can be used to reset hunks inside visual/operator region. Reset means replacing buffer text in region with corresponding reference text.\nmappings.textobject keys define “hunk range under cursor” textobject which can be used in Operator-pending mode as target for operator (like d, y, apply/reset hunks, etc.). It is also set up in Visual mode if keys do not conflict with mappings.apply and mappings.reset. “Hunk range” is used in a sense that contiguous (back-to-back) hunks are considered as parts of a same hunk range.\nmappings.goto_first / mappings.goto_prev / mappings.goto_next / mappings.goto_last keys can be used to navigate to first / previous / next / last hunk range in the current buffer.\n\n\nOptions\nconfig.options contains various customization options.\noptions.algorithm is a string defining which diff algorithm to use. Default: “histogram”. See vim.diff() for possible values.\noptions.indent_heuristic is a boolean defining whether to use indent heuristic for a (possibly) more naturally aligned hunks. Default: true.\noptions.linematch is a number defining hunk size for which a second stage diff is executed for a better aligned and more granular hunks. Default: 60. See vim.diff() and ‘diffopt’ for more details.\noptions.wrap_goto is a boolean indicating whether to wrap around edges during hunk navigation (with MiniDiff.goto_hunk() or goto_* mappings). Like if cursor is after the last hunk, going “next” will put cursor on the first hunk. Default: false.\n\n\n\n\nenable()\n\nMiniDiff.enable({buf_id})\n\nEnable diff processing in buffer\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\ndisable()\n\nMiniDiff.disable({buf_id})\n\nDisable diff processing in buffer\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\ntoggle()\n\nMiniDiff.toggle({buf_id})\n\nToggle diff processing in buffer\nEnable if disabled, disable if enabled.\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\ntoggle_overlay()\n\nMiniDiff.toggle_overlay({buf_id})\n\nToggle overlay view in buffer\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\n\n\nexport()\n\nMiniDiff.export({format}, {opts})\n\nExport hunks\nGet and convert hunks from current/all buffers. Example of using it:\n-- Set quickfix list from all available hunks\nvim.fn.setqflist(MiniDiff.export('qf'))\n\nParameters\n{format} (string) Output format. Currently only 'qf' value is supported.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;scope&gt; (string) - scope defining from which buffers to use hunks. One of “all” (all enabled buffers) or “current”.\n\n\n\nReturn\n(table) Result of export. Depends on the format:\n\nIf “qf”, an array compatible with setqflist() and setloclist().\n\n\n\n\n\nget_buf_data()\n\nMiniDiff.get_buf_data({buf_id})\n\nGet buffer data\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n\n\nReturn\n(table|nil) Table with buffer diff data or nil if buffer is not enabled. Table has the following fields:\n\n&lt;config&gt; (table) - config used for this particular buffer.\n&lt;hunks&gt; (table) - array of hunks. See MiniDiff-hunk-specification.\n&lt;overlay&gt; (boolean) - whether an overlay view is shown.\n&lt;ref_text&gt; (string|nil) - current value of reference text. Lines are separated with newline character ('\\n'). Can be nil indicating that reference text was not yet set (for example, if source did not yet react).\n&lt;summary&gt; (table) - overall diff summary. See MiniDiff-diff-summary.\n\n\n\n\n\nset_ref_text()\n\nMiniDiff.set_ref_text({buf_id}, {text})\n\nSet reference text for the buffer\nNote: this will call MiniDiff.enable() for target buffer if it is not already enabled.\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n{text} (string|table) New reference text. Either a string with \\n used to separate lines or array of lines. Use empty table to unset current reference text (results into no hunks shown). Default: {}. Note: newline character is appended at the end (if it is not there already) for better diffs.\n\n\n\n\ngen_source\n\nMiniDiff.gen_source\n\nGenerate builtin sources\nThis is a table with function elements. Call to actually get source. Examples:\nlocal diff = require('mini.diff')\n\n-- Single `save` source\ndiff.setup({ source = diff.gen_source.save() })\n\n-- Multiple sources (attempted to attach in order)\ndiff.setup({ source = { diff.gen_source.git(), diff.gen_source.save() } })\n\n\n\ngen_source.git()\n\nMiniDiff.gen_source.git()\n\nGit source\nDefault source. Uses file text from Git index as reference. This results in:\n\n“Add” hunks represent text present in current buffer, but not in index.\n“Change” hunks represent modified text already present in index.\n“Delete” hunks represent text deleted from index.\n\nApplying hunks means staging, a.k.a adding to index. Notes:\n\nRequires Git version at least 2.38.0.\nThere is no capability for unstaging hunks. Use full Git client for that.\n\n\nReturn\n(table) Source. See MiniDiff-source-specification.\n\n\n\n\ngen_source.none()\n\nMiniDiff.gen_source.none()\n\n“Do nothing” source\nAllows buffers to be enabled while not setting any reference text. Use this if the goal is to rely on manual MiniDiff.set_ref_text() calls.\n\nReturn\n(table) Source. See MiniDiff-source-specification.\n\n\n\n\ngen_source.save()\n\nMiniDiff.gen_source.save()\n\nLatest save source\nUses text at latest save as the reference. This results into diff showing difference after the latest save.\n\nReturn\n(table) Source. See MiniDiff-source-specification.\n\n\n\n\ndo_hunks()\n\nMiniDiff.do_hunks({buf_id}, {action}, {opts})\n\nPerform action on hunks in region\nCompute hunks inside a target region (even for hunks only partially inside it) and perform apply/reset/yank operation on them.\nThe “yank” action yanks all reference lines of target hunks into a specified register (should be one of registers).\nNotes:\n\nWhether hunk is inside a region is computed based on position of its buffer lines.\nIf “change” or “delete” is only partially inside a target region, all reference lines are used in computed “intersection” hunk.\n\nUsed directly in config.mappings.apply and config.mappings.reset. Usually there is no need to use this function manually. See MiniDiff.operator() for how to set up a mapping for “yank”.\n\nParameters\n{buf_id} (number) Target buffer identifier. Default: 0 for current buffer.\n{action} (string) One of “apply”, “reset”, “yank”.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;line_start&gt; (number) - start line of the region. Default: 1.\n&lt;line_end&gt; (number) - start line of the region. Default: last buffer line.\n&lt;register&gt; (string) - register to yank reference lines into. Default: v:register.\n\n\n\n\n\ngoto_hunk()\n\nMiniDiff.goto_hunk({direction}, {opts})\n\nGo to hunk range in current buffer\n\nParameters\n{direction} (string) One of “first”, “prev”, “next”, “last”.\n{opts} (table|nil) Options. A table with fields:\n\n&lt;n_times&gt; (number) - Number of times to advance. Default: v:count1.\n&lt;line_start&gt; (number) - Line number to start from for directions “prev” and “next”. Default: cursor line.\n&lt;wrap&gt; (boolean) - Whether to wrap around edges. Default: options.wrap value of the config.\n\n\n\n\n\noperator()\n\nMiniDiff.operator({mode})\n\nPerform action over region\nPerform action over region defined by marks. Used in mappings.\nExample of a mapping to yank reference lines of hunk range under cursor (assuming default ‘config.mappings.textobject’):\nlocal rhs = function() return MiniDiff.operator('yank') .. 'gh' end\nvim.keymap.set('n', 'ghy', rhs, { expr = true, remap = true })\n\nParameters\n{mode} (string) One of “apply”, “reset”, “yank”, or the ones used in g@.\n\n\n\n\ntextobject()\n\nMiniDiff.textobject()\n\nSelect hunk range textobject\nSelects all contiguous lines adjacent to cursor line which are in any (not necessarily same) hunk (if cursor line itself is in hunk). Used in default mappings.\n\n\n\nfail_attach()\n\nMiniDiff.fail_attach({buf_id})\n\nIndicate source attach fail\nTry to attach next source; if there is none - call MiniDiff.disable().\n\nParameters\n{buf_id} (integer) Buffer identifier for which attach has failed."
  },
  {
    "objectID": "mini.nvim/doc/mini-hues.html",
    "href": "mini.nvim/doc/mini-hues.html",
    "title": "mini.hues documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.hues Generate configurable color scheme\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nRequired to set two base colors: background and foreground. Their shades and other non-base colors are computed to be as much perceptually different as reasonably possible. See MiniHues.config for setup inspiration.\nConfigurable:\n\nNumber of hues used for non-base colors (from 0 to 8).\nSaturation level (“low”, “lowmedium”, “medium”, “mediumhigh”, “high”).\nAccent color used for some selected UI elements.\nPlugin integration (can be selectively enabled for faster startup).\n\nRandom generator for base colors. See MiniHues.gen_random_base_colors(). Powers randomhue color scheme.\nLua function to compute palette used in color scheme. See MiniHues.make_palette().\nBundled color schemes. See MiniHues-color-schemes.\n\nSupported highlight groups:\n\nAll built-in UI and syntax groups.\nBuilt-in Neovim LSP and diagnostic.\nTree-sitter (treesitter-highlight-groups).\nLSP semantic tokens (lsp-semantic-highlight).\nPlugins (either with explicit definition or by verification that default highlighting works appropriately):\n\nnvim-mini/mini.nvim\nakinsho/bufferline.nvim\nanuvyklack/hydra.nvim\nDanilaMihailov/beacon.nvim\nfolke/lazy.nvim\nfolke/noice.nvim\nfolke/todo-comments.nvim\nfolke/trouble.nvim\nfolke/which-key.nvim\nggandor/leap.nvim\nglepnir/dashboard-nvim\nglepnir/lspsaga.nvim\nHiPhish/rainbow-delimiters.nvim\nhrsh7th/nvim-cmp\nibhagwan/fzf-lua\njustinmk/vim-sneak\nkevinhwang91/nvim-bqf\nkevinhwang91/nvim-ufo\nlewis6991/gitsigns.nvim\nlukas-reineke/indent-blankline.nvim\nMeanderingProgrammer/render-markdown.nvim\nneoclide/coc.nvim\nNeogitOrg/neogit\nnvim-lualine/lualine.nvim\nnvim-neo-tree/neo-tree.nvim\nnvim-telescope/telescope.nvim\nnvim-tree/nvim-tree.lua\nOXY2DEV/helpview.nvim\nOXY2DEV/markview.nvim\nphaazon/hop.nvim\nrcarriga/nvim-dap-ui\nrcarriga/nvim-notify\nrlane/pounce.nvim\nromgrk/barbar.nvim\nstevearc/aerial.nvim\nwilliamboman/mason.nvim\n\n\n\nSetup\nThis module needs a setup with require('mini.hues').setup({}) and mandatory background and foreground fields (add more fields to fit your taste). It will create global Lua table MiniHues which you can use for scripting or manually (with :lua MiniHues.*).\nSee MiniHues.config for config structure and default values.\nThis module doesn’t have runtime options, so using vim.b.minihues_config will have no effect here.\nExample:\nrequire('mini.hues').setup({\n  background = '#11262d',\n  foreground = '#c0c8cc',\n  plugins = {\n    default = false,\n    ['nvim-mini/mini.nvim'] = true,\n  },\n})\n\n\nNotes\n\nThis is used to create some of plugin’s color schemes (see MiniHues-color-schemes).\nUsing setup() doesn’t actually create a colorscheme. It basically creates a coordinated set of highlight-groups. To create your own scheme:\n\nPut “myscheme.lua” file (name after your chosen theme name) inside any “colors” directory reachable from ‘runtimepath’ (“colors” inside your Neovim config directory is usually enough).\nInside “myscheme.lua” call require('mini.hues').setup() with your palette and only after that set g:colors_name to “myscheme”.\n\nThis module doesn’t define cterm-colors for implementation simplicity. Use mini.colors module, MiniColors-colorscheme:add_cterm_attributes() in particular.\n\n\n\n\n\nColor schemes\nBundled color schemes\n\nminiwinter : “icy winter” palette with azure background.\nminispring : “blooming spring” palette with green background.\nminisummer : “hot summer” palette with brown/yellow background.\nminiautumn : “cooling autumn” palette with purple background.\nrandomhue : uses randomly generated same hue background and foreground. Every :colorscheme randomhue call results in a different (randomly yet carefully selected) colors.\nIt is essentially a combination of calls to MiniHues.setup() and MiniHues.gen_random_base_colors() with a slight adjustments for ‘background’ value.\nActivate it as regular :colorscheme. Get currently active config with :lua print(vim.inspect(MiniHues.config)).\n\n\n\n\nsetup()\n\nMiniHues.setup({config})\n\nModule setup\nMain side effect is to create palette and apply it. Essentially, a combination of MiniHues.make_palette() and MiniHues.apply_palette().\n\nUsage\nrequire('mini.hues').setup({\n  -- Use config table as you like\n  -- Needs both `background` and `foreground` fields present\n  background = '#11262d',\n  foreground = '#c0c8cc',\n})\n\n\n\n\nconfig\n\nMiniHues.config\n\n\nDefaults\nMiniHues.config = {\n  -- **Required** base colors as '#rrggbb' hex strings\n  background = nil,\n  foreground = nil,\n\n  -- Number of hues used for non-base colors\n  n_hues = 8,\n\n  -- Saturation. One of 'low', 'lowmedium', 'medium', 'mediumhigh', 'high'.\n  saturation = 'medium',\n\n  -- Accent color. One of: 'bg', 'fg', 'red', 'orange', 'yellow', 'green',\n  -- 'cyan', 'azure', 'blue', 'purple'\n  accent = 'bg',\n\n  -- Plugin integrations. Use `default = false` to disable all integrations.\n  -- Also can be set per plugin (see |MiniHues.config|).\n  plugins = { default = true },\n\n  -- Whether to auto adjust highlight groups based on certain events\n  autoadjust = true,\n}\nSee MiniHues.make_palette() for more information about how certain settings affect output color scheme.\n\n\nPlugin integrations\nconfig.plugins defines for which supported plugins highlight groups will be created. Limiting number of integrations slightly decreases startup time. It is a table with boolean (true/false) values which are applied as follows:\n\nIf plugin name (as listed in mini.hues) has entry, it is used.\nOtherwise config.plugins.default is used.\n\nExample which will load only “mini.nvim” integration:\nrequire('mini.hues').setup({\n  background = '#11262d',\n  foreground = '#c0c8cc',\n  plugins = {\n    default = false,\n    ['nvim-mini/mini.nvim'] = true,\n  },\n})\n\n\nAuto adjust\nconfig.autoadjust defines whether to adjust some highlight groups based on events relevant to them. Currently adjusted groups:\n\nhl-MsgSeparator is adjusted based on msgsep flag in ‘fillchars’. If it is whitespace - highlight background, otherwise - foreground.\nhl-Pmenu is adjusted based on ‘pumborder’ value (on Neovim&gt;=0.12). If it results in a border - same as floating window (but with no accent foreground in border), otherwise - same as hl-CursorLine. This design makes ins-completion-menu stand out from regular floating windows.\n\n\n\nExamples\nMiniHues-examples\nHere are some possible setup configurations (copy first line and then use only one setup call):\nlocal setup = require('mini.hues').setup\n\n-- Choose background and foreground\nsetup({ background = '#2f1c22', foreground = '#cdc4c6' }) -- red\nsetup({ background = '#2f1e16', foreground = '#cdc5c1' }) -- orange\nsetup({ background = '#282211', foreground = '#c9c6c0' }) -- yellow\nsetup({ background = '#1c2617', foreground = '#c4c8c2' }) -- green\nsetup({ background = '#112723', foreground = '#c0c9c7' }) -- cyan\nsetup({ background = '#11262d', foreground = '#c0c8cc' }) -- azure\nsetup({ background = '#1d2231', foreground = '#c4c6cd' }) -- blue\nsetup({ background = '#281e2c', foreground = '#c9c5cb' }) -- purple\n\n-- Choose number of accent colors\nsetup({ background = '#11262d', foreground = '#c0c8cc', n_hues = 6 })\nsetup({ background = '#11262d', foreground = '#c0c8cc', n_hues = 4 })\nsetup({ background = '#11262d', foreground = '#c0c8cc', n_hues = 2 })\nsetup({ background = '#11262d', foreground = '#c0c8cc', n_hues = 0 })\n\n-- Choose saturation of colored text\nsetup({ background = '#11262d', foreground = '#c0c8cc', saturation = 'low' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', saturation = 'lowmedium' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', saturation = 'medium' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', saturation = 'mediumhigh' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', saturation = 'high' })\n\n-- Choose accent color\nsetup({ background = '#11262d', foreground = '#c0c8cc', accent = 'bg' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', accent = 'red' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', accent = 'yellow' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', accent = 'cyan' })\nsetup({ background = '#11262d', foreground = '#c0c8cc', accent = 'blue' })\n\n\n\n\nmake_palette()\n\nMiniHues.make_palette({config})\n\n\nMake palette\nGeneral idea of palette generation is that it is mostly based on color channel information extracted from base colors (background and foreground).\nAll operations are done inside Oklch color space, meaning that each color is defined by three numbers:\n\nLightness (l) - number between 0 (black) and 100 (white) describing how light is a color.\nChroma (c) - positive number describing how colorful is a color (bigger values - more colorful; 0 is gray).\nHue (h) - periodic number in [0, 360) describing a value of “true color” on color circle/wheel.\n\nFor more details about Oklch see MiniColors-color-spaces or https://bottosson.github.io/posts/oklab/.\n\nAlgorithm overview\n\nExtract lightness, chroma, and hue of base colors.\nGenerate reference lightness values:\n\nBackground edge: 0 or 100, whichever is closest to background lightness.\nForeground edge: 0 or 100, different from background edge.\nMiddle: arithmetic mean of background and foreground lightness values.\n\nCompute background and foreground tints and shades by changing lightness of background color: two colors closer to background lightness edge and two closer to middle.\nPick chroma value for non-base colors based on config.saturation.\nGenerate hues for non-base colors:\n\nFit an equidistant circular grid with config.n_hues points to be as far from both background and foreground hues. This will ensure that non-base colors are as different as possible from base ones (for better visual perception). Example: for background hue 0, foreground hue 180, and config.n_hues 2 the output grid will be { 90, 270 }.\nFor each hue of reference color (which itself is an equidistant grid of 8 hues) compute the closest value from the grid. This allows operating in same terms (like “red”, “green”) despite maybe actually having less different hues.\n\nCompute for each hue two variants of non-base colors: with background and foreground lightness values.\nCompute two variants of accent color (with background and foreground lightness) based on config.accent.\n\nNotes:\n\nSome output colors can have not exact values of generated Oklch channels. This is due to actually computed colors being impossible to represent via ‘#rrggbb’ hex string. In this case a process called gamut clipping is done to reduce lightness and chroma in optimal way while maintaining same hue. For more information see MiniColors-gamut-clip.\nNot all colors are actually used in highlight groups and are present for the sake of completeness.\n\n\n\n\nParameters\n{config} (table) Configuration for palette. Same structure as MiniHues.config. Needs to have &lt;background&gt; and &lt;foreground&gt; fields.\n\n\nReturn\n(table) Palette with the following fields:\n\n&lt;bg&gt; and &lt;fg&gt; with supplied background and foreground colors.\nFields like &lt;bg_xxx&gt; and &lt;fg_xxx&gt; are essentially &lt;bg&gt; and &lt;fg&gt; but with different lightness values: _edge/_edge2 - closer to edge lightness, _mid/_mid2 - closer to middle lightness.\nFields for non-base colors (&lt;red&gt;, &lt;orange&gt;, &lt;yellow&gt;, &lt;green&gt;, &lt;cyan&gt;, &lt;azure&gt;, &lt;blue&gt;, &lt;purple&gt;) have the same lightness as foreground.\nFields for non-base colors with &lt;_bg&gt; suffix have the same lightness as background.\n&lt;accent&gt; and &lt;accent_bg&gt; represent accent colors with foreground and background lightness values.\n\n\n\nSee also\nMiniHues.get_palette()\n\n\n\n\napply_palette()\n\nMiniHues.apply_palette({palette}, {plugins}, {opts})\n\nApply palette\nCreate color scheme highlight groups and terminal colors based on supplied palette. This is useful if you want to tweak palette colors. For regular usage prefer MiniHues.setup().\n\nParameters\n{palette} (table) Table with structure as MiniHues.make_palette() output.\n{plugins} (table|nil) Table with boolean values indicating whether to create highlight groups for specific plugins. See MiniHues.config for more details. Default: the value from MiniHues.config.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;autoadjust&gt; - whether to auto adjust some highlight groups when needed. Default: value of autoadjust in MiniHues.config.\n\n\n\nUsage\nlocal palette = require('mini.hues').make_palette({\n  background = '#11262d',\n  foreground = '#c0c8cc',\n})\npalette.cyan = '#76e0a6'\npalette.cyan_bg = '#004629'\nrequire('mini.hues').apply_palette(palette)\n\n\nSee also\nMiniHues.get_palette()\n\n\n\n\nget_palette()\n\nMiniHues.get_palette()\n\nGet latest applied palette\n\nReturn\n(table) Table with structure as MiniHues.make_palette() output that was the latest applied (via MiniHues.apply_palette()) palette.\n\n\n\n\ngen_random_base_colors()\n\nMiniHues.gen_random_base_colors({opts})\n\nGenerate random base colors\nCompute background and foreground colors based on randomly generated hue and heuristically picked lightness-chroma values.\nYou can recreate a similar functionality but tweaked to your taste using mini.colors: &gt; local convert = require(‘mini.colors’).convert local hue = math.random(0, 359) return { background = convert({ l = 15, c = 3, h = hue }, ‘hex’), foreground = convert({ l = 80, c = 1, h = hue }, ‘hex’), }\nNotes:\n\nRespects ‘background’ (uses different lightness and chroma values for “dark” and “light” backgrounds).\nWhen used during startup, might require usage of math.randomseed() for proper random generation. For example: &gt;\nlocal hues = require(‘mini.hues’) math.randomseed(vim.loop.hrtime()) hues.setup(hues.gen_random_base_colors())\n\n\nParameters\n{opts} (table|nil) Options. Possible values:\n\n&lt;gen_hue&gt; (function) - callable which will return single number for output hue. Can be used to limit which hues will be generated. Default: random integer between 0 and 359.\n\n\n\nReturn\n(table) Table with &lt;background&gt; and &lt;foreground&gt; fields containing color hex strings."
  },
  {
    "objectID": "mini.nvim/doc/mini-visits.html",
    "href": "mini.nvim/doc/mini-visits.html",
    "title": "mini.visits documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.visits Track and reuse file system visits\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nPersistently track file system visits (both files and directories) per project directory. Store visit index is human readable and editable.\nVisit index is normalized on every write to contain relevant information. Exact details can be customized. See MiniVisits.normalize_index().\nBuilt-in ability to persistently add labels to path for later use. See MiniVisits.add_label() and MiniVisits.remove_label().\nExported functions to reuse visit data:\n\nList visited paths/labels with custom filter and sort (uses “robust frecency” by default). Can be used as source for pickers. See MiniVisits.list_paths() and MiniVisits.list_labels(). See MiniVisits.gen_filter and MiniVisits.gen_sort.\nSelect visited paths/labels using vim.ui.select(). See MiniVisits.select_path() and MiniVisits.select_label().\nIterate through visit paths in target direction (“forward”, “backward”, “first”, “last”). See MiniVisits.iterate_paths().\n\nExported functions to manually update visit index allowing persistent track of any user information. See *_index() functions.\n\nNotes:\n\nAll data is stored only in in-session Lua variable (for quick operation) and at config.store.path on disk (for persistent usage).\nMost of functions affect an in-session data which gets written to disk only before Neovim is closing or when users asks to.\nIt doesn’t account for paths being renamed or moved (because there is no general way to detect that). Usually a manual intervention to the visit index is required after the change but before the next writing to disk (usually before closing current session) because it will treat previous path as deleted and remove it from index. There is a MiniVisits.rename_in_index() helper for that. If rename/move is done with mini.files, index is autoupdated.\n\nSources with more details:\n\nMiniVisits-overview\nMiniVisits-index-specification\nMiniVisits-examples\n\n\nSetup\nThis module needs a setup with require('mini.visits').setup({}) (replace {} with your config table). It will create global Lua table MiniVisits which you can use for scripting or manually (with :lua MiniVisits.*).\nSee MiniVisits.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minivisits_config which should have same structure as MiniVisits.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nnvim-telescope/telescope-frecency.nvim:\n\nIt stores array of actual visit timestamps, while this module tracks only total number and latest timestamp of visits. This is by design as a different trade-off between how much data is being used/stored and complexity of underlying “frecency” sorting.\nBy default tracks a buffer only once per session, while this module tracks on every meaningful buffer enter. This leads to a more relevant in-session sorting.\nImplements an original frecency algorithm of Firefox’s address bar, while this module uses own “robust frecency” approach.\nMostly designed to work with ‘nvim-telescope/telescope.nvim’, while this module provides general function to list paths and select with vim.ui.select().\nDoes not allow use of custom data (like labels), while this module does.\n\nThePrimeagen/harpoon:\n\nHas slightly different concept than general labeling, which more resembles adding paths to an ordered stack. This module implements a more common labeling which does not imply order with ability to make it automated depending on the task and/or preference.\nImplements marks as positions in a path, while this module labels paths.\nWrites data on disk after every meaning change, while this module is more conservative and read only when Neovim closes or when asked to.\nHas support for labeling terminals, while this modules is oriented only towards paths.\nHas dedicated UI to manage marks, while this module does not by design. There are functions for adding and removing label from the path.\nDoes not provide functionality to track and reuse any visited path, while this module does.\n\n\n\n\nDisabling\nTo disable automated tracking, set vim.g.minivisits_disable (globally) or vim.b.minivisits_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nOverview\n\nTracking visits\nFile system visits (both directory and files) tracking is done in two steps:\n\nOn every dedicated event (config.track.event, BufEnter by default) timer is (re)started to actually register visit after certain amount of time (config.track.delay milliseconds, 1000 by default). It is not registered immediately to allow navigation to target buffer in several steps (for example, with series of :bnext / :bprevious).\nWhen delay time passes without any dedicated events being triggered (meaning user is “settled” on certain buffer), MiniVisits.register_visit() is called if all of the following conditions are met:\n\nModule is not disabled (see “Disabling” section in mini.visits).\nBuffer is normal with non-empty name (used as visit path).\nVisit path does not equal to the latest tracked one. This is to allow temporary enter of non-normal buffers (like help, terminal, etc.) without artificial increase of visit count.\n\n\nVisit is autoregistered for current-directory and leads to increase of count and latest time of visit. See MiniVisits-index-specification for more details.\nNotes:\n\nAll data is stored only in in-session Lua variable (for quick operation) and at config.store.path on disk (for persistent usage). It is automatically written to disk before every Neovim exit (if config.store.autowrite is set).\nTracking can be disabled by supplying empty string as track.event. Then it is up to the user to properly call MiniVisits.register_visit().\n\n\n\nReusing visits\nVisit data can be reused in at least these ways:\n\nGet a list of visited paths (see MiniVisits.list_paths()) and use it to visualize/pick/navigate visit history.\nSelect one of the visited paths to open it (see MiniVisits.select_path()).\nMove along visit history (see MiniVisits.iterate_paths()).\nUtilize labels. Any visit can be added one or more labels (like “core”, “tmp”, etc.). They are bound to the visit (path registered for certain directory) and are stored persistently. Labels can be used to manually create groups of files and/or directories that have particular interest to the user. There is no one right way to use them, though. See MiniVisits-examples for some inspiration.\nUtilizing custom data. Visit index can be manipulated manually using _index() set of functions. All “storable” (i.e. not functions or metatables) user data inside index is then stored on disk, so it can be used to create any kind of workflow user wants.\n\nSee MiniVisits-examples for some actual configuration and workflow examples.\n\n\n\n\nIndex specification\n\nStructure\nVisit index is a table containing actual data in two level deep nested tables.\nFirst level keys are paths of project directory (a.k.a “cwd”) for which visits are registered.\nSecond level keys are actual visit paths. Their values are tables with visit data which should follow these requirements:\n\nField &lt;count&gt; should be present and be a number. It represents the number of times this path was visited under particular cwd.\nField &lt;latest&gt; should be present and be a number. It represents the time of latest path visit under particular cwd. By default computed with os.time() (up to a second).\nField &lt;labels&gt; might not be present. If present, it should be a table with string labels as keys and true as values. It represents labels of the path under particular cwd.\n\nNotes:\n\nAll paths are absolute.\nVisit path should not necessarily be a part of corresponding cwd.\nBoth count and latest can be any number: whole, fractional, negative, etc.\n\nExample of an index data:\n{\n  ['/home/user/project_1'] = {\n    ['home/user/project_1/file'] = { count = 3, latest = 1699796000 },\n    ['home/user/project_1/subdir'] = {\n      count = 10, latest = 1699797000, labels = { core = true },\n    },\n  },\n  ['/home/user/project_2'] = {\n    ['home/user/project_1/file'] = {\n      count = 0, latest = 0, labels = { other = true },\n    },\n    ['home/user/project_2/README'] = { count = 1, latest = 1699798000 },\n  },\n}\n\n\nStorage\nWhen stored on disk, visit index is a file containing Lua code returning visit index table. It can be edited by hand as long as it contains a valid Lua code (to be executed with dofile()).\nNotes:\n\nStorage is implemented in such a way that it doesn’t really support more than one parallel Neovim processes. Meaning that if there are two or more simultaneous Neovim processes with same visit index storage path, the last one writing to it will preserve its visit history while others - won’t.\n\n\n\nNormalization\nTo ensure that visit index contains mostly relevant data, it gets normalized: automatically inside MiniVisits.write_index() or via MiniVisits.normalize_index().\nWhat normalization actually does can be configured in config.store.normalize.\nSee MiniVisits.gen_normalize.default() for default normalization approach.\n\n\n\n\nExamples\nThis module provides a flexible framework for working with file system visits. Exact choice of how to organize workflow is left to the user. Here are some examples for inspiration which can be combined together.\n\nUse different sorting\nDefault sorting in MiniVisits.gen_sort.default() allows flexible adjustment of which feature to prefer more: recency or frequency. Here is an example of how to make set of keymaps for three types of sorting combined with two types of scopes (all visits and only for current cwd):\nlocal make_select_path = function(select_global, recency_weight)\n  local visits = require('mini.visits')\n  local sort = visits.gen_sort.default({ recency_weight = recency_weight })\n  local select_opts = { sort = sort }\n  return function()\n    local cwd = select_global and '' or vim.fn.getcwd()\n    visits.select_path(cwd, select_opts)\n  end\nend\n\nlocal map = function(lhs, desc, ...)\n  vim.keymap.set('n', lhs, make_select_path(...), { desc = desc })\nend\n\n-- Adjust LHS and description to your liking\nmap('&lt;Leader&gt;vr', 'Select recent (all)',   true,  1)\nmap('&lt;Leader&gt;vR', 'Select recent (cwd)',   false, 1)\nmap('&lt;Leader&gt;vy', 'Select frecent (all)',  true,  0.5)\nmap('&lt;Leader&gt;vY', 'Select frecent (cwd)',  false, 0.5)\nmap('&lt;Leader&gt;vf', 'Select frequent (all)', true,  0)\nmap('&lt;Leader&gt;vF', 'Select frequent (cwd)', false, 0)\nNote: If using mini.pick, consider MiniExtra.pickers.visit_paths().\n\n\nUse manual labels\nLabels is a powerful tool to create groups of associated paths. Usual workflow consists of:\n\nAdd label with MiniVisits.add_label() (prompts for actual label).\nRemove label with MiniVisits.remove_label() (prompts for actual label).\nWhen need to use labeled groups, call MiniVisits.select_label() which will then call MiniVisits.select_path() to select path among those having selected label. Note: If using mini.pick, consider MiniExtra.pickers.visit_labels().\n\nTo make this workflow smoother, here is an example of keymaps:\nlocal map_vis = function(keys, call, desc)\n  local rhs = '&lt;Cmd&gt;lua MiniVisits.' .. call .. '&lt;CR&gt;'\n  vim.keymap.set('n', '&lt;Leader&gt;' .. keys, rhs, { desc = desc })\nend\n\nmap_vis('vv', 'add_label()',          'Add label')\nmap_vis('vV', 'remove_label()',       'Remove label')\nmap_vis('vl', 'select_label(\"\", \"\")', 'Select label (all)')\nmap_vis('vL', 'select_label()',       'Select label (cwd)')\n\n\nUse fixed labels\nDuring work on every project there is usually a handful of files where core activity is concentrated. This can be made easier by creating mappings which add/remove special fixed label (for example, “core”) and select paths with that label for both all and current cwd. Example:\n-- Create and select\nlocal map_vis = function(keys, call, desc)\n  local rhs = '&lt;Cmd&gt;lua MiniVisits.' .. call .. '&lt;CR&gt;'\n  vim.keymap.set('n', '&lt;Leader&gt;' .. keys, rhs, { desc = desc })\nend\n\nmap_vis('vv', 'add_label(\"core\")',                     'Add to core')\nmap_vis('vV', 'remove_label(\"core\")',                  'Remove from core')\nmap_vis('vc', 'select_path(\"\", { filter = \"core\" })',  'Select core (all)')\nmap_vis('vC', 'select_path(nil, { filter = \"core\" })', 'Select core (cwd)')\n\n-- Iterate based on recency\nlocal sort_latest = MiniVisits.gen_sort.default({ recency_weight = 1 })\nlocal map_iterate_core = function(lhs, direction, desc)\n  local opts = { filter = 'core', sort = sort_latest, wrap = true }\n  local rhs = function()\n    MiniVisits.iterate_paths(direction, vim.fn.getcwd(), opts)\n  end\n  vim.keymap.set('n', lhs, rhs, { desc = desc })\nend\n\nmap_iterate_core('[{', 'last',     'Core label (earliest)')\nmap_iterate_core('[[', 'forward',  'Core label (earlier)')\nmap_iterate_core(']]', 'backward', 'Core label (later)')\nmap_iterate_core(']}', 'first',    'Core label (latest)')\n\n\nUse automated labels\nWhen using version control system (such as Git), usually there is already an identifier that groups files you are working with - branch name. Here is an example of keymaps to add/remove label equal to branch name:\nlocal map_branch = function(keys, action, desc)\n  local rhs = function()\n    local branch = vim.fn.system('git rev-parse --abbrev-ref HEAD')\n    if vim.v.shell_error ~= 0 then return nil end\n    branch = vim.trim(branch)\n    require('mini.visits')[action](branch)\n  end\n  vim.keymap.set('n', '&lt;Leader&gt;' .. keys, rhs, { desc = desc })\nend\n\nmap_branch('vb', 'add_label',    'Add branch label')\nmap_branch('vB', 'remove_label', 'Remove branch label')\n\n\n\n\nsetup()\n\nMiniVisits.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniVisits.config.\n\n\nUsage\nrequire('mini.visits').setup() -- use default config\n-- OR\nrequire('mini.visits').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniVisits.config\n\n\nDefaults\nMiniVisits.config = {\n  -- How visit index is converted to list of paths\n  list = {\n    -- Predicate for which paths to include (all by default)\n    filter = nil,\n\n    -- Sort paths based on the visit data (robust frecency by default)\n    sort = nil,\n  },\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n\n  -- How visit index is stored\n  store = {\n    -- Whether to write all visits before Neovim is closed\n    autowrite = true,\n\n    -- Function to ensure that written index is relevant\n    normalize = nil,\n\n    -- Path to store visit index\n    path = vim.fn.stdpath('data') .. '/mini-visits-index',\n  },\n\n  -- How visit tracking is done\n  track = {\n    -- Start visit register timer at this event\n    -- Supply empty string (`''`) to not do this automatically\n    event = 'BufEnter',\n\n    -- Debounce delay after event to register a visit\n    delay = 1000,\n  },\n}\n\n\nList\nMiniVisits.config.list\nconfig.list defines how visit index is converted to a path list by default.\nlist.filter is a callable which should take a path data and return true if this path should be present in the list. Default: output of MiniVisits.gen_filter.default().\nPath data is a table with at least these fields:\n\n&lt;path&gt; (string) - absolute path of visit.\n&lt;count&gt; (number) - number of visits.\n&lt;latest&gt; (number) - timestamp of latest visit.\n&lt;labels&gt; (table|nil) - table of labels (has string keys with true values).\n\nNotes:\n\nBoth count and latest (in theory) can be any number. But built-in tracking results into positive integer count and latest coming from os.time().\nThere can be other entries if they are set by user as index entry.\n\nlist.sort is a callable which should take an array of path data and return a sorted array of path data (or at least tables each containing &lt;path&gt; field). Default: output of MiniVisits.gen_sort.default(). Single path data entry is a table with a same structure as for list.filter.\nNote, that list.sort can be used both to filter, sort, or even return paths unrelated to the input.\n\n\nSilent\nconfig.silent is a boolean controlling whether to show non-error feedback (like adding/removing labels, etc.). Default: false.\n\n\nStore\nconfig.store defines how visit index is stored on disk to enable persistent data across several sessions.\nstore.autowrite is a boolean controlling whether to write visit data to disk on VimLeavePre event. Default: true.\nstore.normalize is a callable which should take visit index (see MiniVisits-index-specification) as input and return “normalized” visit index as output. This is used to ensure that visit index is up to date and contains only relevant data. For example, it controls how old and irrelevant visits are “forgotten”, and more. Default: output of MiniVisits.gen_normalize.default().\nstore.path is a path to which visit index is written. See “Storage” section of MiniVisits-index-specification for more details. Note: set to empty string to disable any writing with not explicitly set path (including the one on VimLeavePre). Default: “mini-visits-index” file inside $XDG_DATA_HOME.\n\n\nTrack\nconfig.track defines how visits are tracked (index entry is autoupdated). See “Tracking visits” section in MiniVisits-overview for more details.\ntrack.event is a proper Neovim {event} on which track get triggered. Note: set to empty string to disable automated tracking. Default: BufEnter.\ntrack.delay is a delay in milliseconds after event is triggered and visit is autoregistered. Default: 1000 (to allow navigation between buffers without tracking intermediate ones).\n\n\n\n\nregister_visit()\n\nMiniVisits.register_visit({path}, {cwd})\n\nRegister visit\nSteps:\n\nEnsure that there is an entry for path-cwd pair.\nAdd 1 to visit count.\nSet latest visit time to equal current time.\n\n\nParameters\n{path} (string|nil) Visit path. Default: path of current buffer if normal, error otherwise.\n{cwd} (string|nil) Visit cwd (project directory). Default: current-directory.\n\n\n\n\nadd_path()\n\nMiniVisits.add_path({path}, {cwd})\n\nAdd path to index\nEnsures that there is a (one or more) entry for path-cwd pair. If entry is already present, does nothing. If not - creates it with both count and latest set to 0.\n\nParameters\n{path} (string|nil) Visit path. Can be empty string to mean “all visited paths for cwd”. Default: path of current buffer if normal, error otherwise.\n{cwd} (string|nil) Visit cwd (project directory). Can be empty string to mean “all visited cwd”. Default: current-directory.\n\n\n\n\nadd_label()\n\nMiniVisits.add_label({label}, {path}, {cwd})\n\nAdd label to path\nSteps:\n\nEnsure that there is an entry for path-cwd pair.\nAdd label to the entry.\n\n\nParameters\n{label} (string|nil) Label string. Default: nil to ask from user.\n{path} (string|nil) Visit path. Can be empty string to mean “all visited paths for cwd”. Default: path of current buffer if normal, error otherwise.\n{cwd} (string|nil) Visit cwd (project directory). Can be empty string to mean “all visited cwd”. Default: current-directory.\n\n\n\n\nremove_path()\n\nMiniVisits.remove_path({path}, {cwd})\n\nRemove path\nDeletes a (one or more) entry for path-cwd pair from an index. If entry is already absent, does nothing.\nNotes:\n\nAffects only in-session Lua variable. Call MiniVisits.write_index() to make it persistent.\n\n\nParameters\n{path} (string|nil) Visit path. Can be empty string to mean “all visited paths for cwd”. Default: path of current buffer if normal, error otherwise.\n{cwd} (string|nil) Visit cwd (project directory). Can be empty string to mean “all visited cwd”. Default: current-directory.\n\n\n\n\nremove_label()\n\nMiniVisits.remove_label({label}, {path}, {cwd})\n\nRemove label from path\nSteps:\n\nRemove label from (one or more) index entry.\nIf it was last label in an entry, remove labels key.\n\n\nParameters\n{label} (string|nil) Label string. Default: nil to ask from user.\n{path} (string|nil) Visit path. Can be empty string to mean “all visited paths for cwd”. Default: path of current buffer if normal, error otherwise.\n{cwd} (string|nil) Visit cwd (project directory). Can be empty string to mean “all visited cwd”. Default: current-directory.\n\n\n\n\nlist_paths()\n\nMiniVisits.list_paths({cwd}, {opts})\n\nList visit paths\nConvert visit index for certain cwd into an ordered list of visited paths. Supports custom filtering and sorting.\nExamples:\n-- Get paths sorted from most to least recent\nlocal sort_recent = MiniVisits.gen_sort.default({ recency_weight = 1 })\nMiniVisits.list_paths(nil, { sort = sort_recent })\n\n-- Get paths from all cwd sorted from most to least frequent\nlocal sort_frequent = MiniVisits.gen_sort.default({ recency_weight = 0 })\nMiniVisits.list_paths('', { sort = sort_frequent })\n\n-- Get paths not including hidden\nlocal is_not_hidden = function(path_data)\n  return not vim.startswith(vim.fn.fnamemodify(path_data.path, ':t'), '.')\nend\nMiniVisits.list_paths(nil, { filter = is_not_hidden })\n\nParameters\n{cwd} (string|nil) Visit cwd (project directory). Can be empty string to mean “all visited cwd”. Default: current-directory.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function) - predicate to filter paths. For more information about how it is used, see MiniVisits.config.list. Default: value of config.list.filter with MiniVisits.gen_filter.default() as its default.\n&lt;sort&gt; (function) - path data sorter. For more information about how it is used, see MiniVisits.config.list. Default: value of config.list.sort or MiniVisits.gen_sort.default() as its default.\n\n\n\nReturn\n(table) Array of visited paths.\n\n\n\n\nlist_labels()\n\nMiniVisits.list_labels({path}, {cwd}, {opts})\n\nList visit labels\nConvert visit index for certain path-cwd pair into an ordered list of labels. Supports custom filtering for paths. Result is ordered from most to least frequent label.\nExamples:\n-- Get labels for current path-cwd pair\nMiniVisits.list_labels()\n\n-- Get labels for current path across all cwd\nMiniVisits.list_labels(nil, '')\n\n-- Get all available labels excluding ones from hidden files\nlocal is_not_hidden = function(path_data)\n  return not vim.startswith(vim.fn.fnamemodify(path_data.path, ':t'), '.')\nend\nMiniVisits.list_labels('', '', { filter = is_not_hidden })\n\nParameters\n{path} (string|nil) Visit path. Can be empty string to mean “all visited paths for cwd”. Default: path of current buffer if normal, error otherwise.\n{cwd} (string|nil) Visit cwd (project directory). Can be empty string to mean “all visited cwd”. Default: current-directory.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function) - predicate to filter paths. For more information about how it is used, see MiniVisits.config.list. Default: value of config.list.filter with MiniVisits.gen_filter.default() as its default.\n&lt;sort&gt; (function) - path data sorter. For more information about how it is used, see MiniVisits.config.list. Default: value of config.list.sort or MiniVisits.gen_sort.default() as its default.\n\n\n\nReturn\n(table) Array of available labels.\n\n\n\n\nselect_path()\n\nMiniVisits.select_path({cwd}, {opts})\n\nSelect visit path\nUses vim.ui.select() with an output of MiniVisits.list_paths() and calls :edit on the chosen item.\nNote: if you have mini.pick, consider using MiniExtra.pickers.visit_labels() and MiniExtra.pickers.visit_paths().\nExamples:\n\nSelect from all visited paths: MiniVisits.select_path('')\nSelect from paths under current directory sorted from most to least recent:\nlocal sort_recent = MiniVisits.gen_sort.default({ recency_weight = 1 })\nMiniVisits.select_path(nil, { sort = sort_recent })\n\n\nParameters\n{cwd} (string|nil) Forwarded to MiniVisits.list_paths().\n{opts} (table|nil) Forwarded to MiniVisits.list_paths().\n\n\n\n\nselect_label()\n\nMiniVisits.select_label({path}, {cwd}, {opts})\n\nSelect visit label\nUses vim.ui.select() with an output of MiniVisits.list_labels() and calls MiniVisits.select_path() to get target paths with selected label.\nNote: if you have mini.pick, consider using MiniExtra.pickers.visit_labels().\nExamples:\n\nSelect from labels of current path: MiniVisits.select_label()\nSelect from all visited labels: MiniVisits.select_label('', '')\nSelect from current project labels and sort paths (after choosing) from most to least recent:\nlocal sort_recent = MiniVisits.gen_sort.default({ recency_weight = 1 })\nMiniVisits.select_label('', nil, { sort = sort_recent })\n\n\nParameters\n{path} (string|nil) Forwarded to MiniVisits.list_labels().\n{cwd} (string|nil) Forwarded to MiniVisits.list_labels().\n{opts} (table|nil) Forwarded to both MiniVisits.list_labels() and MiniVisits.select_path() (after choosing a label).\n\n\n\n\niterate_paths()\n\nMiniVisits.iterate_paths({direction}, {cwd}, {opts})\n\nIterate visit paths\nSteps:\n\nCompute a sorted array of target paths using MiniVisits.list_paths().\nIdentify the current index inside the array based on path of current buffer.\nIterate through the array certain amount of times in a dedicated direction:\n\nFor “first” direction - forward starting from index 0 (so that single first iteration leads to first path).\nFor “backward” direction - backward starting from current index.\nFor “forward” direction - forward starting from current index.\nFor “last” direction - backward starting from index after the last one (so that single first iteration leads to the last path).\n\n\nNotes:\n\nMostly designed to be used as a mapping. See MiniVisits-examples.\nIf path from current buffer is not in the output of MiniVisits.list_paths(), starting index is inferred such that first iteration lands on first item (if iterating forward) or last item (if iterating backward).\nNavigation with this function is not tracked (see MiniVisits-overview). This is done to allow consecutive application without affecting underlying list of paths.\n\nExamples assuming underlying array of files { \"file1\", \"file2\", \"file3\" }:\n\nMiniVisits(\"first\") results into focusing on “file1”.\nMiniVisits(\"backward\", { n_times = 2 }) from “file3” results into “file1”.\nMiniVisits(\"forward\", { n_times = 10 }) from “file1” results into “file3”.\nMiniVisits(\"last\", { n_times = 4, wrap = true }) results into “file3”.\n\n\nParameters\n{direction} (string) One of “first”, “backward”, “forward”, “last”.\n{cwd} (string|nil) Forwarded to MiniVisits.list_paths().\n{opts} (table|nil) Options. Possible fields:\n\n&lt;filter&gt; (function) - forwarded to MiniVisits.list_paths().\n&lt;sort&gt; (function) - forwarded to MiniVisits.list_paths().\n&lt;n_times&gt; (number) - number of steps to go in certain direction. Default: v:count1.\n&lt;wrap&gt; (boolean) - whether to wrap around list edges. Default: false.\n\n\n\n\n\nget_index()\n\nMiniVisits.get_index()\n\nGet active visit index\n\nReturn\n(table) Copy of currently active visit index table.\n\n\n\n\nset_index()\n\nMiniVisits.set_index({index})\n\nSet active visit index\n\nParameters\n{index} (table) Visit index table.\n\n\n\n\nreset_index()\n\nMiniVisits.reset_index()\n\nReset active visit index\nSet currently active visit index to the output of MiniVisits.read_index(). Does nothing if reading the index failed.\n\n\n\nnormalize_index()\n\nMiniVisits.normalize_index({index})\n\nNormalize visit index\nApplies config.store.normalize (MiniVisits.gen_normalize.default() by default) to the input index object and returns the output (if it fits in the definition of index object; see MiniVisits-index-specification).\n\nParameters\n{index} (table|nil) Index object. Default: copy of the current index.\n\n\nReturn\n(table) Normalized index object.\n\n\n\n\nread_index()\n\nMiniVisits.read_index({store_path})\n\nRead visit index from disk\n\nParameters\n{store_path} (string|nil) Path on the disk containing visit index data. Default: config.store.path. Notes:\n\nCan return nil if path is empty string or file is not readable.\nFile is sourced with dofile() as a regular Lua file.\n\n\n\nReturn\n(table|nil) Output of the file source.\n\n\n\n\nwrite_index()\n\nMiniVisits.write_index({store_path}, {index})\n\nWrite visit index to disk\nSteps:\n\nNormalize index with MiniVisits.normalize_index().\nEnsure path is valid (all parent directories are created, etc.).\nWrite index object to the path so that it is readable with MiniVisits.read_index().\n\n\nParameters\n{store_path} (string|nil) Path on the disk where to write visit index data. Default: config.store.path. Note: if empty string, nothing is written.\n{index} (table|nil) Index object to write to disk. Default: current session index.\n\n\n\n\nrename_in_index()\n\nMiniVisits.rename_in_index({path_from}, {path_to}, {index})\n\nRename path in index\nA helper to react for a path rename/move in order to preserve its visit data. It works both for file and directory paths.\nNotes:\n\nIt does not update current index, but returns a modified index object. Use MiniVisits.set_index() to make it current.\nUse only full paths.\nDo not append / to directory paths. Use same format as for files.\n\nAssuming path_from and path_to are variables containing full paths before and after rename/move, here is an example to update current index:\nlocal new_index = MiniVisits.rename_in_index(path_from, path_to)\nMiniVisits.set_index(new_index)\n\nParameters\n{path_from} (string) Full path to be renamed.\n{path_to} (string) Full path to be replaced with.\n{index} (table|nil) Index object inside which to perform renaming. Default: current session index.\n\n\nReturn\n(table) Index object with renamed path.\n\n\n\n\ngen_filter\n\nMiniVisits.gen_filter\n\nGenerate filter function\nThis is a table with function elements. Call to actually get specification.\n\n\n\ngen_filter.default()\n\nMiniVisits.gen_filter.default()\n\nDefault filter\nAlways returns true resulting in no actual filter.\n\nReturn\n(function) Visit filter function. See MiniVisits.config.list for more details.\n\n\n\n\ngen_filter.this_session()\n\nMiniVisits.gen_filter.this_session()\n\nFilter visits from current session\n\nReturn\n(function) Visit filter function. See MiniVisits.config.list for more details.\n\n\n\n\ngen_sort\n\nMiniVisits.gen_sort\n\nGenerate sort function\nThis is a table with function elements. Call to actually get specification.\n\n\n\ngen_sort.default()\n\nMiniVisits.gen_sort.default({opts})\n\nDefault sort\nSort paths using “robust frecency” approach. It relies on the rank operation: based on certain reference number for every item, assign it a number between 1 (best) and number of items (worst). Ties are dealt with “average rank” approach: each element with a same reference number is assigned an average rank among such elements. This way total rank sum depends only on number of paths.\nHere is an algorithm outline:\n\nRank paths based on frequency (count value): from most to least frequent.\nRank paths based on recency (latest value): from most to least recent.\nCombine ranks from previous steps with weights: score = (1 - w) * rank_frequency + w * rank_recency, where w is “recency weight”. The smaller this weight the less recency affects outcome.\n\nExamples:\n\nDefault recency weight 0.5 results into “robust frecency” sorting: it combines both frequency and recency. This is called a “robust frecency” because actual values don’t have direct effect on the outcome, only ordering matters. For example, if there is a very frequent file with count = 100 while all others have count = 5, it will not massively dominate the outcome as long as it is not very recent.\nHaving recency weight 1 results into “from most to least recent” sorting.\nHaving recency weight 0 results into “from most to least frequent” sorting.\n\n\nParameters\n{opts} (table|nil) Option. Possible fields:\n\n&lt;recency_weight&gt; (number) - a number between 0 and 1 for recency weight. Default: 0.5.\n\n\n\nReturn\n(function) Visit sort function. See MiniVisits.config.list for more details.\n\n\n\n\ngen_sort.z()\n\nMiniVisits.gen_sort.z()\n\nZ sort\nSort as in https://github.com/rupa/z.\n\nReturn\n(function) Visit sort function. See MiniVisits.config.list for more details.\n\n\n\n\ngen_normalize\n\nMiniVisits.gen_normalize\n\nGenerate normalize function\nThis is a table with function elements. Call to actually get specification.\n\n\n\ngen_normalize.default()\n\nMiniVisits.gen_normalize.default({opts})\n\nGenerate default normalize function\nSteps:\n\nPrune visits, i.e. remove outdated visits:\n\nIf count number of visits is below prune threshold, remove that visit entry from particular cwd (it can still be present in others).\nIf either first (cwd) or second (path) level key doesn’t represent an actual path on disk, remove the whole associated value.\nNOTE: if visit has any label, it is not automatically pruned.\n\nDecay visits, i.e. possibly make visits more outdated. This is an important part to the whole usability: together with pruning it results into automated removing of paths which were visited long ago and are not relevant.\nDecay is done per cwd if its total count values sum exceeds decay threshold. It is performed through multiplying each count by same coefficient so that the new total sum of count is equal to some smaller target value. Note: only two decimal places are preserved, so the sum might not be exact.\nPrune once more to ensure that there are no outdated paths after decay.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;decay_threshold&gt; (number) - decay threshold. Default: 1000.\n&lt;decay_target&gt; (number) - decay target. Default: 800.\n&lt;prune_threshold&gt; (number) - prune threshold. Default: 0.5.\n&lt;prune_paths&gt; (boolean) - whether to prune outdated paths. Default: true.\n\n\n\nReturn\n(function) Visit index normalize function. See “Store” in MiniVisits.config."
  },
  {
    "objectID": "mini.nvim/doc/mini-animate.html",
    "href": "mini.nvim/doc/mini-animate.html",
    "title": "mini.animate documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.animate Animate common Neovim actions\nMIT License Copyright (c) 2022 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nWorks out of the box with a single require('mini.animate').setup(). No extra mappings or commands needed.\nAnimate cursor movement inside same buffer by showing customizable path. See MiniAnimate.config.cursor for more details.\nAnimate scrolling with a series of subscrolls (“smooth scrolling”). See MiniAnimate.config.scroll for more details.\nAnimate window resize by gradually changing sizes of all windows. See MiniAnimate.config.resize for more details.\nAnimate window open/close with visually updating floating window. See MiniAnimate.config.open and MiniAnimate.config.close for more details.\nTimings for all actions can be customized independently. See MiniAnimate-timing for more details.\nAction animations can be enabled/disabled independently.\nAll animations are asynchronous/non-blocking and trigger a targeted event which can be used to perform actions after animation is done.\nMiniAnimate.animate() function which can be used to perform own animations.\n\nNotes:\n\nCursor movement is animated inside same window and buffer, not as cursor moves across the screen.\nScroll and resize animations are done with “side effects”: they actually change the state of what is animated (window view and sizes respectively). This has a downside of possibly needing extra work to account for asynchronous nature of animation (like adjusting certain mappings, etc.). See MiniAnimate.config.scroll and MiniAnimate.config.resize for more details.\n\n\nSetup\nThis module needs a setup with require('mini.animate').setup({}) (replace {} with your config table). It will create global Lua table MiniAnimate which you can use for scripting or manually (with :lua MiniAnimate.*).\nSee MiniAnimate.config for available config settings.\nYou can override runtime config settings (like config.modifiers) locally to buffer inside vim.b.minianimate_config which should have same structure as MiniAnimate.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nNeovide:\n\nNeovide is a standalone GUI which has more control over its animations. While ‘mini.animate’ works inside terminal emulator (with all its limitations, like lack of pixel-size control over animations).\nNeovide animates cursor movement across screen, while ‘mini.animate’ - as it moves across same buffer.\nNeovide has fixed number of animation effects per action, while ‘mini.animate’ is fully customizable.\n‘mini.animate’ implements animations for window open/close, while Neovide does not.\n\nedluffy/specs.nvim:\n\n‘mini.animate’ approaches cursor movement visualization via customizable path function (uses extmarks), while ‘specs.nvim’ can customize within its own visual effects (shading and floating window resizing).\n\nkarb94/neoscroll.nvim:\n\nScroll animation is triggered only inside dedicated mappings. ‘mini.animate’ animates scroll resulting from any window view change.\n\nanuvyklack/windows.nvim:\n\nResize animation is done only within custom commands and mappings, while ‘mini.animate’ animates any resize with appropriate values of ‘winheight’ / ‘winwidth’ and ‘winminheight’ / ‘winminwidth’).\n\n\n\n\nHighlight groups\n\nMiniAnimateCursor - highlight of cursor during its animated movement.\nMiniAnimateNormalFloat - highlight of floating window for open and close animations.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable, set vim.g.minianimate_disable (globally) or vim.b.minianimate_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nsetup()\n\nMiniAnimate.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniAnimate.config.\n\n\nUsage\nrequire('mini.animate').setup() -- use default config\n-- OR\nrequire('mini.animate').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniAnimate.config\n\n\nDefaults\nMiniAnimate.config = {\n  -- Cursor path\n  cursor = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: linear animation, total 250ms&gt;,\n\n    -- Path generator for visualized cursor movement\n    path = --&lt;function: implements shortest line path no longer than 1000&gt;,\n  },\n\n  -- Vertical scroll\n  scroll = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: linear animation, total 250ms&gt;,\n\n    -- Subscroll generator based on total scroll\n    subscroll = --&lt;function: implements equal scroll with at most 60 steps&gt;,\n  },\n\n  -- Window resize\n  resize = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: linear animation, total 250ms&gt;,\n\n    -- Subresize generator for all steps of resize animations\n    subresize = --&lt;function: implements equal linear steps&gt;,\n  },\n\n  -- Window open\n  open = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: linear animation, total 250ms&gt;,\n\n    -- Floating window config generator visualizing specific window\n    winconfig = --&lt;function: implements static window for 25 steps&gt;,\n\n    -- 'winblend' (window transparency) generator for floating window\n    winblend = --&lt;function: implements equal linear steps from 80 to 100&gt;,\n  },\n\n  -- Window close\n  close = {\n    -- Whether to enable this animation\n    enable = true,\n\n    -- Timing of animation (how steps will progress in time)\n    timing = --&lt;function: linear animation, total 250ms&gt;,\n\n    -- Floating window config generator visualizing specific window\n    winconfig = --&lt;function: implements static window for 25 steps&gt;,\n\n    -- 'winblend' (window transparency) generator for floating window\n    winblend = --&lt;function: implements equal linear steps from 80 to 100&gt;,\n  },\n}\n\n\nGeneral\n\nMiniAnimate-timing Every animation is a non-blockingly scheduled series of specific actions. They are executed in a sequence of timed steps controlled by timing option. It is a callable which, given next and total step numbers, returns wait time (in ms). See MiniAnimate.gen_timing for builtin timing functions. See MiniAnimate.animate() for more details about animation process.\nEvery animation can be enabled/disabled independently by setting enable option to true/false.\nMiniAnimate-done-event Every animation triggers custom User event when it is finished. It is named MiniAnimateDoneXxx with Xxx replaced by capitalized supported animation action name (like MiniAnimateDoneCursor). Use it to schedule some action after certain animation is completed. Alternatively, you can use MiniAnimate.execute_after() (usually preferred in mappings).\nEach animation has its main step generator which defines how particular animation is done. They all are callables which take some input data and return an array of step data. Length of that array determines number of animation steps. Outputs nil and empty table result in no animation.\n\n\n\nCursor\nMiniAnimate.config.cursor\nThis animation is triggered for each movement of cursor inside same window and buffer. Its visualization step consists from placing single extmark (see extmarks) at certain position. This extmark contains single space and is highlighted with MiniAnimateCursor highlight group.\nExact places of extmark and their number is controlled by path option. It is a callable which takes destination argument (2d integer point in (line, col) coordinates) and returns array of relative to (0, 0) places for extmark to be placed. Example:\n\nInput (2, -3) means cursor jumped 2 lines forward and 3 columns backward.\nOutput { {0, 0 }, { 0, -1 }, { 0, -2 }, { 0, -3 }, { 1, -3 } } means that path is first visualized along the initial line and then along final column.\n\nSee MiniAnimate.gen_path for builtin path generators.\nNotes:\n\nInput destination value is computed ignoring folds. This is by design as it helps better visualize distance between two cursor positions.\nOutputs of path generator resulting in a place where extmark can’t be placed are silently omitted during animation: this step won’t show any visualization.\n\nConfiguration example:\nlocal animate = require('mini.animate')\nanimate.setup({\n  cursor = {\n    -- Animate for 200 milliseconds with linear easing\n    timing = animate.gen_timing.linear({ duration = 200, unit = 'total' }),\n\n    -- Animate with shortest line for any cursor move\n    path = animate.gen_path.line({\n      predicate = function() return true end,\n    }),\n  }\n})\nAfter animation is done, MiniAnimateDoneCursor event is triggered.\n\n\nScroll\nMiniAnimate.config.scroll\nThis animation is triggered for each vertical scroll of current window. Its visualization step consists from performing a small subscroll which all in total will result into needed total scroll.\nExact subscroll values and their number is controlled by subscroll option. It is a callable which takes total_scroll argument (single non-negative integer) and returns array of non-negative integers each representing the amount of lines needed to be scrolled inside corresponding step. All subscroll values should sum to input total_scroll. Example:\n\nInput 5 means that total scroll consists from 5 lines (either up or down, which doesn’t matter).\nOutput of { 1, 1, 1, 1, 1 } means that there are 5 equal subscrolls.\n\nSee MiniAnimate.gen_subscroll for builtin subscroll generators.\nNotes:\n\nInput value of total_scroll is computed taking folds into account.\nAs scroll animation is essentially a precisely scheduled non-blocking subscrolls, this has two important interconnected consequences:\n\nIf another scroll is attempted during the animation, it is done based on the currently visible window view. Example: if user presses CTRL-D and then CTRL-U when animation is half done, window will not display the previous view half of ‘scroll’ above it. This especially affects mouse wheel scrolling, as each its turn results in a new scroll for number of lines defined by ‘mousescroll’. Tweak it to your liking.\nIt breaks the use of several relative scrolling commands in the same command. Use MiniAnimate.execute_after() to schedule action after reaching target window view. Example: a useful nnoremap n nzvzz mapping (consecutive application of n, zv, and zz) should be expressed in the following way:\n'&lt;Cmd&gt;lua vim.cmd(\"normal! n\"); ' ..\n  'MiniAnimate.execute_after(\"scroll\", \"normal! zvzz\")&lt;CR&gt;'\n\nDefault timing might conflict with scrolling via holding a key (like j or k with ‘wrap’ enabled) due to high key repeat rate: next scroll is done before first step of current one finishes. Resolve this by not scrolling like that or by ensuring maximum value of step duration to be lower than between repeated keys: set timing like function(_, n) return math.min(250/n, 10) end or use timing with constant step duration.\n\nConfiguration example:\nlocal animate = require('mini.animate')\nanimate.setup({\n  scroll = {\n    -- Animate for 200 milliseconds with linear easing\n    timing = animate.gen_timing.linear({ duration = 200, unit = 'total' }),\n\n    -- Animate equally but with at most 120 steps instead of default 60\n    subscroll = animate.gen_subscroll.equal({ max_output_steps = 120 }),\n  }\n})\nAfter animation is done, MiniAnimateDoneScroll event is triggered.\n\n\nResize\nMiniAnimate.config.resize\nThis animation is triggered for window resize while having same layout of same windows. For example, it won’t trigger when window is opened/closed or after something like CTRL-W_K. Its visualization step consists from setting certain sizes to all visible windows (last step being for “true” final sizes).\nExact window step sizes and their number is controlled by subresize option. It is a callable which takes sizes_from and sizes_to arguments (both tables with window id as keys and dimension table as values) and returns array of same shaped data. Example:\n\nInput:\n-- First\n{ [1000] = {width = 7, height = 5}, [1001] = {width = 7, height = 10} }\n-- Second\n{ [1000] = {width = 9, height = 5}, [1001] = {width = 5, height = 10} }\n-- Means window 1000 increased its width by 2 in expense of window 1001\nThe following output demonstrates equal resizing:\n{\n  { [1000] = {width = 8, height = 5}, [1001] = {width = 6, height = 10} },\n  { [1000] = {width = 9, height = 5}, [1001] = {width = 5, height = 10} },\n}\n\nSee MiniAnimate.gen_subresize for builtin subresize generators.\nNotes:\n\nAs resize animation is essentially a precisely scheduled non-blocking subresizes, this has two important interconnected consequences:\n\nIf another resize is attempted during the animation, it is done based on the currently visible window sizes. This might affect relative resizing.\nIt breaks the use of several relative resizing commands in the same command. Use MiniAnimate.execute_after() to schedule action after reaching target window sizes.\n\n\nConfiguration example:\nlocal is_many_wins = function(sizes_from, sizes_to)\n  return vim.tbl_count(sizes_from) &gt;= 3\nend\nlocal animate = require('mini.animate')\nanimate.setup({\n  resize = {\n    -- Animate for 200 milliseconds with linear easing\n    timing = animate.gen_timing.linear({ duration = 200, unit = 'total' }),\n\n    -- Animate only if there are at least 3 windows\n    subresize = animate.gen_subscroll.equal({ predicate = is_many_wins }),\n  }\n})\nAfter animation is done, MiniAnimateDoneResize event is triggered.\n\n\nWindow open/close\nMiniAnimate.config.open MiniAnimate.config.close\nThese animations are similarly triggered for regular (non-floating) window open/close. Their visualization step consists from drawing empty floating window with customizable config and transparency.\nExact window visualization characteristics are controlled by winconfig and winblend options.\nThe winconfig option is a callable which takes window id (window-ID) as input and returns an array of floating window configs (as in config argument of nvim_open_win()). Its length determines number of animation steps. Example:\n\nThe following output results into two animation steps with second being upper left quarter of a first:\n{\n  {\n    row      = 0,        col    = 0,\n    width    = 10,       height = 10,\n    relative = 'editor', anchor = 'NW',   focusable = false,\n    zindex   = 1,        border = 'none', style  = 'minimal',\n  },\n  {\n    row      = 0,        col    = 0,\n    width    = 5,        height = 5,\n    relative = 'editor', anchor = 'NW',   focusable = false,\n    zindex   = 1,        border = 'none', style  = 'minimal',\n  },\n}\n\nThe winblend option is similar to timing option: it is a callable which, given current and total step numbers, returns value of floating window’s ‘winblend’ option. Note, that it is called for current step (so starts from 0), as opposed to timing which is called before step. Example:\n\nFunction function(s, n) return 80 + 20 * s / n end results in linear transition from winblend value of 80 to 100.\n\nSee MiniAnimate.gen_winconfig for builtin window config generators. See MiniAnimate.gen_winblend for builtin window transparency generators.\nConfiguration example:\nlocal animate = require('mini.animate')\nanimate.setup({\n  open = {\n    -- Animate for 400 milliseconds with linear easing\n    timing = animate.gen_timing.linear({ duration = 400, unit = 'total' }),\n\n    -- Animate with wiping from nearest edge instead of default static one\n    winconfig = animate.gen_winconfig.wipe({ direction = 'from_edge' }),\n\n    -- Make bigger windows more transparent\n    winblend = animate.gen_winblend.linear({ from = 80, to = 100 }),\n  },\n\n  close = {\n    -- Animate for 400 milliseconds with linear easing\n    timing = animate.gen_timing.linear({ duration = 400, unit = 'total' }),\n\n    -- Animate with wiping to nearest edge instead of default static one\n    winconfig = animate.gen_winconfig.wipe({ direction = 'to_edge' }),\n\n    -- Make bigger windows more transparent\n    winblend = animate.gen_winblend.linear({ from = 100, to = 80 }),\n  },\n})\nAfter animation is done, MiniAnimateDoneOpen or MiniAnimateDoneClose event is triggered for open and close animation respectively.\n\n\n\n\nis_active()\n\nMiniAnimate.is_active({animation_type})\n\nCheck animation activity\n\nParameters\n{animation_type} (string) One of supported animation types (entries of MiniAnimate.config, like 'cursor', etc.).\n\n\nReturn\n(boolean) Whether the animation is currently active.\n\n\n\n\nexecute_after()\n\nMiniAnimate.execute_after({animation_type}, {action})\n\nExecute action after some animation is done\nExecute action immediately if animation is not active (checked with MiniAnimate.is_active()). Else, schedule its execution until after animation is done (on corresponding “done event”, see MiniAnimate-done-event).\nMostly meant to be used inside mappings.\nExample:\nA useful nnoremap n nzvzz mapping (consecutive application of n, zv, and zz) should be expressed in the following way:\n'&lt;Cmd&gt;lua vim.cmd(\"normal! n\"); ' ..\n  'MiniAnimate.execute_after(\"scroll\", \"normal! zvzz\")&lt;CR&gt;'\n\nParameters\n{animation_type} (string) One of supported animation types (as in MiniAnimate.is_active()).\n{action} (string|function) Action to be executed. If string, executed as command (via vim.cmd()).\n\n\n\n\nanimate()\n\nMiniAnimate.animate({step_action}, {step_timing}, {opts})\n\nAnimate action\nThis is equivalent to asynchronous execution of the following algorithm:\n\nCall step_action(0) immediately after calling this function. Stop if action returned false or nil.\nWait step_timing(1) milliseconds.\nCall step_action(1). Stop if it returned false or nil.\nWait step_timing(2) milliseconds.\nCall step_action(2). Stop if it returned false or nil.\n…\n\nNotes:\n\nAnimation is also stopped on action error or if maximum number of steps is reached.\nAsynchronous execution is done with uv.new_timer(). It only allows integer parts as repeat value. This has several implications:\n\nOutputs of step_timing() are accumulated in order to preserve total execution time.\nAny wait time less than 1 ms means that action will be executed immediately.\n\n\n\nParameters\n{step_action} (function|table) Callable which takes step (integer 0, 1, 2, etc. indicating current step) and executes some action. Its return value defines when animation should stop: values false and nil (equivalent to no explicit return) stop animation timer; any other continues it.\n{step_timing} (function|table) Callable which takes step (integer 1, 2, etc. indicating next step) and returns how many milliseconds to wait before executing this step action.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;max_steps&gt; - Maximum value of allowed step to execute. Default: 10000000.\n\n\n\n\n\ngen_timing\n\nMiniAnimate.gen_timing\n\nGenerate animation timing\nEach field corresponds to one family of progression which can be customized further by supplying appropriate arguments.\nThis is a table with function elements. Call to actually get timing function.\nExample:\nlocal animate = require('mini.animate')\nanimate.setup({\n  cursor = {\n    timing = animate.gen_timing.linear({ duration = 100, unit = 'total' })\n  },\n})\n\nSee also\nMiniIndentscope.gen_animation for similar concept in ‘mini.indentscope’.\n\n\n\n\ngen_timing.none()\n\nMiniAnimate.gen_timing.none()\n\nGenerate timing with no animation\nShow final result immediately. Usually better to use enable field in config if you want to disable animation.\n\n\n\ngen_timing.linear()\n\nMiniAnimate.gen_timing.linear({opts})\n\nGenerate timing with linear progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Timing function (see MiniAnimate-timing).\n\n\n\n\ngen_timing.quadratic()\n\nMiniAnimate.gen_timing.quadratic({opts})\n\nGenerate timing with quadratic progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Timing function (see MiniAnimate-timing).\n\n\n\n\ngen_timing.cubic()\n\nMiniAnimate.gen_timing.cubic({opts})\n\nGenerate timing with cubic progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Timing function (see MiniAnimate-timing).\n\n\n\n\ngen_timing.quartic()\n\nMiniAnimate.gen_timing.quartic({opts})\n\nGenerate timing with quartic progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Timing function (see MiniAnimate-timing).\n\n\n\n\ngen_timing.exponential()\n\nMiniAnimate.gen_timing.exponential({opts})\n\nGenerate timing with exponential progression\n\nParameters\n{opts} (table|nil) Options that control progression. Possible keys:\n\n&lt;easing&gt; (string) - a subtype of progression. One of “in” (accelerating from zero speed), “out” (decelerating to zero speed), “in-out” (default; accelerating halfway, decelerating after).\n&lt;duration&gt; (number) - duration (in ms) of a unit. Default: 20.\n&lt;unit&gt; (string) - which unit’s duration opts.duration controls. One of “step” (default; ensures average duration of step to be opts.duration) or “total” (ensures fixed total duration regardless of scope’s range).\n\n\n\nReturn\n(function) Timing function (see MiniAnimate-timing).\n\n\n\n\ngen_path\n\nMiniAnimate.gen_path\n\nGenerate cursor animation path\nFor more information see MiniAnimate.config.cursor.\nThis is a table with function elements. Call to actually get generator.\nExample:\nlocal animate = require('mini.animate')\nanimate.setup({\n  cursor = {\n    -- Animate with line-column angle instead of shortest line\n    path = animate.gen_path.angle(),\n  }\n})\n\n\n\ngen_path.line()\n\nMiniAnimate.gen_path.line({opts})\n\nGenerate path as shortest line\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes destination as input and returns boolean value indicating whether animation should be done. Default: false if destination is within one line of origin (reduces flickering), true otherwise.\n&lt;max_output_steps&gt; (number) - maximum number of steps in output. Default: 1000.\n\n\n\nReturn\n(function) Path function (see MiniAnimate.config.cursor).\n\n\n\n\ngen_path.angle()\n\nMiniAnimate.gen_path.angle({opts})\n\nGenerate path as line/column angle\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes destination as input and returns boolean value indicating whether animation should be done. Default: false if destination is within one line of origin (reduces flickering), true otherwise.\n&lt;max_output_steps&gt; (number) - maximum number of steps per side in output. Default: 1000.\n&lt;first_direction&gt; (string) - one of \"horizontal\" (default; animates across initial line first) or \"vertical\" (animates across initial column first).\n\n\n\nReturn\n(function) Path function (see MiniAnimate.config.cursor).\n\n\n\n\ngen_path.walls()\n\nMiniAnimate.gen_path.walls({opts})\n\nGenerate path as closing walls at final position\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes destination as input and returns boolean value indicating whether animation should be done. Default: false if destination is within one line of origin (reduces flickering), true otherwise.\n&lt;width&gt; (number) - initial width of left and right walls. Default: 10.\n\n\n\nReturn\n(function) Path function (see MiniAnimate.config.cursor).\n\n\n\n\ngen_path.spiral()\n\nMiniAnimate.gen_path.spiral({opts})\n\nGenerate path as diminishing spiral at final position\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes destination as input and returns boolean value indicating whether animation should be done. Default: false if destination is within one line of origin (reduces flickering), true otherwise.\n&lt;width&gt; (number) - initial width of spiral. Default: 2.\n\n\n\nReturn\n(function) Path function (see MiniAnimate.config.cursor).\n\n\n\n\ngen_subscroll\n\nMiniAnimate.gen_subscroll\n\nGenerate scroll animation subscroll\nFor more information see MiniAnimate.config.scroll.\nThis is a table with function elements. Call to actually get generator.\nExample:\nlocal animate = require('mini.animate')\nanimate.setup({\n  scroll = {\n    -- Animate equally but with 120 maximum steps instead of default 60\n    subscroll = animate.gen_subscroll.equal({ max_output_steps = 120 }),\n  }\n})\n\n\n\ngen_subscroll.equal()\n\nMiniAnimate.gen_subscroll.equal({opts})\n\nGenerate subscroll with equal steps\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes total_scroll as input and returns boolean value indicating whether animation should be done. Default: false if total_scroll is 1 or less (reduces unnecessary waiting), true otherwise.\n&lt;max_output_steps&gt; (number) - maximum number of subscroll steps in output. Adjust this to reduce computations in expense of reduced smoothness. Default: 60.\n\n\n\nReturn\n(function) Subscroll function (see MiniAnimate.config.scroll).\n\n\n\n\ngen_subresize\n\nMiniAnimate.gen_subresize\n\nGenerate resize animation subresize\nFor more information see MiniAnimate.config.resize.\nThis is a table with function elements. Call to actually get generator.\nExample:\nlocal is_many_wins = function(sizes_from, sizes_to)\n  return vim.tbl_count(sizes_from) &gt;= 3\nend\nlocal animate = require('mini.animate')\nanimate.setup({\n  resize = {\n    -- Animate only if there are at least 3 windows\n    subresize = animate.gen_subresize.equal({ predicate = is_many_wins }),\n  }\n})\n\n\n\ngen_subresize.equal()\n\nMiniAnimate.gen_subresize.equal({opts})\n\nGenerate subresize with equal steps\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes sizes_from and sizes_to as input and returns boolean value indicating whether animation should be done. Default: always true.\n\n\n\nReturn\n(function) Subresize function (see MiniAnimate.config.resize).\n\n\n\n\ngen_winconfig\n\nMiniAnimate.gen_winconfig\n\nGenerate open/close animation winconfig\nFor more information see MiniAnimate.config.open or MiniAnimate.config.close.\nThis is a table with function elements. Call to actually get generator.\nExample:\nlocal is_not_single_window = function(win_id)\n  local tabpage_id = vim.api.nvim_win_get_tabpage(win_id)\n  return #vim.api.nvim_tabpage_list_wins(tabpage_id) &gt; 1\nend\nlocal animate = require('mini.animate')\nanimate.setup({\n  open = {\n    -- Animate with wiping from nearest edge instead of default static one\n    -- and only if it is not a single window in tabpage\n    winconfig = animate.gen_winconfig.wipe({\n      predicate = is_not_single_window,\n      direction = 'from_edge',\n    }),\n  },\n  close = {\n    -- Animate with wiping to nearest edge instead of default static one\n    -- and only if it is not a single window in tabpage\n    winconfig = animate.gen_winconfig.wipe({\n      predicate = is_not_single_window,\n      direction = 'to_edge',\n    }),\n  },\n})\n\n\n\ngen_winconfig.static()\n\nMiniAnimate.gen_winconfig.static({opts})\n\nGenerate winconfig for static floating window\nThis will result into floating window statically covering whole target window.\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes win_id as input and returns boolean value indicating whether animation should be done. Default: always true.\n&lt;n_steps&gt; (number) - number of output steps, all with same config. Useful to tweak smoothness of transparency animation (done inside winblend config option). Default: 25.\n\n\n\nReturn\n(function) Winconfig function (see MiniAnimate.config.open or MiniAnimate.config.close).\n\n\n\n\ngen_winconfig.center()\n\nMiniAnimate.gen_winconfig.center({opts})\n\nGenerate winconfig for center-focused animated floating window\nThis will result into floating window growing from or shrinking to the target window center.\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes win_id as input and returns boolean value indicating whether animation should be done. Default: always true.\n&lt;direction&gt; (string) - one of \"to_center\" (default; window will shrink from full coverage to center) or \"from_center\" (window will grow from center to full coverage).\n\n\n\nReturn\n(function) Winconfig function (see MiniAnimate.config.open or MiniAnimate.config.close).\n\n\n\n\ngen_winconfig.wipe()\n\nMiniAnimate.gen_winconfig.wipe({opts})\n\nGenerate winconfig for wiping animated floating window\nThis will result into floating window growing from or shrinking to the nearest edge. This also takes into account the split type of target window: vertically split window will progress towards vertical edge; horizontally - towards horizontal.\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;predicate&gt; (function) - a callable which takes win_id as input and returns boolean value indicating whether animation should be done. Default: always true.\n&lt;direction&gt; (string) - one of \"to_edge\" (default; window will shrink from full coverage to nearest edge) or \"from_edge\" (window will grow from edge to full coverage).\n\n\n\nReturn\n(function) Winconfig function (see MiniAnimate.config.open or MiniAnimate.config.close).\n\n\n\n\ngen_winblend\n\nMiniAnimate.gen_winblend\n\nGenerate open/close animation winblend progression\nFor more information see MiniAnimate.config.open or MiniAnimate.config.close.\nThis is a table with function elements. Call to actually get transparency function.\nExample:\nlocal animate = require('mini.animate')\nanimate.setup({\n  open = {\n    -- Change transparency from 60 to 80 instead of default 80 to 100\n    winblend = animate.gen_winblend.linear({ from = 60, to = 80 }),\n  },\n  close = {\n    -- Change transparency from 60 to 80 instead of default 80 to 100\n    winblend = animate.gen_winblend.linear({ from = 60, to = 80 }),\n  },\n})\n\n\n\ngen_winblend.linear()\n\nMiniAnimate.gen_winblend.linear({opts})\n\nGenerate linear winblend progression\n\nParameters\n{opts} (table|nil) Options that control generator. Possible keys:\n\n&lt;from&gt; (number) - initial value of ‘winblend’.\n&lt;to&gt; (number) - final value of ‘winblend’.\n\n\n\nReturn\n(function) Winblend function (see MiniAnimate.config.open or MiniAnimate.config.close)."
  },
  {
    "objectID": "mini.nvim/doc/mini-jump.html",
    "href": "mini.nvim/doc/mini-jump.html",
    "title": "mini.jump documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.jump Jump to next/previous single character\nMIT License Copyright (c) 2021 Evgeni Chasnovski, Adam Blažek\n\n\nModule\nFeatures:\n\nExtend f, F, t, T to work on multiple lines.\nRepeat jump by pressing f, F, t, T again. It is reset when cursor moved as a result of not jumping or timeout after idle time (duration customizable).\nHighlight (after customizable delay) all possible target characters and stop it after some (customizable) idle time.\nNormal, Visual, and Operator-pending (with full dot-repeat) modes are supported.\n\nThis module follows vim’s ‘ignorecase’ and ‘smartcase’ options. When ‘ignorecase’ is set, f, F, t, T will match case-insensitively. When ‘smartcase’ is also set, f, F, t, T will only match lowercase characters case-insensitively.\n\nSetup\nThis module needs a setup with require('mini.jump').setup({}) (replace {} with your config table). It will create global Lua table MiniJump which you can use for scripting or manually (with :lua MiniJump.*).\nSee MiniJump.config for config structure and default values.\nYou can override runtime config settings locally to buffer inside vim.b.minijump_config which should have same structure as MiniJump.config. See mini.nvim-buffer-local-config for more details.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nHighlight groups\n\nMiniJump - all possible cursor positions.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable core functionality, set vim.g.minijump_disable (globally) or vim.b.minijump_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nEvents\nTo allow user customization and integration of external tools, certain User autocommand events are triggered under common circumstances:\n\nMiniJumpGetTarget - before asking user for the target. Use MiniJump.state for more information about the upcoming jump.\nMiniJumpStart - after jumping has started.\nMiniJumpJump - after performing a jump.\nMiniJumpStop - after jumping is stopped.\n\n\n\n\nsetup()\n\nMiniJump.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniJump.config.\n\n\nUsage\nrequire('mini.jump').setup() -- use default config\n-- OR\nrequire('mini.jump').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniJump.config\n\n\nDefaults\nMiniJump.config = {\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    forward = 'f',\n    backward = 'F',\n    forward_till = 't',\n    backward_till = 'T',\n    repeat_jump = ';',\n  },\n\n  -- Delay values (in ms) for different functionalities. Set any of them to\n  -- a very big number (like 10^7) to virtually disable.\n  delay = {\n    -- Delay between jump and highlighting all possible jumps\n    highlight = 250,\n\n    -- Delay between jump and automatic stop if idle (no jump is done)\n    idle_stop = 10000000,\n  },\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}\n\n\n\n\nstate\n\nMiniJump.state\n\nData about jumping state\nIt stores various information used in this module. All elements, except jumping, is about the latest jump. They are used as default values for similar arguments.\n\nUsage\nThis can be used to define mappings which depend on state; either as a standalone mapping or part of MiniKeymap.map_multistep(). For example:\n-- Stop jumping after pressing `&lt;Esc&gt;`\nlocal jump_stop = function()\n  if not MiniJump.state.jumping then return '&lt;Esc&gt;' end\n  MiniJump.stop_jumping()\nend\nlocal opts = { expr = true, desc = 'Stop jumping' }\nvim.keymap.set({ 'n', 'x', 'o' }, '&lt;Esc&gt;', jump_stop, opts)\n\n\nClass\n{JumpingState}\n\n\nFields\n{target} (string|nil) The string to jump to.\n{backward} (boolean|nil) Whether to jump backward.\n{till} (boolean|nil) Whether to jump just before/after the match instead of exactly on target. This includes positioning cursor past the end of previous/current line. Note that with backward jump this might lead to cursor being on target if can’t be put past the line.\n{n_times} (number|nil) Number of times to perform consecutive jumps.\n{mode} (string) Mode of latest jump (output of mode() with non-zero argument).\n{jumping} (boolean) Whether module is currently in “jumping mode”: usage of MiniJump.smart_jump() and all mappings won’t require target.\nInitial values:\nMiniJump.state = {\n  target = nil,\n  backward = false,\n  till = false,\n  n_times = 1,\n  mode = nil,\n  jumping = false,\n}\n\n\n\n\njump()\n\nMiniJump.jump({target}, {backward}, {till}, {n_times})\n\nJump to target\nTakes a string and jumps to its first occurrence in desired direction.\nAll default values are taken from MiniJump.state to emulate latest jump.\n\nParameters\n{target} (string|nil) The string to jump to.\n{backward} (boolean|nil) Whether to jump backward.\n{till} (boolean|nil) Whether to jump just before/after the match instead of exactly on target. This includes positioning cursor past the end of previous/current line. Note that with backward jump this might lead to cursor being on target if can’t be put past the line.\n{n_times} (number|nil) Number of times to perform consecutive jumps.\n\n\n\n\nsmart_jump()\n\nMiniJump.smart_jump({backward}, {till})\n\nMake smart jump\nIf the last movement was a jump, perform another jump with the same target. Otherwise, wait for a target input (via getcharstr()). Respects v:count.\nAll default values are taken from MiniJump.state to emulate latest jump.\n\nParameters\n{backward} (boolean|nil) Whether to jump backward.\n{till} (boolean|nil) Whether to jump just before/after the match instead of exactly on target. This includes positioning cursor past the end of previous/current line. Note that with backward jump this might lead to cursor being on target if can’t be put past the line.\n\n\n\n\nstop_jumping()\n\nMiniJump.stop_jumping()\n\nStop jumping\nRemoves highlights (if any) and forces the next smart jump to prompt for the target. Automatically called on appropriate Neovim events."
  },
  {
    "objectID": "mini.nvim/doc/mini-files.html",
    "href": "mini.nvim/doc/mini-files.html",
    "title": "mini.files documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.files Navigate and manipulate file system\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nNavigate file system using column view (Miller columns) to display nested directories. See MiniFiles-navigation for overview.\nOpt-in preview of file or directory under cursor.\nManipulate files and directories by editing text buffers: create, delete, copy, rename, move. See MiniFiles-manipulation for overview.\nUse as default file explorer instead of netrw.\nConfigurable:\n\nFilter/prefix/sort of file system entries.\nMappings used for common explorer actions.\nUI options: whether to show preview of file/directory under cursor, etc.\nBookmarks for quicker navigation.\n\n\nWhat it doesn’t do:\n\nTry to be replacement of system file explorer. It is mostly designed to be used within Neovim to quickly explore file system structure, open files, and perform some quick file system edits.\nWork on remote locations. Only local file system is supported.\nProvide built-in interactive toggle of content filter and sort. See MiniFiles-examples for some common examples.\nProvide out of the box extra information like git or diagnostic status. This can be achieved by setting extmarks on appropriate event(s) (see MiniFiles-events)\n\nNotes:\n\nThis module is written and thoroughly tested on Linux. Support for other platform/OS (like Windows or MacOS) is a goal, but there is no guarantee.\nThis module silently reacts to not enough permissions:\n\nIn case of missing file, check its or its parent read permissions.\nIn case of no manipulation result, check write permissions.\n\n\n\nDependencies\nSuggested dependencies (provide extra functionality, will work without them):\n\nEnabled mini.icons module to show icons near file/directory names. Falls back to nvim-tree/nvim-web-devicons plugin or uses default icons.\n\n\n\nSetup\nThis module needs a setup with require('mini.files').setup({}) (replace {} with your config table). It will create global Lua table MiniFiles which you can use for scripting or manually (with :lua MiniFiles.*).\nSee MiniFiles.config for available config settings.\nYou can override runtime config settings (like mappings or window options) locally to buffer inside vim.b.minifiles_config which should have same structure as MiniFiles.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nnvim-tree/nvim-tree.lua:\n\nProvides tree view of file system, while this module uses column view.\nFile system manipulation is done with custom set of mappings for each action, while this module is designed to do that by editing text.\nHas more out of the box functionality with extra configuration, while this module has not (by design).\n\nstevearc/oil.nvim:\n\nUses single window to show information only about currently explored directory, while this module uses column view to show whole currently explored branch.\nAlso uses text editing to manipulate file system entries.\nCan work for remote file systems, while this module can not (by design).\n\nnvim-neo-tree/neo-tree.nvim:\n\nCompares to this module mostly the same as ‘nvim-tree/nvim-tree.lua’.\n\n\n\n\nHighlight groups\n\nMiniFilesBorder - border of regular windows.\nMiniFilesBorderModified - border of windows showing modified buffer.\nMiniFilesCursorLine - cursor line in explorer windows.\nMiniFilesDirectory - text and icon representing directory.\nMiniFilesFile - text representing file.\nMiniFilesNormal - basic foreground/background highlighting.\nMiniFilesTitle - title of regular windows.\nMiniFilesTitleFocused - title of focused window.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nThis plugin provides only manually started functionality, so no disabling is available.\n\n\n\n\nNavigation\nEvery navigation starts by calling MiniFiles.open(), either directly or via mapping (see its help for examples of some common scenarios). It will show an explorer consisting of side-by-side floating windows with the following principles:\n\nExplorer shows one branch of nested directories at a time.\nExplorer consists from several windows:\n\nEach window displays entries of a single directory in a modifiable scratch buffer.\nWindows are organized left to right: for any particular window the left neighbor is its parent directory and right neighbor - its child.\n\nExplorer windows are the viewport to some part of current branch, meaning that their opening/closing does not affect the branch. This matters, for example, if there are more elements in the branch than can be shown windows.\nEvery buffer line represents separate file system entry following certain format (not visible for users by default; set ‘conceallevel’ to 0 to see it)\nOnce directory is shown, its buffer is not updated automatically following external file system changes. Manually use MiniFiles.synchronize() for that.\n\nAfter opening explorer, in-buffer navigation is done the same way as any regular buffer, except without some keys reserved for built-in actions.\nMost common ways to navigate are:\n\nPress j to move cursor onto next (lower) entry in current directory.\nPress k to move cursor onto previous (higher) entry in current directory.\nPress l to expand entry under cursor (see “Go in” action).\nPress h to focus on parent directory (see “Go out” action).\n\nCursor positions in each directory buffer are tracked and saved during navigation. This allows for more convenient repeated navigation to some previously visited branch.\nAvailable built-in actions (see “Details” for more information):\n| Action      | Keys | Description                                    |\n|-------------|------|------------------------------------------------|\n| Close       |  q   | Close explorer                                 |\n|-------------|------|------------------------------------------------|\n| Go in       |  l   | Expand entry (show directory or open file)     |\n|-------------|------|------------------------------------------------|\n| Go in plus  |  L   | Expand entry plus extra action                 |\n|-------------|------|------------------------------------------------|\n| Go out      |  h   | Focus on parent directory                      |\n|-------------|------|------------------------------------------------|\n| Go out plus |  H   | Focus on parent directory plus extra action    |\n|-------------|------|------------------------------------------------|\n| Go to mark  |  '   | Jump to bookmark (waits for single key id)     |\n|-------------|------|------------------------------------------------|\n| Set mark    |  m   | Set bookmark (waits for single key id)         |\n|-------------|------|------------------------------------------------|\n| Reset       | &lt;BS&gt; | Reset current explorer                         |\n|-------------|------|------------------------------------------------|\n| Reveal cwd  |  @   | Reset current current working directory        |\n|-------------|------|------------------------------------------------|\n| Show help   |  g?  | Show help window                               |\n|-------------|------|------------------------------------------------|\n| Synchronize |  =   | Synchronize user edits and/or external changes |\n|-------------|------|------------------------------------------------|\n| Trim left   |  &lt;   | Trim left part of branch                       |\n|-------------|------|------------------------------------------------|\n| Trim right  |  &gt;   | Trim right part of branch                      |\n|-------------|------|------------------------------------------------|\nDetails:\n\n“Go in”:\n\nAlways opens file in the latest window before MiniFiles.open() call.\nNever closes explorer.\nWorks in linewise Visual mode to expand multiple entries.\n\n“Go in plus” is regular “Go in” but closes explorer after opening a file.\n“Go out plus” is regular “Go out” but trims right part of branch.\n“Set mark” and “Go to mark” both wait for user to press a single character of a bookmark id. Example: ma sets directory path of focused window as bookmark “a”; 'a jumps (sets as whole branch) to bookmark “a”. Special bookmark “’” always points to path before the latest bookmark jump.\n“Reset” focuses only on “anchor” directory (the one used to open current explorer) and resets all stored directory cursor positions.\n“Reveal cwd” extends branch to include current-directory. If it is not an ancestor of the current branch, nothing is done.\n“Show help” results into new window with helpful information about current explorer (like buffer mappings and bookmarks). Press q to close it.\n“Synchronize” parses user edits in directory buffers, applies them (after confirmation), and updates all directory buffers with the most relevant file system information. Can also be used without user edits to show up to date file system entries. See MiniFiles-manipulation for more info about file system manipulation.\n“Trim left” and “Trim right” trim parts of the whole branch, not only its currently visible parts.\n\nNotes:\n\nEach action has exported function with more details about it.\nKeys can be configured with mappings table of MiniFiles.config.\n\n\n\n\nManipulation\nFile system manipulation is done by editing text inside directory buffers, which are shown inside dedicated window(s). See MiniFiles-navigation for more information about navigating to a particular directory.\nGeneral workflow:\n\nNavigate to the directory in which manipulation should be done.\nEdit buffer in the way representing file system action.\nRepeat previous steps until all necessary file system actions are recorded. Note: even if directory buffer is hidden, its modifications are preserved, so you can navigate in and out of directory with modified buffer.\nExecute MiniFiles.synchronize() (default key is =). This will prompt confirmation dialog listing all file system actions (per directory) it is about to perform. READ IT CAREFULLY.\nConfirm by pressing y / &lt;CR&gt; (apply edits and update buffers) or don’t confirm by pressing n / &lt;Esc&gt; (update buffers without applying edits).\n\nNote: prefer small and not related steps with more frequent synchronization over single complex manipulation. There are (known) cases which won’t work.\n\nHow does it work\nAll manipulation functionality is powered by creating and keeping track of path indexes: text of the form /xxx (xxx is the number path index) placed at the start of every line representing file system entry.\nBy default they are hidden as concealed text (along with prefix separators) for more convenience but you can see them by setting ‘conceallevel’ to 0. DO NOT modify text to the left of entry name.\nDuring synchronization, actual text for entry name is compared to path index at that line (if present) to deduce which file system action to perform. Note that order of text manipulation steps does not affect performed actions.\n\n\nSupported file system actions\n\nCreate\n\nCreate file by creating new line with file name (including extension).\nCreate directory by creating new line with directory name followed by /.\nCreate file or directory inside nested directories by creating new line with text like ‘dir/nested-dir/’ or ‘dir/nested-dir/file’. Always use / on any OS.\n\n\n\nDelete\n\nDelete file or directory by deleting whole line describing it.\nIf options.permanent_delete is true, delete is permanent. Otherwise file system entry is moved to a module-specific trash directory (see MiniFiles.config for more details).\n\n\n\nRename\n\nRename file or directory by editing its name (not icon or path index to the left of it).\nWith default mappings for h / l it might be not convenient to rename only part of an entry. You can adopt any of the following approaches:\n\nUse different motions, like $, e, f, etc.\nGo into Insert mode and navigate inside it.\nChange mappings to be more suited for manipulation and not navigation. See “Mappings” section in MiniFiles.config.\n\nIt is not needed to end directory name with /.\nAppending / to a file name will delete it and create empty directory with the same name.\nCyclic renames (“a” to “b” and “b” to “a”) are not supported.\n\n\n\nCopy\n\nCopy file or directory by copying whole line describing it and pasting it inside buffer of target directory.\nChange of target path is allowed. Edit only entry name in target location (not icon or path index to the left of it).\nCopying inside same parent directory is supported only if target path has different name.\nCopying inside child directory is supported.\n\n\n\nMove\n\nMove file or directory by cutting whole line describing it and then pasting it inside target directory.\nChange of target path is allowed. Edit only entry name in target location (not icon or path index to the left of it).\nMoving directory inside itself is not supported.\n\n\n\n\n\n\nEvents\nTo allow user customization and integration of external tools, certain User autocommand events are triggered under common circumstances.\n\nUI events\n\nMiniFilesExplorerOpen - just after explorer finishes opening.\nMiniFilesExplorerClose - just before explorer starts closing.\nMiniFilesBufferCreate - when buffer is created to show a particular directory/file. Triggered once per path during explorer session. Can be used to create buffer-local mappings.\nMiniFilesBufferUpdate - when path buffer is updated with new content. Can be used for integrations to set useful extmarks.\nMiniFilesWindowOpen - when new window is opened. Can be used to set window-local settings (like border, ‘winblend’, etc.)\nMiniFilesWindowUpdate - when a window is updated. Triggers VERY frequently. At least after every cursor movement and “go in” / “go out” action.\n\nCallback for each buffer/window UI event will receive &lt;data&gt; field (see nvim_create_autocmd()) with the following information:\n\n&lt;buf_id&gt; - index of target buffer.\n&lt;win_id&gt; - index of target window. Can be nil, like in MiniFilesBufferCreate and buffer’s first MiniFilesBufferUpdate as they are triggered before window is created.\n\n\n\nFile action events\n\nMiniFilesActionCreate - after entry is successfully created.\nMiniFilesActionDelete - after entry is successfully deleted.\nMiniFilesActionRename - after entry is successfully renamed.\nMiniFilesActionCopy - after entry is successfully copied.\nMiniFilesActionMove - after entry is successfully moved.\n\nCallback for each file action event will receive data field (see nvim_create_autocmd()) with the following information:\n\n&lt;action&gt; - string with action name.\n&lt;from&gt; - full path of entry before action (nil for “create” action).\n&lt;to&gt; - full path of entry after action (nil for permanent “delete” action).\n\n\n\n\n\nExamples\n\nToggle explorer\nUse a combination of MiniFiles.open() and MiniFiles.close():\nlocal minifiles_toggle = function(...)\n  if not MiniFiles.close() then MiniFiles.open(...) end\nend\n\n\nCustomize windows\nFor most of the common customizations using MiniFilesWindowOpen event autocommand is the suggested approach:\nvim.api.nvim_create_autocmd('User', {\n  pattern = 'MiniFilesWindowOpen',\n  callback = function(args)\n    local win_id = args.data.win_id\n\n    -- Customize window-local settings\n    vim.wo[win_id].winblend = 50\n    local config = vim.api.nvim_win_get_config(win_id)\n    config.border, config.title_pos = 'double', 'right'\n    vim.api.nvim_win_set_config(win_id, config)\n  end,\n})\nHowever, some parts (like window title and height) of window config are later updated internally. Use MiniFilesWindowUpdate event for them:\nvim.api.nvim_create_autocmd('User', {\n  pattern = 'MiniFilesWindowUpdate',\n  callback = function(args)\n    local config = vim.api.nvim_win_get_config(args.data.win_id)\n\n    -- Ensure fixed height\n    config.height = 10\n\n    -- Ensure no title padding\n    local n = #config.title\n    config.title[1][1] = config.title[1][1]:gsub('^ ', '')\n    config.title[n][1] = config.title[n][1]:gsub(' $', '')\n\n    vim.api.nvim_win_set_config(args.data.win_id, config)\n  end,\n})\n\n\nCustomize icons\nUse different directory icon (if you don’t use mini.icons):\nlocal my_prefix = function(fs_entry)\n  if fs_entry.fs_type == 'directory' then\n    -- NOTE: it is usually a good idea to use icon followed by space\n    return ' ', 'MiniFilesDirectory'\n  end\n  return MiniFiles.default_prefix(fs_entry)\nend\n\nrequire('mini.files').setup({ content = { prefix = my_prefix } })\nShow no icons:\nrequire('mini.files').setup({ content = { prefix = function() end } })\n\n\nCreate mapping to show/hide dot-files\nCreate an autocommand for MiniFilesBufferCreate event which calls MiniFiles.refresh() with explicit content.filter functions:\nlocal show_dotfiles = true\n\nlocal filter_show = function(fs_entry) return true end\n\nlocal filter_hide = function(fs_entry)\n  return not vim.startswith(fs_entry.name, '.')\nend\n\nlocal toggle_dotfiles = function()\n  show_dotfiles = not show_dotfiles\n  local new_filter = show_dotfiles and filter_show or filter_hide\n  MiniFiles.refresh({ content = { filter = new_filter } })\nend\n\nvim.api.nvim_create_autocmd('User', {\n  pattern = 'MiniFilesBufferCreate',\n  callback = function(args)\n    local buf_id = args.data.buf_id\n    -- Tweak left-hand side of mapping to your liking\n    vim.keymap.set('n', 'g.', toggle_dotfiles, { buffer = buf_id })\n  end,\n})\n\n\nCreate mappings to modify target window via split\nCombine MiniFiles.get_explorer_state() and MiniFiles.set_target_window():\nlocal map_split = function(buf_id, lhs, direction)\n  local rhs = function()\n    -- Make new window and set it as target\n    local cur_target = MiniFiles.get_explorer_state().target_window\n    local new_target = vim.api.nvim_win_call(cur_target, function()\n      vim.cmd(direction .. ' split')\n      return vim.api.nvim_get_current_win()\n    end)\n\n    MiniFiles.set_target_window(new_target)\n\n    -- This intentionally doesn't act on file under cursor in favor of\n    -- explicit \"go in\" action (`l` / `L`). To immediately open file,\n    -- add appropriate `MiniFiles.go_in()` call instead of this comment.\n  end\n\n  -- Adding `desc` will result into `show_help` entries\n  local desc = 'Split ' .. direction\n  vim.keymap.set('n', lhs, rhs, { buffer = buf_id, desc = desc })\nend\n\nvim.api.nvim_create_autocmd('User', {\n  pattern = 'MiniFilesBufferCreate',\n  callback = function(args)\n    local buf_id = args.data.buf_id\n    -- Tweak keys to your liking\n    map_split(buf_id, '&lt;C-s&gt;', 'belowright horizontal')\n    map_split(buf_id, '&lt;C-v&gt;', 'belowright vertical')\n    map_split(buf_id, '&lt;C-t&gt;', 'tab')\n  end,\n})\n\n\nCreate mappings which use data from entry under cursor\nUse MiniFiles.get_fs_entry():\n-- Set focused directory as current working directory\nlocal set_cwd = function()\n  local path = (MiniFiles.get_fs_entry() or {}).path\n  if path == nil then return vim.notify('Cursor is not on valid entry') end\n  vim.fn.chdir(vim.fs.dirname(path))\nend\n\n-- Yank in register full path of entry under cursor\nlocal yank_path = function()\n  local path = (MiniFiles.get_fs_entry() or {}).path\n  if path == nil then return vim.notify('Cursor is not on valid entry') end\n  vim.fn.setreg(vim.v.register, path)\nend\n\n-- Open path with system default handler (useful for non-text files)\nlocal ui_open = function() vim.ui.open(MiniFiles.get_fs_entry().path) end\n\nvim.api.nvim_create_autocmd('User', {\n  pattern = 'MiniFilesBufferCreate',\n  callback = function(args)\n    local b = args.data.buf_id\n    vim.keymap.set('n', 'g~', set_cwd,   { buffer = b, desc = 'Set cwd' })\n    vim.keymap.set('n', 'gX', ui_open,   { buffer = b, desc = 'OS open' })\n    vim.keymap.set('n', 'gy', yank_path, { buffer = b, desc = 'Yank path' })\n  end,\n})\n\n\nSet custom bookmarks\nUse MiniFiles.set_bookmark() inside MiniFilesExplorerOpen event:\nlocal set_mark = function(id, path, desc)\n  MiniFiles.set_bookmark(id, path, { desc = desc })\nend\nvim.api.nvim_create_autocmd('User', {\n  pattern = 'MiniFilesExplorerOpen',\n  callback = function()\n    set_mark('c', vim.fn.stdpath('config'), 'Config') -- path\n    set_mark('w', vim.fn.getcwd, 'Working directory') -- callable\n    set_mark('~', '~', 'Home directory')\n  end,\n})\n\n\n\n\nsetup()\n\nMiniFiles.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniFiles.config.\n\n\nUsage\nrequire('mini.files').setup() -- use default config\n-- OR\nrequire('mini.files').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniFiles.config\n\n\nDefaults\nMiniFiles.config = {\n  -- Customization of shown content\n  content = {\n    -- Predicate for which file system entries to show\n    filter = nil,\n    -- Highlight group to use for a file system entry\n    highlight = nil,\n    -- Prefix text and highlight to show to the left of file system entry\n    prefix = nil,\n    -- Order in which to show file system entries\n    sort = nil,\n  },\n\n  -- Module mappings created only inside explorer.\n  -- Use `''` (empty string) to not create one.\n  mappings = {\n    close       = 'q',\n    go_in       = 'l',\n    go_in_plus  = 'L',\n    go_out      = 'h',\n    go_out_plus = 'H',\n    mark_goto   = \"'\",\n    mark_set    = 'm',\n    reset       = '&lt;BS&gt;',\n    reveal_cwd  = '@',\n    show_help   = 'g?',\n    synchronize = '=',\n    trim_left   = '&lt;',\n    trim_right  = '&gt;',\n  },\n\n  -- General options\n  options = {\n    -- Whether to delete permanently or move into module-specific trash\n    permanent_delete = true,\n    -- Whether to use for editing directories\n    use_as_default_explorer = true,\n  },\n\n  -- Customization of explorer windows\n  windows = {\n    -- Maximum number of windows to show side by side\n    max_number = math.huge,\n    -- Whether to show preview of file/directory under cursor\n    preview = false,\n    -- Width of focused window\n    width_focus = 50,\n    -- Width of non-focused window\n    width_nofocus = 15,\n    -- Width of preview window\n    width_preview = 25,\n  },\n}\n\n\nContent\ncontent.filter is a predicate which takes file system entry data as input and returns true-ish value if it should be shown. Uses MiniFiles.default_filter() by default.\nA file system entry data is a table with the following fields:\n\n&lt;fs_type&gt; (string) - one of “file” or “directory”.\n&lt;name&gt; (string) - basename of an entry (including extension).\n&lt;path&gt; (string) - full path of an entry.\n\ncontent.highlight describes how file system entry name should be highlighted. Takes file system entry data as input and returns a highlight group name. Uses MiniFiles.default_highlight() by default.\ncontent.prefix describes what text (prefix) to show to the left of file system entry name (if any) and how to highlight it. It also takes file system entry data as input and returns tuple of text and highlight group name to be used to highlight prefix. See MiniFiles-examples for common examples of how to use it. Note: due to how lines are parsed to detect user edits for file system manipulation, output of content.prefix should not contain / character. Uses MiniFiles.default_prefix() by default.\ncontent.sort describes in which order directory entries should be shown in directory buffer. Takes as input and returns as output an array of file system entry data. Note: technically, it can be used to filter and modify its elements as well. Uses MiniFiles.default_sort() by default.\n\n\nMappings\nmappings table can be used to customize buffer-local mappings created in each directory buffer for built-in actions. Entry name corresponds to the function name of the action, value - right hand side of the mapping. Supply empty string to not create a particular mapping.\nDefault mappings are mostly designed for consistent navigation experience. Here are some alternatives:\n-- Close explorer after opening file with `l`\nmappings = {\n  go_in = 'L',\n  go_in_plus = 'l',\n}\n\n-- Don't use `h`/`l` for easier cursor navigation during text edit\nmappings = {\n  go_in = 'L',\n  go_in_plus = '',\n  go_out = 'H',\n  go_out_plus = '',\n}\n\n\nOptions\noptions.use_as_default_explorer is a boolean indicating whether this module will be used as a default file explorer to edit directory (instead of netrw). Note: to work with directory in arglist, do not lazy load this module.\noptions.permanent_delete is a boolean indicating whether to perform permanent delete or move into special trash directory. This is a module-specific variant of “remove to trash”. Target directory is ‘mini.files/trash’ inside standard path of Neovim data directory (execute :echo stdpath('data') to see its path in your case).\n\n\nWindows\nwindows.max_number is a maximum number of windows allowed to be open simultaneously. For example, use value 1 to always show single window. There is no constraint by default.\nwindows.preview is a boolean indicating whether to show preview of file/directory under cursor. Notes:\n\nIt is always shown, even if current line is for not yet existing path.\nFile preview is highlighted if its size is small enough (less than 1K bytes per line or 1M bytes in total).\n\nwindows.width_focus and windows.width_nofocus are number of columns used as width for focused and non-focused windows respectively.\n\n\n\n\nopen()\n\nMiniFiles.open({path}, {use_latest}, {opts})\n\nOpen file explorer\nCommon ways to use this function:\n-- Open current working directory in a last used state\nMiniFiles.open()\n\n-- Fresh explorer in current working directory\nMiniFiles.open(nil, false)\n\n-- Open directory of current file (in last used state) focused on the file\nMiniFiles.open(vim.api.nvim_buf_get_name(0))\n\n-- Fresh explorer in directory of current file\nMiniFiles.open(vim.api.nvim_buf_get_name(0), false)\n\n-- Open last used `path` (per tabpage)\n-- Current working directory for the first time\nMiniFiles.open(MiniFiles.get_latest_path())\n\nParameters\n{path} (string|nil) A valid file system path used as anchor. If it is a path to directory, used directly. If it is a path to file, its parent directory is used as anchor while explorer will focus on the supplied file. Default: path of current-directory.\n{use_latest} (boolean|nil) Whether to load explorer state from history (based on the supplied anchor path). Default: true.\n{opts} (table|nil) Table of options overriding MiniFiles.config and vim.b.minifiles_config for this particular explorer session.\n\n\n\n\nrefresh()\n\nMiniFiles.refresh({opts})\n\nRefresh explorer\nNotes:\n\nIf in opts at least one of content entry is not nil, all directory buffers are forced to update.\n\n\nParameters\n{opts} (table|nil) Table of options to update.\n\n\n\n\nsynchronize()\n\nMiniFiles.synchronize()\n\nSynchronize explorer\n\nParse user edits in directory buffers.\nConvert edits to file system actions and apply them after confirmation. Choosing “No” skips application while “Cancel” stops synchronization.\nUpdate all directory buffers with the most relevant file system information. Can be used without user edits to account for external file system changes.\n\n\nReturn\n(boolean) Whether synchronization was done.\n\n\n\n\nreset()\n\nMiniFiles.reset()\n\nReset explorer\n\nShow single window focused on anchor directory (which was used as first argument for MiniFiles.open()).\nReset all tracked directory cursors to point at first entry.\n\n\n\n\nclose()\n\nMiniFiles.close()\n\nClose explorer\n\nReturn\n(boolean|nil) Whether closing was done or nil if there was nothing to close.\n\n\n\n\ngo_in()\n\nMiniFiles.go_in({opts})\n\nGo in entry under cursor\nDepends on entry under cursor:\n\nIf directory, focus on it in the window to the right.\nIf file, open it in the window which was current during MiniFiles.open(). Explorer is not closed after that.\n\n\nParameters\n{opts} (table|nil) Options. Possible fields:\n\n&lt;close_on_file&gt; (boolean) - whether to close explorer after going inside a file. Powers the go_in_plus mapping. Default: false.\n\n\n\n\n\ngo_out()\n\nMiniFiles.go_out()\n\nGo out to parent directory\n\nFocus on window to the left showing parent of current directory.\n\n\n\n\ntrim_left()\n\nMiniFiles.trim_left()\n\nTrim left part of branch\n\nRemove all branch paths to the left of currently focused one. This also results into current window becoming the most left one.\n\n\n\n\ntrim_right()\n\nMiniFiles.trim_right()\n\nTrim right part of branch\n\nRemove all branch paths to the right of currently focused one. This also results into current window becoming the most right one.\n\n\n\n\nreveal_cwd()\n\nMiniFiles.reveal_cwd()\n\nReveal current working directory\n\nPrepend branch with parent paths until current working directory is reached. Do nothing if not inside it.\n\n\n\n\nshow_help()\n\nMiniFiles.show_help()\n\nShow help window\n\nOpen window with helpful information about currently shown explorer and focus on it. To close it, press q.\n\n\n\n\nget_fs_entry()\n\nMiniFiles.get_fs_entry({buf_id}, {line})\n\nGet file system entry data\n\nParameters\n{buf_id} (number|nil) Buffer identifier of valid directory buffer. Default: current buffer.\n{line} (number|nil) Line number of entry for which to return information. Default: cursor line.\n\n\nReturn\n(table|nil) Table of file system entry data with the following fields:\n\n&lt;fs_type&gt; (string) - one of “file” or “directory”.\n&lt;name&gt; (string) - basename of an entry (including extension).\n&lt;path&gt; (string) - full path of an entry.\n\nReturns nil if there is no proper file system entry path at the line.\n\n\n\n\nget_explorer_state()\n\nMiniFiles.get_explorer_state()\n\nGet state of active explorer\n\nReturn\n(table|nil) Table with explorer state data or nil if no active explorer. State data is a table with the following fields:\n\n&lt;anchor&gt; (string) - anchor directory path (see MiniFiles.open()).\n&lt;bookmarks&gt; (table) - map from bookmark id (single character) to its data: table with &lt;path&gt; and &lt;desc&gt; fields (see MiniFiles.set_bookmark()).\n&lt;branch&gt; (table) - array of nested paths for currently opened branch.\n&lt;depth_focus&gt; (number) - an index in &lt;branch&gt; for currently focused path.\n&lt;target_window&gt; (number) - identifier of target window.\n&lt;windows&gt; (table) - array with data about currently opened windows. Each element is a table with &lt;win_id&gt; (window identifier) and &lt;path&gt; (path shown in the window) fields.\n\n\n\nSee also\n\nMiniFiles.set_bookmark()\nMiniFiles.set_branch()\nMiniFiles.set_target_window()\n\n\n\n\n\nset_target_window()\n\nMiniFiles.set_target_window({win_id})\n\nSet target window\n\nParameters\n{win_id} (number) Window identifier inside which file will be opened.\n\n\n\n\nset_branch()\n\nMiniFiles.set_branch({branch}, {opts})\n\nSet branch\nSet which paths to display. Preview (if enabled) is applied afterwards.\n\nParameters\n{branch} (table) Array of strings representing actually present on disk paths. Each consecutive pair should represent direct parent-child paths. Should contain at least one directory path. May end with file path (will be previwed). Relative paths are resolved using current-directory.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;depth_focus&gt; (number) - an index in branch for path to focus. Will be normalized to fit inside branch. Default: index of deepest directory.\n\n\n\nSee also\nMiniFiles.get_explorer_state()\n\n\n\n\nset_bookmark()\n\nMiniFiles.set_bookmark({id}, {path}, {opts})\n\nSet bookmark\n\nParameters\n{id} (string) Single character bookmark id.\n{path} (string|function) Path of a present on disk directory to set as a bookmark’s path. If callable, should return such path.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;desc&gt; (string) - bookmark description (used in help window).\n\n\n\n\n\nget_latest_path()\n\nMiniFiles.get_latest_path()\n\nGet latest used anchor path\nNote: if latest used path argument for MiniFiles.open() was for file, this will return its parent (as it was used as anchor path).\n\n\n\ndefault_filter()\n\nMiniFiles.default_filter({fs_entry})\n\nDefault filter of file system entries\nCurrently does not filter anything out.\n\nParameters\n{fs_entry} (table) Table with the following fields:\n\n&lt;fs_type&gt; (string) - one of “file” or “directory”.\n&lt;name&gt; (string) - basename of an entry (including extension).\n&lt;path&gt; (string) - full path of an entry.\n\n\n\nReturn\n(boolean) Always true.\n\n\n\n\ndefault_prefix()\n\nMiniFiles.default_prefix({fs_entry})\n\nDefault prefix of file system entries\n\nIf set up mini.icons, use MiniIcons.get() for “directory”/“file” category.\nOtherwise:\n\nFor directory return fixed icon and “MiniFilesDirectory” group name.\nFor file try to use get_icon() from ‘nvim-tree/nvim-web-devicons’. If missing, return fixed icon and ‘MiniFilesFile’ group name.\n\n\n\nParameters\n{fs_entry} (table) Table with the following fields:\n\n&lt;fs_type&gt; (string) - one of “file” or “directory”.\n&lt;name&gt; (string) - basename of an entry (including extension).\n&lt;path&gt; (string) - full path of an entry.\n\n\n\nReturn\n(...) Icon and highlight group name. For more details, see MiniFiles.config and MiniFiles-examples.\n\n\n\n\ndefault_sort()\n\nMiniFiles.default_sort({fs_entries})\n\nDefault sort of file system entries\nSort directories and files separately (alphabetically ignoring case) and put directories first.\n\nParameters\n{fs_entries} (table) Array of file system entry data. Each one is a table with the following fields:\n\n&lt;fs_type&gt; (string) - one of “file” or “directory”.\n&lt;name&gt; (string) - basename of an entry (including extension).\n&lt;path&gt; (string) - full path of an entry.\n\n\n\nReturn\n(table) Sorted array of file system entries.\n\n\n\n\ndefault_highlight()\n\nMiniFiles.default_highlight({fs_entry})\n\nDefault file system entry highlight\nReturns 'MiniFilesDirectory' for directory and 'MiniFilesFile' otherwise.\n\nParameters\n{fs_entry} (table) Table with the following fields:\n\n&lt;fs_type&gt; (string) - one of “file” or “directory”.\n&lt;name&gt; (string) - basename of an entry (including extension).\n&lt;path&gt; (string) - full path of an entry.\n\n\n\nReturn\n(string) Highlight group name."
  },
  {
    "objectID": "mini.nvim/doc/mini-basics.html",
    "href": "mini.nvim/doc/mini-basics.html",
    "title": "mini.basics documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.basics Common configuration presets\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nInstall, create ‘init.lua’, add require('mini.basics').setup(), and you are good to go.\nFeatures:\n\nPresets for common options. It will only change option if it wasn’t manually set before. See more in MiniBasics.config.options.\nPresets for common mappings. It will only add a mapping if it wasn’t manually created before. See more in MiniBasics.config.mappings.\nPresets for common autocommands. See more in MiniBasics.config.autocommands.\nReverse compatibility is a high priority. Any decision to change already present behavior will be made with great care.\n\nNotes:\n\nMain goal of this module is to provide a relatively easier way for new-ish Neovim users to have better “works out of the box” experience while having documented relevant options/mappings/autocommands to study. It is based partially on survey among Neovim users and partially is coming from personal preferences.\nHowever, more seasoned users almost surely will find something useful.\nStill, it is recommended to read about used options/mappings/autocommands and decide if they are needed. The main way to do that is by reading Neovim’s help pages (linked in help file) and this module’s source code (thoroughly documented for easier comprehension).\n\n\nSetup\nThis module needs a setup with require('mini.basics').setup({}) (replace {} with your config table). It will create global Lua table MiniBasics which you can use for scripting or manually (with :lua MiniBasics.*).\nSee MiniBasics.config for available config settings.\nTo stop module from showing non-error feedback, set config.silent = true.\n\n\nComparisons\n\ntpope/vim-sensible:\n\nMost of ‘tpope/vim-sensible’ is already incorporated as default options in Neovim (see nvim-defaults). This module has a much broader effect.\n\ntpope/vim-unimpaired:\n\nThe ‘tpope/vim-unimpaired’ has mapping for toggling options with yo prefix. This module implements similar functionality with \\ prefix (see MiniBasics.config.mappings).\n\n\n\n\n\n\nsetup()\n\nMiniBasics.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniBasics.config.\n\n\nUsage\nrequire('mini.basics').setup() -- use default config\n-- OR\nrequire('mini.basics').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniBasics.config\n\n\nDefaults\nMiniBasics.config = {\n  -- Options. Set field to `false` to disable.\n  options = {\n    -- Basic options ('number', 'ignorecase', and many more)\n    basic = true,\n\n    -- Extra UI features ('winblend', 'listchars', 'pumheight', ...)\n    extra_ui = false,\n\n    -- Presets for window borders ('single', 'double', ...)\n    -- Default 'auto' infers from 'winborder' option\n    win_borders = 'auto',\n  },\n\n  -- Mappings. Set field to `false` to disable.\n  mappings = {\n    -- Basic mappings (better 'jk', save with Ctrl+S, ...)\n    basic = true,\n\n    -- Prefix for mappings that toggle common options ('wrap', 'spell', ...).\n    -- Supply empty string to not create these mappings.\n    option_toggle_prefix = [[\\]],\n\n    -- Window navigation with &lt;C-hjkl&gt;, resize with &lt;C-arrow&gt;\n    windows = false,\n\n    -- Move cursor in Insert, Command, and Terminal mode with &lt;M-hjkl&gt;\n    move_with_alt = false,\n  },\n\n  -- Autocommands. Set field to `false` to disable\n  autocommands = {\n    -- Basic autocommands (highlight on yank, start Insert in terminal, ...)\n    basic = true,\n\n    -- Set 'relativenumber' only in linewise and blockwise Visual mode\n    relnum_in_visual_mode = false,\n  },\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}\n\n\nOptions\nMiniBasics.config.options\nUsage example:\nrequire('mini.basics').setup({\n  options = {\n    basic = true,\n    extra_ui = true,\n    win_borders = 'double',\n  }\n})\n\noptions.basic\nThe config.options.basic sets certain options to values which are quite commonly used (judging by study of available Neovim pre-configurations, public dotfiles, and surveys). Any option is changed only if it was not set manually beforehand. For exact changes, please see source code (‘lua/mini/basics.lua’).\nHere is the list of affected options (put cursor on it and press [CTRL-]](https://neovim.io/doc/user/helptag.html?tag=CTRL-])):\n\nGeneral:\n\nSets &lt;Leader&gt; key to &lt;Space&gt;. Be sure to make all Leader mappings after this (otherwise they are made with default &lt;Leader&gt;).\nRuns :filetype plugin indent on (see :filetype-overview)\n‘backup’\n‘mouse’\n‘undofile’\n‘writebackup’\n\nAppearance\n\n‘breakindent’\n‘cursorline’\n‘fillchars’\n‘linebreak’\n‘number’\n‘ruler’\n‘showmode’\n‘signcolumn’\n‘shortmess’\n‘splitbelow’\n‘splitkeep’\n‘splitright’\n‘termguicolors’ (on Neovim&lt;0.10; later versions have it smartly enabled)\n‘wrap’\n\nEditing\n\n‘completeopt’\n‘formatoptions’\n‘ignorecase’\n‘incsearch’\n‘infercase’\n‘smartcase’\n‘smartindent’\n‘virtualedit’\n\n\n\n\noptions.extra_ui\nThe config.options.extra_ui sets certain options for visual appearance which might not be aligned with common preferences, but still worth trying. Any option is changed only if it was not set manually beforehand. For exact changes, please see source code (‘lua/mini/basics.lua’).\nList of affected options:\n\n‘list’\n‘listchars’\n‘pumblend’\n‘pumheight’\n‘winblend’\nRuns :syntax on (see :syntax-on)\n\n\n\noptions.win_borders\nThe config.options.win_borders updates ‘fillchars’ to have a consistent set of characters for window border (vert, horiz, msgsep, etc.).\nAvailable values:\n\n'auto' - infer from ‘winborder’. On Neovim&lt;0.11 do nothing.\n'bold' - bold lines.\n'dot' - dot in every cell.\n'double' - double line.\n'single' - single line.\n'solid' - no symbol, only background.\n\n\n\n\nMappings\nMiniBasics.config.mappings\nUsage example:\nrequire('mini.basics').setup({\n  mappings = {\n    basic = true,\n    option_toggle_prefix = [[\\]],\n    windows = true,\n    move_with_alt = true,\n  }\n})\nIf you want some mappings to be different or not made at all, set or delete them after calling MiniBasics.setup().\n\nmappings.basic\nThe config.mappings.basic creates mappings for certain commonly mapped actions (judging by study of available Neovim pre-configurations and public dotfiles).\nSome of the mappings override built-in ones to either improve their behavior or override its default not very useful action. It will only add a mapping if it wasn’t manually created before.\nHere is a table with created mappings :\n|Keys   |     Modes       |                  Description                  |\n|-------|-----------------|-----------------------------------------------|\n| j     | Normal, Visual  | Move down by visible lines with no [count]    |\n| k     | Normal, Visual  | Move up by visible lines with no [count]      |\n| go    | Normal          | Add [count] empty lines after cursor          |\n| gO    | Normal          | Add [count] empty lines before cursor         |\n| gy    | Normal, Visual  | Copy to system clipboard                      |\n| gp    | Normal, Visual  | Paste from system clipboard                   |\n| gV    | Normal          | Visually select latest changed or yanked text |\n| g/    | Visual          | Search inside current visual selection        |\n| *     | Visual          | Search forward for current visual selection   |\n| #     | Visual          | Search backward for current visual selection  |\n| &lt;C-s&gt; | Normal, Visual, | Save and go to Normal mode                    |\n|       |     Insert      |                                               |\nNotes:\n\nSee [count] for its meaning.\nOn Neovim&gt;=0.10 mappings for # and * are not created as their enhanced variants are made built-in. See v_star-default and v_#-default.\nOn Neovim&gt;=0.11 there are [&lt;Space&gt; / []&lt;Space&gt;](https://neovim.io/doc/user/helptag.html?tag=]&lt;Space&gt;) for adding empty lines. The gO and go mappings are still created as they are more aligned with similarly purposed O and o keys (although sometimes conflict with gO).\n\n\n\nmappings.option_toggle_prefix\nThe config.mappings.option_toggle_prefix defines a prefix used for creating mappings that toggle common options. The result mappings will be &lt;prefix&gt; + &lt;suffix&gt;. For example, with default value, \\w will toggle ‘wrap’.\nOther viable choices for prefix are\n\n, (as a mnemonic for several values to toggle).\n| (as a same mnemonic).\nyo (used in ‘tpope/vim-unimpaired’)\nSomething with &lt;Leader&gt; key, like &lt;Leader&gt;t (t for “toggle”). Note: if your prefix contains &lt;Leader&gt; key, make sure to set it before calling MiniBasics.setup() (as is done with default basic field of MiniBasics.config.options).\n\nAfter toggling, there will be a feedback about the current option value if prior to require('mini.basics').setup() module wasn’t silenced (see “Silencing” section in mini.basics).\nIt will only add a mapping if it wasn’t manually created before.\nHere is a list of suffixes for created toggling mappings (all in Normal mode):\n\nb - ‘background’.\nc - ‘cursorline’.\nC - ‘cursorcolumn’.\nd - diagnostic (via vim.diagnostic functions).\nh - ‘hlsearch’ (or v:hlsearch to be precise).\ni - ‘ignorecase’.\nl - ‘list’.\nn - ‘number’.\nr - ‘relativenumber’.\ns - ‘spell’.\nw - ‘wrap’.\n\n\n\nmappings.windows\nThe config.mappings.windows creates mappings for easiere window manipulation.\nIt will only add a mapping if it wasn’t manually created before.\nHere is a list with created Normal mode mappings (all respect [count]):\n\nWindow navigation:\n\n&lt;C-h&gt; - focus on left window (see CTRL-W_H).\n&lt;C-j&gt; - focus on below window (see CTRL-W_J).\n&lt;C-k&gt; - focus on above window (see CTRL-W_K).\n&lt;C-l&gt; - focus on right window (see CTRL-W_L).\n\nWindow resize (all use arrow keys; variants of :resize; respect [count]):\n\n&lt;C-left&gt; - decrease window width.\n&lt;C-down&gt; - decrease window height.\n&lt;C-up&gt; - increase window height.\n&lt;C-right&gt; - increase window width.\n\n\n\n\nmappings.move_with_alt\nThe config.mappings.move_with_alt creates mappings for a more consistent cursor move in Insert, Command, and Terminal modes. For example, it proves useful in combination of autopair plugin (like mini.pairs) to move right outside of inserted pairs (no matter what the pair is).\nIt will only add a mapping if it wasn’t manually created before.\nHere is a list of created mappings (&lt;M-x&gt; means Alt/Meta plus x):\n\n&lt;M-h&gt; - move cursor left. Modes: Insert, Terminal, Command.\n&lt;M-j&gt; - move cursor down. Modes: Insert, Terminal.\n&lt;M-k&gt; - move cursor up. Modes: Insert, Terminal.\n&lt;M-l&gt; - move cursor right. Modes: Insert, Terminal, Command.\n\n\n\n\nAutocommands\nMiniBasics.config.autocommands\nUsage example:\nrequire('mini.basics').setup({\n  autocommands = {\n    basic = true,\n    relnum_in_visual_mode = true,\n  }\n})\n\nautocommands.basic\nThe config.autocommands.basic creates some common autocommands:\n\nStarts insert mode when opening terminal (see :startinsert and TermOpen).\nHighlights yanked text for a brief period of time (see vim.hl.on_yank(); on Neovim&lt;0.11 - vim.hl.on_yank()) and TextYankPost).\n\n\n\nautocommands.relnum_in_visual_mode\nThe config.autocommands.relnum_in_visual_mode creates autocommands that enable ‘relativenumber’ in linewise and blockwise Visual modes and disable otherwise. See ModeChanged.\n\n\n\n\n\ntoggle_diagnostic()\n\nMiniBasics.toggle_diagnostic()\n\nToggle diagnostic for current buffer\nThis uses vim.diagnostic functions per buffer.\n\nReturn\n(string) String indicator for new state. Similar to what :set {option}? shows."
  },
  {
    "objectID": "mini.nvim/doc/mini-pick.html",
    "href": "mini.nvim/doc/mini-pick.html",
    "title": "mini.pick documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.pick Pick anything\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nSingle window general purpose interface for picking element from any array.\nOn demand toggleable preview and info views.\nInteractive query matching (filter+sort) with fast non-blocking default which does fuzzy matching and allows other modes (MiniPick.default_match()).\nBuilt-in pickers (see MiniPick.builtin):\n\nFiles.\nPattern match (for fixed pattern or with live feedback; both allow file filtering via glob patterns).\nBuffers.\nHelp tags.\nCLI output.\nResume latest picker.\n\n:Pick command to work with extensible MiniPick.registry.\nvim.ui.select() implementation. To adjust, use MiniPick.ui_select() or save-restore vim.ui.select manually after calling MiniPick.setup().\nRich and customizable built-in MiniPick-actions when picker is active:\n\nManually change currently focused item.\nScroll vertically and horizontally.\nToggle preview or info view.\nMark/unmark items to choose later.\nRefine current matches (make them part of a new picker).\nAnd many more.\n\nMinimal yet flexible MiniPick-source specification with:\n\nItems (array, callable, or manually set later).\nSource name.\nWorking directory.\nMatching algorithm.\nWay matches are shown in main window.\nItem preview.\n“On choice” action for current and marked items.\n\nCustom actions/keys can be configured globally, per buffer, or per picker.\nOut of the box support for ‘ignorecase’ and ‘smartcase’.\nMatch caching to increase responsiveness on repeated prompts.\n\nNotes:\n\nWorks on all supported versions but Neovim&gt;=0.10 will give more visual feedback in floating window footer.\nFor more pickers see MiniExtra.pickers.\n\nSources with more details:\n\nMiniPick-overview\nMiniPick-source\nMiniPick-actions\nMiniPick-examples\nMiniPick.builtin\n\n\nDependencies\nSuggested dependencies (provide extra functionality, will work without them):\n\nEnabled mini.icons module to show icons near the items for actual paths. Falls back to ‘nvim-tree/nvim-web-devicons’ plugin or no icons will be used.\nMiniPick-cli-tools CLI tool(s) to power MiniPick.builtin.files(), MiniPick.builtin.grep(), and MiniPick.builtin.grep_live() built-in pickers:\n\nrg (github.com/BurntSushi/ripgrep; enough for all three; recommended).\nfd (github.com/sharkdp/fd; for files only).\ngit (github.com/git/git; enough for all three).\n\nNote: CLI tools are called only with basic arguments needed to get items. To customize the output, use their respective configuration approaches. Here are some examples of where to start:\n\ngithub.com/BurntSushi/ripgrep/blob/master/GUIDE.md#configuration-file\ngithub.com/sharkdp/fd#excluding-specific-files-or-directories\ngit-scm.com/docs/gitignore\n\n\n\n\nSetup\nThis module needs a setup with require('mini.pick').setup({}) (replace {} with your config table). It will create global Lua table MiniPick which you can use for scripting or manually (with :lua MiniPick.*).\nSee MiniPick.config for available config settings.\nYou can override runtime config settings locally to buffer inside vim.b.minipick_config which should have same structure as MiniPick.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nnvim-telescope/telescope.nvim:\n\nThe main inspiration for this module, so there is significant overlap.\nHas three (or two) window UI (prompt, matches, preview), while this module combines everything in one window. It allows more straightforward customization for unusual scenarios.\nDefault match algorithm is somewhat slow, while this module should match relatively lag-free for at least 100K+ items.\nHas many built-in pickers, while this module has handful at its core relying on other ‘mini.nvim’ modules to provide more (see mini.extra).\n\nibhagwan/fzf-lua:\n\nMostly same comparison as with ‘nvim-telescope/telescope.nvim’.\nRequires junegunn/fzf installed to power fuzzy matching, while this module provides built-in Lua matching.\n\n\n\n\nHighlight groups\n\nMiniPickBorder - window border.\nMiniPickBorderBusy - window border while picker is busy processing.\nMiniPickBorderText - non-prompt on border.\nMiniPickCursor - cursor during active picker (hidden by default).\nMiniPickIconDirectory - default icon for directory.\nMiniPickIconFile - default icon for file.\nMiniPickHeader - headers in info buffer and previews.\nMiniPickMatchCurrent - current matched item.\nMiniPickMatchMarked - marked matched items.\nMiniPickMatchRanges - ranges matching query elements.\nMiniPickNormal - basic foreground/background highlighting.\nMiniPickPreviewLine - target line in preview.\nMiniPickPreviewRegion - target region in preview.\nMiniPickPrompt - prompt.\nMiniPickPromptCaret - caret in prompt.\nMiniPickPromptPrefix - prefix of the prompt.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\n\n\nEvents\nTo allow user customization and integration of external tools, certain User autocommand events are triggered under common circumstances:\n\nMiniPickMatch - just after updating query matches or setting items.\nMiniPickStart - just after picker has started.\nMiniPickStop - just before picker is stopped.\n\n\n\n\nOverview\nGeneral idea is to take array of objects, display them with interactive filter/sort/navigate/preview, and allow to choose one or more items.\n\nHow to start a picker\n\nUse MiniPick.start() with opts.source defining MiniPick-source. Example: MiniPick.start({ source = { items = vim.fn.readdir('.') } })\nUse any of MiniPick.builtin pickers directly. Example: MiniPick.builtin.files({ tool = 'git' })\nUse :Pick command which uses customizable pickers from MiniPick.registry. Example: :Pick files tool='git'\n\n\n\nUser interface\nUI consists from a single window capable of displaying three different views:\n\n“Main” - where current query matches are shown.\n“Preview” - preview of current item (toggle with &lt;Tab&gt;).\n“Info” - general info about picker and its state (toggle with &lt;S-Tab&gt;).\n\nCurrent prompt is displayed at the top left of the window border with vertical line indicating caret (current input position).\nBottom part of window border displays (in Neovim&gt;=0.10) extra visual feedback:\n\nLeft part is a picker name.\nRight part contains information in the format\n&lt;current index in matches&gt; | &lt;match count&gt; | &lt;marked count&gt; / &lt;total count&gt;\n\nWhen picker is busy (like if there are no items yet set or matching is active) window border changes color to be MiniPickBorderBusy after config.delay.busy milliseconds of idle time.\n\n\nLife cycle\n\nType characters to filter and sort matches. It uses MiniPick.default_match() with query being an array of pressed characters. Overview of how it matches:\n\nIf query starts with ', the match is exact.\nIf query starts with ^, the match is exact at start.\nIf query ends with $, the match is exact at end.\nIf query starts with *, the match is forced to be fuzzy.\nOtherwise match is fuzzy.\nSorting is done to first minimize match width and then match start. Nothing more: no favoring certain places in string, etc.\n\nType special keys to perform MiniPick-actions. Here are some basic ones:\n\n&lt;C-n&gt; / &lt;Down&gt; moves down; &lt;C-p&gt; / &lt;Up&gt; moves up.\n&lt;Left&gt; / &lt;Right&gt; moves prompt caret left / right.\n&lt;S-Tab&gt; toggles information window with all available mappings.\n&lt;Tab&gt; toggles preview.\n&lt;C-x&gt; / &lt;C-a&gt; toggles current / all item(s) as (un)marked.\n&lt;C-Space&gt; / &lt;M-Space&gt; makes all matches or marked items as new picker.\n&lt;CR&gt; / &lt;M-CR&gt; chooses current/marked item(s).\n&lt;Esc&gt; / &lt;C-c&gt; stops picker.\n\n\n\n\nImplementation details\n\nProcessing key typing is done via a dedicated key query process for more control over their side effects. As a result, regular mappings don’t work here and picker’s window needs to be current as long as it is shown. Changing window focus leads to automatic picker stop (after small delay).\nAny picker is non-blocking but waits to return the chosen item. Example: file = MiniPick.builtin.files() allows other actions to be executed when picker is shown while still assigning file with value of the chosen item.\n\n\n\n\n\nSource\nSource is defined as a source field inside one of (in increasing priority):\n\nMiniPick.config - has global effect.\nvim.b.minipick_config - has buffer-local effect.\nopts.source in picker call - has effect for that particular call.\n\nExample of source to choose from arglist:\n{ items = vim.fn.argv, name = 'Arglist' }\nNote: this is mostly useful for writing pickers. Can safely skip if you want to just use provided pickers.\n\nItems\nMiniPick-source.items\nsource.items defines items to choose from. It should be one of the following:\n\nArray of objects which can have different types. Any type is allowed.\nnil. Picker waits for explicit MiniPick.set_picker_items() call.\nCallable returning any of the previous types. Will be called once on start with source’s cwd set as current-directory.\n\nMiniPick-source.items-stritems Matching is done for items array based on the string representation of its elements (here called “stritems”). For single item it is computed as follows:\n\nCallable is called once with output used in next steps.\nString item is used as is.\nString &lt;text&gt; field of table item is used (if present).\nUse output of vim.inspect().\n\nExample:\nitems = { 'aaa.txt', { text = 'bbb' }, function() return 'ccc' end }\n-- corresponding stritems are { 'aaa.txt', 'bbb', 'ccc' }\nDefault value is nil, assuming it always be supplied by the caller.\nMiniPick-source.items-common There are some recommendations for common item types in order for them to work out of the box with MiniPick.default_show(), MiniPick.default_preview(), MiniPick.default_choose(), MiniPick.default_choose_marked():\n\nPath (file or directory). Use string or path field of a table. Path can be either absolute, relative to the source.cwd, or have a general URI format (only if supplied as table field). Examples: 'aaa.txt', { path = 'aaa.txt' }\nBuffer. Use buffer id as number, string, or bufnr / buf_id / buf field of a table (any name is allowed). Examples: 1, '1', { bufnr = 1 }, { buf_id = 1 }, { buf = 1 }\nLine in file or buffer. Use table representation with lnum field with line number (starting from 1) or string in “&lt;path&gt;\\0&lt;line&gt;” format (\\0 is an actual null character; don’t escape the slash; may need to be \\000). Examples:\n{ path = 'aaa.txt', lnum = 2 }, 'aaa.txt\\0002', { bufnr = 1, lnum = 3 }\nPosition in file or buffer. Use table representation with lnum and col fields with line and column numbers (starting from 1) or string in “&lt;path&gt;\\0&lt;line&gt;\\0&lt;col&gt;” format (\\0 is an actual null character, don’t escape the slash; may need to be \\000). Examples:\n{ path = 'aaa.txt', lnum = 2, col = 3 }, 'aaa.txt\\0' .. '2\\0003',\n{ bufnr = 1, lnum = 3, col = 4 }\nRegion in file or buffer. Use table representation with lnum, col, end_lnum, end_col fields for start and end line/column. All numbers start from 1, end line is inclusive, end column is exclusive. This naming is similar to getqflist() and diagnostic-structure. Examples:\n{ path = 'aaa.txt', lnum = 2, col = 3, end_lnum = 4, end_col = 5 },\n{ bufnr = 1, lnum = 3, col = 4, end_lnum = 5, end_col = 6 }\n\nNote: all table items will benefit from having text field for better matching.\n\n\nName\nMiniPick-source.name\nsource.name defines the name of the picker to be used for visual feedback.\nDefault value is “”.\n\n\nCurrent working directory\nMiniPick-source.cwd\nsource.cwd is a string defining the current working directory in which picker operates. It should point to a valid actually present directory path. This is a part of source to allow persistent way to use relative paths, i.e. not depend on current directory being constant after picker start. It also makes the MiniPick.builtin.resume() picker more robust.\nIt will be set as local current-directory (:lcd) of picker’s main window to allow simpler code for “in window” functions (choose/preview/custom/etc.).\nDefault value is current-directory.\n\n\nMatch\nMiniPick-source.match\nsource.match is a callable defining how stritems (see MiniPick-source.items-stritems) are matched (filtered and sorted) based on the query.\nIt will be called with the following arguments:\n\nstritems - all available stritems for current picker.\ninds - array of stritems indexes usually pointing at current matches. It does point to current matches in the case of interactively appending character at the end of the query. It assumes that matches for such bigger query is a subset of previous matches (implementation can ignore it). This can be utilized to increase performance by checking fewer stritems.\nquery - array of strings. Usually (like is common case of user interactively typing query) each string represents one character. However, any strings are allowed, as query can be set with MiniPick.set_picker_query().\n\nIt should either return array of match indexes for stritems elements matching the query (synchronous) or explicitly use MiniPick.set_picker_match_inds() to set them (may be asynchronous).\nNotes:\n\nThe result can be any array of stritems indexes, i.e. not necessarily a subset of input inds.\nBoth stritems and query depend on values of ‘ignorecase’ and ‘smartcase’. If query shows “ignore case” properties (only ‘ignorecase’ is set or both ‘ignorecase’ / ‘smartcase’ are set and query has only lowercase characters), then stritems and query will have only lowercase characters. This allows automatic support for case insensitive matching while being faster and having simpler match function implementation.\nWriting custom source.match usually means also changing MiniPick-source.show because it is used to highlight stritems parts actually matching the query.\n\nExample of simple “exact” match() preserving initial order:\nlocal match_exact = function(stritems, inds, query)\n  local prompt_pattern = vim.pesc(table.concat(query))\n  local f = function(i) return stritems[i]:find(prompt_pattern) ~= nil end\n  return vim.tbl_filter(f, inds)\nend\n-- For non-blocking version see `:h MiniPick.poke_is_picker_active()`\nDefault value is MiniPick.default_match().\n\n\nShow\nMiniPick-source.show\nsource.show is a callable defining how matched items are shown in the window.\nIt will be called with the following arguments:\n\nbuf_id - identifier of the target buffer.\nitems_to_show - array of actual items to be shown in buf_id. This is a subset of currently matched items computed to fit in current window view.\nquery - array of strings. Same as in source.match.\n\nIt should update buffer buf_id to visually represent items_to_show one item per line starting from line one (it shouldn’t depend on options.content_from_bottom). This also includes possible visualization of which parts of stritem actually matched query.\nExample (assuming string items; without highlighting):\nlocal show_prepend = function(buf_id, items_arr, query)\n  local lines = vim.tbl_map(function(x) return 'Item: ' .. x end, items_arr)\n  vim.api.nvim_buf_set_lines(buf_id, 0, -1, false, lines)\nend\nDefault value is MiniPick.default_show().\n\n\nPreview\nMiniPick-source.preview\nsource.preview is a callable defining how item preview is done.\nIt will be called with the following arguments:\n\nbuf_id - identifier of the target buffer. Note: for every separate instance of item previewing new scratch buffer is be created.\nitem - item to preview.\n\nIt should update buffer buf_id to visually represent item.\nExample:\nlocal preview_inspect = function(buf_id, item)\n  local lines = vim.split(vim.inspect(item), '\\n')\n  vim.api.nvim_buf_set_lines(buf_id, 0, -1, false, lines)\nend\nDefault value is MiniPick.default_preview().\n\n\nChoose an item\nMiniPick-source.choose\nsource.choose is a callable defining what to do when an item is chosen.\nIt will be called with the following arguments:\n\nitem - chosen item. Always non-nil.\n\nIt should perform any intended “choose” action for an item and return a value indicating whether picker should continue (i.e. not stop): nil and false will stop picker, other values will continue.\nNotes:\n\nIt is called when picker window is still current. Use windows.target value from MiniPick.get_picker_state() output to do something with target window.\n\nExample:\nlocal choose_file_continue = function(item)\n  if vim.fn.filereadable(item) == 0 then return end\n  vim.api.nvim_win_call(\n    MiniPick.get_picker_state().windows.main,\n    function() vim.cmd('edit ' .. item) end\n  )\n  return true\nend\nDefault value is MiniPick.default_choose().\n\n\nChoose marked items\nMiniPick-source.choose_marked\nsource.choose_marked is a callable defining what to do when marked items (see MiniPick-actions-mark) are chosen. Serves as a companion to source.choose which can choose several items.\nIt will be called with the following arguments:\n\nitems_marked - array of marked items. Can be empty.\n\nIt should perform any intended “choose” action for several items and return a value indicating whether picker should continue (i.e. not stop): nil and false will stop picker, other values will continue.\nNotes:\n\nIt is called when picker window is still current. Use windows.target value from MiniPick.get_picker_state() output to do something with target window.\n\nExample:\nlocal choose_marked_print = function(items) print(vim.inspect(items)) end\nDefault value is MiniPick.default_choose_marked().\n\n\n\n\nActions\nWhen picker is active, mappings table defines a set of special keys which when pressed will execute certain actions. Those can be of two types:\n\nBuilt-in: actions present in default config.mappings. Can be only overridden with a different key.\nCustom: user defined actions. Should be a table with char and func fields.\n\n\nBuilt-in\n\nCaret\nMiniPick-actions-caret\nUser can add character not only at query end, but more generally at caret.\n\nmappings.caret_left - move caret to left.\nmappings.caret_right - move caret to right.\n\n\n\nChoose\nMiniPick-actions-choose\nChoose is a fundamental action that actually implements the intent of calling a picker, i.e. pick an item.\n\nmappings.choose - choose as is, i.e. apply source.choose for current item.\nmappings.choose_in_split - make horizontal split at target window, update target window to the new split, and choose.\nmappings.choose_in_tabpage - same as choose_in_split, but create tabpage.\nmappings.choose_in_vsplit - same as choose_in_split, but split vertically.\nmappings.choose_marked - choose marked items as is, i.e. apply source.choose_marked at current marked items.\n\n\n\nDelete\nMiniPick-actions-delete\nDelete actions are for deleting elements from query.\n\nmappings.delete_char - delete one character to the left.\nmappings.delete_char_right - delete one character to the right.\nmappings.delete_left - delete everything to the left (like i_CTRL-U).\nmappings.delete_word - delete word to the left (like i_CTRL-W).\n\n\n\nMark\nMiniPick-actions-mark\nMarking is an action of adding certain items to a separate list which then can be chosen with mappings.choose_marked (for example, sent to quickfix list). This is a companion to a regular choosing which can pick only one item.\n\nmappings.mark - toggle marked/unmarked state of current item.\nmappings.mark_all - toggle marked/unmarked state (mark all if not all marked; unmark all otherwise) of all currently matched items.\n\nNotes:\n\nMarks persist across queries and matches. For example, user can make a query with marking all matches several times and marked items from all queries will be preserved.\n\n\n\nMove\nMiniPick-actions-move\nMove is a fundamental action of changing which item is current.\n\nmappings.move_down - change focus to the item below.\nmappings.move_start change focus to the first currently matched item\nmappings.move_up - change focus to the item above.\n\nNotes:\n\nUp and down wrap around edges: move_down on last item moves to first, move_up on first moves to last.\nMoving when preview or info view is shown updates the view with new item.\nThese also work with non-overridable alternatives:\n\n&lt;Down&gt; moves down.\n&lt;Home&gt; moves to first matched.\n&lt;Up&gt; moves up.\n\n\n\n\nPaste\nMiniPick-actions-paste\nPaste is an action to paste content of registers at caret.\n\nmappings.paste - paste from register defined by the next key press.\n\nNotes:\n\nDoes not support expression register =.\nSupports special cases of register: &lt;C-f&gt; (as c_CTRL-R_CTRL-F), &lt;C-w&gt; (as c_CTRL-R_CTRL-W), &lt;C-a&gt; (as c_CTRL-R_CTRL-A), &lt;C-l&gt; (as c_CTRL-R_CTRL-L).\n\n\n\nRefine\nMiniPick-actions-refine\nRefine is an action that primarily executes the following:\n\nTakes certain items and makes them be all items (in order they are present).\nResets query.\nUpdates source.match to be the one from config.\nmappings.refine - refine currently matched items.\nmappings.refine_marked - refine currently marked items.\n\nThis action is useful in at least two cases:\n\nPerform consecutive “narrowing” queries. Example: to get items that contain both “hello” and “world” exact matches (in no particular order) with default matching, type “’hello” (notice “’” at the start) followed by &lt;C-Space&gt; and another “’world”.\nReset match to default. Particularly useful in MiniPick.builtin.grep_live() and MiniExtra.pickers.lsp() with “workspace_symbol_live” scope.\n\n\n\nScroll\nMiniPick-actions-scroll\nScroll is an action to either move current item focus further than to the neighbor item or adjust window view to see more information.\n\nmappings.scroll_down - when matches are shown, go down by the amount of visible matches. In preview and info view - scroll down as with CTRL-F.\nmappings.scroll_left - scroll left as with zH.\nmappings.scroll_right - scroll right as with zL.\nmappings.scroll_up - when matches are shown, go up by the amount of visible matches. In preview and info view - scroll up as with CTRL-B.\n\n\n\nStop\nMiniPick-actions-stop\nmappings.stop stops the picker. &lt;C-c&gt; also always stops the picker.\n\n\nToggle\nMiniPick-actions-toggle\nToggle action is a way to change view: show if target is not shown, reset to main view otherwise.\n\nmappings.toggle_info - toggle info view.\nmappings.toggle_preview - toggle preview.\n\nNote:\n\nUpdating query in any way resets window view to show matches.\nMoving current item focus keeps preview or info view with updated item.\n\n\n\n\nCustom\nMiniPick-actions-custom\nAlong with built-in actions, users can define custom actions. This can be done by supplying custom elements to mappings table. The field defines action name (used to infer an action description in info view). The value is a table with the following fields:\n\n&lt;char&gt; (string) - single character acting as action trigger.\n&lt;func&gt; (function) - callable to be executed without arguments after user presses &lt;char&gt;. Its return value is treated as “should stop picker after execution”, i.e. returning nothing, nil, or false continues picker while everything else (prefer true) stops it.\n\nExample of execute custom mapping:\nexecute = {\n  char = '&lt;C-e&gt;',\n  func = function() vim.cmd(vim.fn.input('Execute: ')) end,\n}\n\n\n\n\nExamples\n\nDisable icons\nDisable icons in MiniPick.builtin pickers related to paths:\nlocal pick = require('mini.pick')\npick.setup({ source = { show = pick.default_show } })\n\n\nSwitch toggle and move keys\nrequire('mini.pick').setup({\n  mappings = {\n    toggle_info    = '&lt;C-k&gt;',\n    toggle_preview = '&lt;C-p&gt;',\n    move_down      = '&lt;Tab&gt;',\n    move_up        = '&lt;S-Tab&gt;',\n  }\n})\n\n\nDifferent window styles:\n-- Different border\n{ window = { config = { border = 'double' } } }\n\n-- \"Cursor tooltip\"\n{\n  window = {\n    config = {\n      relative = 'cursor', anchor = 'NW',\n      row = 0, col = 0, width = 40, height = 20,\n    },\n  },\n}\n\n-- Centered on screen\nlocal win_config = function()\n  local height = math.floor(0.618 * vim.o.lines)\n  local width = math.floor(0.618 * vim.o.columns)\n  return {\n    anchor = 'NW', height = height, width = width,\n    row = math.floor(0.5 * (vim.o.lines - height)),\n    col = math.floor(0.5 * (vim.o.columns - width)),\n  }\nend\n{ window = { config = win_config } }\n\n\n\n\nsetup()\n\nMiniPick.setup({config})\n\nModule setup\n\n:Pick\n:Pick\nCalling this function creates a :Pick user command. It takes picker name from MiniPick.registry as mandatory first argument and executes it with following (expanded, expandcmd()) &lt;f-args&gt; combined in a single table. To add custom pickers, update MiniPick.registry.\nExample:\n:Pick files tool='git'\n:Pick grep pattern='&lt;cword&gt;'\nIt also sets custom vim.ui.select() implementation to use the module. See MiniPick.ui_select().\n\n\nParameters\n{config} (table|nil) Module config table. See MiniPick.config.\n\n\nUsage\nrequire('mini.pick').setup() -- use default config\n-- OR\nrequire('mini.pick').setup({}) -- replace {} with your config table\n\n\n\n\nconfig\n\nMiniPick.config\n\n\nDefaults\nMiniPick.config = {\n  -- Delays (in ms; should be at least 1)\n  delay = {\n    -- Delay between forcing asynchronous behavior\n    async = 10,\n\n    -- Delay between computation start and visual feedback about it\n    busy = 50,\n  },\n\n  -- Keys for performing actions. See `:h MiniPick-actions`.\n  mappings = {\n    caret_left  = '&lt;Left&gt;',\n    caret_right = '&lt;Right&gt;',\n\n    choose            = '&lt;CR&gt;',\n    choose_in_split   = '&lt;C-s&gt;',\n    choose_in_tabpage = '&lt;C-t&gt;',\n    choose_in_vsplit  = '&lt;C-v&gt;',\n    choose_marked     = '&lt;M-CR&gt;',\n\n    delete_char       = '&lt;BS&gt;',\n    delete_char_right = '&lt;Del&gt;',\n    delete_left       = '&lt;C-u&gt;',\n    delete_word       = '&lt;C-w&gt;',\n\n    mark     = '&lt;C-x&gt;',\n    mark_all = '&lt;C-a&gt;',\n\n    move_down  = '&lt;C-n&gt;',\n    move_start = '&lt;C-g&gt;',\n    move_up    = '&lt;C-p&gt;',\n\n    paste = '&lt;C-r&gt;',\n\n    refine        = '&lt;C-Space&gt;',\n    refine_marked = '&lt;M-Space&gt;',\n\n    scroll_down  = '&lt;C-f&gt;',\n    scroll_left  = '&lt;C-h&gt;',\n    scroll_right = '&lt;C-l&gt;',\n    scroll_up    = '&lt;C-b&gt;',\n\n    stop = '&lt;Esc&gt;',\n\n    toggle_info    = '&lt;S-Tab&gt;',\n    toggle_preview = '&lt;Tab&gt;',\n  },\n\n  -- General options\n  options = {\n    -- Whether to show content from bottom to top\n    content_from_bottom = false,\n\n    -- Whether to cache matches (more speed and memory on repeated prompts)\n    use_cache = false,\n  },\n\n  -- Source definition. See `:h MiniPick-source`.\n  source = {\n    items = nil,\n    name  = nil,\n    cwd   = nil,\n\n    match   = nil,\n    show    = nil,\n    preview = nil,\n\n    choose        = nil,\n    choose_marked = nil,\n  },\n\n  -- Window related options\n  window = {\n    -- Float window config (table or callable returning it)\n    config = nil,\n\n    -- String to use as caret in prompt\n    prompt_caret = '▏',\n\n    -- String to use as prefix in prompt\n    prompt_prefix = '&gt; ',\n  },\n}\n\n\nDelays\nconfig.delay defines plugin delays (in ms). All should be strictly positive.\ndelay.async is a delay between forcing asynchronous behavior. This usually means making screen redraws and utilizing MiniPick.poke_is_picker_active() (for example, to stop current matching if query has updated). Smaller values give smoother user experience at the cost of more computations.\ndelay.busy is a delay between when some computation starts and showing visual feedback about it by making window border to have MiniPickBorderBusy highlight group. Smaller values will give feedback faster at the cost of feeling like flicker.\n\n\nMappings\nconfig.mappings defines keys for special actions to be triggered after certain keys. See MiniPick-actions for more information.\n\n\nOptions\nconfig.options contains some general purpose options.\noptions.content_from_bottom is a boolean indicating whether content should be shown from bottom to top. That means that best matches will be shown at the bottom. Note: for better experience use Neovim&gt;=0.10, which has floating window footer capability. Default: false.\noptions.use_cache is a boolean indicating whether match results should be cached per prompt (i.e. concatenated query). This results into faster response on repeated prompts (like when deleting query entries) at the cost of using more memory. Default: false.\n\n\nSource\nconfig.source defines fallbacks for source specification. For example, this can be used to change default match to use different implementation or show to not show icons for some MiniPick.builtin pickers (see MiniPick-examples). See MiniPick-source for more information.\n\n\nWindow\nconfig.window contains window specific configurations.\nwindow.config defines a (parts of) default floating window config for the main picker window. This can be either a table overriding some parts or a callable returning such table. See MiniPick-examples for some examples.\nwindow.prompt_caret defines how caret is displayed in window’s prompt. Default: ‘▏’.\nwindow.prompt_prefix defines what prefix is used in window’s prompt. Default: ‘&gt;’.\n\n\n\n\nstart()\n\nMiniPick.start({opts})\n\nStart picker\nNotes:\n\nIf there is currently an active picker, it is properly stopped and new one is started “soon” in the main event-loop (see vim.schedule()).\nCurrent window at the moment of this function call is treated as “target”. It will be set back as current after MiniPick.stop(). See MiniPick.get_picker_state() and MiniPick.set_picker_target_window().\n\n\nParameters\n{opts} (table|nil) Options. Should have same structure as MiniPick.config. Default values are inferred from there. Usually should have proper MiniPick-source.items defined.\n\n\nReturn\n(any) Item which was current when picker is stopped; nil if aborted.\n\n\n\n\nstop()\n\nMiniPick.stop()\n\nStop active picker\n\n\n\nrefresh()\n\nMiniPick.refresh()\n\nRefresh active picker\n\n\n\ndefault_match()\n\nMiniPick.default_match({stritems}, {inds}, {query}, {opts})\n\nDefault match\nFilter target stritems to contain query and sort from best to worst matches.\nImplements default value for MiniPick-source.match.\nBy default (if no special modes apply) it does the following fuzzy matching:\n\nStritem contains query if it contains all its elements verbatim in the same order (possibly with gaps, i.e. not strictly one after another). Note: empty query and empty string element is contained in any string.\nSorting is done with the following ordering (same as in mini.fuzzy):\n\nThe smaller the match width (end column minus start column) the better.\nAmong same match width, the smaller start column the better.\nAmong same match width and start column, preserve original order.\n\n\nNotes:\n\nMost common interactive usage results into query containing one typed character per element.\n\n\nSpecial modes\n\nForced modes:\n\nQuery starts with “*“: match the rest fuzzy (without other modes).\nQuery starts with “’”: match the rest exactly (without gaps).\n\nPlace modes:\n\nQuery starts with ‘^’: match the rest exactly at start.\nQuery ends with ‘$’: match the rest exactly at end.\nBoth modes can be used simultaneously.\n\nGrouped: query contains at least one whitespace element. Output is computed as if query is split at whitespace indexes with concatenation between them.\n\nPrecedence of modes: “forced exact” = “forced fuzzy” &gt; “place start/end” &gt; “grouped” &gt; “default”\n\n\nExamples\nAssuming stritems are { '_abc', 'a_bc', 'ab_c', 'abc_' }, here are some example matches based on prompt (concatenated query):\n| Prompt | Matches                |\n|--------|------------------------|\n| abc    | All                    |\n| *abc   | All                    |\n|        |                        |\n| 'abc   | abc_, _abc             |\n| *'abc  | None (no \"'\" in items) |\n|        |                        |\n| ^abc   | abc_                   |\n| *^abc  | None (no \"^\" in items) |\n|        |                        |\n| abc$   | _abc                   |\n| *abc$  | None (no \"$\" in items) |\n|        |                        |\n| ab c   | abc_, _abc, ab_c       |\n| *ab c  | None (no \" \" in items) |\nHaving query { 'ab', 'c' } is the same as “ab c” prompt.\nYou can have a feel of how this works with this command:\nMiniPick.start({ source = { items = { '_abc', 'a_bc', 'ab_c', 'abc_' } } })\n\n\nParameters\n{stritems} (table) Array of all stritems.\n{inds} (table) Array of stritems indexes to match. All of them should point at string elements of stritems. No check is done for performance reasons.\n{query} (table) Array of strings.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;sync&gt; (boolean) - Whether to match synchronously. Default: false.\n&lt;preserve_order&gt; (boolean) - Whether to skip sort step. Default: false.\n\n\n\nReturn\n(table|nil) Depending on whether computation is synchronous (either opts.sync is true or there is an active picker):\n\nIf yes, array of stritems indexes matching the query (from best to worst).\nIf no, nil is returned with MiniPick.set_picker_match_inds() used later.\n\n\n\n\n\ndefault_show()\n\nMiniPick.default_show({buf_id}, {items}, {query}, {opts})\n\nDefault show\nShow items in a buffer and highlight parts that actually match query (assuming match is done with MiniPick.default_match()). Lines are computed based on the MiniPick-source.items-stritems.\nImplements default value for MiniPick-source.show.\nUses the following highlight groups (see mini.pick for their description):\n\nMiniPickIconDirectory\nMiniPickIconFile\nMiniPickMatchCurrent\nMiniPickMatchMarked\nMiniPickMatchRanges\n\n\nParameters\n{buf_id} (number) Identifier of target buffer.\n{items} (table) Array of items to show.\n{query} (table) Array of strings representing query.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;show_icons&gt; (boolean) - whether to show icons for entries recognized as valid actually present paths on disk (see MiniPick-source.items-common), empty space otherwise. Tries to use text field as fallback for path. Default: false. Note: MiniPick.builtin pickers showing file/directory paths use true by default.\n&lt;icons&gt; (table) - table with fallback icons used if icon provider does not itself supply default icons for category. Can have fields:\n\n&lt;directory&gt; (string) - icon for directory. Default: “”.\n&lt;file&gt; (string) - icon for file. Default: “”.\n&lt;none&gt; (string) - icon for non-valid path. Default: ” “.\n\n\n\n\n\n\ndefault_preview()\n\nMiniPick.default_preview({buf_id}, {item}, {opts})\n\nDefault preview\nPreview item. Logic follows the rules in MiniPick-source.items-common:\n\nFile and buffer are shown at the start.\nDirectory has its content listed.\nLine/position/region in file or buffer is shown at start.\nOthers are shown directly with vim.inspect().\n\nImplements default value for MiniPick-source.preview.\nUses the following highlight groups (see mini.pick for their description):\n\nMiniPickPreviewLine\nMiniPickPreviewRegion\n\n\nParameters\n{buf_id} (number) Identifier of target buffer.\n{item} (any) Item to preview.\n{opts} (table|nil) Options. Possible values:\n\n&lt;n_context_lines&gt; (number) - number of lines to load past target position when reading from disk. Useful to explore context. Default: ‘lines’ twice.\n&lt;line_position&gt; (string) - where in the window to show item position. One of “top”, “center”, “bottom”. Default: “top”.\n\n\n\n\n\ndefault_choose()\n\nMiniPick.default_choose({item})\n\nDefault choose\nChoose item. Logic follows the rules in MiniPick-source.items-common:\n\nFile uses bufadd() and sets cursor at the start of line/position/region.\nBuffer is set as current in target window and sets cursor similarly.\nDirectory is called with :edit in the target window.\nOthers have the output of vim.inspect() printed in Command line.\n\nImplements default value for MiniPick-source.choose.\n\nParameters\n{item} (any) Item to choose.\n\n\n\n\ndefault_choose_marked()\n\nMiniPick.default_choose_marked({items}, {opts})\n\nDefault choose marked items\nChoose marked items. Logic follows the rules in MiniPick-source.items-common:\n\nIf among items there is at least one file or buffer, quickfix list is opened with all file or buffer lines/positions/regions.\nOtherwise, picker’s source.choose is called on the first item.\n\nImplements default value for MiniPick-source.choose_marked.\n\nParameters\n{items} (table) Array of items to choose.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;list_type&gt; (string) - which type of list to open. One of “quickfix” or “location”. Default: “quickfix”.\n\n\n\n\n\nui_select()\n\nMiniPick.ui_select({items}, {opts}, {on_choice}, {start_opts})\n\nSelect rewrite\nFunction which can be used to directly override vim.ui.select() to use ‘mini.pick’ for any “select” type of tasks. Set automatically in MiniPick.setup().\nImplements required by vim.ui.select() signature, with some differencies:\n\nAllows opts.preview_item that returns an array of lines for item preview.\nAllows fourth start_opts argument to customize MiniPick.start() call.\n\nNotes:\n\non_choice is called when target window is current.\n\n\nUsage\n-- Customize with fourth argument inside a function wrapper\nvim.ui.select = function(items, opts, on_choice)\n  local start_opts = { window = { config = { width = vim.o.columns } } }\n  return MiniPick.ui_select(items, opts, on_choice, start_opts)\nend\nTo preserve original vim.ui.select():\nlocal ui_select_orig = vim.ui.select\nrequire('mini.pick').setup()\nvim.ui.select = ui_select_orig\n\n\n\n\nbuiltin\n\nMiniPick.builtin\n\nTable with built-in pickers\n\n\n\nbuiltin.files()\n\nMiniPick.builtin.files({local_opts}, {opts})\n\nPick from files\nLists all files recursively in all subdirectories. Tries to use one of the CLI tools to create items (see MiniPick-cli-tools): rg, fd, git. If none is present, uses fallback which utilizes vim.fs.dir().\nTo customize CLI tool search, either use tool’s global configuration approach or directly MiniPick.builtin.cli() with specific command.\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;tool&gt; (string) - which tool to use. One of “rg”, “fd”, “git”, “fallback”. Default: whichever tool is present, trying in that same order.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\n\n\nbuiltin.grep()\n\nMiniPick.builtin.grep({local_opts}, {opts})\n\nPick from pattern matches\nLists all pattern matches recursively in all subdirectories. Tries to use one of the CLI tools to create items (see MiniPick-cli-tools): rg, git. If none is present, uses fallback which utilizes vim.fs.dir() and Lua pattern matches (NOT recommended in large directories).\nTo customize CLI tool search, either use tool’s global configuration approach or directly MiniPick.builtin.cli() with specific command. Options ‘ignorecase’ and ‘smartcase’ are respected via forcing appropriate flags to CLI tool (i.e. overriding tool’s global config).\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;tool&gt; (string) - which tool to use. One of “rg”, “git”, “fallback”. Default: whichever tool is present, trying in that same order.\n&lt;pattern&gt; (string) - string pattern to search. If not given, asks user interactively with input().\n&lt;globs&gt; (table) - array of string glob patterns to restrict search to matching files. Supported only by “rg” and “git” tools, respects their specific glob syntax and effects. Default: {} (no restriction). Example: { '*.lua', 'lua/**' } for Lua files and files in “lua” directory.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\n\n\nbuiltin.grep_live()\n\nMiniPick.builtin.grep_live({local_opts}, {opts})\n\nPick from pattern matches with live feedback\nPerform pattern matching treating prompt as pattern. Gives live feedback on which matches are found. Use MiniPick-actions-refine to revert to regular matching. Use &lt;C-o&gt; to restrict search to files matching glob patterns. Tries to use one of the CLI tools to create items (see MiniPick-cli-tools): rg, git. If none is present, error is thrown (for performance reasons).\nTo customize search, use tool’s global configuration approach. Options ‘ignorecase’ and ‘smartcase’ are respected via forcing appropriate flags to CLI tool (i.e. overriding tool’s global config).\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;tool&gt; (string) - which tool to use. One of “rg”, “git”. Default: whichever tool is present, trying in that same order.\n&lt;globs&gt; (table) - array of string glob patterns to restrict search to matching files. Supported only by “rg” and “git” tools, respects their specific glob syntax and effects. Default: {} (no restriction). Example: { '*.lua', 'lua/**' } for Lua files and files in “lua” directory. Use &lt;C-o&gt; custom mapping to add glob to the array.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\n\n\nbuiltin.help()\n\nMiniPick.builtin.help({local_opts}, {opts})\n\nPick from help tags\nNotes:\n\nOn choose directly executes :help command with appropriate modifier (none, :vertical, :tab). This is done through custom mappings named show_help_in_{split,vsplit,tab}. Not choose_in_{split,vsplit,tab} because there is no split guarantee (like if there is already help window opened).\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;default_split&gt; (string) - direction of a split for choose action. One of “horizontal”, “vertical”, “tab”. Default: “horizontal”.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\n\n\nbuiltin.buffers()\n\nMiniPick.builtin.buffers({local_opts}, {opts})\n\nPick from buffers\nNotes:\n\nThere are not built-in mappings for buffer manipulation. Here is an example of how to call this function with mapping to wipeout the current item:\nlocal wipeout_cur = function()\n  vim.api.nvim_buf_delete(MiniPick.get_picker_matches().current.bufnr, {})\nend\nlocal buffer_mappings = { wipeout = { char = '&lt;C-d&gt;', func = wipeout_cur } }\nMiniPick.builtin.buffers(local_opts, { mappings = buffer_mappings })\n\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;include_current&gt; (boolean) - whether to include current buffer in the output. Default: true.\n&lt;include_unlisted&gt; (boolean) - whether to include unlisted-buffers in the output. Default: false.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\n\n\nbuiltin.cli()\n\nMiniPick.builtin.cli({local_opts}, {opts})\n\nPick from CLI output\nExecutes command line tool and constructs items based on its output. Uses MiniPick.set_picker_items_from_cli().\nExample: MiniPick.builtin.cli({ command = { 'echo', 'a\\nb\\nc' } })\n\nParameters\n{local_opts} (table|nil) Options defining behavior of this particular picker. Possible fields:\n\n&lt;command&gt; (table) - forwarded to set_picker_items_from_cli().\n&lt;postprocess&gt; (function) - forwarded to set_picker_items_from_cli().\n&lt;spawn_opts&gt; (table) - forwarded to set_picker_items_from_cli(). Note: if cwd field is absent, it is inferred from MiniPick-source.cwd.\n\n{opts} (table|nil) Options forwarded to MiniPick.start().\n\n\n\n\nbuiltin.resume()\n\nMiniPick.builtin.resume()\n\nResume latest picker\n\n\n\nregistry\n\nMiniPick.registry\n\nPicker registry\nPlace for users and extensions to manage pickers with their commonly used local options. By default contains all MiniPick.builtin pickers. All entries should accept only a single local_opts table argument.\nServes as a source for :Pick command.\nCustomization examples:\n-- Adding custom picker to pick `register` entries\nMiniPick.registry.registry = function()\n  local items = vim.tbl_keys(MiniPick.registry)\n  table.sort(items)\n  local source = {items = items, name = 'Registry', choose = function() end}\n  local chosen_picker_name = MiniPick.start({ source = source })\n  if chosen_picker_name == nil then return end\n  return MiniPick.registry[chosen_picker_name]()\nend\n\n-- Make `:Pick files` accept `cwd`\nMiniPick.registry.files = function(local_opts)\n  local opts = { source = { cwd = local_opts.cwd } }\n  local_opts.cwd = nil\n  return MiniPick.builtin.files(local_opts, opts)\nend\n\n\n\nget_picker_items()\n\nMiniPick.get_picker_items()\n\nGet items of active picker\n\nReturn\n(table|nil) Picker items or nil if no active picker.\n\n\nSee also\nMiniPick.set_picker_items() and MiniPick.set_picker_items_from_cli()\n\n\n\n\nget_picker_stritems()\n\nMiniPick.get_picker_stritems()\n\nGet stritems of active picker\n\nReturn\n(table|nil) Picker stritems (MiniPick-source.items-stritems) or nil if no active picker.\n\n\nSee also\nMiniPick.set_picker_items() and MiniPick.set_picker_items_from_cli()\n\n\n\n\nget_picker_matches()\n\nMiniPick.get_picker_matches()\n\nGet matches of active picker\n\nReturn\n(table|nil) Picker matches or nil if no active picker. Matches is a table with the following fields:\n\n&lt;all&gt; (table|nil) - all currently matched items.\n&lt;all_inds&gt; (table|nil) - indexes of all currently matched items.\n&lt;current&gt; (any) - current matched item.\n&lt;current_ind&gt; (number|nil) - index of current matched item.\n&lt;marked&gt; (table|nil) - marked items.\n&lt;marked_inds&gt; (table|nil) - indexes of marked items.\n&lt;shown&gt; (table|nil) - shown items (from top to bottom).\n&lt;shown_inds&gt; (table|nil) - indexes of shown items (from top to bottom).\n\n\n\nSee also\nMiniPick.set_picker_match_inds()\n\n\n\n\nget_picker_opts()\n\nMiniPick.get_picker_opts()\n\nGet config of active picker\n\nReturn\n(table|nil) Picker config (start()’s input opts table) or nil if no active picker.\n\n\nSee also\nMiniPick.set_picker_opts()\n\n\n\n\nget_picker_state()\n\nMiniPick.get_picker_state()\n\nGet state data of active picker\n\nReturn\n(table|nil) Table with picker state data or nil if no active picker. State data is a table with the following fields:\n\n&lt;buffers&gt; (table) - table with main, preview, info fields representing buffer identifier (or nil) for corresponding view.\n&lt;windows&gt; (table) - table with main and target fields representing window identifiers for main and target windows.\n&lt;caret&gt; (number) - caret column.\n&lt;is_busy&gt; (boolean) - whether picker is busy with computations.\n\n\n\nSee also\nMiniPick.set_picker_target_window()\n\n\n\n\nget_picker_query()\n\nMiniPick.get_picker_query()\n\nGet query of active picker\n\nReturn\n(table|nil) Array of picker query or nil if no active picker.\n\n\nSee also\nMiniPick.set_picker_query()\n\n\n\n\nset_picker_items()\n\nMiniPick.set_picker_items({items}, {opts})\n\nSet items for active picker\nNote: sets items asynchronously in non-blocking fashion.\n\nParameters\n{items} (table) Array of items.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;do_match&gt; (boolean) - whether to perform match after setting items. Default: true.\n&lt;querytick&gt; (number|nil) - value of querytick (MiniPick.get_querytick()) to periodically check against when setting items. If checked querytick differs from supplied, no items are set.\n\n\n\nSee also\nMiniPick.get_picker_items() and MiniPick.get_picker_stritems()\n\n\n\n\nset_picker_items_from_cli()\n\nMiniPick.set_picker_items_from_cli({command}, {opts})\n\nSet items for active picker based on CLI output\nAsynchronously executes command and sets items to its postprocessed output.\nExample:\nlocal items = vim.schedule_wrap(function()\n  MiniPick.set_picker_items_from_cli({ 'echo', 'a\\nb\\nc' })\nend)\nMiniPick.start({ source = { items = items, name = 'Echo abc' } })\n\nParameters\n{command} (table) Array with (at least one) string command parts.\n{opts} (table|nil) Options. Possible fields:\n\n&lt;postprocess&gt; (function) - callable performing postprocessing of output. Will be called with array of lines as input, should return array of items. Default: removes trailing empty lines and uses rest as string items.\n&lt;spawn_opts&gt; (table) - options for uv.spawn(), except args and stdio. Note: relative cwd path is resolved against active picker’s cwd.\n&lt;set_items_opts&gt; (table) - table forwarded to MiniPick.set_picker_items().\n\n\n\nSee also\nMiniPick.get_picker_items() and MiniPick.get_picker_stritems()\n\n\n\n\nset_picker_match_inds()\n\nMiniPick.set_picker_match_inds({match_inds}, {match_type})\n\nSet match indexes for active picker\nThere are two intended use cases:\n\nInside custom asynchronous MiniPick-source.match function to set which of picker’s stritems match the query. See MiniPick.poke_is_picker_active().\nTo programmatically set current match and marked items. See MiniPick.get_picker_matches().\n\n\nParameters\n{match_inds} (table) Array of numbers with picker’s items indexes.\n{match_type} (string|nil) Type of match indexes to set. One of:\n\n\"all\" (default) - indexes of items that match query.\n\"current\" - index of current match. Only first element is used and should also be present among query matches.\n\"marked\" - indexes of marked items. Values can be not among query matches. Will make only input indexes be marked, i.e. current marks are reset. Note: no \"shown\" match type as those indexes are computed automatically.\n\n\n\nSee also\nMiniPick.get_picker_matches()\n\n\n\n\nset_picker_opts()\n\nMiniPick.set_picker_opts({opts})\n\nSet config for active picker\n\nParameters\n{opts} (table) Table overriding initial opts input of MiniPick.start().\n\n\nSee also\nMiniPick.get_picker_opts()\n\n\n\n\nset_picker_target_window()\n\nMiniPick.set_picker_target_window({win_id})\n\nSet target window for active picker\n\nParameters\n{win_id} (number) Valid window identifier to be used as the new target window.\n\n\nSee also\nMiniPick.get_picker_state()\n\n\n\n\nset_picker_query()\n\nMiniPick.set_picker_query({query})\n\nSet query for active picker\n\nParameters\n{query} (table) Array of strings to be set as the new picker query.\n\n\nSee also\nMiniPick.get_picker_query()\n\n\n\n\nget_querytick()\n\nMiniPick.get_querytick()\n\nGet query tick\nQuery tick is a unique query identifier. Intended to be used to detect user activity during and between MiniPick.start() calls for efficient non-blocking functionality. Updates after any query change, picker start and stop.\nSee MiniPick.poke_is_picker_active() for usage example.\n\nReturn\n(number) Query tick.\n\n\n\n\nis_picker_active()\n\nMiniPick.is_picker_active()\n\nCheck if there is an active picker\n\nReturn\n(boolean) Whether there is currently an active picker.\n\n\nSee also\nMiniPick.poke_is_picker_active()\n\n\n\n\npoke_is_picker_active()\n\nMiniPick.poke_is_picker_active()\n\nPoke if picker is active\nIntended to be used for non-blocking implementation of source methods. Returns an output of MiniPick.is_picker_active(), but depending on whether there is a coroutine running:\n\nIf no, return it immediately.\nIf yes, return it after coroutine.yield() with coroutine.resume() called “soon” by the main event-loop (see vim.schedule()).\n\nExample of non-blocking exact match (as demo; can be optimized further):\nlocal match_nonblock = function(match_inds, stritems, query)\n  local prompt, querytick = table.concat(query), MiniPick.get_querytick()\n  local f = function()\n    local res = {}\n    for _, ind in ipairs(match_inds) do\n      local should_stop = not MiniPick.poke_is_picker_active() or\n        MiniPick.get_querytick() ~= querytick\n      if should_stop then return end\n\n      if stritems[ind]:find(prompt) ~= nil then table.insert(res, ind) end\n    end\n\n    MiniPick.set_picker_match_inds(res)\n  end\n\n  coroutine.resume(coroutine.create(f))\nend\n\nReturn\n(boolean) Whether there is an active picker.\n\n\nSee also\nMiniPick.is_picker_active()"
  },
  {
    "objectID": "mini.nvim/doc/mini-clue.html",
    "href": "mini.nvim/doc/mini-clue.html",
    "title": "mini.clue documentation",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nmini.clue Show next key clues\nMIT License Copyright (c) 2023 Evgeni Chasnovski\n\n\nModule\nFeatures:\n\nImplement custom key query process to reach target key combination:\n\nStarts after customizable opt-in triggers (mode + keys).\nEach key press narrows down set of possible targets. Pressing &lt;BS&gt; removes previous user entry. Pressing &lt;Esc&gt; or &lt;C-c&gt; leads to an early stop. Doesn’t depend on ‘timeoutlen’ and has basic support for ‘langmap’.\nEnds when there is at most one target left or user pressed &lt;CR&gt;. Results into emulating pressing all query keys plus possible postkeys.\n\nShow window (after configurable delay) with clues. It lists available next keys along with their descriptions (auto generated from descriptions present keymaps and user-supplied clues; preferring the former).\nConfigurable “postkeys” for key combinations - keys which will be emulated after combination is reached during key query process.\nProvide customizable sets of clues for common built-in keys/concepts:\n\ng key.\nz key.\nWindow commands.\nBuilt-in completion.\nMarks.\nRegisters.\n\nLua functions to disable/enable triggers globally or per buffer.\n\nFor more details see:\n\nMiniClue-key-query-process.\nMiniClue-examples.\nMiniClue.config.\nMiniClue.gen_clues.\n\nNotes:\n\nThere is no functionality to create mappings while defining clues. This is done to clearly separate these two different actions. The best suggested practice is to manually create mappings with descriptions (desc field in options), as they will be automatically used inside clue window.\nTriggers are implemented as special buffer-local mappings. This leads to several caveats:\n\nThey will override same regular buffer-local mappings and have precedence over global one.\nExample: having set &lt;C-w&gt; as Normal mode trigger means that there should not be another &lt;C-w&gt; mapping.\nThey need to be the latest created buffer-local mappings or they will not function properly. Most common indicator of this is that some mapping starts to work only after clue window is shown.\nExample: g is set as Normal mode trigger, but gcc from mini.comment doesn’t work right away. This is probably because there are some other buffer-local mappings starting with g which were created after mapping for g trigger. Most common places for this are in LSP server’s on_attach or during tree-sitter start in buffer.\nTo check if trigger is the most recent buffer-local mapping, execute :&lt;mode-char&gt;map &lt;trigger-keys&gt; (like :nmap g for previous example). Mapping for trigger should be the first listed.\nThis module makes the best effort to work out of the box and cover most common cases, but it is not foolproof. The solution here is to ensure that triggers are created after making all buffer-local mappings: run either MiniClue.setup() or MiniClue.ensure_buf_triggers().\n\nDescriptions from existing mappings take precedence over user-supplied clues. This is to ensure that information shown in clue window is as relevant as possible. To add/customize description of an already existing mapping, use MiniClue.set_mapping_desc().\nDue to technical difficulties, there is no foolproof support for Operator-pending mode triggers (like a/i from mini.ai):\n\nDoesn’t work as part of a command in “temporary Normal mode” (like after i_CTRL-O) due to implementation difficulties.\nCan have unexpected behavior with custom operators.\n\nHas (mostly solved) issues with macros:\n\nAll triggers are disabled during macro recording due to technical reasons.\nThe @ and Q keys are specially mapped inside MiniClue.setup() (if the key is not already mapped) to temporarily disable triggers.\n\n\n\nSetup\nThis module needs a setup with require('mini.clue').setup({}) (replace {} with your config table). It will create global Lua table MiniClue which you can use for scripting or manually (with :lua MiniClue.*).\nConfig table needs to have triggers configured, none is set up by default.\nSee MiniClue.config for available config settings.\nYou can override runtime config settings (like clues or window options) locally to a buffer inside vim.b.miniclue_config which should have same structure as MiniClue.config. See mini.nvim-buffer-local-config for more details.\n\n\nComparisons\n\nfolke/which-key.nvim:\n\nBoth have the same main goal: show available next keys along with their customizable descriptions.\nHas different UI and content layout.\nAllows creating mappings inside its configuration, while this module doesn’t have this by design (to clearly separate two different tasks).\nDoesn’t allow creating submodes, while this module does (via postkeys).\n\nanuvyklack/hydra.nvim:\n\nBoth allow creating submodes: state which starts at certain key combination; treats some keys differently; ends after &lt;Esc&gt;.\nDoesn’t show information about available next keys (outside of submodes), while that is this module’s main goal.\n\n\n\n\nHighlight groups\n\nMiniClueBorder - window border.\nMiniClueDescGroup - group description in clue window.\nMiniClueDescSingle - single target description in clue window.\nMiniClueNextKey - next key label in clue window.\nMiniClueNextKeyWithPostkeys - next key label with postkeys in clue window.\nMiniClueSeparator - separator in clue window.\nMiniClueTitle - window title.\n\nTo change any highlight group, set it directly with nvim_set_hl().\n\n\nDisabling\nTo disable creating triggers, set vim.g.miniclue_disable (globally) or vim.b.miniclue_disable (for a buffer) to true. Considering high number of different scenarios and customization intentions, writing exact rules for disabling module’s functionality is left to user. See mini.nvim-disabling-recipes for common recipes.\n\n\n\n\nKey query process\n\nGeneral info\nThis module implements custom key query process imitating a usual built-in mechanism of user pressing keys in order to execute a mapping. General idea is the same: narrow down key combinations until the target is reached.\nMain goals of its existence are:\n\nAllow reaching certain mappings be independent of ‘timeoutlen’. That is, there is no fixed timeout after which currently typed keys are executed.\nEnable automated showing of next key clues after user-supplied delay (also independent of ‘timeoutlen’).\nAllow emulating configurable key presses after certain key combination is reached. This granular control allows creating so called “submodes”. See more at MiniClue-examples-submodes.\n\nThis process is primarily designed for nested &lt;Leader&gt; mappings in Normal mode but works in all other main modes: Visual, Insert, Operator-pending (with caveats; no foolproof guarantees), Command-line, Terminal.\n\n\nLifecycle\n\nKey query process starts when user types a trigger: certain keys in certain mode. Those keys are put into key query as a single user input. All possible mode key combinations are filtered to ones starting with the trigger keys.\nNote: trigger is implemented as a regular mapping, so if it has at least two keys, they should be pressed within ‘timeoutlen’ milliseconds.\nWait (indefinitely) for user to press a key. Advance depending on the key:\n\nSpecial key:\n\nIf &lt;Esc&gt; or &lt;C-c&gt;, stop the process without any action.\nIf &lt;CR&gt;, stop the process and execute current key query, meaning emulate (with nvim_feedkeys()) user pressing those keys.\nIf &lt;BS&gt;, remove previous user input from the query. If query becomes empty, stop the process without any action.\nIf a key for scrolling clue window (scroll_down / scroll_up in config.window; &lt;C-d&gt; / &lt;C-u&gt; by default), scroll clue window and wait for the next user key. Note: if clue window is not shown, treated as a not special key.\n\nNot special key. Add key to the query while filtering all available key combinations to start with the current key query. Advance:\n\nIf there is a single available key combination matching current key query, execute it.\nIf there is no key combinations starting with the current query, execute it. This, for instance, allows a seamless execution of operators in presence of a longer key combinations. Example: with\n\ng as trigger in Normal mode and available mappings gc / gcc\n\n(like from mini.comment), this allows typing gcip to comment current paragraph, although there are no key combinations starting with gci.\nOtherwise wait for the new user key press.\n\n\n\n\n\nClue window\nAfter initiating key query process and after each key press, a timer is started to show a clue window: floating window with information about available next keys along with their descriptions. Note: if window is already shown, its content is updated right away.\nClues can have these types:\n\n“Terminal next key”: when pressed, will lead to query execution.\n“Terminal next key with postkeys”: when pressed, will lead to query execution plus some configured postkeys.\n“Group next key”: when pressed, will narrow down available key combinations and wait for another key press. Note: can have configured description (inside config.clues) or it will be auto generated based on the number of available key combinations.\n\n\n\n\n\nExamples\n\nFull starter example\nIf not sure where to start, try this example with all provided clues from this module plus all &lt;Leader&gt; mappings in Normal and Visual modes:\nlocal miniclue = require('mini.clue')\nminiclue.setup({\n  triggers = {\n    -- Leader triggers\n    { mode = 'n', keys = '&lt;Leader&gt;' },\n    { mode = 'x', keys = '&lt;Leader&gt;' },\n\n    -- `[` and `]` keys\n    { mode = 'n', keys = '[' },\n    { mode = 'n', keys = ']' },\n\n    -- Built-in completion\n    { mode = 'i', keys = '&lt;C-x&gt;' },\n\n    -- `g` key\n    { mode = 'n', keys = 'g' },\n    { mode = 'x', keys = 'g' },\n\n    -- Marks\n    { mode = 'n', keys = \"'\" },\n    { mode = 'n', keys = '`' },\n    { mode = 'x', keys = \"'\" },\n    { mode = 'x', keys = '`' },\n\n    -- Registers\n    { mode = 'n', keys = '\"' },\n    { mode = 'x', keys = '\"' },\n    { mode = 'i', keys = '&lt;C-r&gt;' },\n    { mode = 'c', keys = '&lt;C-r&gt;' },\n\n    -- Window commands\n    { mode = 'n', keys = '&lt;C-w&gt;' },\n\n    -- `z` key\n    { mode = 'n', keys = 'z' },\n    { mode = 'x', keys = 'z' },\n  },\n\n  clues = {\n    -- Enhance this by adding descriptions for &lt;Leader&gt; mapping groups\n    miniclue.gen_clues.square_brackets(),\n    miniclue.gen_clues.builtin_completion(),\n    miniclue.gen_clues.g(),\n    miniclue.gen_clues.marks(),\n    miniclue.gen_clues.registers(),\n    miniclue.gen_clues.windows(),\n    miniclue.gen_clues.z(),\n  },\n})\n\n\nLeader clues\nAssume there are these &lt;Leader&gt; mappings set up:\n-- Set `&lt;Leader&gt;` before making any mappings and configuring 'mini.clue'\nvim.g.mapleader = ' '\n\nlocal nmap_leader = function(suffix, rhs, desc)\n  vim.keymap.set('n', '&lt;Leader&gt;' .. suffix, rhs, { desc = desc })\nend\nlocal xmap_leader = function(suffix, rhs, desc)\n  vim.keymap.set('x', '&lt;Leader&gt;' .. suffix, rhs, { desc = desc })\nend\n\nnmap_leader('bd', '&lt;Cmd&gt;lua MiniBufremove.delete()&lt;CR&gt;',  'Delete')\nnmap_leader('bw', '&lt;Cmd&gt;lua MiniBufremove.wipeout()&lt;CR&gt;', 'Wipeout')\n\nnmap_leader('lf', '&lt;Cmd&gt;lua vim.lsp.buf.format()&lt;CR&gt;',     'Format')\nxmap_leader('lf', '&lt;Cmd&gt;lua vim.lsp.buf.format()&lt;CR&gt;',     'Format')\nnmap_leader('lr', '&lt;Cmd&gt;lua vim.lsp.buf.rename()&lt;CR&gt;',     'Rename')\nnmap_leader('lR', '&lt;Cmd&gt;lua vim.lsp.buf.references()&lt;CR&gt;', 'References')\nThe following setup will enable &lt;Leader&gt; as trigger in Normal and Visual modes and add descriptions to mapping groups:\nrequire('mini.clue').setup({\n  -- Register `&lt;Leader&gt;` as trigger\n  triggers = {\n    { mode = 'n', keys = '&lt;Leader&gt;' },\n    { mode = 'x', keys = '&lt;Leader&gt;' },\n  },\n\n  -- Add descriptions for mapping groups\n  clues = {\n    { mode = 'n', keys = '&lt;Leader&gt;b', desc = '+Buffers' },\n    { mode = 'n', keys = '&lt;Leader&gt;l', desc = '+LSP' },\n  },\n})\n\n\nClues without mappings\nClues can be shown not only for actually present mappings. This is helpful for showing clues for built-in key combinations. Here is an example of clues for a subset of built-in completion (see MiniClue.gen_clues.builtin_completion() to generate clues for all available completion sources):\nrequire('mini.clue').setup({\n  -- Make `&lt;C-x&gt;` a trigger. Otherwise, key query process won't start.\n  triggers = {\n    { mode = 'i', keys = '&lt;C-x&gt;' },\n  },\n\n  -- Register custom clues\n  clues = {\n    { mode = 'i', keys = '&lt;C-x&gt;&lt;C-f&gt;', desc = 'File names' },\n    { mode = 'i', keys = '&lt;C-x&gt;&lt;C-l&gt;', desc = 'Whole lines' },\n    { mode = 'i', keys = '&lt;C-x&gt;&lt;C-o&gt;', desc = 'Omni completion' },\n    { mode = 'i', keys = '&lt;C-x&gt;&lt;C-s&gt;', desc = 'Spelling suggestions' },\n    { mode = 'i', keys = '&lt;C-x&gt;&lt;C-u&gt;', desc = \"With 'completefunc'\" },\n  }\n})\n\n\nTriggers in special buffers\nBy default triggers are automatically created in listed (‘buflisted’) and some special non-listed buffers. Use MiniClue.ensure_buf_triggers() to manually enable in when you need them. For example:\nau FileType special_ft lua MiniClue.ensure_buf_triggers()\n\n\nSubmodes\nMiniClue-examples-submodes\nSubmode is a state initiated after pressing certain key combination (“prefix”) during which some keys are interpreted differently.\nIn this module submode can be implemented following these steps:\n\nCreate mappings for each key inside submode. Left hand side of mappings should consist from prefix followed by the key.\nCreate clue for each key inside submode with postkeys value equal to prefix. It would mean that after executing particular key combination from this submode, pressing its prefix will be automatically emulated (leading back to being inside submode).\nRegister submode prefix (or some of its starting part) as trigger.\n\n\nSubmode examples\n\nSubmode for moving with mini.move:\n\nPress &lt;Leader&gt;m to start submode.\nPress any of h/j/k/l to move selection/line.\nPress &lt;Esc&gt; to stop submode.\n\nThe code:\nrequire('mini.move').setup({\n  mappings = {\n    left       = '&lt;Leader&gt;mh',\n    right      = '&lt;Leader&gt;ml',\n    down       = '&lt;Leader&gt;mj',\n    up         = '&lt;Leader&gt;mk',\n    line_left  = '&lt;Leader&gt;mh',\n    line_right = '&lt;Leader&gt;ml',\n    line_down  = '&lt;Leader&gt;mj',\n    line_up    = '&lt;Leader&gt;mk',\n  },\n})\n\nrequire('mini.clue').setup({\n  triggers = {\n    { mode = 'n', keys = '&lt;Leader&gt;m' },\n    { mode = 'x', keys = '&lt;Leader&gt;m' },\n  },\n  clues = {\n    { mode = 'n', keys = '&lt;Leader&gt;mh', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'n', keys = '&lt;Leader&gt;mj', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'n', keys = '&lt;Leader&gt;mk', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'n', keys = '&lt;Leader&gt;ml', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'x', keys = '&lt;Leader&gt;mh', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'x', keys = '&lt;Leader&gt;mj', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'x', keys = '&lt;Leader&gt;mk', postkeys = '&lt;Leader&gt;m' },\n    { mode = 'x', keys = '&lt;Leader&gt;ml', postkeys = '&lt;Leader&gt;m' },\n  },\n})\nSubmode for iterating buffers and windows with mini.bracketed:\n\nPress [ or ] to start key query process for certain direction.\nPress b / w to iterate buffers/windows until reach target one.\nPress &lt;Esc&gt; to stop submode.\n\nThe code:\nrequire('mini.bracketed').setup()\n\nrequire('mini.clue').setup({\n  triggers = {\n    { mode = 'n', keys = ']' },\n    { mode = 'n', keys = '[' },\n  },\n  clues = {\n    { mode = 'n', keys = ']b', postkeys = ']' },\n    { mode = 'n', keys = ']w', postkeys = ']' },\n\n    { mode = 'n', keys = '[b', postkeys = '[' },\n    { mode = 'n', keys = '[w', postkeys = '[' },\n  },\n})\nSubmode for window commands using MiniClue.gen_clues.windows():\n\nPress &lt;C-w&gt; to start key query process.\nPress keys which move / change focus / resize windows.\nPress &lt;Esc&gt; to stop submode.\n\nThe code:\nlocal miniclue = require('mini.clue')\nminiclue.setup({\n  triggers = {\n    { mode = 'n', keys = '&lt;C-w&gt;' },\n  },\n  clues = {\n    miniclue.gen_clues.windows({\n      submode_move = true,\n      submode_navigate = true,\n      submode_resize = true,\n    })\n  },\n})\n\n\n\n\nWindow config\nrequire('mini.clue').setup({\n  triggers = { { mode = 'n', keys = '&lt;Leader&gt;' } },\n\n  window = {\n    -- Show window immediately\n    delay = 0,\n\n    config = {\n      -- Compute window width automatically\n      width = 'auto',\n\n      -- Use double-line border\n      border = 'double',\n    },\n  },\n})\n\n\n\n\nsetup()\n\nMiniClue.setup({config})\n\nModule setup\n\nParameters\n{config} (table|nil) Module config table. See MiniClue.config.\n\n\nUsage\nrequire('mini.clue').setup({}) -- replace {} with your config table\n                               -- needs `triggers` field present\n\n\n\n\nconfig\n\nMiniClue.config\n\n\nDefaults\nMiniClue.config = {\n  -- Array of extra clues to show\n  clues = {},\n\n  -- Array of opt-in triggers which start custom key query process.\n  -- **Needs to have something in order to show clues**.\n  triggers = {},\n\n  -- Clue window settings\n  window = {\n    -- Floating window config\n    config = {},\n\n    -- Delay before showing clue window\n    delay = 1000,\n\n    -- Keys to scroll inside the clue window\n    scroll_down = '&lt;C-d&gt;',\n    scroll_up = '&lt;C-u&gt;',\n  },\n}\n\n\nGeneral info\n\nTo use &lt;Leader&gt; as part of the config (either as trigger or inside clues), set it prior to running MiniClue.setup().\nSee MiniClue-examples for examples.\n\n\n\nClues\nconfig.clues is an array with extra information about key combinations. Each element can be one of:\n\nClue table.\nArray (possibly nested) of clue tables.\nCallable (function) returning either of the previous two.\n\nA clue table is a table with the following fields:\n\n&lt;mode&gt; (string) - single character describing single mode short-name of key combination as in nvim_set_keymap() (‘n’, ‘x’, ‘i’, ‘o’, ‘c’, etc.).\n&lt;keys&gt; (string) - key combination for which clue will be shown. “Human-readable” key names as in key-notation (like “&lt;Leader&gt;”, “&lt;Space&gt;”, “&lt;Tab&gt;”, etc.) are allowed.\n&lt;desc&gt; (string|function|nil) - optional key combination description which is shown in clue window. If function, should return string description.\n&lt;postkeys&gt; (string|nil) - optional postkeys which will be executed automatically after keys. Allows creation of submodes (see MiniClue-examples-submodes).\n\nNotes:\n\nPostkeys are literal simulation of keypresses with nvim_feedkeys().\nSuggested approach to configuring clues is to create mappings with desc field while supplying to config.clues only elements describing groups, postkeys, and built-in mappings.\n\n\n\nTriggers\nconfig.triggers is an array with information when MiniClue-key-query-process should start. Each element is a trigger table with the fields &lt;mode&gt; and &lt;keys&gt; which are treated the same as in clue table.\n\n\nWindow\nconfig.window defines behavior of clue window.\nconfig.window.delay is a number of milliseconds after which clue window will appear. Can be 0 to show immediately.\nconfig.window.config is a table defining floating window characteristics or a callable returning such table (will be called with identifier of window’s buffer already showing all clues). It should have the same structure as in nvim_open_win() with the following enhancements:\n\n&lt;width&gt; field can be equal to \"auto\" leading to window width being computed automatically based on its content. Default is fixed width of 30.\n&lt;row&gt; and &lt;col&gt; can be equal to \"auto\" in which case they will be computed to “stick” to set anchor (“SE” by default; see nvim_open_win()). This allows changing corner in which window is shown:\n-- Pick one anchor\nlocal anchor = 'NW' -- top-left\nlocal anchor = 'NE' -- top-right\nlocal anchor = 'SW' -- bottom-left\nlocal anchor = 'SE' -- bottom-right\n\nrequire('mini.clue').setup({\n  window = {\n    config = { anchor = anchor, row = 'auto', col = 'auto' },\n  },\n})\n\nconfig.window.scroll_down / config.window.scroll_up are strings defining keys which will scroll clue window down / up which is useful in case not all clues fit in current window height. Set to empty string '' to disable either of them.\n\n\n\n\nenable_all_triggers()\n\nMiniClue.enable_all_triggers()\n\nEnable triggers in all listed and some special buffers\n\n\n\nenable_buf_triggers()\n\nMiniClue.enable_buf_triggers({buf_id})\n\nEnable triggers in buffer\n\nParameters\n{buf_id} (number|nil) Buffer identifier. Default: current buffer.\n\n\n\n\ndisable_all_triggers()\n\nMiniClue.disable_all_triggers()\n\nDisable triggers in all buffers\n\n\n\ndisable_buf_triggers()\n\nMiniClue.disable_buf_triggers({buf_id})\n\nDisable triggers in buffer\n\nParameters\n{buf_id} (number|nil) Buffer identifier. Default: current buffer.\n\n\n\n\nensure_all_triggers()\n\nMiniClue.ensure_all_triggers()\n\nEnsure all triggers are valid\n\n\n\nensure_buf_triggers()\n\nMiniClue.ensure_buf_triggers({buf_id})\n\nEnsure buffer triggers are valid\n\nParameters\n{buf_id} (number|nil) Buffer identifier. Default: current buffer.\n\n\n\n\nset_mapping_desc()\n\nMiniClue.set_mapping_desc({mode}, {lhs}, {desc})\n\nUpdate description of an existing mapping\nNotes:\n\nUses buffer-local mapping in case there are both global and buffer-local mappings with same mode and LHS. Similar to maparg().\n\n\nParameters\n{mode} (string) Mapping mode (as in maparg()).\n{lhs} (string) Mapping left hand side (as name in maparg()).\n{desc} (string) New description to set.\n\n\n\n\ngen_clues\n\nMiniClue.gen_clues\n\nGenerate pre-configured clues\nThis is a table with function elements. Call to actually get array of clues.\n\n\n\ngen_clues.builtin_completion()\n\nMiniClue.gen_clues.builtin_completion()\n\nGenerate clues for built-in completion\nContains clues for the following triggers:\n{ mode = 'i', keys = '&lt;C-x&gt;' }\n\nReturn\n(table) Array of clues.\n\n\n\n\ngen_clues.g()\n\nMiniClue.gen_clues.g()\n\nGenerate clues for g key\nContains clues for the following triggers:\n{ mode = 'n', keys = 'g' }\n{ mode = 'x', keys = 'g' }\n\nReturn\n(table) Array of clues.\n\n\n\n\ngen_clues.square_brackets()\n\nMiniClue.gen_clues.square_brackets()\n\nGenerate clues for [ and ] keys\nContains clues for the following triggers:\n{ mode = 'n', keys = '[' }\n{ mode = 'n', keys = ']' }\n\nReturn\n(table) Array of clues.\n\n\n\n\ngen_clues.marks()\n\nMiniClue.gen_clues.marks()\n\nGenerate clues for marks\nContains clues for the following triggers:\n{ mode = 'n', keys = \"'\" }\n{ mode = 'n', keys = \"g'\" }\n{ mode = 'n', keys = '`' }\n{ mode = 'n', keys = 'g`' }\n{ mode = 'x', keys = \"'\" }\n{ mode = 'x', keys = \"g'\" }\n{ mode = 'x', keys = '`' }\n{ mode = 'x', keys = 'g`' }\nNote: if you use “g” as trigger (like to enable MiniClue.gen_clues.g()), don’t add “g’” and “g`” as triggers: they already will be taken into account.\n\nReturn\n(table) Array of clues.\n\n\nSee also\nmark-motions\n\n\n\n\ngen_clues.registers()\n\nMiniClue.gen_clues.registers({opts})\n\nGenerate clues for registers\nContains clues for the following triggers:\n{ mode = 'n', keys = '\"' }\n{ mode = 'x', keys = '\"' }\n{ mode = 'i', keys = '&lt;C-r&gt;' }\n{ mode = 'c', keys = '&lt;C-r&gt;' }\n\nParameters\n{opts} (table|nil) Options. Possible keys:\n\n&lt;show_contents&gt; (boolean) - whether to show contents of all possible registers. If false, only description of special registers is shown. Default: false.\n\n\n\nReturn\n(table) Array of clues.\n\n\nSee also\nregisters\n\n\n\n\ngen_clues.windows()\n\nMiniClue.gen_clues.windows({opts})\n\nGenerate clues for window commands\nContains clues for the following triggers:\n{ mode = 'n', keys = '&lt;C-w&gt;' }\nNote: only non-duplicated commands are included. For full list see CTRL-W.\n\nParameters\n{opts} (table|nil) Options. Possible keys:\n\n&lt;submode_move&gt; (boolean) - whether to make move (change layout) commands a submode by using postkeys field. Default: false.\n&lt;submode_navigate&gt; (boolean) - whether to make navigation (change focus) commands a submode by using postkeys field. Default: false.\n&lt;submode_resize&gt; (boolean) - whether to make resize (change size) commands a submode by using postkeys field. Default: false.\n\n\n\nReturn\n(table) Array of clues.\n\n\n\n\ngen_clues.z()\n\nMiniClue.gen_clues.z()\n\nGenerate clues for z key\nContains clues for the following triggers:\n{ mode = 'n', keys = 'z' }\n{ mode = 'x', keys = 'z' }\n\nReturn\n(table) Array of clues."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html",
    "href": "mini.nvim/CHANGELOG.html",
    "title": "Version 0.18.0-dev",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’\nThis is the log of changes for past and current development versions. It lists changes in user-facing functionality per module (or all modules) and type.\nThere are following change types:"
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nEvolve\n\nMove repository hosting from personal ‘echasnovski’ GitHub account to the ‘nvim-mini’ organization. All git pull and git clone should be automatically redirected from previous to new locations without breaking user configurations. Yet updating source links to point to new locations (like 'echasnovski/mini.nvim' -&gt; 'nvim-mini/mini.nvim' and standalone repos) is recommended.\nThis change is made to improve long term project stability. See more details here.\nStart setting custom Neovim method implementation during setup() (if module provides one). This is usually the expected behavior for majority of use cases and should improve “out of the box” experience. Modules should still export a function to manually adjust the implementation.\nIt is a breaking change only if the implementation was not explicitly used. Can still be done if set or restored after calling module’s setup().\nAffected modules:\n\n‘mini.notify’ sets vim.notify.\n‘mini.pick’ sets vim.ui.select.\n\n\n\n\nRefine\n\nStop official support of Neovim 0.8.\n\n\n\nExpand\n\nAdd new bundled color schemes based on ‘mini.hues’:\n\nminiwinter: “icy winter” palette with azure background.\nminispring: “blooming spring” palette with green background.\nminisummer: “hot summer” palette with brown/yellow background.\nminiautumn: “cooling autumn” palette with purple background."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.ai",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.ai",
    "title": "Version 0.18.0-dev",
    "section": "mini.ai",
    "text": "mini.ai\n\nRefine\n\nUpdate gen_spec.treesitter() to have use_nvim_treesitter = false as default option value (instead of true). It used to implement more advanced behavior, but as built-in vim.treesitter is capable enough, there is no need in extra dependency. The option will be removed after the release.\n\n\n\nExpand\n\nAdd gen_spec.user_prompt that acts the same as ? built-in textobject. It can be used for using this textobject under another identifier."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.basics",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.basics",
    "title": "Version 0.18.0-dev",
    "section": "mini.basics",
    "text": "mini.basics\n\nRefine\n\nChange default value of options.win_border to be 'auto'.\n\n\n\nExpand\n\nUpdate options.win_border to allow value 'auto' which infers target ‘fillchars’ values from ‘winborder’ option."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.colors",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.colors",
    "title": "Version 0.18.0-dev",
    "section": "mini.colors",
    "text": "mini.colors\n\nUpdate add_transparency() color scheme method to adjust more groups:\n\nXxxMsg groups in case of opts.general = true.\nDiagnosticSignXxx groups in case of opts.statuscolumn = true."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.completion",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.completion",
    "title": "Version 0.18.0-dev",
    "section": "mini.completion",
    "text": "mini.completion\n\nEvolve\n\nUpdate setup() to remove “t” flag from ‘complete’ option (if not previously set and fallback action is default) as it leads to visible lags.\n\n\n\nExpand\n\nAdd MiniCompletionWindowOpen and MiniCompletionWindowUpdate events.\nAdd support for highlighting LSP item label via setting abbr_hlgroup field as part of an LSP item (like inside config.lsp_completion.process_items)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.clue",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.clue",
    "title": "Version 0.18.0-dev",
    "section": "mini.clue",
    "text": "mini.clue\n\nEvolve\n\nUse current query clue (if not immediately after trigger) as a window title instead of showing keys verbatim. This shows extra context when navigating through mappings.\n\n\n\nExpand\n\nAdd gen_clues.square_brackets to generate clues for [ and ] keys. By @TheLeoP, PR #1937.\nEnsure triggers for ‘mini.starter’ buffers, but not override its query updaters (like for “g” and “z” triggers)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.cmdline",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.cmdline",
    "title": "Version 0.18.0-dev",
    "section": "mini.cmdline",
    "text": "mini.cmdline\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.diff",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.diff",
    "title": "Version 0.18.0-dev",
    "section": "mini.diff",
    "text": "mini.diff\n\nExpand\n\nAdd support for working with files containing BOM bytes."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.doc",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.doc",
    "title": "Version 0.18.0-dev",
    "section": "mini.doc",
    "text": "mini.doc\n\nRefine\n\nUpdate default write_pre hook to remove === and --- delimiters from the top of the file to better comply with :h local-additions."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.extra",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.extra",
    "title": "Version 0.18.0-dev",
    "section": "mini.extra",
    "text": "mini.extra\n\nExpand\n\nAdd pickers.colorschemes picker. By @pkazmier, PR #1789.\nAdd workspace_symbol_live scope to pickers.lsp picker. It allows searching for LSP symbols in the workspace with live feedback. Relates to workspace_symbol scope similarly to how MiniPick.builtin.grep_live() relates to MiniPick.builtin.grep().\nAdd &lt;C-e&gt; mapping for pickers.history picker to edit commands or searches in cmdline. By @TheLeoP, PR #1960."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nEvolve\n\nAllow appending / to a file name to mean “delete file” + “create directory”. This is useful when initial intention was to create a directory but there was no / at the end.\n\n\n\nRefine\n\nEnsure preview window is never hidden, even if cursor is on the line for a not (yet) existing file system entry. This reduces flickering of preview window when creating new files in Insert mode.\n\n\n\nExpand\n\nAdd config.content.highlight to customize how file system entry is highlighted. Defaults to a new default_highlight() function."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nEvolve\n\nAdd auto adjusting of highlight groups based on certain events. It can be disabled via new autoadjust config setting or opts.autoadjust in apply_palette(). Affected groups:\n\nMsgSeparator depends on msgsep flag of ‘fillchars’ option.\nPmenu depends on ‘pumborder’ option value (on Neovim&gt;=0.12).\n\n\n\n\nRefine\n\nMake black (0 and 8) and white (7 and 15) colors for built-in terminal different from regular background and foreground. This improves color coverage and does not affect default uncolored text (it is highlighted as Normal).\n\n\n\nExpand\n\nAdd get_palette() function."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.jump",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.jump",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump",
    "text": "mini.jump\n\nExpand\n\nTrigger dedicated events during steps of jumping life cycle. See :h MiniJump-events."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.jump2d",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.jump2d",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump2d",
    "text": "mini.jump2d\n\nEvolve\n\nUpdate builtin_opts.word_start to use built-in notion of “keyword” (see :h 'iskeyword') when computing word start.\n\n\n\nRefine\n\nMove gen_xxx_spotter into separate gen_spotter table for consistency with other modules:\n\ngen_pattern_spotter -&gt; gen_spotter.pattern\ngen_union_spotter -&gt; gen_spotter.union\n\nThe gen_xxx_spotter functions will work (with warning) until at least next release.\nNot focusable windows are now ignored when computing jump spots.\n\n\n\nExpand\n\nAdd gen_spotter.vimpattern() that can generate spotter based on Vimscript (not Lua) pattern."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.map",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.map",
    "title": "Version 0.18.0-dev",
    "section": "mini.map",
    "text": "mini.map\n\nExpand\n\nUpdate gen_integration.builtin_search() to react to change of v:hlsearch."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.misc",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.misc",
    "title": "Version 0.18.0-dev",
    "section": "mini.misc",
    "text": "mini.misc\n\nExpand\n\nUpdate zoom() to return whether current buffer is zoomed in. By @loichyan, PR #1954.\nAdd log_add() and related functions (log_get(), log_show(), log_clear()) to work with a special in-memory log array. Useful when debugging Lua code (instead of print())."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nEvolve\n\nPickers grep and grep_live with rg tool now respect Neovim’s 'ignorecase' and 'smartcase' options. This forces corresponding case matching flag (thus overriding global configuration) in favor of a more consistent user experience.\n\n\n\nExpand\n\n“Paste” action now supports special registers: &lt;C-w&gt; (word at cursor), &lt;C-a&gt; (WORD at cursor), &lt;C-l&gt; (line at cursor), &lt;C-f&gt; (filename at cursor).\nKey query process now respects most language mappings. By @yehorb, PR #2026."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.sessions",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.sessions",
    "title": "Version 0.18.0-dev",
    "section": "mini.sessions",
    "text": "mini.sessions\n\nRefine\n\nUpdate read() to write currently read session only if MiniSessions.config.autowrite is set to true."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nEvolve\n\nStop creating update_n_lines mapping: it occupies “mapping real estate” while being rarely needed and straightforward to create manually using MiniSurround.update_n_lines().\nAutomatically map s key to &lt;Nop&gt; if the key is not already mapped and any of created mappings starts with it. This prevents accidental trigger of built-in s if there is a long delay between pressing “s” and the next key.\n\n\n\nRefine\n\nUpdate gen_spec.inpuf.treesitter() to have use_nvim_treesitter = false as default option value (instead of true). It used to implement more advanced behavior, but as built-in vim.treesitter is capable enough, there is no need in extra dependency. The option will be removed after the release."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.17.0-mini.test",
    "href": "mini.nvim/CHANGELOG.html#v0.17.0-mini.test",
    "title": "Version 0.18.0-dev",
    "section": "mini.test",
    "text": "mini.test\n\nRefine\n\nSoft deprecate ignore_lines option in expect.reference_screenshot() in favor of more capable ignore_text and ignore_attr options. For example, ignore_lines = { 1 } is the same as supplying both ignore_text = { 1 } and ignore_attr = { 1 }.\nIt will work at least until the next release, after which its support will be removed. Sorry for the inconvenience.\n\n\n\nExpand\n\nUpdate expect.reference_screenshot() to support separate ignoring of text and attribute screenshot data via new ignore_text and ignore_attr options."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nEvolve\n\nUnify behavior of floating windows:\n\nTruncate title/footer from left if it is too wide.\nSet default title if window is allowed to have border.\nUse single space padding for default title/footer.\nUse ‘single’ as default window border in modules where it can be configured. On Neovim&gt;=0.11 also respect non-empty ‘winborder’ option with lower precedence than explicitly configured value for the module.\n\nUnify how module-related buffers are named: mini&lt;module-name&gt;://&lt;buffer-number&gt;/&lt;useful-info&gt;. This structure allows creating identifiable, reasonably unique, and useful buffer names. This is a user facing change because in some cases the shown buffer’s name will change (like in statusline of opened ‘mini.starter’ buffer or output of :buffers!).\nStop forcing recommended option values behind set_vim_settings config setting. Instead set them automatically in setup(). If it is not essential, do so only if it was not set by user/plugin beforehand (no matter the value). Document this as a new general principle to be followed in the future. Affected modules:\n\n‘mini.bufremove’ (do nothing as recommended ‘hidden’ is on by default)\n‘mini.completion’ (conditionally set ‘completeopt=menuone,noselect’ and flags “c” in ‘shortmess’)\n‘mini.statusline’ (do nothing as recommended ‘laststatus=2’ is default)\n‘mini.tabline’ (unconditionally set ‘showtabline=2’, as it is essential to module’s functinonality)\n\n\n\n\nRefine\n\nSoft deprecate support for Neovim 0.8. It will be fully stopped in next release."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.ai",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.ai",
    "title": "Version 0.18.0-dev",
    "section": "mini.ai",
    "text": "mini.ai\n\nRefine\n\nVisual textobject selection now puts the cursor on the right edge instead of left. This better aligns with the (undocumented) behavior of how built-in a / i textobjects work in Visual mode, as opposed to the (documented in :h operator-resulting-pos) behavior of how it is done after applying the operator.\n\n\n\nExpand\n\nTextobject identifier can now be any single character supported by :h getcharstr(). This also makes it possible to use characters outside of Latin alphanumeric and punctuation sets as custom_textobjects keys. Default textobject is extended to be anything but Latin letters (to fall back to :h text-objects).\nUpdate gen_spec.treesitter() to respect capture ranges specified by query directives (like (#offset! @table.inner 0 1 0 -1))."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nRefine\n\nUpdate ‘mini.pick’ highlight groups to show prompt text with same colors as match ranges, as they are connected.\n\n\n\nExpand\n\nAdd support for colored markdown headings.\nAdd new plugin integrations:\n\n‘ibhagwan/fzf-lua’\n‘MeanderingProgrammer/render-markdown.nvim’\n‘OXY2DEV/helpview.nvim’\n‘OXY2DEV/markview.nvim’"
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.colors",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.colors",
    "title": "Version 0.18.0-dev",
    "section": "mini.colors",
    "text": "mini.colors\n\nExpand\n\nUpdate convert() to have adjust_lightness option which can be used to disable lightness adjustment (which is enabled by default for a more uniform progression from 0 to 100). This can be useful for output to be more consistent with other Oklab/Oklch implementations."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nUpdate textobject to respect ignore_blank_line option. Blank lines between commented lines are treated as part of a textobject."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.completion",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.completion",
    "title": "Version 0.18.0-dev",
    "section": "mini.completion",
    "text": "mini.completion\n\nEvolve\n\nAdd snippet support. By default uses ‘mini.snippets’ to manage snippet session (if enabled, **highly recommended), falls back to vim.snippet on Neovim&gt;=0.10. See “Snippets” section in :h MiniCompletion for more details.\nThis affect existing functionality because items with Snippet kind are no longer filtered out by default.\nRework how LSP completion items are converted to Neovim’s completion items:\n\nShow detail highlighted as buffer’s language at the start of info window, but only if detail provides information not already present in documentation. It was previously used as extra text in the popup menu (via menu field), but this doesn’t quite follow LSP specification: detail and documentation fields can be delayed up until completionItem/resolve request which implies they should be treated similarly.\nShow labelDetails as a part of the popup menu via menu completion item field.\n\nRework how information window is shown with the goal to reduce flickering during fast up/down navigation through completion candidates:\n\nDo not close the window immediately after the move. Instead highlight border with MiniCompletionInfoBorderOutdated immediately while update window when its content is ready. Close the window only if no candidate is selected.\nShow content of already visited/resolved candidate without delay.\nShow default -No-info- text if there is no extra information about the candidate.\n\nUpdate behavior and capabilities of default_process_items():\n\nAdd filtersort option to control how items are filtered and/or sorted. Its new default value has changed behavior: do fuzzy matching if ‘completeopt’ option contains “fuzzy” entry; same as before otherwise.\nAdd kind_priority option to allow arranging items by completion item kind (like “Variable”, “Snippet”, “Text”, etc.) after applying filtersort. This allows finer filter and/or sort based on kind, like “put Variable on top, Snippet on bottom, remove Text”.\nUse filterText and label item fields during matching (instead of textEdit.newText, insertText, and label as before). This is more aligned with LSP specification.\n\n\n\n\nRefine\n\nPrefer in some cases to use nil as default config value with explicit fallback. This should not have any user facing effects and marked as breaking only because a structure of a default config has changed. Affected fields:\n\nlsp_completion.process_items (use default_process_items as fallback) and fallback_action (use '&lt;C-n&gt;' as fallback). This makes it more aligned with other modules that usually avoid using function values in default config.\nwindow.info.border and window.signature.border (use non-empty ‘winborder’ and 'single' as fallback).\n\nChange default value of MiniCompletionActiveParameter highlight group to link to LspSignatureActiveParameter (instead of forcing underline).\nCall lsp_completion.process_items with an array of items from all buffer servers at once (and not for each server separately). This can be used for more elaborate filter/sort strategies.\n\n\n\nExpand\n\nAdd scrolling in info and signature window. By default can be done with &lt;C-f&gt; / &lt;C-b&gt; when target window is shown. Can be configured via mappings.scroll_down and mappings.scroll_up config options.\nRespect isIncomplete in LSP completion response and immediately force new completion request on the next key press.\nAdd support for context in ‘textDocument/completion’ request.\nBoth info and signature help windows now use tree-sitter highlighting:\n\nInfo window uses “markdown” parser (works best on Neovim&gt;=0.10 as its parser is built-in). Special markdown characters are concealed (i.e. hidden) which might result into seemingly unnecessary whitespace as dimensions are computed not accounting for that.\nSignature help uses same parser as in current filetype.\n\nUpdate signature help without delay if it is already shown. This helps to keep signature help up to date after cursor jumps in Insert mode (like during snippet session).\nAdd support for item defaults in CompletionList response.\nAdd get_lsp_capabilities() that returns data about which part of LSP specification is supported in ‘mini.completion’.\nInput items for lsp_completion.process_items now have client_id field with the identifier of the server that item came from. Use vim.lsp.get_client_by_id() to get an actual data about the server."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.diff",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.diff",
    "title": "Version 0.18.0-dev",
    "section": "mini.diff",
    "text": "mini.diff\n\nExpand\n\nThe config.source can now be array of sources, which will be attempted to attach in order. Important for source’s attach to either return false or call MiniDiff.fail_attach() (even not immediately) to signal that source has failed to attach to a particular buffer.\nOverlay virtual lines now scroll horizontally along with buffer lines. Requires Neovim&gt;=0.11 and disabled ‘wrap’ option.\nHighlighting of buffer parts of change hunks can now be customized with these new highlight groups:\n\nMiniDiffOverChangeBuf - changed buffer text. Previously used MiniDiffOverChange (for changed reference text); links to it by default.\nMiniDiffOverContextBuf - context of a change shown in buffer overlay. Previously not highlighted, default highlight group is not created."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.doc",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.doc",
    "title": "Version 0.18.0-dev",
    "section": "mini.doc",
    "text": "mini.doc\n\nExpand\n\nFEATURE: improve detection and formatting for types in @param, @return, and similar."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.fuzzy",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.fuzzy",
    "title": "Version 0.18.0-dev",
    "section": "mini.fuzzy",
    "text": "mini.fuzzy\n\nRefine\n\nUpdate process_lsp_items() to only use filterText and label item fields during fuzzy matching (instead of textEdit.newText, insertText, and label as before). This is more aligned with LSP specification.\nTreat empty word as matching any candidate (matched positions is empty array and score is -1). This behavior is usually more useful in practice."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nEvolve\n\n\nRefine\n\nUpdate ‘mini.pick’ highlight groups to show prompt text with same colors as match ranges, as they are connected.\n\n\n\nExpand\n\nAdd support for colored markdown headings.\nAdd new plugin integrations:\n\n‘ibhagwan/fzf-lua’\n‘MeanderingProgrammer/render-markdown.nvim’\n‘OXY2DEV/helpview.nvim’\n‘OXY2DEV/markview.nvim’"
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.keymap",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.keymap",
    "title": "Version 0.18.0-dev",
    "section": "mini.keymap",
    "text": "mini.keymap\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.notify",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.notify",
    "title": "Version 0.18.0-dev",
    "section": "mini.notify",
    "text": "mini.notify\n\nExpand\n\nAdd lsp_progress.level option to control level of LSP progress notifications.\nAdd MiniNotifyLspProgress highlight group to be used for LSP progress notifications.\nAdd data field to notification specification and as a new argument to MiniNotify.add(). It can be used to store any data relevant to the notification. For example, notifications from make_notify() output set source field to 'vim.notify', while notifications from LSP progress set source to 'lsp_progress'."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.operators",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.operators",
    "title": "Version 0.18.0-dev",
    "section": "mini.operators",
    "text": "mini.operators\n\nExpand\n\nUpdate setup() to remap built-in gx Normal/Visual mode mappings (for opening an URI under cursor) to gX (if that is not already taken)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.pairs",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.pairs",
    "title": "Version 0.18.0-dev",
    "section": "mini.pairs",
    "text": "mini.pairs\n\nExpand\n\nUpdate all actions to work with pairs containing multibyte characters (like “¿?”, “「」”, and similar)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nRefine\n\nRename prompt_cursor in config.window to prompt_caret for better naming consistency. It works for now, but will stop in the next release. Sorry for the inconvenience.\n\n\n\nExpand\n\nAdd MiniPickPromptCaret and MiniPickPromptPrefix highlight groups to allow finer customization of picker’s prompt.\nUpdate get_picker_matches() to return data (items and indexes) about currently shown items.\nUpdate set_picker_match_inds() to be able to set current match and marked items indexes."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.snippets",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.snippets",
    "title": "Version 0.18.0-dev",
    "section": "mini.snippets",
    "text": "mini.snippets\n\nExpand\n\nAdd start_lsp_server() to start specialized in-process LSP server to show loaded snippets inside (auto)completion engines (like ‘mini.completion’)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nRefine\n\nFunction section_fileinfo() got several updates:\n\nFile size is now computed based on the current buffer text and not for file’s saved version.\nFile info is now shown even for buffers with empty ‘filetype’. It previously was treated as a sign of a “temporary buffer”, but it might be a result of an unsuccessful filetype matching."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nExpand\n\nSurrounding identifier can now be any single character supported by :h getcharstr(). This also makes it possible to use characters outside of Latin alphanumeric and punctuation sets as custom_surroundings keys.\nUpdate gen_spec.input.treesitter() to respect capture ranges specified by query directives (like (#offset! @table.inner 0 1 0 -1))."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.16.0-mini.tabline",
    "href": "mini.nvim/CHANGELOG.html#v0.16.0-mini.tabline",
    "title": "Version 0.18.0-dev",
    "section": "mini.tabline",
    "text": "mini.tabline\n\nExpand\n\nAdd support for showing special (truncation) characters at left and/or right if there are more tabs to the left and/or right. They are shown with the new MiniTablineTrunc highlight group in case ‘list’ option is enabled (i.e. user deliberately enabled similar functionality for windows). Exact characters are taken from ‘listchars’ option: precedes and extends fields.\nLabels for quickfix and location lists are now different."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.align",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.align",
    "title": "Version 0.18.0-dev",
    "section": "mini.align",
    "text": "mini.align\n\nExpand\n\nAdd built-in modifier for “|” character with aligning Markdown-like tables in mind."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.animate",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.animate",
    "title": "Version 0.18.0-dev",
    "section": "mini.animate",
    "text": "mini.animate\n\nEvolve\n\nAdd max_output_steps option to gen_path.line() and gen_path.angle() to limit the number of steps the return. Default is 1000 to improve performance on large cursor jumps which also is set for config.cursor.path."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nExpand\n\nClosing and refreshing explorer now requires confirmation only if there are pending file system actions (and not in case of at least one modified buffer present).\nConfirming file system actions in synchronize() now can cancel synchronization (by pressing c) while keeping buffer contents the same. synchronize() also returns a boolean representing whether synchronization was done."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.git",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.git",
    "title": "Version 0.18.0-dev",
    "section": "mini.git",
    "text": "mini.git\n\nExpand\n\nGit data is computed after resolving symlinks. This allows working with files symlinked into outside of Git repo. This behavior is the same as in ‘mini.diff’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.hipatterns",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.hipatterns",
    "title": "Version 0.18.0-dev",
    "section": "mini.hipatterns",
    "text": "mini.hipatterns\n\nRefine\n\nMake MiniHipatterns{Fixme,Hack,Todo,Note} highlight groups by default be reverse and bold variant of Diagnostic{Error,Warn,Info,Hint} group instead of directly link to them. This ensures better visibility for color schemes which don’t have explicit ‘mini.hipatterns’ support."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nExpand\n\nAdd 'lowmedium' and 'mediumhigh' saturation levels."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.icons",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.icons",
    "title": "Version 0.18.0-dev",
    "section": "mini.icons",
    "text": "mini.icons\n\nExpand\n\nAdd distinctive glyphs and highlighting for special Neovim directories (from :h 'runtimepath')."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.indentscope",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.indentscope",
    "title": "Version 0.18.0-dev",
    "section": "mini.indentscope",
    "text": "mini.indentscope\n\nEvolve\n\nAdd options.n_lines option to limit the scope computation (for better performance). It’s default value is 10000 while previous behavior behavior had no restriction (as with n_lines = math.huge) which should matter only in very big scopes.\nAdd draw.predicate configuration to customize whether the scope should be autodrawn. It’s default value does not draw scope with incomplete computation (i.e. interrupted due to options.n_lines value), which should matter only in very big scopes."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.notify",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.notify",
    "title": "Version 0.18.0-dev",
    "section": "mini.notify",
    "text": "mini.notify\n\nFEATURE: setup() now also can be used to clean history (for example, like MiniNotify.setup(MiniNotify.config))."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nEvolve\n\nPicker window now has local current directory set to source’s cwd. This allows easier code for “in window” functions (callable items, choose, preview, etc.) as relative paths will be properly resolved. It also results in some changes:\n\nCalling set_picker_items_from_cli() with active picker now resolves explicitly set to relative path spawn_opts.cwd against picker’s cwd (and not against global current directory as was done previously).\n\n\n\n\nExpand\n\nUpdate grep and grep_live pickers to allow globs local option which restricts search to files that match any of its glob patterns (for example, { '*.lua', 'lua/**' } will only search in Lua files and files in ‘lua’ directory). The grep_live picker also has custom &lt;C-o&gt; mapping to add globs interactively after picker is opened.\nUpdate help picker to have default_split local option which customizes split direction of choose action (&lt;CR&gt; by default).\nUpdate ui_select() to allow fourth argument start_opts to customize MiniPick.start() call.\nAdd MiniPickMatch event triggered after updating query matches or setting items. Can be used, for example, to adjust window height based on current matches."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.snippets",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.snippets",
    "title": "Version 0.18.0-dev",
    "section": "mini.snippets",
    "text": "mini.snippets\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nRefine\n\nCreated mappings for find, find_left, and highlight are now not dot-repeatable. Dot-repeat should repeat last text change but neither of those actions change text. Having them dot-repeatable breaks the common “move cursor -&gt; press dot” workflow. Initially making them dot-repeatable was a “you can but you should not” type of mistake."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.15.0-mini.test",
    "href": "mini.nvim/CHANGELOG.html#v0.15.0-mini.test",
    "title": "Version 0.18.0-dev",
    "section": "mini.test",
    "text": "mini.test\n\nEvolve\n\nNow calling skip() in set’s pre_case hook results in skipping all test cases in a set. Calling in other hooks has no effect. This enables a more structured skipping of all test cases inside a set. To skip inside hooks, use add_note() followed by return.\n\n\n\nExpand\n\nAdd n_retry test set property. When set, each case will be tried that at most that many times until first success (if any).\nAdd hooks.pre_source and hooks.post_source fields to collected cases. They can be either 'once' or 'case' and allow a more granular control over case execution.\nFunction finally() now can be called several times inside a single function with callbacks executed in order of how they were registered.\nUpdate expect.reference_screenshot() to allow directory option pointing to a directory where automatically constructed reference path is located."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nEvolve\n\nUpdate help files to use code blocks with language annotation, as it results in a better code highlighting. Implies enabled tree-sitter highlighting in ‘help’ filetype:\n\nIt is default in Neovim&gt;=0.10.\nTree-sitter parser is built-in in Neovim 0.9.x, needs manual enabling via vim.treesitter.start().\nHas visual regressions on Neovim 0.8.0 and 0.8.1 without enabled tree-sitter (code blocks are highlighted as normal text). Use 0.8.2 or newer.\n\nUniversally prefer ‘mini.icons’ module over ‘nvim-tree/nvim-web-devicons’.\n\n\n\nRefine\n\nStop official support of Neovim 0.7.\n\n\n\nExpand\n\nStart automated testing on Windows and MacOS.\nUniversally ensure that all plugin’s highlight groups are defined after any color scheme takes effect."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nExpand\n\nAdd ‘kevinhwang91/nvim-bqf’ plugin integration."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.completion",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.completion",
    "title": "Version 0.18.0-dev",
    "section": "mini.completion",
    "text": "mini.completion\n\nExpand\n\nAdd highlighting of LSP kind (like “Function”, “Keyword”, etc.). Works only on Neovim&gt;=0.11. Requires enabled ‘mini.icons’ to work out of the box."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.doc",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.doc",
    "title": "Version 0.18.0-dev",
    "section": "mini.doc",
    "text": "mini.doc\n\nEvolve\n\nUpdate afterlines_to_code() to result into Lua code block in help file by using &gt;lua at the start instead of &gt;. NOTE: users need enabled help tree-sitter parser (which is default on Neovim&gt;=0.9) for code blocks to have proper highlighting."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.extra",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.extra",
    "title": "Version 0.18.0-dev",
    "section": "mini.extra",
    "text": "mini.extra\n\nRefine\n\nUse “│” as line/position separator instead of “:”. This aligns with changes in ‘mini.pick’ and makes line/position more easily visible.\n\n\n\nExpand\n\nUpdate oldfiles picker to have current_dir option which if true shows files only from picker’s working directory. By @abeldekat, PR #997.\nUpdate git_hunks, list, and lsp pickers to show icons. Scopes document_symbol and workspace_symbol in lsp picker show icon based on LSP kind (requires set up ‘mini.icons’), others - based on path data.\nUpdate buf_lines and oldfiles pickers to have preserve_order local option, similar to visit_paths picker. Other possible candidates for this option are intentionally not updated to not increase maintenance (manually override match source method to call MiniPick.default_match() with { preserve_order = true } options).\nUpdate buf_lines picker to pad line numbers to achieve more aligned look."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.git",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.git",
    "title": "Version 0.18.0-dev",
    "section": "mini.git",
    "text": "mini.git\n\nExpand\n\nUpdate show_at_cursor() to include commit’s statistics when showing commit.\nUpdate show_at_cursor() to show relevant at cursor commit data inside ‘mini.deps’ confirmation buffer."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.hipatterns",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.hipatterns",
    "title": "Version 0.18.0-dev",
    "section": "mini.hipatterns",
    "text": "mini.hipatterns\n\nEvolve\n\nUpdate compute_hex_color_group() to compute based on combination of hex_color and style, opposed to just hex_color. This allows simultaneous usage of several styles in user’s custom highlighters."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nExpand\n\nImplement apply_palette() (to compliment make_palette()) providing a way to tweak applied palette before applying it.\nAdd ‘kevinhwang91/nvim-bqf’ plugin integration."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nEvolve\n\n\nRefine\n\nUpdate how confirmation lines are computed:\n\nShow create actions in the group directory where text manipulation took place. This matters during creating nested entries and is usually a more intuitive representation.\nFor delete show its type after the file name (“permanently” or “to trash”) as an additional visual indication of delete type.\nFor create, copy and move prefer showing its “to” path relative to group directory.\nSeparate action name and paths with “│” (instead of “:”) for better visual separation.\nDon’t enclose paths in quotes. Initially it was done to reliably show possible whitespace in paths, but inferring it from overall line structure should be good enough.\n\nSoft deprecate get_target_window() in favor of get_explorer_state().target_window. Will be completely removed after the next release.\n\n\n\nExpand\n\nPrefer using ‘mini.icons’ as icon provider.\nImplement bookmarks. With default config:\n\nType m followed by a single character &lt;char&gt; to set directory path of focused window as a bookmark with id &lt;char&gt;.\nType ' followed by a bookmark id to make bookmark’s path focused in explorer.\nUse MiniFiles.set_bookmark() inside MiniFilesExplorerOpen event to set custom bookmarks.\n\nMake data for MiniFilesActionDelete contain to field in case of not permanent delete.\nMake file manipulation work better for special complex/overlapping cases (like delete ‘file-a’ and copy ‘file-b’ as ‘file-a’). It is still a better idea to split overlapping manipulations into smaller and not related steps, as there are cases which won’t work.\nAdd get_explorer_state() to allow more reliable user customizations.\nAdd set_branch() to allow to set what paths should be displayed and focused."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.icons",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.icons",
    "title": "Version 0.18.0-dev",
    "section": "mini.icons",
    "text": "mini.icons\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.misc",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.misc",
    "title": "Version 0.18.0-dev",
    "section": "mini.misc",
    "text": "mini.misc\n\nExpand\n\nImplement setup_termbg_sync() to set up terminal background synchronization (removes possible “frame” around current Neovim instance). Works only on Neovim&gt;=0.10."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nEvolve\n\n\nRefine\n\nUpdate default_match() to have table opts as fourth argument (instead of boolean do_sync). Use { sync = true } to run synchronously. The new design is more aligned with other functions and is more forward compatible.\nEncoding line or position in string items has changed:\n\nUse “\\0” (null character; use “\\000” form if it is in a string before digit) instead of “:” as delimiter. This makes it work with files similar to “:” position encoding (like “time_12:34:56”). This only matters for custom sources which provide line or position in string items.\nUpdate default_show() to display “│” character instead of “\\0” in item’s string representation (previously was “:”). In particular, this changes how line/position is displayed in grep and grep_live built-in pickers. This change was done because “│” is more visible as separator.\n\n\n\n\nExpand\n\nPrefer using ‘mini.icons’ as icon provider.\nAdd preserve_order option to default_match() to allow asynchronous matching which preserves order (i.e. doesn’t do sort step of fuzzy matching).\nExplicitly hide cursor when picker is active (instead of putting it in command line)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nRefine\n\nChange filetype of Starter buffer from ‘starter’ to ‘ministarter’. This is a more robust value and more aligned with other modules."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nRefine\n\nUpdate section_fileinfo() to show non-empty filetype even in not normal buffers (like plugin’s scratch buffers, help, quickfix, etc.). Previously it showed nothing, which was a mistake as filetype can be a valuable information.\nThe default set_vim_settings config value now does not affect laststatus = 3 (aka global statusline).\n\n\n\nExpand\n\nPrefer using ‘mini.icons’ as icon provider for section_fileinfo()."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nRefine\n\nAdding surrounding in linewise mode now also ignores trailing whitespace on the last line (same as it ignores indent on the first line)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.tabline",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.tabline",
    "title": "Version 0.18.0-dev",
    "section": "mini.tabline",
    "text": "mini.tabline\n\nExpand\n\nPrefer using ‘mini.icons’ as icon provider."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.14.0-mini.test",
    "href": "mini.nvim/CHANGELOG.html#v0.14.0-mini.test",
    "title": "Version 0.18.0-dev",
    "section": "mini.test",
    "text": "mini.test\n\nExpand\n\nMake it work on Windows. By @cameronr, PR #1101."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nRefine\n\nBlank lines are now completely ignored when deciding the toggling action. In practice this means that if target block consists only from commented and/or blank lines, it will be uncommented rather than commented.\nWhitespace in comment parts is now treated more explicitly. In particular:\n\nDefault options.pad_comment_parts = true now more explicitly means that any value of ‘commentstring’ is transformed so that comment parts have exactly single space inner padding.\nExample: any /*%s*/, /* %s */, or /*  %s  */ is equivalent to having /* %s */.\nDetection of whether consecutive lines are commented or not does not depend on whitespace in comment parts. Uncommenting is first attempted with exact comment parts and falls back on trying its trimmed parts.\nExample of toggling comment on single line with /* %s */ ‘commentstring’ value:\n\n/* this is commented */ -&gt; this is commented.\n/*this is also commented */ -&gt; this is also commented (notice trailing space).\n\nCommenting blank lines is done with trimmed comments parts, while uncommenting explicitly results into empty lines.\n\n\n\n\nExpand\n\nSupport dot-repeat after initial commenting is done for visual selection; repeating is done for same relative range."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.deps",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.deps",
    "title": "Version 0.18.0-dev",
    "section": "mini.deps",
    "text": "mini.deps\n\nExpand\n\nAdd MiniDepsMsgBreaking highlight group for messages indicating a breaking change in a conventional commit style."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.diff",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.diff",
    "title": "Version 0.18.0-dev",
    "section": "mini.diff",
    "text": "mini.diff\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nExpand\n\nAdd new MiniFilesExplorerOpen and MiniFilesExplorerClose events."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.git",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.git",
    "title": "Version 0.18.0-dev",
    "section": "mini.git",
    "text": "mini.git\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nRefine\n\nUpdate some highlight groups for better usability:\n\nDiffChange and DiffText - make changed diff lines have colored background.\nFolded - make folds differ from CursorLine.\nQuickFixLine - make current quickfix item differ from CursorLine."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.map",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.map",
    "title": "Version 0.18.0-dev",
    "section": "mini.map",
    "text": "mini.map\n\nExpand\n\nAdd gen_integration.diff() which highlights general diff hunks from ‘mini.diff’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nEvolve\n\n\nRefine\n\nStop trying to parse path for special format (“path:row” and “path:row:col”) if supplied inside a table item. This made impossible working with paths containing “:”.\nUpdate builtin.files() to use table items when string item might be ambiguous.\n\n\n\nExpand\n\nRespect general URI format for paths inside table items."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nRefine\n\nExplicitly block all events in open() during startup for a better performance."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nEvolve\n\nUpdate section_git() to prefer using data from ‘mini.git’ with fallback on pure HEAD data from ‘lewis6991/gistigns.nvim’.\nUpdate default active content:\n\nAdd section_diff() (shows diff data near  icon) following refactor of section_git().\nAdd section_lsp() (shows number of attached LSP servers near 󰰎 icon) following refactor of section_diagnostics().\n\n\n\n\nRefine\n\nUpdate section_diagnostics() to depend only on defined diagnostic. This means:\n\nSomething is shown only if there is any diagnostic actually present in the buffer. No diagnostic entries - nothing is shown. Previously it did not show if there was no LSP servers attached (as initially diagnostics came only from LSP) or buffer was not normal.\nFallback icon is “Diag” instead of “LSP”.\n\n\n\n\nExpand\n\nUpdate section_diagnostics() to support signs table option to customize signs for severity levels.\nAdd section_diff() to show data from ‘mini.diff’ with fallback on diff data from ‘lewis6991/gistigns.nvim’.\nAdd section_lsp() to show indicator of LSP servers attached to the buffer."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.tabline",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.tabline",
    "title": "Version 0.18.0-dev",
    "section": "mini.tabline",
    "text": "mini.tabline\n\nExpand\n\nImplement config.format for custom label formatting."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.13.0-mini.test",
    "href": "mini.nvim/CHANGELOG.html#v0.13.0-mini.test",
    "title": "Version 0.18.0-dev",
    "section": "mini.test",
    "text": "mini.test\n\nRefine\n\nChild process is now created with extra --headless --cmd \"set lines=24 columns=80\" arguments making it headless but still reasonably similar to fully functioning Neovim during interactive usage. This change should generally not break a lot of things, while enabling a faster and more robust test execution."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.basics",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.basics",
    "title": "Version 0.18.0-dev",
    "section": "mini.basics",
    "text": "mini.basics\n\nRefine\n\nRemove &lt;C-z&gt; mapping, as it is more useful in most terminal emulators for suspending Neovim process (to later resume with fg command). To correct latest misspelled word, use mappings like this:\nvim.keymap.set('n', '&lt;C-z&gt;', '[s1z=',                     { desc = 'Correct latest misspelled word' })\nvim.keymap.set('i', '&lt;C-z&gt;', '&lt;C-g&gt;u&lt;Esc&gt;[s1z=`]a&lt;C-g&gt;u', { desc = 'Correct latest misspelled word' })\n\n\n\nExpand\n\nAdd tab:&gt; to ‘listchars’ option when options.extra_ui is set. This prevents showing ^I instead of a tab and actual value comes from Neovim’s default.\nSet termguicolors only on Neovim&lt;0.10, as later versions should have it on by default (if terminal emulator supports it)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nHooks are now called with data about commenting action."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.deps",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.deps",
    "title": "Version 0.18.0-dev",
    "section": "mini.deps",
    "text": "mini.deps\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.doc",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.doc",
    "title": "Version 0.18.0-dev",
    "section": "mini.doc",
    "text": "mini.doc\n\nRefine\n\nStop using :echo to display messages and warnings in favor of vim.notify().\nUpdate default write_post hook to not display current time in success message.\nUpdate to include space before ~ in generated section headings."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nExpand\n\nUpdate go_in() to have close_on_file option.\nShow warning if action is set to override existing path."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nRefine\n\nUpdate verbatim text (@text.literal and @markup.raw) color to be distinctive instead of dimmed.\n\n\n\nExpand\n\nAdd support for new standard tree-sitter captures on Neovim&gt;=0.10 (see https://github.com/neovim/neovim/pull/27067)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.misc",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.misc",
    "title": "Version 0.18.0-dev",
    "section": "mini.misc",
    "text": "mini.misc\n\nRefine\n\nUpdate bench_time() to use vim.loop.hrtime() (as better designed for benchmarking) instead of vim.loop.gettimeofday()."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.notify",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.notify",
    "title": "Version 0.18.0-dev",
    "section": "mini.notify",
    "text": "mini.notify\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nExpand\n\nImplement window.prompt_cursor and window.prompt_prefix config options.\nUpdate builtin.help() to use tree-sitter highlighting (if there is any)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.sessions",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.sessions",
    "title": "Version 0.18.0-dev",
    "section": "mini.sessions",
    "text": "mini.sessions\n\nRefine\n\nUpdate read() to first write() current session (if there is any)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nExpand\n\nAdd sections.pick() with ‘mini.pick’ pickers."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nEvolve\n\nAdd search_count section to default active content."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.12.0-mini.visits",
    "href": "mini.nvim/CHANGELOG.html#v0.12.0-mini.visits",
    "title": "Version 0.18.0-dev",
    "section": "mini.visits",
    "text": "mini.visits\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nRefine\n\nStop supporting deprecated ‘HiPhish/nvim-ts-rainbow2’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.bufremove",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.bufremove",
    "title": "Version 0.18.0-dev",
    "section": "mini.bufremove",
    "text": "mini.bufremove\n\nEvolve\n\nApplying delete() and wipeout() without force in a modified buffer now asks for confirmation instead of declining and showing message."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.clue",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.clue",
    "title": "Version 0.18.0-dev",
    "section": "mini.clue",
    "text": "mini.clue\n\nExpand\n\nValue of config.window.config now can be callable returning window config."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nImplement config.mappings.comment_visual to configure mapped keys in Visual mode."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.completion",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.completion",
    "title": "Version 0.18.0-dev",
    "section": "mini.completion",
    "text": "mini.completion\n\nEvolve\n\nStart adding C flag to shortmess option on Neovim&gt;=0.9. By @yamin-shihab, PR #554."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.extra",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.extra",
    "title": "Version 0.18.0-dev",
    "section": "mini.extra",
    "text": "mini.extra\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nRefine\n\nOpening file which is present in unlisted buffer now makes the buffer listed.\nHighlight in preview now is not enabled if file is sufficiently large.\n\n\n\nExpand\n\nExplorer now tracks if focus is lost and properly closes on detection.\nImplement MiniFilesCursorLine highlight group."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.hipatterns",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.hipatterns",
    "title": "Version 0.18.0-dev",
    "section": "mini.hipatterns",
    "text": "mini.hipatterns\n\nRefine\n\nField priority in highlighter definitions is soft deprecated in favor of extmark_opts = { priority = &lt;value&gt; }.\n\n\n\nExpand\n\nAllow pattern in highlighter definitions to be an array to highlight several patterns under the same highlighter name.\nImplement extmark_opts in highlighter definitions for a more control over extmarks placed at matches.\nUpdate compute_hex_color_group() to allow style = 'fg'.\nUpdate gen_highlighter.hex_color() to allow style = 'inline' (requires Neovim&gt;=0.10 with support of inline extmarks).\nImplement get_matches() to get buffer matches."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nRefine\n\nStop supporting deprecated ‘HiPhish/nvim-ts-rainbow2’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.map",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.map",
    "title": "Version 0.18.0-dev",
    "section": "mini.map",
    "text": "mini.map\n\nExpand\n\nImplement config.window.zindex to configure z-index of map window."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.misc",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.misc",
    "title": "Version 0.18.0-dev",
    "section": "mini.misc",
    "text": "mini.misc\n\nExpand\n\nUpdate setup_auto_root() and find_root() to now have fallback argument to be applied when no root is found with vim.fn.find()."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.pick",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.pick",
    "title": "Version 0.18.0-dev",
    "section": "mini.pick",
    "text": "mini.pick\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nExpand\n\nValue of show_path in sections.recent_files() can now be callable for more control on how full path is displayed."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.11.0-mini.test",
    "href": "mini.nvim/CHANGELOG.html#v0.11.0-mini.test",
    "title": "Version 0.18.0-dev",
    "section": "mini.test",
    "text": "mini.test\n\nEvolve\n\nUpdate child.get_screenshot() to now by default call :redraw prior to computing screenshot. Can be disabled by new opts.redraw argument.\n\n\n\nRefine\n\nError in any “pre” hook now leads to test case not being executed (with note).\n\n\n\nExpand\n\nNew method child.lua_func() can execute simple functions inside child process and return the result (stasjok, #437).\nUpdate expect.reference_screenshot() to now have ignore_lines option allowing to ignore specified lines during screenshot compare."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.ai",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.ai",
    "title": "Version 0.18.0-dev",
    "section": "mini.ai",
    "text": "mini.ai\n\nExpand\n\nAllow vis_mode field in custom texobject region to force Visual mode with which textobject is selected."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.animate",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.animate",
    "title": "Version 0.18.0-dev",
    "section": "mini.animate",
    "text": "mini.animate\n\nExpand\n\nAdd MiniAnimateNormalFloat highlight group to tweak highlighting of open and close animations."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nExpand\n\nAdd ‘HiPhish/rainbow-delimiters.nvim’ integration."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.basics",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.basics",
    "title": "Version 0.18.0-dev",
    "section": "mini.basics",
    "text": "mini.basics\n\nRefine\n\nRemove &lt;C-w&gt; mapping in Terminal mode, as it is more useful inside terminal emulator itself."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.bracketed",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.bracketed",
    "title": "Version 0.18.0-dev",
    "section": "mini.bracketed",
    "text": "mini.bracketed\n\nExpand\n\nAdd add_to_jumplist option to relevant targets (which move cursor and don’t already add to jumplist)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.bufremove",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.bufremove",
    "title": "Version 0.18.0-dev",
    "section": "mini.bufremove",
    "text": "mini.bufremove\n\nRefine\n\nCreate normal buffer instead of scratch when there is no reasonable target to focus (#394)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.clue",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.clue",
    "title": "Version 0.18.0-dev",
    "section": "mini.clue",
    "text": "mini.clue\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.files",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.files",
    "title": "Version 0.18.0-dev",
    "section": "mini.files",
    "text": "mini.files\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nExpand\n\nAdd ‘HiPhish/rainbow-delimiters.nvim’ integration."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.jump2d",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.jump2d",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump2d",
    "text": "mini.jump2d\n\nExpand\n\nAdd gen_union_spotter() to allow combining separate spotters into one."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.operators",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.operators",
    "title": "Version 0.18.0-dev",
    "section": "mini.operators",
    "text": "mini.operators\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.pairs",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.pairs",
    "title": "Version 0.18.0-dev",
    "section": "mini.pairs",
    "text": "mini.pairs\n\nExpand\n\nAllow false in config.mappings to not map the key."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.10.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.10.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nExpand\n\nUpdate add (sa) with ability to replicate left and right parts by respecting [count]. In Normal mode two kinds of [count] is respected: one for operator (replicates left and right parts) and one for textobject/motion. In Visual mode [count] replicates parts."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nEvolve\n\nUse Lua API to create autocommands. Stop exporting functions only related to autocommands.\nUse vim.keymap to deal with mappings. Stop exporting functions only related to mappings.\n\n\n\nRefine\n\nStop official support of Neovim 0.6.\n\n\n\nExpand\n\nAdd ‘randomhue’ color scheme."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nEvolve\n\nStop supporting archived ‘p00f/nvim-ts-rainbow’ in favor of ‘HiPhish/nvim-ts-rainbow2’.\n\n\n\nExpand\n\nAdd new integrations:\n\nLsp semantic tokens.\n‘folke/lazy.nvim’.\n‘folke/noice.nvim’.\n‘kevinhwang91/nvim-ufo’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-mini.basics",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-mini.basics",
    "title": "Version 0.18.0-dev",
    "section": "mini.basics",
    "text": "mini.basics\n\nExpand\n\nAdd dot-repeat support for adding empty lines (go and gO mappings)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-mini.colors",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-mini.colors",
    "title": "Version 0.18.0-dev",
    "section": "mini.colors",
    "text": "mini.colors\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nUse tree-sitter information about locally active language to infer ‘commentstring’ option value.\nAdd options.custom_commentstring option for a more granular customization of comment structure.\nAdd get_commentstring() function representing built-in logic of computing relevant ‘commentstring’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-mini.hipatterns",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-mini.hipatterns",
    "title": "Version 0.18.0-dev",
    "section": "mini.hipatterns",
    "text": "mini.hipatterns\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.9.0-mini.hues",
    "href": "mini.nvim/CHANGELOG.html#v0.9.0-mini.hues",
    "title": "Version 0.18.0-dev",
    "section": "mini.hues",
    "text": "mini.hues\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nExpand\n\nAdd and implement design principle for silencing module by setting config.silent = true. It is now present in modules capable of showing non-error feedback:\n\nmini.ai\nmini.align\nmini.basics\nmini.bufremove\nmini.doc\nmini.jump\nmini.jump2d\nmini.starter\nmini.surround\nmini.test"
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.bracketed",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.bracketed",
    "title": "Version 0.18.0-dev",
    "section": "mini.bracketed",
    "text": "mini.bracketed\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nAdd options.start_of_line option which controls whether to recognize as comment only lines without indent.\nAdd options.ignore_blank_line option which controls whether to ignore blank lines.\nAdd options.pad_comment_parts option which controls whether to ensure single space pad for comment leaders."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.doc",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.doc",
    "title": "Version 0.18.0-dev",
    "section": "mini.doc",
    "text": "mini.doc\n\nExpand\n\nAdd config.hooks.write_pre hook to be executed before writing to a file."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.indentscope",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.indentscope",
    "title": "Version 0.18.0-dev",
    "section": "mini.indentscope",
    "text": "mini.indentscope\n\nExpand\n\nAdd MiniIndentscopeSymbolOff highlight group to be used if scope’s indent is not multiple of ‘shiftwidth’.\nAdd draw.priority option to control priority of scope line draw."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.jump2d",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.jump2d",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump2d",
    "text": "mini.jump2d\n\nExpand\n\nAdd view.n_steps_ahead option which controls how many steps ahead to show. Appearance is controlled by new MiniJump2dSpotAhead highlight group.\nAdd view.dim option which controls whether to dim lines with at least one jump spot. Appearance is controlled by new MiniJump2dDim highlight group.\nAdd MiniJump2dSpotUnique highlight group to be used for spots with unique label for next step."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.pairs",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.pairs",
    "title": "Version 0.18.0-dev",
    "section": "mini.pairs",
    "text": "mini.pairs\n\nExpand\n\nBoth MiniPairs.br() and MiniPairs.cr() can now take a key which will be used instead of default &lt;BS&gt; and &lt;CR&gt;."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.sessions",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.sessions",
    "title": "Version 0.18.0-dev",
    "section": "mini.sessions",
    "text": "mini.sessions\n\nExpand\n\nUpdate setup() to now create global directory at path config.directory if it doesn’t exist.\nAll actions now keep list of detected sessions up to date."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.splitjoin",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.splitjoin",
    "title": "Version 0.18.0-dev",
    "section": "mini.splitjoin",
    "text": "mini.splitjoin\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.8.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.8.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nExpand\n\nAdd respect_selection_type option which, when enabled, makes adding and deleting surrounding respect selection type:\n\nLinewise adding places surrounding parts on separate lines while indenting surrounded lines once.\nDeleting surrounding which looks like a result of linewise adding will act to revert it: delete lines with surrounding parts and dedent surrounded lines once.\nBlockwise adding places surrounding parts on whole edges, not only start and end of selection."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nExpand\n\nStart dual distribution. Every module is now distributed both as part of ‘mini.nvim’ library and as standalone plugin (in separate git repository)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.ai",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.ai",
    "title": "Version 0.18.0-dev",
    "section": "mini.ai",
    "text": "mini.ai\n\nRefine\n\nIn MiniAi.gen_spec.argument() option separators (plural; array of characters) is soft deprecated in favor of separator (singular; Lua pattern) option."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.animate",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.animate",
    "title": "Version 0.18.0-dev",
    "section": "mini.animate",
    "text": "mini.animate\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.basics",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.basics",
    "title": "Version 0.18.0-dev",
    "section": "mini.basics",
    "text": "mini.basics\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.completion",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.completion",
    "title": "Version 0.18.0-dev",
    "section": "mini.completion",
    "text": "mini.completion\n\nRefine\n\nRename MiniCompletion.config.window_dimensions to MiniCompletion.config.window to be able to handle more general configuration.\n\n\n\nExpand\n\nAdd MiniCompletion.config.window.info.border and MiniCompletion.config.window.signature.border which can be used to define border of info and signature floating windows respectively."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.indentscope",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.indentscope",
    "title": "Version 0.18.0-dev",
    "section": "mini.indentscope",
    "text": "mini.indentscope\n\nRefine\n\nStop using (deprecate) MiniIndentscopePrefix highlight groups. It was initially introduced as a way to properly show scope indicator on empty lines. It had a drawback of overshadowing ‘listchars’ symbols (see #125) and vertical guides from ‘lukas-reineke/indent-blankline.nvim’. As the other implementation approach was found by @mivort (see #161), MiniIndentscopePrefix is no longer needed and no overshadowing is done.\nUpdate MiniIndentscope.gen_animation to now be a table (for consistency with other gen_* functions in ‘mini.nvim’). See “Migrate from function type” section of :h MiniIndentscope.gen_animation. Calling it as function will be available until next release."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.misc",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.misc",
    "title": "Version 0.18.0-dev",
    "section": "mini.misc",
    "text": "mini.misc\n\nExpand\n\nAdd MiniMisc.setup_auto_root() and MiniMisc.find_root() for root finding functionality. NOTE: requires Neovim&gt;=0.8.\nAdd MiniMisc.setup_restore_cursor() for automatically restoring latest cursor position on file reopen. By @cryptomilk, PR #198."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.7.0-mini.move",
    "href": "mini.nvim/CHANGELOG.html#v0.7.0-mini.move",
    "title": "Version 0.18.0-dev",
    "section": "mini.move",
    "text": "mini.move\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nRefine\n\nStop official support of Neovim 0.5.\n\n\n\nExpand\n\nMake all messages use colors and not cause hit-enter-prompt."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-mini.align",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-mini.align",
    "title": "Version 0.18.0-dev",
    "section": "mini.align",
    "text": "mini.align\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nRefine\n\nChange some ‘mini.nvim’ highlights:\n\nMiniCompletionActiveParameter now highlights with background instead of underline.\nMiniJump2dSpot now explicitly defined to use plugin’s palette.\nMiniStarterItemPrefix and MiniStarterQuery are now bold for better visibility.\n\nUpdate highlight for changed git diff to be more visible and to comply more with general guidelines.\n\n\n\nExpand\n\nAdd support for many plugin integrations.\nImplement MiniBase16.config.plugins for configuring plugin integrations."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-mini.jump",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-mini.jump",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump",
    "text": "mini.jump\n\nRefine\n\nAllow cursor to be positioned past the end of previous/current line (#113)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-mini.map",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-mini.map",
    "title": "Version 0.18.0-dev",
    "section": "mini.map",
    "text": "mini.map\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nRefine\n\nItem evaluation is now prepended with query reset, as it is rarely needed any more (#105).\nAll hooks are now called with (content, buf_id) signature allowing them properly use current window layout."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.6.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.6.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nEvolve\n\nUpdate ‘mini.surround’ to share as much with ‘mini.ai’ as possible. This provides more integrated experience while enabling more useful features. Details:\n\nCustom surrounding specification for input action has changed. Instead of { find = &lt;string&gt;, extract = &lt;string&gt; } it is now { &lt;function or composed pattern&gt; }. Previous format will work until the next release. See more in help file.\nAlgorithm for finding surrounding is now more powerful. It allows searching for more complex surroundings (via composed patterns or array of region pairs) and respects v:count.\nMultiline input and output surroundings are now supported.\nOpening brackets ((, [, {, &lt;) now include whitespace in surrounding: input surrounding selects all inner edge whitespace, output surrounding is padded with single space.\nSurrounding identifier i (“interactive”) is soft deprecated in favor of ? (“user prompt”).\nNew surrounding aliases:\n\nb for “brackets”. Input - any of balanced (), [] {}. Output - ().\nq for “quotes”. Input - any of \", ', `. Output - \"\".\n\nThree new search methods 'prev', 'next', and 'nearest' for finding non-covering previous and next surrounding.\n\nImplement “last”/“next” extended mappings which force 'prev' or 'next' search method. Controlled with config.mappings.suffix_last and config.mappings.suffix_nextrespectively. This also means that custom surroundings with identifier equal to “last”/“next” mappings suffixes (defaults to ‘l’ and ‘n’) will work only with long enough delay after typing action mapping.\n\n\n\nExpand\n\nImplement MiniSurround.gen_spec with generators of common surrounding specifications (like MiniSurround.gen_spec.input.treesitter for tree-sitter based input surrounding)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nRefine\n\nUpdate all tests to use new ‘mini.test’ module.\n\n\n\nExpand\n\nImplement buffer local configuration. This is done with vim.b.mini*_config buffer variables.\nAdd new minicyan color scheme."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.ai",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.ai",
    "title": "Version 0.18.0-dev",
    "section": "mini.ai",
    "text": "mini.ai\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nNow hooks can be used to terminate further actions by returning false (#108)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.indentscope",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.indentscope",
    "title": "Version 0.18.0-dev",
    "section": "mini.indentscope",
    "text": "mini.indentscope\n\nRefine\n\nSoft deprecate vim.b.miniindentscope_options in favor of using options field of miniindentscope_config."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.sessions",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.sessions",
    "title": "Version 0.18.0-dev",
    "section": "mini.sessions",
    "text": "mini.sessions\n\nExpand\n\nHooks are now called with active session data as argument."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nEvolve\n\n\nRefine\n\nDeprecate MiniStarter.content in favor of MiniStarter.get_content().\n\n\n\nExpand\n\nMake it possible to open multiple Starter buffers at the same time (#82).\nAll functions dealing with Starter buffer now have buf_id as argument."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nExpand\n\nImplement config.use_icons which controls whether to use icons by default."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.test",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.test",
    "title": "Version 0.18.0-dev",
    "section": "mini.test",
    "text": "mini.test\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.5.0-mini.trailspace",
    "href": "mini.nvim/CHANGELOG.html#v0.5.0-mini.trailspace",
    "title": "Version 0.18.0-dev",
    "section": "mini.trailspace",
    "text": "mini.trailspace\n\nExpand\n\nImplement MiniTrailspace.trim_last_lines()."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nExpand\n\nUpdate all modules to supply mapping description for Neovim&gt;=0.7.\nCover all modules with extensive tests."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nImplement config.hooks with pre and post hooks (executed before and after successful commenting). Fixes #50, #59."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.completion",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.completion",
    "title": "Version 0.18.0-dev",
    "section": "mini.completion",
    "text": "mini.completion\n\nExpand\n\nImplement support for additionalTextEdits (issue #61)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.jump",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.jump",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump",
    "text": "mini.jump\n\nRefine\n\nSoft deprecate config.highlight_delay in favor of config.delay.highlight.\n\n\n\nExpand\n\nImplement idle timeout to stop jumping automatically (@annenpolka, #56).\nImplement MiniJump.state: table with useful model-related information.\nUpdate process of querying target symbol: show help message after delay, allow &lt;C-c&gt; to stop selecting target."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.jump2d",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.jump2d",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump2d",
    "text": "mini.jump2d\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.pairs",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.pairs",
    "title": "Version 0.18.0-dev",
    "section": "mini.pairs",
    "text": "mini.pairs\n\nRefine\n\nCreate mappings for &lt;BS&gt; and &lt;CR&gt; in certain mode only after some pair is registered in that mode."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.sessions",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.sessions",
    "title": "Version 0.18.0-dev",
    "section": "mini.sessions",
    "text": "mini.sessions\n\nRefine\n\nAll feedback about incorrect behavior is now an error instead of message notifications.\n\n\n\nExpand\n\nImplement MiniSessions.select() to select session interactively and perform action on it.\nImplement config.hooks to execute hook functions before and after successful action."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nExpand\n\nAllow config.header and config.footer be any value, which will be converted to string via tostring().\nUpdate query logic to not allow queries which result into no items.\nAdd &lt;C-n&gt; and &lt;C-p&gt; to default mappings."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nRefine\n\nChange default icon for MiniStatusline.section_diagnostics() from ﯭ to  due to former having issues in some terminal emulators."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.surround",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.surround",
    "title": "Version 0.18.0-dev",
    "section": "mini.surround",
    "text": "mini.surround\n\nEvolve\n\n\nRefine\n\nDeprecate config.funname_pattern option in favor of manually modifying f surrounding.\nAlways move cursor to the right of left surrounding in add(), delete(), and replace() (instead of moving only if it was on the same line as left surrounding).\n\n\n\nExpand\n\nImplement config.search_method.\nImplement custom surroundings via config.custom_surroundings.\nImplement MiniSurround.user_input().\nUpdate process of getting user input: allow &lt;C-c&gt; to cancel and make empty string a valid input."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.4.0-mini.tabline",
    "href": "mini.nvim/CHANGELOG.html#v0.4.0-mini.tabline",
    "title": "Version 0.18.0-dev",
    "section": "mini.tabline",
    "text": "mini.tabline\n\nRefine\n\nShow listed buffers also in case of multiple tabpages (instead of using builtin behavior).\n\n\n\nExpand\n\nImplement config.tabpage_section.\nShow quickfix/loclist buffers with special *quickfix* label."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.3.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.3.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nExpand\n\nUpdate all modules to have annotations formatted for ‘mini.doc’."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.3.0-mini.cursorword",
    "href": "mini.nvim/CHANGELOG.html#v0.3.0-mini.cursorword",
    "title": "Version 0.18.0-dev",
    "section": "mini.cursorword",
    "text": "mini.cursorword\n\nExpand\n\nCurrent word under cursor now can be highlighted differently."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.3.0-mini.doc",
    "href": "mini.nvim/CHANGELOG.html#v0.3.0-mini.doc",
    "title": "Version 0.18.0-dev",
    "section": "mini.doc",
    "text": "mini.doc\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.3.0-mini.indentscope",
    "href": "mini.nvim/CHANGELOG.html#v0.3.0-mini.indentscope",
    "title": "Version 0.18.0-dev",
    "section": "mini.indentscope",
    "text": "mini.indentscope\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.3.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.3.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nExpand\n\nImplement MiniStarter.set_query() and make &lt;Esc&gt; mapping for resetting query."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.base16",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.base16",
    "title": "Version 0.18.0-dev",
    "section": "mini.base16",
    "text": "mini.base16\n\nExpand\n\nUse new Diagnostic* highlight groups in Neovim 0.6.0."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.comment",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.comment",
    "title": "Version 0.18.0-dev",
    "section": "mini.comment",
    "text": "mini.comment\n\nExpand\n\nRespect tab indentation (#20)."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.jump",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.jump",
    "title": "Version 0.18.0-dev",
    "section": "mini.jump",
    "text": "mini.jump\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.pairs",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.pairs",
    "title": "Version 0.18.0-dev",
    "section": "mini.pairs",
    "text": "mini.pairs\n\nExpand\n\nImplement pair registration with custom mapping functions:\n\nImplement MiniPairs.map(), MiniPairs.map_buf(), MiniPairs.unmap(), MiniPairs.unmap_buf() to (un)make mappings for pairs which automatically register them for &lt;BS&gt; and &lt;CR&gt;. Note, that this has a minor break of previous behavior: now MiniPairs.bs() and MiniPairs.cr() don’t have any input argument. But default behavior didn’t change.\nAllow setting global pair mappings inside config of MiniPairs.setup()."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.sessions",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.sessions",
    "title": "Version 0.18.0-dev",
    "section": "mini.sessions",
    "text": "mini.sessions\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.starter",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.starter",
    "title": "Version 0.18.0-dev",
    "section": "mini.starter",
    "text": "mini.starter\n\nExpand\n\nIntroduction of a new module."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.2.0-mini.statusline",
    "href": "mini.nvim/CHANGELOG.html#v0.2.0-mini.statusline",
    "title": "Version 0.18.0-dev",
    "section": "mini.statusline",
    "text": "mini.statusline\n\nExpand\n\nImplement new section MiniStatusline.section_searchcount().\nUpdate section_diagnostics to use vim.diagnostic in Neovim 0.6.0."
  },
  {
    "objectID": "mini.nvim/CHANGELOG.html#v0.1.0-all",
    "href": "mini.nvim/CHANGELOG.html#v0.1.0-all",
    "title": "Version 0.18.0-dev",
    "section": "All",
    "text": "All\n\nExpand\n\nInitial stable version."
  },
  {
    "objectID": "mini.nvim/TESTING.html",
    "href": "mini.nvim/TESTING.html",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "Writing tests for Neovim Lua plugin is hard. Writing good tests for Neovim Lua plugin is even harder. The ‘mini.test’ module is designed to make it reasonably easier while still allowing lots of flexibility. It deliberately favors a more verbose and program-like style of writing tests, opposite to “human readable, DSL like” approach of nvim-lua/plenary.nvim (“busted-style testing” from Olivine-Labs/busted). Although the latter is also possible.\nThis file is intended as a hands-on introduction to ‘mini.test’ with examples. For more details, see its documentation and tests of this plugin’s modules.\nGeneral approach of writing test files:\n\nOrganize tests in separate Lua files.\nEach file should be associated with a test set table (output of MiniTest.new_set()). Recommended approach is to create it manually in each test file and then return it.\nEach test action should be defined in separate function assign to an entry of test set.\nIt is strongly encouraged to use custom Neovim processes to do actual testing inside test action. See Using child process.\n\nNOTES:\n\nAll commands are assumed to be executed with current working directory being a root of your Neovim plugin project. That is both for shell and Neovim commands.\nAll paths are assumed to be relative to current working directory.\n\n\n\nIn this file we will be testing ‘hello_lines’ plugin (once some basic concepts are introduced). It will have functionality to add prefix ‘Hello’ to lines implemented in a single file ‘lua/hello_lines/init.lua’:\n\n\n‘lua/hello_lines/init.lua’\n\nlocal M = {}\n\n--- Prepend 'Hello ' to every element\n---@param lines table Array. Default: { 'world' }.\n---@return table Array of strings.\nM.compute = function(lines)\n  lines = lines or { 'world' }\n  return vim.tbl_map(function(x) return 'Hello ' .. tostring(x) end, lines)\nend\n\nlocal ns_id = vim.api.nvim_create_namespace('hello_lines')\n\n--- Set lines with highlighted 'Hello ' prefix\n---@param buf_id number Buffer handle where lines should be set. Default: 0.\n---@param lines table Array. Default: { 'world' }.\nM.set_lines = function(buf_id, lines)\n  buf_id = buf_id or 0\n  lines = lines or { 'world' }\n  vim.api.nvim_buf_clear_namespace(buf_id, ns_id, 0, -1)\n  vim.api.nvim_buf_set_lines(buf_id or 0, 0, -1, true, M.compute(lines))\n  for i = 1, #lines do\n    local extmark_opts = { end_row = i - 1, end_col = 5, hl_group = 'Special' }\n    vim.api.nvim_buf_set_extmark(buf_id, ns_id, i - 1, 0, extmark_opts)\n  end\nend\n\nreturn M\n\n\n\n\nHere is a quick demo of how tests with ‘mini.test’ look like:\n\n\n‘tests/test_hello_lines.lua’\n\n-- Define helper aliases\nlocal new_set = MiniTest.new_set\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\n-- Create (but not start) child Neovim object\nlocal child = MiniTest.new_child_neovim()\n\n-- Define main test set of this file\nlocal T = new_set({\n  -- Register hooks\n  hooks = {\n    -- This will be executed before every (even nested) case\n    pre_case = function()\n      -- Restart child process with custom 'init.lua' script\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      -- Load tested plugin\n      child.lua([[M = require('hello_lines')]])\n    end,\n    -- This will be executed one after all tests from this set are finished\n    post_once = child.stop,\n  },\n})\n\n-- Test set fields define nested structure\nT['compute()'] = new_set()\n\n-- Define test action as callable field of test set.\n-- If it produces error - test fails.\nT['compute()']['works'] = function()\n  -- Execute Lua code inside child process, get its result and compare with\n  -- expected result\n  eq(child.lua_get([[M.compute({'a', 'b'})]]), { 'Hello a', 'Hello b' })\nend\n\nT['compute()']['uses correct defaults'] = function()\n  eq(child.lua_get([[M.compute()]]), { 'Hello world' })\nend\n\n-- Make parametrized tests. This will create three copies of each case\nT['set_lines()'] = new_set({ parametrize = { {}, { 0, { 'a' } }, { 0, { 1, 2, 3 } } } })\n\n-- Use arguments from test parametrization\nT['set_lines()']['works'] = function(buf_id, lines)\n  -- Directly modify some options to make better test\n  child.o.lines, child.o.columns = 10, 20\n  child.bo.readonly = false\n\n  -- Execute Lua code without returning value\n  child.lua('M.set_lines(...)', { buf_id, lines })\n\n  -- Test screen state. On first run it will automatically create reference\n  -- screenshots with text and look information in predefined location. On\n  -- later runs it will compare current screenshot with reference. Will throw\n  -- informative error with helpful information if they don't match exactly.\n  expect.reference_screenshot(child.get_screenshot())\nend\n\n-- Return test set which will be collected and execute inside `MiniTest.run()`\nreturn T\n\n\n\n\nIt might be a bit overwhelming. It actually is for most of the people. However, it should be done once and then you rarely need to touch it.\nOverview of full file structure used in for testing ‘hello_lines’ plugin:\n.\n├── deps\n│   └── mini.nvim # Mandatory\n├── lua\n│   └── hello_lines\n│       └── init.lua # Mandatory\n├── Makefile # Recommended\n├── scripts\n│   ├── minimal_init.lua # Mandatory\n│   └── minitest.lua # Recommended\n└── tests\n    └── test_hello_lines.lua # Mandatory\nTo write tests, you’ll need these files:\nMandatory:\n\nYour Lua plugin in ‘lua’ directory. Here we will be testing ‘hello_lines’ plugin.\nTest files. By default they should be Lua files located in ‘tests/’ directory and named with ‘test_’ prefix. For example, we will write everything in ‘test_hello_lines.lua’. It is usually a good idea to follow this template (will be assumed for the rest of this file):\n\n\nTemplate for test files\n\nlocal new_set = MiniTest.new_set\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\nlocal T = new_set()\n\n-- Actual tests definitions will go here\n\nreturn T\n\n‘mini.nvim’ dependency. It is needed to use its ‘mini.test’ module. Proposed way to store it is in ‘deps/mini.nvim’ directory. Create it with git:\nmkdir -p deps\ngit clone --filter=blob:none https://github.com/nvim-mini/mini.nvim deps/mini.nvim\nManual Neovim startup file (a.k.a ‘init.lua’) with proposed path ‘scripts/minimal_init.lua’. It will be used to ensure that Neovim processes can recognize your tested plugin and ‘mini.nvim’ dependency. Proposed minimal content:\n\n\n‘scripts/minimal_init.lua’\n\n-- Add current directory to 'runtimepath' to be able to use 'lua' files\nvim.cmd([[let &rtp.=','.getcwd()]])\n\n-- Set up 'mini.test' only when calling headless Neovim (like with `make test`)\nif #vim.api.nvim_list_uis() == 0 then\n  -- Add 'mini.nvim' to 'runtimepath' to be able to use 'mini.test'\n  -- Assumed that 'mini.nvim' is stored in 'deps/mini.nvim'\n  vim.cmd('set rtp+=deps/mini.nvim')\n\n  -- Set up 'mini.test'\n  require('mini.test').setup()\nend\n\n\nRecommended:\n\nMakefile. In order to simplify running tests from shell and inside Continuous Integration services (like Github Actions), it is recommended to define Makefile. It will define steps for running tests. Proposed template:\n\n\nTemplate for Makefile\n\n# Run all test files\ntest: deps/mini.nvim\n    nvim --headless --noplugin -u ./scripts/minimal_init.lua -c \"lua MiniTest.run()\"\n\n# Run test from file at `$FILE` environment variable\ntest_file: deps/mini.nvim\n    nvim --headless --noplugin -u ./scripts/minimal_init.lua -c \"lua MiniTest.run_file('$(FILE)')\"\n\n# Download 'mini.nvim' to use its 'mini.test' testing module\ndeps/mini.nvim:\n    @mkdir -p deps\n    git clone --filter=blob:none https://github.com/nvim-mini/mini.nvim $@\n\n‘mini.test’ script at ‘scripts/minitest.lua’. Use it to customize what is tested (which files, etc.) and how. Usually not needed, but otherwise should have some variant of a call to MiniTest.run().\n\n\n\n\nThe ‘mini.test’ module out of the box supports two major ways of running tests:\n\nInteractive. All test files will be run directly inside current Neovim session. This proved to be very useful for debugging while writing tests. To run tests, simply execute :lua MiniTest.run() / :lua MiniTest.run_file() / :lua MiniTest.run_at_location() (assuming, you already have ‘mini.test’ set up with require('mini.test').setup()). With default configuration this will result into floating window with information about results of test execution. Press q to close it. Note: Be careful though, as it might affect your current setup. To avoid this, use child processes inside tests.\nHeadless (from shell). Start headless Neovim process with proper startup file and execute lua MiniTest.run(). Assuming full file organization from previous section, this can be achieved with make test. This will show information about results of test execution directly in shell.\n\n\n\n\nThese sections will show some basic capabilities of ‘mini.test’ and how to use them. In all examples code blocks represent some whole test file (like ‘tests/test_basics.lua’).\n\n\nA test is defined as function assigned to a field of test set. If it throws error, test has failed. Test file should return single test set. Here is an example:\nlocal T = MiniTest.new_set()\n\nT['works'] = function()\n  local x = 1 + 1\n  if x ~= 2 then\n    error('`x` is not equal to 2')\n  end\nend\n\nreturn T\nWriting if .. error() .. end is too tiresome. That is why ‘mini.test’ comes with very minimal but usually quite enough set of expectations: MiniTest.expect. They display the intended expectation between objects and will throw error with informative message if it doesn’t hold. Here is a rewritten previous example:\nlocal T = MiniTest.new_set()\n\nT['works'] = function()\n  local x = 1 + 1\n  MiniTest.expect.equality(x, 2)\nend\n\nreturn T\nTest sets can be nested. This will be useful in combination with hooks and parametrization:\nlocal T = MiniTest.new_set()\n\nT['big scope'] = new_set()\n\nT['big scope']['works'] = function()\n  local x = 1 + 1\n  MiniTest.expect.equality(x, 2)\nend\n\nT['big scope']['also works'] = function()\n  local x = 2 + 2\n  MiniTest.expect.equality(x, 4)\nend\n\nT['out of scope'] = function()\n  local x = 3 + 3\n  MiniTest.expect.equality(x, 6)\nend\n\nreturn T\nNOTE: ‘mini.test’ supports emulation of busted-style testing by default. So previous example can be written like this:\ndescribe('big scope', function()\n  it('works', function()\n    local x = 1 + 1\n    MiniTest.expect.equality(x, 2)\n  end)\n\n  it('also works', function()\n    local x = 2 + 2\n    MiniTest.expect.equality(x, 4)\n  end)\nend)\n\nit('out of scope', function()\n  local x = 3 + 3\n  MiniTest.expect.equality(x, 6)\nend)\n\n-- NOTE: when using this style, no test set should be returned\nAlthough this is possible, the rest of this file will use a recommended test set approach.\n\n\n\nThese four builtin expectations are the ones used most commonly:\nlocal T = MiniTest.new_set()\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\nlocal x = 1 + 1\n\n-- This is so frequently used that having short alias proved useful\nT['expect.equality'] = function()\n  eq(x, 2)\nend\n\nT['expect.no_equality'] = function()\n  expect.no_equality(x, 1)\nend\n\nT['expect.error'] = function()\n  -- This expectation will pass because function will throw an error\n  expect.error(function()\n    if x == 2 then error('Deliberate error') end\n  end)\nend\n\nT['expect.no_error'] = function()\n  -- This expectation will pass because function will *not* throw an error\n  expect.no_error(function()\n    if x ~= 2 then error('This should not be thrown') end\n  end)\nend\n\nreturn T\n\n\n\nAlthough you can use if ... error() ... end approach, there is MiniTest.new_expectation() to simplify this process for some repetitive expectation. Here is an example used in this plugin:\nlocal T = MiniTest.new_set()\n\nlocal expect_match = MiniTest.new_expectation(\n  -- Expectation subject\n  'string matching',\n  -- Predicate\n  function(str, pattern) return str:find(pattern) ~= nil end,\n  -- Fail context\n  function(str, pattern)\n    return string.format('Pattern: %s\\nObserved string: %s', vim.inspect(pattern), str)\n  end\n)\n\nT['string matching'] = function()\n  local x = 'abcd'\n  -- This will pass\n  expect_match(x, '^a')\n\n  -- This will fail\n  expect_match(x, 'x')\nend\n\nreturn T\nExecuting this content from file ‘tests/test_basics.lua’ will fail with the following message:\nFAIL in \"tests/test_basics.lua | string matching\":\n  Failed expectation for string matching.\n  Pattern: \"x\"\n  Observed string: abcd\n  Traceback:\n    tests/test_basics.lua:20\n\n\n\nHooks are functions that will be called without arguments at predefined stages of test execution. They are defined for a test set. There are four types of hooks:\n\npre_once - executed before first (filtered) node.\npre_case - executed before each case (even nested).\npost_case - executed after each case (even nested).\npost_once - executed after last (filtered) node.\n\nExample:\nlocal new_set = MiniTest.new_set\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\nlocal T = new_set()\n\nlocal n = 0\nlocal increase_n = function() n = n + 1 end\n\nT['hooks'] = new_set({\n  hooks = { pre_once = increase_n, pre_case = increase_n, post_case = increase_n, post_once = increase_n },\n})\n\nT['hooks']['work'] = function()\n  -- `n` will be increased twice: in `pre_once` and `pre_case`\n  eq(n, 2)\nend\n\nT['hooks']['work again'] = function()\n  -- `n` will be increased twice: in `post_case` from previous case and\n  -- `pre_case` before this one\n  eq(n, 4)\nend\n\nT['after hooks set'] = function()\n  -- `n` will be again increased twice: in `post_case` from previous case and\n  -- `post_once` after last case in T['hooks'] test set\n  eq(n, 6)\nend\n\nreturn T\n\n\n\nOne of the distinctive features of ‘mini.test’ is ability to leverage test parametrization. As hooks, it is a feature of test set.\nExample of simple parametrization:\nlocal new_set = MiniTest.new_set\nlocal eq = MiniTest.expect.equality\n\nlocal T = new_set()\n\n-- Each parameter should be an array to allow parametrizing multiple arguments\nT['parametrize'] = new_set({ parametrize = { { 1 }, { 2 } } })\n\n-- This will result into two cases. First will fail.\nT['parametrize']['works'] = function(x)\n  eq(x, 2)\nend\n\n-- Parametrization can be nested. Cases are \"multiplied\" with every combination\n-- of parameters.\nT['parametrize']['nested'] = new_set({ parametrize = { { '1' }, { '2' } } })\n\n-- This will result into four cases. Two of them will fail.\nT['parametrize']['nested']['works'] = function(x, y)\n  eq(tostring(x), y)\nend\n\n-- Parametrizing multiple arguments\nT['parametrize multiple arguments'] = new_set({ parametrize = { { 1, 1 }, { 2, 2 } } })\n\n-- This will result into two cases. Both will pass.\nT['parametrize multiple arguments']['works'] = function(x, y)\n  eq(x, y)\nend\n\nreturn T\n\n\n\nSome tests can be inherently flaky (can randomly fail even if its tested feature is correct). For example, testing that sequence of events is executed with correct delay between each other. Such tests can work reliably on fast machines, but can spuriously fail on slow ones (like during Continuous Integrations checks) while underlying feature is correct.\nTo reduce flakiness, there is a feature of test set called n_retry: a maximum number of times to retry each its test case until success.\nExample of how it can be used:\nlocal new_set = MiniTest.new_set\n\nlocal T = new_set()\n\n-- Each case will be attempted until first success at most 5 times\nT['n_retry'] = new_set({ n_retry = 5 })\n\n-- With default `n_retry = 1` this case will fail 1 out of 2 runs.\n-- With `n_retry = 5` this case will fail 1 out of 32 runs.\nT['n_retry']['case'] = function()\n  math.randomseed(vim.loop.hrtime())\n  assert(math.random() &lt; 0.5)\nend\n\nreturn T\n\n\n\nThere is MiniTest.current table containing information about “current” test cases. It has all_cases and case fields with all currently executed tests and the current case.\nTest case is a single unit of sequential test execution. It contains all information needed to execute test case along with data about its execution. Example:\nlocal new_set = MiniTest.new_set\nlocal eq = MiniTest.expect.equality\n\nlocal T = new_set()\n\nT['MiniTest.current.all_cases'] = function()\n  -- A useful hack: show runtime data with expecting it to be something else\n  eq(MiniTest.current.all_cases, 0)\nend\n\nT['MiniTest.current.case'] = function()\n  eq(MiniTest.current.case, 0)\nend\n\nreturn T\nThis will result into following lengthy fails:\n\n\nFail information\n\nFAIL in \"tests/test_basics.lua | MiniTest.current.all_cases\":\n  Failed expectation for equality.\n  Left: { {\n      args = {},\n      data = {},\n      desc = { \"tests/test_basics.lua\", \"MiniTest.current.all_cases\" },\n      exec = {\n        fails = {},\n        notes = {},\n        state = \"Executing test\"\n      },\n      hooks = {\n        post = {},\n        pre = {}\n      },\n      test = &lt;function 1&gt;\n    }, {\n      args = {},\n      data = {},\n      desc = { \"tests/test_basics.lua\", \"MiniTest.current.case\" },\n      hooks = {\n        post = {},\n        pre = {}\n      },\n      test = &lt;function 2&gt;\n    } }\n  Right: 0\n  Traceback:\n    tests/test_basics.lua:8\n\nFAIL in \"tests/test_basics.lua | MiniTest.current.case\":\n  Failed expectation for equality.\n  Left: {\n    args = {},\n    data = {},\n    desc = { \"tests/test_basics.lua\", \"MiniTest.current.case\" },\n    exec = {\n      fails = {},\n      notes = {},\n      state = \"Executing test\"\n    },\n    hooks = {\n      post = {},\n      pre = {}\n    },\n    test = &lt;function 1&gt;\n  }\n  Right: 0\n  Traceback:\n    tests/test_basics.lua:12\n\n\n\n\nThere are some functions intended to help writing more robust cases: skip(), finally(), and add_note(). The MiniTest.current table contains useful information about the current state of tests execution.\nExample:\nlocal T = MiniTest.new_set()\n\n-- `MiniTest.skip()` allows skipping rest of test execution while giving an\n-- informative note. This test will pass with notes.\nT['skip()'] = function()\n  if 1 + 1 == 2 then\n    MiniTest.skip('Apparently, 1 + 1 is 2')\n  end\n  error('1 + 1 is not 2')\nend\n\n-- `MiniTest.add_note()` allows adding notes. Final state will have\n-- \"with notes\" suffix.\nT['add_note()'] = function()\n  MiniTest.add_note('This test is not important.')\n  error('Custom error.')\nend\n\n-- `MiniTest.finally()` allows registering some function to be executed after\n-- this case is finished executing (with or without an error).\nT['finally()'] = function()\n  -- Add note only if test fails\n  MiniTest.finally(function()\n    if #MiniTest.current.case.exec.fails &gt; 0 then\n      MiniTest.add_note('This test is flaky.')\n    end\n  end)\n  error('Expected error from time to time')\nend\n\nreturn T\nThis will result into following messages:\nNOTE in \"tests/test_basics.lua | skip()\": Apparently, 1 + 1 is 2\n\nFAIL in \"tests/test_basics.lua | add_note()\": tests/test_basics.lua:16: Custom error.\nNOTE in \"tests/test_basics.lua | add_note()\": This test is not important.\n\nFAIL in \"tests/test_basics.lua | finally()\": tests/test_basics.lua:28: Expected error from time to time\nNOTE in \"tests/test_basics.lua | finally()\": This test is flaky.\n\n\n\n\nTest run consists from two stages:\n\nCollection. It will source each appropriate file (customizable), combine all test sets into single test set, convert it from hierarchical to sequential form (array of test cases), and filter cases based on customizable predicate.\nExecution. It will safely execute array of test cases (with each pre-hooks, test action, post-hooks) one after another in scheduled asynchronous fashion while collecting information about how it went and calling customizable reporter methods.\n\nAll configuration goes into opts argument of MiniTest.run().\n\n\nYou can customize which files will be sourced and which cases will be later executed. Example:\nlocal new_set = MiniTest.new_set\n\nlocal T = new_set()\n\n-- Use `data` field to pass custom information for easier test management\nT['fast'] = new_set({ data = { type = 'fast' } })\nT['fast']['first test'] = function() end\nT['fast']['second test'] = function() end\n\nT['slow'] = new_set({ data = { type = 'slow' } })\nT['slow']['first test'] = function() vim.loop.sleep(1000) end\nT['slow']['second test'] = function() vim.loop.sleep(1000) end\n\nreturn T\nYou can run only this file (‘tests/test_basics.lua’) and only “fast” cases with this call:\nMiniTest.run({\n  collect = {\n    find_files = function() return { 'tests/test_basics.lua' } end,\n    filter_cases = function(case) return case.data.type == 'fast' end,\n  }\n})\n\n\n\nYou can customize execution of test cases with custom reporter (how test results are displayed in real time) and whether to stop execution after the first test case fail/error. Execution doesn’t result into any output, instead it updates MiniTest.current.all_cases in place: each case gets an exec field with information about how its execution went.\nExample of showing status summary table in the command line after everything is finished:\nlocal reporter = {\n  -- Other used methods are `start(cases)` and `update(case_num)`\n  finish = function()\n    local summary = {}\n    for _, c in ipairs(MiniTest.current.all_cases) do\n      local state = c.exec.state\n      summary[state] = (summary[state] or 0) + 1\n    end\n\n    print(vim.inspect(summary, { newline = ' ', indent = '' }))\n  end,\n}\n\nMiniTest.run({ execute = { reporter = reporter } })\n\n\n\n\nMain feature of ‘mini.test’ which makes it different from other Lua testing frameworks is its design towards custom usage of child Neovim process inside tests. Ultimately, each test should be done with fresh Neovim process initialized with bare minimum setup (like allowing to load your plugin). To make this easier, there is a dedicated function MiniTest.new_child_neovim(). It returns an object with many useful helper methods, like for start/stop/restart, redirected execution (write code in current process, it gets executed in child one), emulating typing keys, testing screen state, etc.\n\n\nYou can start/stop/restart child process associated with this child Neovim object. Current (from which testing is initiated) and child Neovim processes can “talk” to each through RPC messages (see :h RPC). It means you can programmatically execute code inside child process, get its output inside current process, and test if it meets your expectation. Child process is headless but fully functioning process which allows you to test things such as extmarks, floating windows, etc.\nAlthough this approach proved to be useful and efficient, it is not ideal. Here are some limitations: - Due to current RPC protocol implementation functions and userdata can’t be used in both input and output with child process. Indicator of this issue is a Cannot convert given lua type error. Usual solution is to move some logic on the side of child process, like create and use global functions (note that they will be “forgotten” after next restart). - Sometimes hanging process will occur: it stops executing without any output. Most of the time it is because Neovim process is “blocked”, i.e. it waits for user input and won’t return from other call. Common causes are active hit-enter-prompt (solution: increase prompt height to a bigger value) or Operator-pending mode (solution: exit it). To mitigate this experience, most helper methods will throw an error if they can deduce that immediate execution will lead to hanging state.\nHere is recommended setup for managing child processes. It will make fresh Neovim process before every test case:\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      -- Restart child process with custom 'init.lua' script\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      -- Load tested plugin\n      child.lua([[M = require('hello_lines')]])\n    end,\n    -- Stop once all test cases are finished\n    post_once = child.stop,\n  },\n})\n\n-- Define some tests here\n\nreturn T\n\n\n\nPrevious section already demonstrated that there is a child.lua() method. It will execute arbitrary Lua code in the form of a single string. This is basically a wrapper for vim.api.nvim_exec_lua(). There is also a convenience wrapper child.lua_get() which is essentially a child.lua('return ' .. s, ...). Examples:\nlocal eq = MiniTest.expect.equality\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\nT['lua()'] = MiniTest.new_set()\n\nT['lua()']['works'] = function()\n  child.lua('_G.n = 0; _G.n = _G.n + 1')\n  eq(child.lua('return _G.n'), 1)\nend\n\nT['lua()']['can use tested plugin'] = function()\n  eq(child.lua('return M.compute()'), { 'Hello world' })\n  eq(child.lua([[return M.compute({'a', 'b'})]]), { 'Hello a', 'Hello b' })\nend\n\nT['lua_get()'] = function()\n  child.lua('_G.n = 0')\n  eq(child.lua_get('_G.n'), child.lua('return _G.n'))\nend\n\nreturn T\n\n\n\nAlthough ability to execute arbitrary Lua code is technically enough to write any tests, it gets cumbersome very quickly due it using only string input. That is why there are many convenience helpers with the same idea: write code inside current Neovim process that will be automatically executed same way in child process. Here is the showcase:\nlocal new_set = MiniTest.new_set\nlocal eq = MiniTest.expect.equality\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\n-- These methods will \"redirect\" execution to child through `vim.rpcrequest()`\n-- and `vim.rpcnotify()` respectively. Any call `child.api.xxx(...)` returns\n-- the output of `vim.api.xxx(...)` executed inside child process.\nT['api()/api_notify()'] = function()\n  -- Set option. For some reason, first buffer is 'readonly' which leads to\n  -- high delay in test execution\n  child.api.nvim_set_option_value('readonly', false, { buf = 0 })\n\n  -- Set all lines\n  child.api.nvim_buf_set_lines(0, 0, -1, true, { 'aaa' })\n\n  -- Get all lines and test with expected ones\n  eq(child.api.nvim_buf_get_lines(0, 0, -1, true), { 'aaa' })\nend\n\n-- Execute Vimscript with or without capturing its output\nT['cmd()/cmd()'] = function()\n  child.cmd('hi Comment guifg=#aaaaaa')\n  eq(child.cmd_capture('hi Comment'), 'Comment        xxx guifg=#aaaaaa')\nend\n\n-- There are redirection tables for most of the main Neovim functionality\nT['various redirection tables with methods'] = function()\n  eq(child.fn.fnamemodify('hello_lines.lua', ':t:r'), 'hello_lines')\n  eq(child.loop.hrtime() &gt; 0, true)\n  eq(child.lsp.get_clients(), {})\n\n  -- And more\nend\n\n-- There are redirection tables for scoped (buffer, window, etc.) variables\n-- You can use them to both set and get values\nT['redirection tables for variables'] = function()\n  child.b.aaa = true\n  eq(child.b.aaa, true)\n  eq(child.b.aaa, child.lua_get('vim.b.aaa'))\nend\n\n-- There are redirection tables for scoped (buffer, window, etc.) options\n-- You can use them to both set and get values\nT['redirection tables for options'] = function()\n  child.o.lines, child.o.columns = 5, 12\n  eq(child.o.lines, 5)\n  eq({ child.o.lines, child.o.columns }, child.lua_get('{ vim.o.lines, vim.o.columns }'))\nend\n\nreturn T\n\n\n\nVery important part of testing is emulating user typing keys. There is a special child.type_keys() helper method for that. Examples:\nlocal eq = MiniTest.expect.equality\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.bo.readonly = false\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\nlocal get_lines = function() return child.api.nvim_buf_get_lines(0, 0, -1, true) end\n\nT['type_keys()'] = MiniTest.new_set()\n\nT['type_keys()']['works'] = function()\n  -- It can take one string\n  child.type_keys('iabcde&lt;Esc&gt;')\n  eq(get_lines(), { 'abcde' })\n  eq(child.fn.mode(), 'n')\n\n  -- Or several strings which improves readability\n  child.type_keys('cc', 'fghij', '&lt;Esc&gt;')\n  eq(get_lines(), { 'fghij' })\n\n  -- Or tables of strings (possibly nested)\n  child.type_keys({ 'cc', { 'j', 'k', 'l', 'm', 'n' } })\n  eq(get_lines(), { 'jklmn' })\nend\n\nT['type_keys()']['allows custom delay'] = function()\n  -- This adds delay of 500 ms after each supplied string (three times here)\n  child.type_keys(500, 'i', 'abcde', '&lt;Esc&gt;')\n  eq(get_lines(), { 'abcde' })\nend\n\nreturn T\n\n\n\nOne of the main difficulties in testing Neovim plugins is verifying that something is actually displayed in the way you intend. Like general highlighting, statusline, tabline, sign column, extmarks, etc. Testing screen state with screenshots makes this a lot easier. There is a child.get_screenshot() method which basically calls screenstring() (:h screenstring()) and screenattr() (:h screenattr()) for every visible cell (row from 1 to ‘lines’ option, column from 1 to ‘columns’ option). It then returns screenshot with two layers:\n\ntext - “2d array” (row-column) of single characters displayed at particular cells.\nattr - “2d array” (row-column) of symbols representing how text is displayed (basically, “coded” appearance/highlighting). They should be used only in relation to each other: same/different symbols for two cells mean same/different visual appearance. Note: there will be false positives if there are more than 94 different attribute values. To make output more portable and visually useful, outputs of screenattr() are coded with single character symbols.\n\nCouple of caveats:\n\nAs is apparent from use of screenattr(), these screenshots can’t tell how exactly cell is highlighted, only if two cells are highlighted the same. This is due to the currently lacking functionality in Neovim itself. This might change in the future.\n\nTo help manage testing screen state, there is a special MiniTest.expect.reference_screenshot(screenshot, path, opts) method. It takes screenshot table along with optional path of where to save this screenshot (if not supplied, inferred from test case description and put in ‘tests/screenshots’ directory). On first run it will automatically create reference screenshot at path. On later runs it will compare current screenshot with reference. Will throw informative error with helpful information if they don’t match exactly.\nExample:\nlocal expect = MiniTest.expect\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.bo.readonly = false\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\nT['set_lines()'] = MiniTest.new_set({ parametrize = { {}, { 0, { 'a' } }, { 0, { 1, 2, 3 } } } })\n\nT['set_lines()']['works'] = function(buf_id, lines)\n  child.o.lines, child.o.columns = 10, 15\n  child.lua('M.set_lines(...)', { buf_id, lines })\n  expect.reference_screenshot(child.get_screenshot())\nend\n\nreturn T\nThis will result into three files in ‘tests/screenshots’ with names containing test case description along with supplied arguments. Here is example reference screenshot for { 0, { 1, 2, 3 } } arguments (line numbers and ruler for columns is added as file specification to make it easier to find differences between two screenshots):\n--|---------|-----\n01|Hello 1        \n02|Hello 2        \n03|Hello 3        \n04|~              \n05|~              \n06|~              \n07|~              \n08|~              \n09|&lt;e] [+] 1,1 All\n10|               \n\n--|---------|-----\n01|000001111111111\n02|000001111111111\n03|000001111111111\n04|222222222222222\n05|222222222222222\n06|222222222222222\n07|222222222222222\n08|222222222222222\n09|333333333333333\n10|444444444444444\nTo update already existing screenshot either delete the corresponding screenshot file and rerun test case or temporarily add { force = true } option to reference_screenshot() to force updating the screenshot file.\n\n\n\n\n\nCreate a ‘tests/helpers.lua’ file with code that can be useful in multiple files. It can have “monkey-patched” versions of ‘mini.test’ functions. Example:\n\nlocal Helpers = {}\n\nHelpers.new_child_neovim = function()\n  local child = MiniTest.new_child_neovim()\n\n  child.setup = function()\n    child.restart({'-u', 'scripts/minimal_init.lua'})\n    child.bo.readonly = false\n    child.lua([[M = require('hello_lines')]])\n  end\n\n  return child\nend\n\nreturn Helpers\n\nWrite aliases for commonly used functions at top of the file. It will make your life a little bit easier and usually will lead to more readable tests. Example:\n\n-- Some code setting up `child`\nlocal set_lines = function(lines) child.api.nvim_buf_set_lines(0, 0, -1, true, lines) end\n\nWhen working with automatically named screenshots, beware of the following caveats:\n\nSome systems are case insensitive (like usually Windows and MacOS). So having two different file names which are the same ignoring case will introduce problems for users to properly install plugin.\nSome system setups have restrictions on full path length (like 260 bytes on some Git+Windows combinations) or file name length (like 255 bytes on ext4 Windows partitions and 143 bytes on eCryptfs Linux partitions). Restriction on full path is hard to accommodate for (apart from limiting file name size to some reasonable number), but trying to not have file names longer than 143 bytes (by having shorter test case names) should be reasonable.\n\nTo make reading strings that contain Lua code easier (for child.lua and child.lua_get), you can add the following tree-sitter capture to your personal configuration. Put it in the file ‘after/queries/lua/injections.scm’. Don’t forget to add ; extends at the beginning of the file (see :h treesitter-query-modeline-extends):\n; extends\n(function_call\n  name: (dot_index_expression\n    table: (identifier) @_table\n    field: (identifier) @_field)\n  arguments: (arguments\n    (string\n      content: (string_content) @injection.content))\n  (#eq? @_table child)\n  (#any-of? @_field lua lua_get)\n  (#set! injection.language \"lua\"))"
  },
  {
    "objectID": "mini.nvim/TESTING.html#example-plugin",
    "href": "mini.nvim/TESTING.html#example-plugin",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "In this file we will be testing ‘hello_lines’ plugin (once some basic concepts are introduced). It will have functionality to add prefix ‘Hello’ to lines implemented in a single file ‘lua/hello_lines/init.lua’:\n\n\n‘lua/hello_lines/init.lua’\n\nlocal M = {}\n\n--- Prepend 'Hello ' to every element\n---@param lines table Array. Default: { 'world' }.\n---@return table Array of strings.\nM.compute = function(lines)\n  lines = lines or { 'world' }\n  return vim.tbl_map(function(x) return 'Hello ' .. tostring(x) end, lines)\nend\n\nlocal ns_id = vim.api.nvim_create_namespace('hello_lines')\n\n--- Set lines with highlighted 'Hello ' prefix\n---@param buf_id number Buffer handle where lines should be set. Default: 0.\n---@param lines table Array. Default: { 'world' }.\nM.set_lines = function(buf_id, lines)\n  buf_id = buf_id or 0\n  lines = lines or { 'world' }\n  vim.api.nvim_buf_clear_namespace(buf_id, ns_id, 0, -1)\n  vim.api.nvim_buf_set_lines(buf_id or 0, 0, -1, true, M.compute(lines))\n  for i = 1, #lines do\n    local extmark_opts = { end_row = i - 1, end_col = 5, hl_group = 'Special' }\n    vim.api.nvim_buf_set_extmark(buf_id, ns_id, i - 1, 0, extmark_opts)\n  end\nend\n\nreturn M"
  },
  {
    "objectID": "mini.nvim/TESTING.html#quick-demo",
    "href": "mini.nvim/TESTING.html#quick-demo",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "Here is a quick demo of how tests with ‘mini.test’ look like:\n\n\n‘tests/test_hello_lines.lua’\n\n-- Define helper aliases\nlocal new_set = MiniTest.new_set\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\n-- Create (but not start) child Neovim object\nlocal child = MiniTest.new_child_neovim()\n\n-- Define main test set of this file\nlocal T = new_set({\n  -- Register hooks\n  hooks = {\n    -- This will be executed before every (even nested) case\n    pre_case = function()\n      -- Restart child process with custom 'init.lua' script\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      -- Load tested plugin\n      child.lua([[M = require('hello_lines')]])\n    end,\n    -- This will be executed one after all tests from this set are finished\n    post_once = child.stop,\n  },\n})\n\n-- Test set fields define nested structure\nT['compute()'] = new_set()\n\n-- Define test action as callable field of test set.\n-- If it produces error - test fails.\nT['compute()']['works'] = function()\n  -- Execute Lua code inside child process, get its result and compare with\n  -- expected result\n  eq(child.lua_get([[M.compute({'a', 'b'})]]), { 'Hello a', 'Hello b' })\nend\n\nT['compute()']['uses correct defaults'] = function()\n  eq(child.lua_get([[M.compute()]]), { 'Hello world' })\nend\n\n-- Make parametrized tests. This will create three copies of each case\nT['set_lines()'] = new_set({ parametrize = { {}, { 0, { 'a' } }, { 0, { 1, 2, 3 } } } })\n\n-- Use arguments from test parametrization\nT['set_lines()']['works'] = function(buf_id, lines)\n  -- Directly modify some options to make better test\n  child.o.lines, child.o.columns = 10, 20\n  child.bo.readonly = false\n\n  -- Execute Lua code without returning value\n  child.lua('M.set_lines(...)', { buf_id, lines })\n\n  -- Test screen state. On first run it will automatically create reference\n  -- screenshots with text and look information in predefined location. On\n  -- later runs it will compare current screenshot with reference. Will throw\n  -- informative error with helpful information if they don't match exactly.\n  expect.reference_screenshot(child.get_screenshot())\nend\n\n-- Return test set which will be collected and execute inside `MiniTest.run()`\nreturn T"
  },
  {
    "objectID": "mini.nvim/TESTING.html#file-organization",
    "href": "mini.nvim/TESTING.html#file-organization",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "It might be a bit overwhelming. It actually is for most of the people. However, it should be done once and then you rarely need to touch it.\nOverview of full file structure used in for testing ‘hello_lines’ plugin:\n.\n├── deps\n│   └── mini.nvim # Mandatory\n├── lua\n│   └── hello_lines\n│       └── init.lua # Mandatory\n├── Makefile # Recommended\n├── scripts\n│   ├── minimal_init.lua # Mandatory\n│   └── minitest.lua # Recommended\n└── tests\n    └── test_hello_lines.lua # Mandatory\nTo write tests, you’ll need these files:\nMandatory:\n\nYour Lua plugin in ‘lua’ directory. Here we will be testing ‘hello_lines’ plugin.\nTest files. By default they should be Lua files located in ‘tests/’ directory and named with ‘test_’ prefix. For example, we will write everything in ‘test_hello_lines.lua’. It is usually a good idea to follow this template (will be assumed for the rest of this file):\n\n\nTemplate for test files\n\nlocal new_set = MiniTest.new_set\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\nlocal T = new_set()\n\n-- Actual tests definitions will go here\n\nreturn T\n\n‘mini.nvim’ dependency. It is needed to use its ‘mini.test’ module. Proposed way to store it is in ‘deps/mini.nvim’ directory. Create it with git:\nmkdir -p deps\ngit clone --filter=blob:none https://github.com/nvim-mini/mini.nvim deps/mini.nvim\nManual Neovim startup file (a.k.a ‘init.lua’) with proposed path ‘scripts/minimal_init.lua’. It will be used to ensure that Neovim processes can recognize your tested plugin and ‘mini.nvim’ dependency. Proposed minimal content:\n\n\n‘scripts/minimal_init.lua’\n\n-- Add current directory to 'runtimepath' to be able to use 'lua' files\nvim.cmd([[let &rtp.=','.getcwd()]])\n\n-- Set up 'mini.test' only when calling headless Neovim (like with `make test`)\nif #vim.api.nvim_list_uis() == 0 then\n  -- Add 'mini.nvim' to 'runtimepath' to be able to use 'mini.test'\n  -- Assumed that 'mini.nvim' is stored in 'deps/mini.nvim'\n  vim.cmd('set rtp+=deps/mini.nvim')\n\n  -- Set up 'mini.test'\n  require('mini.test').setup()\nend\n\n\nRecommended:\n\nMakefile. In order to simplify running tests from shell and inside Continuous Integration services (like Github Actions), it is recommended to define Makefile. It will define steps for running tests. Proposed template:\n\n\nTemplate for Makefile\n\n# Run all test files\ntest: deps/mini.nvim\n    nvim --headless --noplugin -u ./scripts/minimal_init.lua -c \"lua MiniTest.run()\"\n\n# Run test from file at `$FILE` environment variable\ntest_file: deps/mini.nvim\n    nvim --headless --noplugin -u ./scripts/minimal_init.lua -c \"lua MiniTest.run_file('$(FILE)')\"\n\n# Download 'mini.nvim' to use its 'mini.test' testing module\ndeps/mini.nvim:\n    @mkdir -p deps\n    git clone --filter=blob:none https://github.com/nvim-mini/mini.nvim $@\n\n‘mini.test’ script at ‘scripts/minitest.lua’. Use it to customize what is tested (which files, etc.) and how. Usually not needed, but otherwise should have some variant of a call to MiniTest.run()."
  },
  {
    "objectID": "mini.nvim/TESTING.html#running-tests",
    "href": "mini.nvim/TESTING.html#running-tests",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "The ‘mini.test’ module out of the box supports two major ways of running tests:\n\nInteractive. All test files will be run directly inside current Neovim session. This proved to be very useful for debugging while writing tests. To run tests, simply execute :lua MiniTest.run() / :lua MiniTest.run_file() / :lua MiniTest.run_at_location() (assuming, you already have ‘mini.test’ set up with require('mini.test').setup()). With default configuration this will result into floating window with information about results of test execution. Press q to close it. Note: Be careful though, as it might affect your current setup. To avoid this, use child processes inside tests.\nHeadless (from shell). Start headless Neovim process with proper startup file and execute lua MiniTest.run(). Assuming full file organization from previous section, this can be achieved with make test. This will show information about results of test execution directly in shell."
  },
  {
    "objectID": "mini.nvim/TESTING.html#basics",
    "href": "mini.nvim/TESTING.html#basics",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "These sections will show some basic capabilities of ‘mini.test’ and how to use them. In all examples code blocks represent some whole test file (like ‘tests/test_basics.lua’).\n\n\nA test is defined as function assigned to a field of test set. If it throws error, test has failed. Test file should return single test set. Here is an example:\nlocal T = MiniTest.new_set()\n\nT['works'] = function()\n  local x = 1 + 1\n  if x ~= 2 then\n    error('`x` is not equal to 2')\n  end\nend\n\nreturn T\nWriting if .. error() .. end is too tiresome. That is why ‘mini.test’ comes with very minimal but usually quite enough set of expectations: MiniTest.expect. They display the intended expectation between objects and will throw error with informative message if it doesn’t hold. Here is a rewritten previous example:\nlocal T = MiniTest.new_set()\n\nT['works'] = function()\n  local x = 1 + 1\n  MiniTest.expect.equality(x, 2)\nend\n\nreturn T\nTest sets can be nested. This will be useful in combination with hooks and parametrization:\nlocal T = MiniTest.new_set()\n\nT['big scope'] = new_set()\n\nT['big scope']['works'] = function()\n  local x = 1 + 1\n  MiniTest.expect.equality(x, 2)\nend\n\nT['big scope']['also works'] = function()\n  local x = 2 + 2\n  MiniTest.expect.equality(x, 4)\nend\n\nT['out of scope'] = function()\n  local x = 3 + 3\n  MiniTest.expect.equality(x, 6)\nend\n\nreturn T\nNOTE: ‘mini.test’ supports emulation of busted-style testing by default. So previous example can be written like this:\ndescribe('big scope', function()\n  it('works', function()\n    local x = 1 + 1\n    MiniTest.expect.equality(x, 2)\n  end)\n\n  it('also works', function()\n    local x = 2 + 2\n    MiniTest.expect.equality(x, 4)\n  end)\nend)\n\nit('out of scope', function()\n  local x = 3 + 3\n  MiniTest.expect.equality(x, 6)\nend)\n\n-- NOTE: when using this style, no test set should be returned\nAlthough this is possible, the rest of this file will use a recommended test set approach.\n\n\n\nThese four builtin expectations are the ones used most commonly:\nlocal T = MiniTest.new_set()\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\nlocal x = 1 + 1\n\n-- This is so frequently used that having short alias proved useful\nT['expect.equality'] = function()\n  eq(x, 2)\nend\n\nT['expect.no_equality'] = function()\n  expect.no_equality(x, 1)\nend\n\nT['expect.error'] = function()\n  -- This expectation will pass because function will throw an error\n  expect.error(function()\n    if x == 2 then error('Deliberate error') end\n  end)\nend\n\nT['expect.no_error'] = function()\n  -- This expectation will pass because function will *not* throw an error\n  expect.no_error(function()\n    if x ~= 2 then error('This should not be thrown') end\n  end)\nend\n\nreturn T\n\n\n\nAlthough you can use if ... error() ... end approach, there is MiniTest.new_expectation() to simplify this process for some repetitive expectation. Here is an example used in this plugin:\nlocal T = MiniTest.new_set()\n\nlocal expect_match = MiniTest.new_expectation(\n  -- Expectation subject\n  'string matching',\n  -- Predicate\n  function(str, pattern) return str:find(pattern) ~= nil end,\n  -- Fail context\n  function(str, pattern)\n    return string.format('Pattern: %s\\nObserved string: %s', vim.inspect(pattern), str)\n  end\n)\n\nT['string matching'] = function()\n  local x = 'abcd'\n  -- This will pass\n  expect_match(x, '^a')\n\n  -- This will fail\n  expect_match(x, 'x')\nend\n\nreturn T\nExecuting this content from file ‘tests/test_basics.lua’ will fail with the following message:\nFAIL in \"tests/test_basics.lua | string matching\":\n  Failed expectation for string matching.\n  Pattern: \"x\"\n  Observed string: abcd\n  Traceback:\n    tests/test_basics.lua:20\n\n\n\nHooks are functions that will be called without arguments at predefined stages of test execution. They are defined for a test set. There are four types of hooks:\n\npre_once - executed before first (filtered) node.\npre_case - executed before each case (even nested).\npost_case - executed after each case (even nested).\npost_once - executed after last (filtered) node.\n\nExample:\nlocal new_set = MiniTest.new_set\nlocal expect, eq = MiniTest.expect, MiniTest.expect.equality\n\nlocal T = new_set()\n\nlocal n = 0\nlocal increase_n = function() n = n + 1 end\n\nT['hooks'] = new_set({\n  hooks = { pre_once = increase_n, pre_case = increase_n, post_case = increase_n, post_once = increase_n },\n})\n\nT['hooks']['work'] = function()\n  -- `n` will be increased twice: in `pre_once` and `pre_case`\n  eq(n, 2)\nend\n\nT['hooks']['work again'] = function()\n  -- `n` will be increased twice: in `post_case` from previous case and\n  -- `pre_case` before this one\n  eq(n, 4)\nend\n\nT['after hooks set'] = function()\n  -- `n` will be again increased twice: in `post_case` from previous case and\n  -- `post_once` after last case in T['hooks'] test set\n  eq(n, 6)\nend\n\nreturn T\n\n\n\nOne of the distinctive features of ‘mini.test’ is ability to leverage test parametrization. As hooks, it is a feature of test set.\nExample of simple parametrization:\nlocal new_set = MiniTest.new_set\nlocal eq = MiniTest.expect.equality\n\nlocal T = new_set()\n\n-- Each parameter should be an array to allow parametrizing multiple arguments\nT['parametrize'] = new_set({ parametrize = { { 1 }, { 2 } } })\n\n-- This will result into two cases. First will fail.\nT['parametrize']['works'] = function(x)\n  eq(x, 2)\nend\n\n-- Parametrization can be nested. Cases are \"multiplied\" with every combination\n-- of parameters.\nT['parametrize']['nested'] = new_set({ parametrize = { { '1' }, { '2' } } })\n\n-- This will result into four cases. Two of them will fail.\nT['parametrize']['nested']['works'] = function(x, y)\n  eq(tostring(x), y)\nend\n\n-- Parametrizing multiple arguments\nT['parametrize multiple arguments'] = new_set({ parametrize = { { 1, 1 }, { 2, 2 } } })\n\n-- This will result into two cases. Both will pass.\nT['parametrize multiple arguments']['works'] = function(x, y)\n  eq(x, y)\nend\n\nreturn T\n\n\n\nSome tests can be inherently flaky (can randomly fail even if its tested feature is correct). For example, testing that sequence of events is executed with correct delay between each other. Such tests can work reliably on fast machines, but can spuriously fail on slow ones (like during Continuous Integrations checks) while underlying feature is correct.\nTo reduce flakiness, there is a feature of test set called n_retry: a maximum number of times to retry each its test case until success.\nExample of how it can be used:\nlocal new_set = MiniTest.new_set\n\nlocal T = new_set()\n\n-- Each case will be attempted until first success at most 5 times\nT['n_retry'] = new_set({ n_retry = 5 })\n\n-- With default `n_retry = 1` this case will fail 1 out of 2 runs.\n-- With `n_retry = 5` this case will fail 1 out of 32 runs.\nT['n_retry']['case'] = function()\n  math.randomseed(vim.loop.hrtime())\n  assert(math.random() &lt; 0.5)\nend\n\nreturn T\n\n\n\nThere is MiniTest.current table containing information about “current” test cases. It has all_cases and case fields with all currently executed tests and the current case.\nTest case is a single unit of sequential test execution. It contains all information needed to execute test case along with data about its execution. Example:\nlocal new_set = MiniTest.new_set\nlocal eq = MiniTest.expect.equality\n\nlocal T = new_set()\n\nT['MiniTest.current.all_cases'] = function()\n  -- A useful hack: show runtime data with expecting it to be something else\n  eq(MiniTest.current.all_cases, 0)\nend\n\nT['MiniTest.current.case'] = function()\n  eq(MiniTest.current.case, 0)\nend\n\nreturn T\nThis will result into following lengthy fails:\n\n\nFail information\n\nFAIL in \"tests/test_basics.lua | MiniTest.current.all_cases\":\n  Failed expectation for equality.\n  Left: { {\n      args = {},\n      data = {},\n      desc = { \"tests/test_basics.lua\", \"MiniTest.current.all_cases\" },\n      exec = {\n        fails = {},\n        notes = {},\n        state = \"Executing test\"\n      },\n      hooks = {\n        post = {},\n        pre = {}\n      },\n      test = &lt;function 1&gt;\n    }, {\n      args = {},\n      data = {},\n      desc = { \"tests/test_basics.lua\", \"MiniTest.current.case\" },\n      hooks = {\n        post = {},\n        pre = {}\n      },\n      test = &lt;function 2&gt;\n    } }\n  Right: 0\n  Traceback:\n    tests/test_basics.lua:8\n\nFAIL in \"tests/test_basics.lua | MiniTest.current.case\":\n  Failed expectation for equality.\n  Left: {\n    args = {},\n    data = {},\n    desc = { \"tests/test_basics.lua\", \"MiniTest.current.case\" },\n    exec = {\n      fails = {},\n      notes = {},\n      state = \"Executing test\"\n    },\n    hooks = {\n      post = {},\n      pre = {}\n    },\n    test = &lt;function 1&gt;\n  }\n  Right: 0\n  Traceback:\n    tests/test_basics.lua:12\n\n\n\n\nThere are some functions intended to help writing more robust cases: skip(), finally(), and add_note(). The MiniTest.current table contains useful information about the current state of tests execution.\nExample:\nlocal T = MiniTest.new_set()\n\n-- `MiniTest.skip()` allows skipping rest of test execution while giving an\n-- informative note. This test will pass with notes.\nT['skip()'] = function()\n  if 1 + 1 == 2 then\n    MiniTest.skip('Apparently, 1 + 1 is 2')\n  end\n  error('1 + 1 is not 2')\nend\n\n-- `MiniTest.add_note()` allows adding notes. Final state will have\n-- \"with notes\" suffix.\nT['add_note()'] = function()\n  MiniTest.add_note('This test is not important.')\n  error('Custom error.')\nend\n\n-- `MiniTest.finally()` allows registering some function to be executed after\n-- this case is finished executing (with or without an error).\nT['finally()'] = function()\n  -- Add note only if test fails\n  MiniTest.finally(function()\n    if #MiniTest.current.case.exec.fails &gt; 0 then\n      MiniTest.add_note('This test is flaky.')\n    end\n  end)\n  error('Expected error from time to time')\nend\n\nreturn T\nThis will result into following messages:\nNOTE in \"tests/test_basics.lua | skip()\": Apparently, 1 + 1 is 2\n\nFAIL in \"tests/test_basics.lua | add_note()\": tests/test_basics.lua:16: Custom error.\nNOTE in \"tests/test_basics.lua | add_note()\": This test is not important.\n\nFAIL in \"tests/test_basics.lua | finally()\": tests/test_basics.lua:28: Expected error from time to time\nNOTE in \"tests/test_basics.lua | finally()\": This test is flaky."
  },
  {
    "objectID": "mini.nvim/TESTING.html#customizing-test-run",
    "href": "mini.nvim/TESTING.html#customizing-test-run",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "Test run consists from two stages:\n\nCollection. It will source each appropriate file (customizable), combine all test sets into single test set, convert it from hierarchical to sequential form (array of test cases), and filter cases based on customizable predicate.\nExecution. It will safely execute array of test cases (with each pre-hooks, test action, post-hooks) one after another in scheduled asynchronous fashion while collecting information about how it went and calling customizable reporter methods.\n\nAll configuration goes into opts argument of MiniTest.run().\n\n\nYou can customize which files will be sourced and which cases will be later executed. Example:\nlocal new_set = MiniTest.new_set\n\nlocal T = new_set()\n\n-- Use `data` field to pass custom information for easier test management\nT['fast'] = new_set({ data = { type = 'fast' } })\nT['fast']['first test'] = function() end\nT['fast']['second test'] = function() end\n\nT['slow'] = new_set({ data = { type = 'slow' } })\nT['slow']['first test'] = function() vim.loop.sleep(1000) end\nT['slow']['second test'] = function() vim.loop.sleep(1000) end\n\nreturn T\nYou can run only this file (‘tests/test_basics.lua’) and only “fast” cases with this call:\nMiniTest.run({\n  collect = {\n    find_files = function() return { 'tests/test_basics.lua' } end,\n    filter_cases = function(case) return case.data.type == 'fast' end,\n  }\n})\n\n\n\nYou can customize execution of test cases with custom reporter (how test results are displayed in real time) and whether to stop execution after the first test case fail/error. Execution doesn’t result into any output, instead it updates MiniTest.current.all_cases in place: each case gets an exec field with information about how its execution went.\nExample of showing status summary table in the command line after everything is finished:\nlocal reporter = {\n  -- Other used methods are `start(cases)` and `update(case_num)`\n  finish = function()\n    local summary = {}\n    for _, c in ipairs(MiniTest.current.all_cases) do\n      local state = c.exec.state\n      summary[state] = (summary[state] or 0) + 1\n    end\n\n    print(vim.inspect(summary, { newline = ' ', indent = '' }))\n  end,\n}\n\nMiniTest.run({ execute = { reporter = reporter } })"
  },
  {
    "objectID": "mini.nvim/TESTING.html#using-child-process",
    "href": "mini.nvim/TESTING.html#using-child-process",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "Main feature of ‘mini.test’ which makes it different from other Lua testing frameworks is its design towards custom usage of child Neovim process inside tests. Ultimately, each test should be done with fresh Neovim process initialized with bare minimum setup (like allowing to load your plugin). To make this easier, there is a dedicated function MiniTest.new_child_neovim(). It returns an object with many useful helper methods, like for start/stop/restart, redirected execution (write code in current process, it gets executed in child one), emulating typing keys, testing screen state, etc.\n\n\nYou can start/stop/restart child process associated with this child Neovim object. Current (from which testing is initiated) and child Neovim processes can “talk” to each through RPC messages (see :h RPC). It means you can programmatically execute code inside child process, get its output inside current process, and test if it meets your expectation. Child process is headless but fully functioning process which allows you to test things such as extmarks, floating windows, etc.\nAlthough this approach proved to be useful and efficient, it is not ideal. Here are some limitations: - Due to current RPC protocol implementation functions and userdata can’t be used in both input and output with child process. Indicator of this issue is a Cannot convert given lua type error. Usual solution is to move some logic on the side of child process, like create and use global functions (note that they will be “forgotten” after next restart). - Sometimes hanging process will occur: it stops executing without any output. Most of the time it is because Neovim process is “blocked”, i.e. it waits for user input and won’t return from other call. Common causes are active hit-enter-prompt (solution: increase prompt height to a bigger value) or Operator-pending mode (solution: exit it). To mitigate this experience, most helper methods will throw an error if they can deduce that immediate execution will lead to hanging state.\nHere is recommended setup for managing child processes. It will make fresh Neovim process before every test case:\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      -- Restart child process with custom 'init.lua' script\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      -- Load tested plugin\n      child.lua([[M = require('hello_lines')]])\n    end,\n    -- Stop once all test cases are finished\n    post_once = child.stop,\n  },\n})\n\n-- Define some tests here\n\nreturn T\n\n\n\nPrevious section already demonstrated that there is a child.lua() method. It will execute arbitrary Lua code in the form of a single string. This is basically a wrapper for vim.api.nvim_exec_lua(). There is also a convenience wrapper child.lua_get() which is essentially a child.lua('return ' .. s, ...). Examples:\nlocal eq = MiniTest.expect.equality\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\nT['lua()'] = MiniTest.new_set()\n\nT['lua()']['works'] = function()\n  child.lua('_G.n = 0; _G.n = _G.n + 1')\n  eq(child.lua('return _G.n'), 1)\nend\n\nT['lua()']['can use tested plugin'] = function()\n  eq(child.lua('return M.compute()'), { 'Hello world' })\n  eq(child.lua([[return M.compute({'a', 'b'})]]), { 'Hello a', 'Hello b' })\nend\n\nT['lua_get()'] = function()\n  child.lua('_G.n = 0')\n  eq(child.lua_get('_G.n'), child.lua('return _G.n'))\nend\n\nreturn T\n\n\n\nAlthough ability to execute arbitrary Lua code is technically enough to write any tests, it gets cumbersome very quickly due it using only string input. That is why there are many convenience helpers with the same idea: write code inside current Neovim process that will be automatically executed same way in child process. Here is the showcase:\nlocal new_set = MiniTest.new_set\nlocal eq = MiniTest.expect.equality\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\n-- These methods will \"redirect\" execution to child through `vim.rpcrequest()`\n-- and `vim.rpcnotify()` respectively. Any call `child.api.xxx(...)` returns\n-- the output of `vim.api.xxx(...)` executed inside child process.\nT['api()/api_notify()'] = function()\n  -- Set option. For some reason, first buffer is 'readonly' which leads to\n  -- high delay in test execution\n  child.api.nvim_set_option_value('readonly', false, { buf = 0 })\n\n  -- Set all lines\n  child.api.nvim_buf_set_lines(0, 0, -1, true, { 'aaa' })\n\n  -- Get all lines and test with expected ones\n  eq(child.api.nvim_buf_get_lines(0, 0, -1, true), { 'aaa' })\nend\n\n-- Execute Vimscript with or without capturing its output\nT['cmd()/cmd()'] = function()\n  child.cmd('hi Comment guifg=#aaaaaa')\n  eq(child.cmd_capture('hi Comment'), 'Comment        xxx guifg=#aaaaaa')\nend\n\n-- There are redirection tables for most of the main Neovim functionality\nT['various redirection tables with methods'] = function()\n  eq(child.fn.fnamemodify('hello_lines.lua', ':t:r'), 'hello_lines')\n  eq(child.loop.hrtime() &gt; 0, true)\n  eq(child.lsp.get_clients(), {})\n\n  -- And more\nend\n\n-- There are redirection tables for scoped (buffer, window, etc.) variables\n-- You can use them to both set and get values\nT['redirection tables for variables'] = function()\n  child.b.aaa = true\n  eq(child.b.aaa, true)\n  eq(child.b.aaa, child.lua_get('vim.b.aaa'))\nend\n\n-- There are redirection tables for scoped (buffer, window, etc.) options\n-- You can use them to both set and get values\nT['redirection tables for options'] = function()\n  child.o.lines, child.o.columns = 5, 12\n  eq(child.o.lines, 5)\n  eq({ child.o.lines, child.o.columns }, child.lua_get('{ vim.o.lines, vim.o.columns }'))\nend\n\nreturn T\n\n\n\nVery important part of testing is emulating user typing keys. There is a special child.type_keys() helper method for that. Examples:\nlocal eq = MiniTest.expect.equality\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.bo.readonly = false\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\nlocal get_lines = function() return child.api.nvim_buf_get_lines(0, 0, -1, true) end\n\nT['type_keys()'] = MiniTest.new_set()\n\nT['type_keys()']['works'] = function()\n  -- It can take one string\n  child.type_keys('iabcde&lt;Esc&gt;')\n  eq(get_lines(), { 'abcde' })\n  eq(child.fn.mode(), 'n')\n\n  -- Or several strings which improves readability\n  child.type_keys('cc', 'fghij', '&lt;Esc&gt;')\n  eq(get_lines(), { 'fghij' })\n\n  -- Or tables of strings (possibly nested)\n  child.type_keys({ 'cc', { 'j', 'k', 'l', 'm', 'n' } })\n  eq(get_lines(), { 'jklmn' })\nend\n\nT['type_keys()']['allows custom delay'] = function()\n  -- This adds delay of 500 ms after each supplied string (three times here)\n  child.type_keys(500, 'i', 'abcde', '&lt;Esc&gt;')\n  eq(get_lines(), { 'abcde' })\nend\n\nreturn T\n\n\n\nOne of the main difficulties in testing Neovim plugins is verifying that something is actually displayed in the way you intend. Like general highlighting, statusline, tabline, sign column, extmarks, etc. Testing screen state with screenshots makes this a lot easier. There is a child.get_screenshot() method which basically calls screenstring() (:h screenstring()) and screenattr() (:h screenattr()) for every visible cell (row from 1 to ‘lines’ option, column from 1 to ‘columns’ option). It then returns screenshot with two layers:\n\ntext - “2d array” (row-column) of single characters displayed at particular cells.\nattr - “2d array” (row-column) of symbols representing how text is displayed (basically, “coded” appearance/highlighting). They should be used only in relation to each other: same/different symbols for two cells mean same/different visual appearance. Note: there will be false positives if there are more than 94 different attribute values. To make output more portable and visually useful, outputs of screenattr() are coded with single character symbols.\n\nCouple of caveats:\n\nAs is apparent from use of screenattr(), these screenshots can’t tell how exactly cell is highlighted, only if two cells are highlighted the same. This is due to the currently lacking functionality in Neovim itself. This might change in the future.\n\nTo help manage testing screen state, there is a special MiniTest.expect.reference_screenshot(screenshot, path, opts) method. It takes screenshot table along with optional path of where to save this screenshot (if not supplied, inferred from test case description and put in ‘tests/screenshots’ directory). On first run it will automatically create reference screenshot at path. On later runs it will compare current screenshot with reference. Will throw informative error with helpful information if they don’t match exactly.\nExample:\nlocal expect = MiniTest.expect\n\nlocal child = MiniTest.new_child_neovim()\n\nlocal T = MiniTest.new_set({\n  hooks = {\n    pre_case = function()\n      child.restart({ '-u', 'scripts/minimal_init.lua' })\n      child.bo.readonly = false\n      child.lua([[M = require('hello_lines')]])\n    end,\n    post_once = child.stop,\n  },\n})\n\nT['set_lines()'] = MiniTest.new_set({ parametrize = { {}, { 0, { 'a' } }, { 0, { 1, 2, 3 } } } })\n\nT['set_lines()']['works'] = function(buf_id, lines)\n  child.o.lines, child.o.columns = 10, 15\n  child.lua('M.set_lines(...)', { buf_id, lines })\n  expect.reference_screenshot(child.get_screenshot())\nend\n\nreturn T\nThis will result into three files in ‘tests/screenshots’ with names containing test case description along with supplied arguments. Here is example reference screenshot for { 0, { 1, 2, 3 } } arguments (line numbers and ruler for columns is added as file specification to make it easier to find differences between two screenshots):\n--|---------|-----\n01|Hello 1        \n02|Hello 2        \n03|Hello 3        \n04|~              \n05|~              \n06|~              \n07|~              \n08|~              \n09|&lt;e] [+] 1,1 All\n10|               \n\n--|---------|-----\n01|000001111111111\n02|000001111111111\n03|000001111111111\n04|222222222222222\n05|222222222222222\n06|222222222222222\n07|222222222222222\n08|222222222222222\n09|333333333333333\n10|444444444444444\nTo update already existing screenshot either delete the corresponding screenshot file and rerun test case or temporarily add { force = true } option to reference_screenshot() to force updating the screenshot file."
  },
  {
    "objectID": "mini.nvim/TESTING.html#general-tips",
    "href": "mini.nvim/TESTING.html#general-tips",
    "title": "How to test with ‘mini.test’",
    "section": "",
    "text": "Create a ‘tests/helpers.lua’ file with code that can be useful in multiple files. It can have “monkey-patched” versions of ‘mini.test’ functions. Example:\n\nlocal Helpers = {}\n\nHelpers.new_child_neovim = function()\n  local child = MiniTest.new_child_neovim()\n\n  child.setup = function()\n    child.restart({'-u', 'scripts/minimal_init.lua'})\n    child.bo.readonly = false\n    child.lua([[M = require('hello_lines')]])\n  end\n\n  return child\nend\n\nreturn Helpers\n\nWrite aliases for commonly used functions at top of the file. It will make your life a little bit easier and usually will lead to more readable tests. Example:\n\n-- Some code setting up `child`\nlocal set_lines = function(lines) child.api.nvim_buf_set_lines(0, 0, -1, true, lines) end\n\nWhen working with automatically named screenshots, beware of the following caveats:\n\nSome systems are case insensitive (like usually Windows and MacOS). So having two different file names which are the same ignoring case will introduce problems for users to properly install plugin.\nSome system setups have restrictions on full path length (like 260 bytes on some Git+Windows combinations) or file name length (like 255 bytes on ext4 Windows partitions and 143 bytes on eCryptfs Linux partitions). Restriction on full path is hard to accommodate for (apart from limiting file name size to some reasonable number), but trying to not have file names longer than 143 bytes (by having shorter test case names) should be reasonable.\n\nTo make reading strings that contain Lua code easier (for child.lua and child.lua_get), you can add the following tree-sitter capture to your personal configuration. Put it in the file ‘after/queries/lua/injections.scm’. Don’t forget to add ; extends at the beginning of the file (see :h treesitter-query-modeline-extends):\n; extends\n(function_call\n  name: (dot_index_expression\n    table: (identifier) @_table\n    field: (identifier) @_field)\n  arguments: (arguments\n    (string\n      content: (string_content) @injection.content))\n  (#eq? @_table child)\n  (#any-of? @_field lua lua_get)\n  (#set! injection.language \"lua\"))"
  },
  {
    "objectID": "mini.nvim/readmes/mini-sessions.html",
    "href": "mini.nvim/readmes/mini-sessions.html",
    "title": "mini.sessions",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-sessions.html#demo",
    "href": "mini.nvim/readmes/mini-sessions.html#demo",
    "title": "mini.sessions",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-sessions.html#features",
    "href": "mini.nvim/readmes/mini-sessions.html#features",
    "title": "mini.sessions",
    "section": "Features",
    "text": "Features\n\nWorks using :mksession ('sessionoptions' is fully respected).\nImplements both global (from configured directory) and local (from current directory) sessions.\nNo automated new session creation. Use MiniSessions.write() manually.\nAutoread default session (local if detected, else latest written global) if Neovim was called without intention to show something else.\nAutowrite currently read session before quitting Neovim.\nConfigurable severity level of all actions."
  },
  {
    "objectID": "mini.nvim/readmes/mini-sessions.html#installation",
    "href": "mini.nvim/readmes/mini-sessions.html#installation",
    "title": "mini.sessions",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.sessions’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.sessions’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.sessions', version = false },\n\n\nStable\n{ 'nvim-mini/mini.sessions', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.sessions'\n\n\nStable\nPlug 'nvim-mini/mini.sessions', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.sessions').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-sessions.html#default-config",
    "href": "mini.nvim/readmes/mini-sessions.html#default-config",
    "title": "mini.sessions",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Whether to read default session if Neovim opened without file arguments\n  autoread = false,\n\n  -- Whether to write currently read session before leaving it\n  autowrite = true,\n\n  -- Directory where global sessions are stored (use `''` to disable)\n  directory = --&lt;\"session\" subdir of user data directory from |stdpath()|&gt;,\n\n  -- File for local session (use `''` to disable)\n  file = 'Session.vim',\n\n  -- Whether to force possibly harmful actions (meaning depends on function)\n  force = { read = false, write = true, delete = false },\n\n  -- Hook functions for actions. Default `nil` means 'do nothing'.\n  hooks = {\n    -- Before successful action\n    pre = { read = nil, write = nil, delete = nil },\n    -- After successful action\n    post = { read = nil, write = nil, delete = nil },\n  },\n\n  -- Whether to print session path after action\n  verbose = { read = false, write = true, delete = true },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-sessions.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-sessions.html#similar-plugins",
    "title": "mini.sessions",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nmhinz/vim-startify\nShatur/neovim-session-manager"
  },
  {
    "objectID": "mini.nvim/readmes/mini-basics.html",
    "href": "mini.nvim/readmes/mini-basics.html",
    "title": "mini.basics",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-basics.html#demo",
    "href": "mini.nvim/readmes/mini-basics.html#demo",
    "title": "mini.basics",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-basics.html#features",
    "href": "mini.nvim/readmes/mini-basics.html#features",
    "title": "mini.basics",
    "section": "Features",
    "text": "Features\n\nPresets for common options. It will only change option if it wasn’t manually set before. See :h MiniBasics.config.options for more details.\nPresets for common mappings. It will only add a mapping if it wasn’t manually created before. See :h MiniBasics.config.mappings for more details.\nPresets for common autocommands. See :h MiniBasics.config.autocommands for more details.\nReverse compatibility is a high priority. Any decision to change already present behavior will be made with great care.\n\nNotes:\n\nMain goal of this module is to provide a relatively easier way for new-ish Neovim users to have better “works out of the box” experience while having documented relevant options/mappings/autocommands to study. It is based partially on survey among Neovim users and partially is coming from personal preferences.\nHowever, more seasoned users almost surely will find something useful.\nStill, it is recommended to read about used options/mappings/autocommands and decide if they are needed. The main way to do that is by reading Neovim’s help pages (linked in help file) and this module’s source code (thoroughly documented for easier comprehension)."
  },
  {
    "objectID": "mini.nvim/readmes/mini-basics.html#installation",
    "href": "mini.nvim/readmes/mini-basics.html#installation",
    "title": "mini.basics",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.basics’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.basics’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.basics', version = false },\n\n\nStable\n{ 'nvim-mini/mini.basics', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.basics'\n\n\nStable\nPlug 'nvim-mini/mini.basics', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.basics').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-basics.html#default-config",
    "href": "mini.nvim/readmes/mini-basics.html#default-config",
    "title": "mini.basics",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Options. Set field to `false` to disable.\n  options = {\n    -- Basic options ('number', 'ignorecase', and many more)\n    basic = true,\n\n    -- Extra UI features ('winblend', 'listchars', 'pumheight', ...)\n    extra_ui = false,\n\n    -- Presets for window borders ('single', 'double', ...)\n    -- Default 'auto' infers from 'winborder' option\n    win_borders = 'auto',\n  },\n\n  -- Mappings. Set field to `false` to disable.\n  mappings = {\n    -- Basic mappings (better 'jk', save with Ctrl+S, ...)\n    basic = true,\n\n    -- Prefix for mappings that toggle common options ('wrap', 'spell', ...).\n    -- Supply empty string to not create these mappings.\n    option_toggle_prefix = [[\\]],\n\n    -- Window navigation with &lt;C-hjkl&gt;, resize with &lt;C-arrow&gt;\n    windows = false,\n\n    -- Move cursor in Insert, Command, and Terminal mode with &lt;M-hjkl&gt;\n    move_with_alt = false,\n  },\n\n  -- Autocommands. Set field to `false` to disable\n  autocommands = {\n    -- Basic autocommands (highlight on yank, start Insert in terminal, ...)\n    basic = true,\n\n    -- Set 'relativenumber' only in linewise and blockwise Visual mode\n    relnum_in_visual_mode = false,\n  },\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-basics.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-basics.html#similar-plugins",
    "title": "mini.basics",
    "section": "Similar plugins",
    "text": "Similar plugins\n\ntpope/vim-sensible\ntpope/vim-unimpaired"
  },
  {
    "objectID": "mini.nvim/readmes/mini-move.html",
    "href": "mini.nvim/readmes/mini-move.html",
    "title": "mini.move",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-move.html#demo",
    "href": "mini.nvim/readmes/mini-move.html#demo",
    "title": "mini.move",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-move.html#features",
    "href": "mini.nvim/readmes/mini-move.html#features",
    "title": "mini.move",
    "section": "Features",
    "text": "Features\n\nWorks in two modes:\n\nVisual mode. Select text (charwise with v, linewise with V, and blockwise with CTRL-V) and press customizable mapping to move in all four directions (left, right, down, up). It keeps Visual mode.\nNormal mode. Press customizable mapping to move current line in all four directions (left, right, down, up).\nSpecial handling of linewise movement:\n\nVertical movement gets reindented with =.\nHorizontal movement is improved indent/dedent with &gt; / &lt;.\nCursor moves along with selection.\n\n\nProvides both mappings and Lua functions for motions. See :h MiniMove.move_selection() and :h MiniMove.move_line().\nRespects v:count. Movement mappings can be preceded by a number which multiplies command effect.\nAll consecutive moves (regardless of direction) can be undone by a single u.\nRespects preferred column for vertical movement. It will vertically move selection as how cursor is moving (not strictly vertically if target column is not present in target line)."
  },
  {
    "objectID": "mini.nvim/readmes/mini-move.html#installation",
    "href": "mini.nvim/readmes/mini-move.html#installation",
    "title": "mini.move",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.move’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.move’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.move', version = false },\n\n\nStable\n{ 'nvim-mini/mini.move', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.move'\n\n\nStable\nPlug 'nvim-mini/mini.move', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.move').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-move.html#default-config",
    "href": "mini.nvim/readmes/mini-move.html#default-config",
    "title": "mini.move",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Move visual selection in Visual mode. Defaults are Alt (Meta) + hjkl.\n    left = '&lt;M-h&gt;',\n    right = '&lt;M-l&gt;',\n    down = '&lt;M-j&gt;',\n    up = '&lt;M-k&gt;',\n\n    -- Move current line in Normal mode\n    line_left = '&lt;M-h&gt;',\n    line_right = '&lt;M-l&gt;',\n    line_down = '&lt;M-j&gt;',\n    line_up = '&lt;M-k&gt;',\n  },\n\n  -- Options which control moving behavior\n  options = {\n    -- Automatically reindent selection during linewise vertical move\n    reindent_linewise = true,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-move.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-move.html#similar-plugins",
    "title": "mini.move",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nmatze/vim-move\nbooperlv/nvim-gomove"
  },
  {
    "objectID": "mini.nvim/readmes/mini-trailspace.html",
    "href": "mini.nvim/readmes/mini-trailspace.html",
    "title": "mini.trailspace",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-trailspace.html#demo",
    "href": "mini.nvim/readmes/mini-trailspace.html#demo",
    "title": "mini.trailspace",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-trailspace.html#features",
    "href": "mini.nvim/readmes/mini-trailspace.html#features",
    "title": "mini.trailspace",
    "section": "Features",
    "text": "Features\n\nHighlighting is done only in modifiable buffer by default, only in Normal mode, and stops in Insert mode and when leaving window.\nTrim all trailing whitespace with MiniTrailspace.trim().\nTrim all trailing empty lines with MiniTrailspace.trim_last_lines()."
  },
  {
    "objectID": "mini.nvim/readmes/mini-trailspace.html#installation",
    "href": "mini.nvim/readmes/mini-trailspace.html#installation",
    "title": "mini.trailspace",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.trailspace’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.trailspace’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.trailspace', version = false },\n\n\nStable\n{ 'nvim-mini/mini.trailspace', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.trailspace'\n\n\nStable\nPlug 'nvim-mini/mini.trailspace', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.trailspace').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-trailspace.html#default-config",
    "href": "mini.nvim/readmes/mini-trailspace.html#default-config",
    "title": "mini.trailspace",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Highlight only in normal buffers (ones with empty 'buftype'). This is\n  -- useful to not show trailing whitespace where it usually doesn't matter.\n  only_in_normal_buffers = true,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-trailspace.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-trailspace.html#similar-plugins",
    "title": "mini.trailspace",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nntpeters/vim-better-whitespace"
  },
  {
    "objectID": "mini.nvim/readmes/mini-surround.html",
    "href": "mini.nvim/readmes/mini-surround.html",
    "title": "mini.surround",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-surround.html#demo",
    "href": "mini.nvim/readmes/mini-surround.html#demo",
    "title": "mini.surround",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-surround.html#features",
    "href": "mini.nvim/readmes/mini-surround.html#features",
    "title": "mini.surround",
    "section": "Features",
    "text": "Features\n\nActions (text editing actions are dot-repeatable out of the box and respect [count]) with configurable mappings:\n\nAdd surrounding with sa (in visual mode or on motion).\nDelete surrounding with sd.\nReplace surrounding with sr.\nFind surrounding with sf or sF (move cursor right or left).\nHighlight surrounding with sh.\n\nSurrounding is identified by a single character as both “input” (in delete and replace start, find, and highlight) and “output” (in add and replace end):\n\n‘f’ - function call (string of alphanumeric symbols or ’_’ or ‘.’ followed by balanced ‘()’). In “input” finds function call, in “output” prompts user to enter function name.\n‘t’ - tag. In “input” finds tag with same identifier, in “output” prompts user to enter tag name.\nAll symbols in brackets ‘()’, ‘[]’, ‘{}’, ‘&lt;&gt;“. In”input’ represents balanced brackets (open - with whitespace pad, close - without), in “output” - left and right parts of brackets.\n‘?’ - interactive. Prompts user to enter left and right parts.\nAll other single character identifiers (supported by getcharstr()) represent surrounding with identical left and right parts.\n\nConfigurable search methods to find not only covering but possibly next, previous, or nearest surrounding. See more in help for MiniSurround.config.\nAll actions involving finding surrounding (delete, replace, find, highlight) can be used with suffix that changes search method to find previous/last. See more in help for MiniSurround.config."
  },
  {
    "objectID": "mini.nvim/readmes/mini-surround.html#installation",
    "href": "mini.nvim/readmes/mini-surround.html#installation",
    "title": "mini.surround",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.surround’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.surround’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.surround', version = false },\n\n\nStable\n{ 'nvim-mini/mini.surround', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.surround'\n\n\nStable\nPlug 'nvim-mini/mini.surround', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.surround').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-surround.html#default-config",
    "href": "mini.nvim/readmes/mini-surround.html#default-config",
    "title": "mini.surround",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Add custom surroundings to be used on top of builtin ones. For more\n  -- information with examples, see [`:h MiniSurround.config`](../doc/mini-surround.qmd#minisurround.config).\n  custom_surroundings = nil,\n\n  -- Duration (in ms) of highlight when calling [`MiniSurround.highlight()`](../doc/mini-surround.qmd#minisurround.highlight)\n  highlight_duration = 500,\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    add = 'sa', -- Add surrounding in Normal and Visual modes\n    delete = 'sd', -- Delete surrounding\n    find = 'sf', -- Find surrounding (to the right)\n    find_left = 'sF', -- Find surrounding (to the left)\n    highlight = 'sh', -- Highlight surrounding\n    replace = 'sr', -- Replace surrounding\n\n    suffix_last = 'l', -- Suffix to search with \"prev\" method\n    suffix_next = 'n', -- Suffix to search with \"next\" method\n  },\n\n  -- Number of lines within which surrounding is searched\n  n_lines = 20,\n\n  -- Whether to respect selection type:\n  -- - Place surroundings on separate lines in linewise mode.\n  -- - Place surroundings on each line in blockwise mode.\n  respect_selection_type = false,\n\n  -- How to search for surrounding (first inside current line, then inside\n  -- neighborhood). One of 'cover', 'cover_or_next', 'cover_or_prev',\n  -- 'cover_or_nearest', 'next', 'prev', 'nearest'. For more details,\n  -- see [`:h MiniSurround.config`](../doc/mini-surround.qmd#minisurround.config).\n  search_method = 'cover',\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-surround.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-surround.html#similar-plugins",
    "title": "mini.surround",
    "section": "Similar plugins",
    "text": "Similar plugins\n\ntpope/vim-surround\nkylechui/nvim-surround\nmachakann/vim-sandwich"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cmdline.html",
    "href": "mini.nvim/readmes/mini-cmdline.html",
    "title": "mini.cmdline",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cmdline.html#demo",
    "href": "mini.nvim/readmes/mini-cmdline.html#demo",
    "title": "mini.cmdline",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cmdline.html#features",
    "href": "mini.nvim/readmes/mini-cmdline.html#features",
    "title": "mini.cmdline",
    "section": "Features",
    "text": "Features\n\nAutocomplete with customizable delay. Enhances :h cmdline-completion and manual :h 'wildchar' pressing experience. Requires Neovim&gt;=0.11, though Neovim&gt;=0.12 is recommended.\nAutocorrect words as-you-type. Only words that must come from a fixed set of candidates (like commands and options) are autocorrected by default.\nAutopeek command range as-you-type. Shows a floating window with range lines along with customizable context lines.\n\nWhat it doesn’t do:\n\nCustomization of command line UI. Use :h vim._extui (on Neovim&gt;=0.12).\nCustomization of autocompletion candidates. They are computed via :h cmdline-completion."
  },
  {
    "objectID": "mini.nvim/readmes/mini-cmdline.html#installation",
    "href": "mini.nvim/readmes/mini-cmdline.html#installation",
    "title": "mini.cmdline",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nDuring beta-testing phase there is only one branch to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.cmdline’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.cmdline’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.cmdline', version = false },\n\n\nStable\n{ 'nvim-mini/mini.cmdline', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.cmdline'\n\n\nStable\nPlug 'nvim-mini/mini.cmdline', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.cmdline').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-cmdline.html#default-config",
    "href": "mini.nvim/readmes/mini-cmdline.html#default-config",
    "title": "mini.cmdline",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Autocompletion: show `:h 'wildmenu'` as you type\n  autocomplete = {\n    enable = true,\n\n    -- Delay (in ms) after which to trigger completion\n    -- Neovim&gt;=0.12 is recommended for positive values\n    delay = 0,\n\n    -- Custom rule of when to trigger completion\n    predicate = nil,\n\n    -- Whether to map arrow keys for more consistent wildmenu behavior\n    map_arrows = true,\n  },\n\n  -- Autocorrection: adjust non-existing words (commands, options, etc.)\n  autocorrect = {\n    enable = true,\n\n    -- Custom autocorrection rule\n    func = nil,\n  },\n\n  -- Autopeek: show command's target range in a floating window\n  autopeek = {\n    enable = true,\n\n    -- Number of lines to show above and below range lines\n    n_context = 1,\n\n    -- Custom rule of when to show peek window\n    predicate = nil,\n\n    -- Window options\n    window = {\n      -- Floating window config\n      config = {},\n\n      -- Function to render statuscolumn\n      statuscolumn = nil,\n    },\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cmdline.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-cmdline.html#similar-plugins",
    "title": "mini.cmdline",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nfolke/noice.nvim\nnacro90/numb.nvim\nBuilt-in cmdline-autocompletion (on Neovim&gt;=0.12):"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html",
    "href": "mini.nvim/readmes/mini-hues.html",
    "title": "mini.hues",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html#demo",
    "href": "mini.nvim/readmes/mini-hues.html#demo",
    "title": "mini.hues",
    "section": "Demo",
    "text": "Demo\nVideo\n\nBundled color schemes\n\nFour seasons\n\nminiwinter: “icy winter” palette with azure background\n\n     \n\nminispring: “blooming spring” palette with green background\n\n     \n\nminisummer: “hot summer” palette with brown/yellow background\n\n     \n\nminiautumn: “cooling autumn” palette with purple background\n\n     \n\n\nrandomhue\nrandomhue uses randomly generated background and foreground of same hue (color will change on every :colorscheme randomhue call):"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html#example-configurations",
    "href": "mini.nvim/readmes/mini-hues.html#example-configurations",
    "title": "mini.hues",
    "section": "Example configurations",
    "text": "Example configurations\n-- Choose background and foreground\nrequire('mini.hues').setup({ background = '#351721', foreground = '#cdc4c6' }) -- red\nrequire('mini.hues').setup({ background = '#361a0d', foreground = '#cdc5c1' }) -- orange\nrequire('mini.hues').setup({ background = '#2c2101', foreground = '#c9c6c0' }) -- yellow\nrequire('mini.hues').setup({ background = '#17280e', foreground = '#c4c8c2' }) -- green\nrequire('mini.hues').setup({ background = '#002923', foreground = '#c0c9c7' }) -- cyan\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc' }) -- azure\nrequire('mini.hues').setup({ background = '#19213a', foreground = '#c4c6cd' }) -- blue\nrequire('mini.hues').setup({ background = '#2b1a33', foreground = '#c9c5cb' }) -- purple\n\n-- Different number of non-base hues\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', n_hues = 6 })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', n_hues = 4 })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', n_hues = 2 })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', n_hues = 0 })\n\n-- Different text saturation\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', saturation = 'low' })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', saturation = 'lowmedium' })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', saturation = 'medium' })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', saturation = 'mediumhigh' })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', saturation = 'high' })\n\n-- Choose accent color\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', accent = 'yellow' })\nrequire('mini.hues').setup({ background = '#002734', foreground = '#c0c8cc', accent = 'blue' })"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html#features",
    "href": "mini.nvim/readmes/mini-hues.html#features",
    "title": "mini.hues",
    "section": "Features",
    "text": "Features\n\nRequired to set two base colors: background and foreground. Their shades and other non-base colors are computed to be as much perceptually different as reasonably possible.\nConfigurable:\n\nNumber of hues used for non-base colors (from 0 to 8).\nSaturation level (‘low’, ‘lowmedium’, ‘medium’, ‘mediumhigh’, ‘high’).\nAccent color used for some selected UI elements.\nPlugin integration (can be selectively enabled for faster startup).\n\nRandom generator for base colors. Powers randomhue color scheme.\nLua function to compute palette used in color scheme.\nBundled color schemes. See bundled-color-schemes.\n\nSupported highlight groups:\n\nAll built-in UI and syntax groups.\nBuilt-in Neovim LSP and diagnostic.\nTree-sitter.\nLSP semantic tokens.\nPlugins (either with explicit definition or by verification that default highlighting works appropriately):\n\nnvim-mini/mini.nvim\nakinsho/bufferline.nvim\nanuvyklack/hydra.nvim\nDanilaMihailov/beacon.nvim\nfolke/lazy.nvim\nfolke/noice.nvim\nfolke/todo-comments.nvim\nfolke/trouble.nvim\nfolke/which-key.nvim\nggandor/leap.nvim\nglepnir/dashboard-nvim\nglepnir/lspsaga.nvim\nHiPhish/rainbow-delimiters.nvim\nhrsh7th/nvim-cmp\nibhagwan/fzf-lua\njustinmk/vim-sneak\nkevinhwang91/nvim-bqf\nkevinhwang91/nvim-ufo\nlewis6991/gitsigns.nvim\nlukas-reineke/indent-blankline.nvim\nMeanderingProgrammer/render-markdown.nvim\nneoclide/coc.nvim\nNeogitOrg/neogit\nnvim-lualine/lualine.nvim\nnvim-neo-tree/neo-tree.nvim\nnvim-telescope/telescope.nvim\nnvim-tree/nvim-tree.lua\nOXY2DEV/helpview.nvim\nOXY2DEV/markview.nvim\nphaazon/hop.nvim\nrcarriga/nvim-dap-ui\nrcarriga/nvim-notify\nrlane/pounce.nvim\nromgrk/barbar.nvim\nstevearc/aerial.nvim\nwilliamboman/mason.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html#installation",
    "href": "mini.nvim/readmes/mini-hues.html#installation",
    "title": "mini.hues",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.hues’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.hues’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.hues', version = false },\n\n\nStable\n{ 'nvim-mini/mini.hues', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.hues'\n\n\nStable\nPlug 'nvim-mini/mini.hues', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.hues').setup() with background and foreground fields to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html#default-config",
    "href": "mini.nvim/readmes/mini-hues.html#default-config",
    "title": "mini.hues",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- **Required** base colors as '#rrggbb' hex strings\n  background = nil,\n  foreground = nil,\n\n  -- Number of hues used for non-base colors\n  n_hues = 8,\n\n  -- Saturation. One of 'low', 'lowmedium', 'medium', 'mediumhigh', 'high'.\n  saturation = 'medium',\n\n  -- Accent color. One of: 'bg', 'fg', 'red', 'orange', 'yellow', 'green',\n  -- 'cyan', 'azure', 'blue', 'purple'\n  accent = 'bg',\n\n  -- Plugin integrations. Use `default = false` to disable all integrations.\n  -- Also can be set per plugin (see |MiniHues.config|).\n  plugins = { default = true },\n\n  -- Whether to auto adjust highlight groups based on certain events\n  autoadjust = true,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hues.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-hues.html#similar-plugins",
    "title": "mini.hues",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nmini.base16"
  },
  {
    "objectID": "mini.nvim/readmes/mini-test.html",
    "href": "mini.nvim/readmes/mini-test.html",
    "title": "mini.test",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-test.html#demo",
    "href": "mini.nvim/readmes/mini-test.html#demo",
    "title": "mini.test",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-test.html#features",
    "href": "mini.nvim/readmes/mini-test.html#features",
    "title": "mini.test",
    "section": "Features",
    "text": "Features\n\nTest action is defined as a named callable entry of a table.\nHelper for creating child Neovim process which is designed to be used in tests (including taking and verifying screenshots). See help for MiniTest.new_child_neovim() and MiniTest.expect.reference_screenshot().\nHierarchical organization of tests with custom hooks, parametrization, and user data. See help for MiniTest.new_set().\nEmulation of Olivine-Labs/busted interface (describe, it, etc.).\nPredefined small yet usable set of expectations (assert-like functions). See help for MiniTest.expect.\nCustomizable definition of what files should be tested.\nTest case filtering. There are predefined wrappers for testing a file (MiniTest.run_file()) and case at a location like current cursor position (MiniTest.run_at_location()).\nCustomizable reporter of output results. There are two predefined ones:\n\nMiniTest.gen_reporter.buffer() for interactive usage.\nMiniTest.gen_reporter.stdout() for headless Neovim.\n\nCustomizable project specific testing script.\nWorks on Unix (Linux, MacOS, etc.) and Windows."
  },
  {
    "objectID": "mini.nvim/readmes/mini-test.html#installation",
    "href": "mini.nvim/readmes/mini-test.html#installation",
    "title": "mini.test",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.test’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.test’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.test', version = false },\n\n\nStable\n{ 'nvim-mini/mini.test', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.test'\n\n\nStable\nPlug 'nvim-mini/mini.test', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.test').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-test.html#default-config",
    "href": "mini.nvim/readmes/mini-test.html#default-config",
    "title": "mini.test",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Options for collection of test cases. See [`:h MiniTest.collect()`](../doc/mini-test.qmd#minitest.collect).\n  collect = {\n    -- Temporarily emulate functions from 'busted' testing framework\n    -- (`describe`, `it`, `before_each`, `after_each`, and more)\n    emulate_busted = true,\n\n    -- Function returning array of file paths to be collected.\n    -- Default: all Lua files in 'tests' directory starting with 'test_'.\n    find_files = function()\n      return vim.fn.globpath('tests', '**/test_*.lua', true, true)\n    end,\n\n    -- Predicate function indicating if test case should be executed\n    filter_cases = function(case) return true end,\n  },\n\n  -- Options for execution of test cases. See [`:h MiniTest.execute()`](../doc/mini-test.qmd#minitest.execute).\n  execute = {\n    -- Table with callable fields `start()`, `update()`, and `finish()`\n    reporter = nil,\n\n    -- Whether to stop execution after first error\n    stop_on_error = false,\n  },\n\n  -- Path (relative to current directory) to script which handles project\n  -- specific test running\n  script_path = 'scripts/minitest.lua',\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-test.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-test.html#similar-plugins",
    "title": "mini.test",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-lua/plenary.nvim (‘test_harness’, ‘busted’, ‘luassert’ modules)"
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html",
    "href": "mini.nvim/readmes/mini-deps.html",
    "title": "mini.deps",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html#demo",
    "href": "mini.nvim/readmes/mini-deps.html#demo",
    "title": "mini.deps",
    "section": "Demo",
    "text": "Demo\nVideo\nNote: This demo features custom vim.notify() from mini.notify."
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html#features",
    "href": "mini.nvim/readmes/mini-deps.html#features",
    "title": "mini.deps",
    "section": "Features",
    "text": "Features\n\nManage plugins utilizing Git and built-in packages with these actions:\n\nAdd plugin to current session, download if absent.\nUpdate with/without confirm, with/without parallel download of new data.\nDelete unused plugins with/without confirm.\nGet / set / save / load snapshot.\n\nMinimal yet flexible plugin specification:\n\nPlugin source.\nName of target plugin directory.\nCheckout target: branch, commit, tag, etc.\nMonitor branch to track updates without checking out.\nDependencies to be set up prior to the target plugin.\nHooks to call before/after plugin is created/changed.\n\nHelpers implementing two-stage startup: now() and later().\n\nFor more information see these parts of help:\n\n:h MiniDeps-overview\n:h MiniDeps-plugin-specification\n:h MiniDeps-commands"
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html#installation",
    "href": "mini.nvim/readmes/mini-deps.html#installation",
    "title": "mini.deps",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nInstallation should be done manually with git clone in the proper directory. Here is a suggested snippet to put at the top of your ‘init.lua’:\n-- Clone 'mini.nvim' manually in a way that it gets managed by 'mini.deps'\nlocal path_package = vim.fn.stdpath('data') .. '/site/'\nlocal mini_path = path_package .. 'pack/deps/start/mini.nvim'\nif not vim.loop.fs_stat(mini_path) then\n  vim.cmd('echo \"Installing [`mini.nvim`](../doc/mini-nvim.qmd#mini.nvim)\" | redraw')\n  local clone_cmd = {\n    'git', 'clone', '--filter=blob:none',\n    'https://github.com/nvim-mini/mini.nvim', mini_path\n  }\n  vim.fn.system(clone_cmd)\n  vim.cmd('packadd mini.nvim | helptags ALL')\n  vim.cmd('echo \"Installed [`mini.nvim`](../doc/mini-nvim.qmd#mini.nvim)\" | redraw')\nend\n\n-- Set up 'mini.deps' (customize to your liking)\nrequire('mini.deps').setup({ path = { package = path_package } })\nUsing default ‘main’ branch is OK, as changes there rarely accidentally break something (so far). However, if you want to be extra safe and use only stable releases of ‘mini.nvim’, add MiniDeps.add({ name = 'mini.nvim', checkout = 'stable' }) call after ‘mini.deps’ is set up and execute :DepsUpdateOffline mini.nvim.\nTo install from standalone repository, replace any occurrence of ‘mini.nvim’ in the code snippet to ‘mini.deps’.\nNOTE: ‘mini.nvim’ is installed in ‘pack/deps/start’ and not ‘pack/deps/opt’ to always be included in ‘mini.deps’ session. If you want to make it “opt” plugin (as any other installed plugin), use ‘pack/deps/opt’ but add MiniDeps.add('mini.nvim') call after ‘mini.deps’ is set up."
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html#overview",
    "href": "mini.nvim/readmes/mini-deps.html#overview",
    "title": "mini.deps",
    "section": "Overview",
    "text": "Overview\nSee and use example ‘init.lua’ file as a quick demo of how ‘mini.deps’ can be used:\n\nCopy its contents into a ‘~/.config/nvim-deps/init.lua’ file (on UNIX systems).\nRun NVIM_APPNAME=nvim-deps nvim -- ~/.config/nvim-deps/init.lua (on Neovim&lt;0.10 might display tree-sitter issues on first start). This will run Neovim with that ‘init.lua’ as the only config while completely not affecting your current config.\n\n\nDirectory structure\nThis module uses built-in packages to make plugins usable in current session. It works with “pack/deps” package inside config.path.package directory.\nBy default “opt” subdirectory is used to install optional plugins which are loaded on demand with MiniDeps.add(). Non-optional plugins in “start” subdirectory are supported but only if moved there manually after initial install.\n\n\nAdd plugin\nUse MiniDeps.add() to add plugin to current session. Supply plugin’s URL source as a string or plugin specification in general. If plugin is not present in “pack/deps” package, it will be created (a.k.a. installed) before processing anything else.\nThe recommended way of adding a plugin is by calling MiniDeps.add() in the ‘init.lua’ file (make sure MiniDeps.setup() is called prior):\nlocal add = MiniDeps.add\n\n-- Add to current session (install if absent)\nadd({\n  source = 'neovim/nvim-lspconfig',\n  -- Supply dependencies near target plugin\n  depends = { 'williamboman/mason.nvim' },\n})\n\nadd({\n  source = 'nvim-treesitter/nvim-treesitter',\n  -- Use 'master' while monitoring updates in 'main'\n  checkout = 'master',\n  monitor = 'main',\n  -- Perform action after every checkout\n  hooks = { post_checkout = function() vim.cmd('TSUpdate') end },\n})\n-- Possible to immediately execute code which depends on the added plugin\nrequire('nvim-treesitter.configs').setup({\n  ensure_installed = { 'lua', 'vimdoc' },\n  highlight = { enable = true },\n})\nNOTE:\n\nTo increase performance, add() only ensures presence on disk and nothing else. In particular, it doesn’t ensure opts.checkout state. Update or modify plugin state explicitly (see later sections).\n\n\n\nPlugin specification\nSpecification can be a single string which is inferred as:\n\nPlugin name if it doesn’t contain “/”.\nPlugin source otherwise.\n\nPrimarily, specification is a table with the following fields (see :h MiniDeps-plugin-specification for more details):\n\n\n\nField\nDescription\n\n\n\n\nsource\nURI of plugin source\n\n\nname\nName to be used on disk\n\n\ncheckout\nTarget state\n\n\nmonitor\nMonitor branch\n\n\ndepends\nArray of plugin dependencies\n\n\nhooks\nTable with hooks\n\n\n\n\n\nLazy loading\nAny lazy-loading is assumed to be done manually by calling MiniDeps.add() at appropriate time. This module provides helpers implementing special safe two-stage loading:\n\nMiniDeps.now() safely executes code immediately. Use it to load plugins with UI necessary to make initial screen draw.\nMiniDeps.later() schedules code to be safely executed later, preserving order. Use it (with caution) for everything else which doesn’t need precisely timed effect, as it will be executed some time soon on one of the next event loops.\n\nlocal now, later = MiniDeps.now, MiniDeps.later\n\n-- Safely execute immediately\nnow(function() vim.cmd('colorscheme miniwinter') end)\nnow(function() require('mini.statusline').setup() end)\n\n-- Safely execute later\nlater(function() require('mini.pick').setup() end)\n\n\nUpdate\nTo update plugins from current session with new data from their sources, use :DepsUpdate. This will download updates (utilizing multiple cores) and show confirmation buffer. Follow instructions at its top to finish an update.\nNOTE: This updates plugins on disk which most likely won’t affect current session. Restart Nvim to have them properly loaded.\n\n\nModify\nTo change plugin’s specification (like set different checkout, etc.):\n\nUpdate corresponding MiniDeps.add() call.\nRun :DepsUpdateOffline &lt;plugin_name&gt;.\nReview changes and confirm.\nRestart Nvim.\n\nNOTE: if add() prior used a single source string, make sure to convert its argument to { source = '&lt;previous_argument&gt;', checkout = '&lt;state&gt;'}\n\n\nSnapshots\nUse :DepsSnapSave to save state of all plugins from current session into a snapshot file (see config.path.snapshot).\nUse :DepsSnapLoad to load snapshot. This will change (without confirmation) state on disk. Plugins present in both snapshot file and current session will be affected. Restart Nvim to see the effect.\nNOTE: loading snapshot does not change plugin’s specification defined inside MiniDeps.add() call. This means that next update might change plugin’s state. To make it permanent, freeze plugin in target state manually.\n\n\nFreeze\nModify plugin’s specification to have checkout pointing to a static target: tag, state (commit hash), or ‘HEAD’ (to freeze in current state).\nFrozen plugins will not receive updates. You can monitor any new changes from its source by “subscribing” to monitor branch which will be shown inside confirmation buffer after :DepsUpdate.\nExample: use checkout = 'v0.10.0' to freeze plugin at tag “v0.10.0” while monitoring new versions in the log from monitor (usually default) branch.\n\n\nRollback\nTo roll back after an unfortunate update:\n\nGet identifier of latest working state:\n\nUse :DepsShowLog to see update log, look for plugin’s name, and copy identifier listed as “State before:”.\nSee previously saved snapshot file for plugin’s name and copy identifier next to it.\n\nFreeze plugin at that state while monitoring appropriate branch. Revert to previous shape of MiniDeps.add() call to resume updating.\n\n\n\nRemove\n\nMake sure that target plugin is not registered in current session. Usually it means removing corresponding MiniDeps.add() call.\nRun :DepsClean. This will show confirmation buffer with a list of plugins to be deleted from disk. Follow instructions at its top to finish cleaning.\n\nAlternatively, manually delete plugin’s directory from “pack/deps” package."
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html#default-config",
    "href": "mini.nvim/readmes/mini-deps.html#default-config",
    "title": "mini.deps",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Parameters of CLI jobs\n  job = {\n    -- Number of parallel threads to use. Default: 80% of all available.\n    n_threads = nil,\n\n    -- Timeout (in ms) for each job before force quit\n    timeout = 30000,\n  },\n\n  -- Paths describing where to store data\n  path = {\n    -- Directory for built-in package.\n    -- All plugins are actually stored in 'pack/deps' subdirectory.\n    package = vim.fn.stdpath('data') .. '/site',\n\n    -- Default file path for a snapshot\n    snapshot = vim.fn.stdpath('config') .. '/mini-deps-snap',\n\n    -- Log file\n    log = vim.fn.stdpath('log') .. '/mini-deps.log'\n  },\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-deps.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-deps.html#similar-plugins",
    "title": "mini.deps",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nfolke/lazy.nvim\nsavq/paq-nvim\njunegunn/vim-plug"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bufremove.html",
    "href": "mini.nvim/readmes/mini-bufremove.html",
    "title": "mini.bufremove",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bufremove.html#demo",
    "href": "mini.nvim/readmes/mini-bufremove.html#demo",
    "title": "mini.bufremove",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bufremove.html#features",
    "href": "mini.nvim/readmes/mini-bufremove.html#features",
    "title": "mini.bufremove",
    "section": "Features",
    "text": "Features\nWhich buffer to show in window(s) after its current buffer is removed is decided by the algorithm:\n\nIf alternate buffer is listed, use it.\nIf previous listed buffer is different, use it.\nOtherwise create a scratch one with nvim_create_buf(true, true) and use it."
  },
  {
    "objectID": "mini.nvim/readmes/mini-bufremove.html#installation",
    "href": "mini.nvim/readmes/mini-bufremove.html#installation",
    "title": "mini.bufremove",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.bufremove’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.bufremove’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.bufremove', version = false },\n\n\nStable\n{ 'nvim-mini/mini.bufremove', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.bufremove'\n\n\nStable\nPlug 'nvim-mini/mini.bufremove', { 'branch': 'stable' }\n\n\n\n\n\nImportant: no need to call require('mini.bufremove').setup(), but it can be done to improve usability.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-bufremove.html#default-config",
    "href": "mini.nvim/readmes/mini-bufremove.html#default-config",
    "title": "mini.bufremove",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bufremove.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-bufremove.html#similar-plugins",
    "title": "mini.bufremove",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nmhinz/vim-sayonara\nmoll/vim-bbye"
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html",
    "href": "mini.nvim/readmes/mini-colors.html",
    "title": "mini.colors",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html#demo",
    "href": "mini.nvim/readmes/mini-colors.html#demo",
    "title": "mini.colors",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html#features",
    "href": "mini.nvim/readmes/mini-colors.html#features",
    "title": "mini.colors",
    "section": "Features",
    "text": "Features\n\nCreate colorscheme object (see :h MiniColors-colorscheme): either manually (:h MiniColors.as_colorscheme()) or by querying present color schemes (including currently active one; see :h MiniColors.get_colorscheme()).\nInfer data about color scheme and/or modify based on it:\n\nAdd transparency by removing background color (requires transparency in terminal emulator).\nInfer cterm attributes based on gui colors making it compatible with ‘notermguicolors’.\nResolve highlight group links.\nCompress by removing redundant highlight groups.\nExtract palette of used colors and/or infer terminal colors based on it.\n\nModify colors to better fit your taste and/or goals:\n\nApply any function to color hex string.\nUpdate channels (like lightness, saturation, hue, temperature, red, green, blue, etc.). Use either own function or one of the implemented methods:\n\nAdd value to channel or multiply it by coefficient. Like “add 10 to saturation of every color” or “multiply saturation by 2” to make colors more saturated (less gray).\nInvert. Like “invert lightness” to convert between dark/light theme.\nSet to one or more values (picks closest to current one). Like “set to one or two hues” to make mono- or dichromatic color scheme.\nRepel from certain source(s) with stronger effect for closer values. Like “repel from hue 30” to remove red color from color scheme. Repel hue (how much is removed) is configurable.\n\nSimulate color vision deficiency.\n\nOnce color scheme is ready, either apply it to see effects right away or write it into a Lua file as a fully functioning separate color scheme.\nExperiment interactively with a feedback.\nAnimate transition between color schemes either with MiniColors.animate() or with :Colorscheme user command.\nConvert within supported color spaces (MiniColors.convert()):\n\nHex string.\n8-bit number (terminal colors).\nRGB.\nOklab, Oklch, Okhsl (https://bottosson.github.io/posts/oklab/)."
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html#tweak-quick-start",
    "href": "mini.nvim/readmes/mini-colors.html#tweak-quick-start",
    "title": "mini.colors",
    "section": "Tweak quick start",
    "text": "Tweak quick start\n\nExecute :lua require('mini.colors').interactive().\nExperiment by writing calls to exposed color scheme methods and applying them with &lt;M-a&gt;. For more information, see :h MiniColors-colorscheme-methods and :h MiniColors-recipes.\nIf you are happy with result, write color scheme with &lt;M-w&gt;. If not, reset to initial color scheme with &lt;M-r&gt;.\nIf only some highlight groups can be made better, adjust them manually inside written color scheme file."
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html#installation",
    "href": "mini.nvim/readmes/mini-colors.html#installation",
    "title": "mini.colors",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.colors’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.colors’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.colors', version = false },\n\n\nStable\n{ 'nvim-mini/mini.colors', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.colors'\n\n\nStable\nPlug 'nvim-mini/mini.colors', { 'branch': 'stable' }\n\n\n\n\n\nImportant: no need to call require('mini.colors').setup(), but it can be done to improve usability.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html#default-config",
    "href": "mini.nvim/readmes/mini-colors.html#default-config",
    "title": "mini.colors",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-colors.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-colors.html#similar-plugins",
    "title": "mini.colors",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nrktjmp/lush.nvim\nlifepillar/vim-colortemplate\ntjdevries/colorbuddy.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-notify.html",
    "href": "mini.nvim/readmes/mini-notify.html",
    "title": "mini.notify",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-notify.html#demo",
    "href": "mini.nvim/readmes/mini-notify.html#demo",
    "title": "mini.notify",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-notify.html#features",
    "href": "mini.nvim/readmes/mini-notify.html#features",
    "title": "mini.notify",
    "section": "Features",
    "text": "Features\n\nShow one or more highlighted notifications in a single floating window.\nManage notifications (add, update, remove, clear).\nCustom vim.notify() implementation. To adjust, use MiniNotify.make_notify() after calling setup().\nAutomated show of LSP progress report.\nTrack history which can be accessed with MiniNotify.get_all() and shown with MiniNotify.show_history()."
  },
  {
    "objectID": "mini.nvim/readmes/mini-notify.html#installation",
    "href": "mini.nvim/readmes/mini-notify.html#installation",
    "title": "mini.notify",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.notify’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.notify’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.notify', version = false },\n\n\nStable\n{ 'nvim-mini/mini.notify', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.notify'\n\n\nStable\nPlug 'nvim-mini/mini.notify', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.notify').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-notify.html#default-config",
    "href": "mini.nvim/readmes/mini-notify.html#default-config",
    "title": "mini.notify",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Content management\n  content = {\n    -- Function which formats the notification message\n    -- By default prepends message with notification time\n    format = nil,\n\n    -- Function which orders notification array from most to least important\n    -- By default orders first by level and then by update timestamp\n    sort = nil,\n  },\n\n  -- Notifications about LSP progress\n  lsp_progress = {\n    -- Whether to enable showing\n    enable = true,\n\n    -- Notification level\n    level = 'INFO',\n\n    -- Duration (in ms) of how long last message should be shown\n    duration_last = 1000,\n  },\n\n  -- Window options\n  window = {\n    -- Floating window config\n    config = {},\n\n    -- Maximum window width as share (between 0 and 1) of available columns\n    max_width_share = 0.382,\n\n    -- Value of 'winblend' option\n    winblend = 25,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-notify.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-notify.html#similar-plugins",
    "title": "mini.notify",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nj-hui/fidget.nvim\nrcarriga/nvim-notify"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cursorword.html",
    "href": "mini.nvim/readmes/mini-cursorword.html",
    "title": "mini.cursorword",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cursorword.html#demo",
    "href": "mini.nvim/readmes/mini-cursorword.html#demo",
    "title": "mini.cursorword",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cursorword.html#features",
    "href": "mini.nvim/readmes/mini-cursorword.html#features",
    "title": "mini.cursorword",
    "section": "Features",
    "text": "Features\n\nCurrent word under cursor can be highlighted differently.\n“Word under cursor” is meant as in Vim’s &lt;cword&gt;: something user would get as ‘iw’ text object.\nHighlighting stops in insert and terminal modes."
  },
  {
    "objectID": "mini.nvim/readmes/mini-cursorword.html#installation",
    "href": "mini.nvim/readmes/mini-cursorword.html#installation",
    "title": "mini.cursorword",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.cursorword’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.cursorword’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.cursorword', version = false },\n\n\nStable\n{ 'nvim-mini/mini.cursorword', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.cursorword'\n\n\nStable\nPlug 'nvim-mini/mini.cursorword', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.cursorword').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-cursorword.html#default-config",
    "href": "mini.nvim/readmes/mini-cursorword.html#default-config",
    "title": "mini.cursorword",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Delay (in ms) between when cursor moved and when highlighting appeared\n  delay = 100,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-cursorword.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-cursorword.html#similar-plugins",
    "title": "mini.cursorword",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nRRethy/vim-illuminate\nitchyny/vim-cursorword"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump2d.html",
    "href": "mini.nvim/readmes/mini-jump2d.html",
    "title": "mini.jump2d",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump2d.html#demo",
    "href": "mini.nvim/readmes/mini-jump2d.html#demo",
    "title": "mini.jump2d",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump2d.html#features",
    "href": "mini.nvim/readmes/mini-jump2d.html#features",
    "title": "mini.jump2d",
    "section": "Features",
    "text": "Features\n\nMake jump by iterative filtering of possible, equally considered jump spots until there is only one. Filtering is done by typing a label character that is visualized at jump spot.\nCustomizable:\n\nWay of computing possible jump spots with opinionated default.\nCharacters used to label jump spots during iterative filtering.\nVisual effects: how many steps ahead to show; dim lines with spots.\nAction hooks to be executed at certain events during jump.\nAllowed windows: current and/or not current.\nAllowed lines: whether to process blank or folded lines, lines before/at/after cursor line, etc. Example: user can configure to look for spots only inside current window at or after cursor line. Example: user can configure to look for word starts only inside current window at or after cursor line with ‘j’ and ‘k’ labels performing some action after jump.\n\nWorks in Visual and Operator-pending (with dot-repeat) modes.\nPreconfigured ways of computing jump spots (see help for MiniJump2d.builtin_opts()):\n\nStarts of lines.\nStarts of words.\nSingle character from user input.\nVariable length query from user input.\n\nWorks with multibyte characters."
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump2d.html#installation",
    "href": "mini.nvim/readmes/mini-jump2d.html#installation",
    "title": "mini.jump2d",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.jump2d’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.jump2d’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.jump2d', version = false },\n\n\nStable\n{ 'nvim-mini/mini.jump2d', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.jump2d'\n\n\nStable\nPlug 'nvim-mini/mini.jump2d', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.jump2d').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump2d.html#default-config",
    "href": "mini.nvim/readmes/mini-jump2d.html#default-config",
    "title": "mini.jump2d",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Function producing jump spots (byte indexed) for a particular line.\n  -- For more information see |MiniJump2d.start|.\n  -- If `nil` (default) - use |MiniJump2d.default_spotter|\n  spotter = nil,\n\n  -- Characters used for labels of jump spots (in supplied order)\n  labels = 'abcdefghijklmnopqrstuvwxyz',\n\n  -- Options for visual effects\n  view = {\n    -- Whether to dim lines with at least one jump spot\n    dim = false,\n\n    -- How many steps ahead to show. Set to big number to show all steps.\n    n_steps_ahead = 0,\n  },\n\n  -- Which lines are used for computing spots\n  allowed_lines = {\n    blank = true, -- Blank line (not sent to spotter even if `true`)\n    cursor_before = true, -- Lines before cursor line\n    cursor_at = true, -- Cursor line\n    cursor_after = true, -- Lines after cursor line\n    fold = true, -- Start of fold (not sent to spotter even if `true`)\n  },\n\n  -- Which windows from current tabpage are used for visible lines\n  allowed_windows = {\n    current = true,\n    not_current = true,\n  },\n\n  -- Functions to be executed at certain events\n  hooks = {\n    before_start = nil, -- Before jump start\n    after_jump = nil, -- After jump was actually done\n  },\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    start_jumping = '&lt;CR&gt;',\n  },\n\n  -- Whether to disable showing non-error feedback\n  -- This also affects (purely informational) helper messages shown after\n  -- idle time if user input is required.\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-jump2d.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-jump2d.html#similar-plugins",
    "title": "mini.jump2d",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nphaazon/hop.nvim (main inspiration behind this module)\nggandor/lightspeed.nvim\nggandor/leap.nvim\nrlane/pounce.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html",
    "href": "mini.nvim/readmes/mini-snippets.html",
    "title": "mini.snippets",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#demo",
    "href": "mini.nvim/readmes/mini-snippets.html#demo",
    "title": "mini.snippets",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#features",
    "href": "mini.nvim/readmes/mini-snippets.html#features",
    "title": "mini.snippets",
    "section": "Features",
    "text": "Features\n\nManage snippet collection by adding it explicitly or with a flexible set of performant built-in loaders. See :h MiniSnippets.gen_loader.\nConfigured snippets are efficiently resolved before every expand based on current local context. This, for example, allows using different snippets in different local tree-sitter languages (like in markdown code blocks). See :h MiniSnippets.default_prepare().\nMatch which snippet to insert based on the currently typed text. Supports both exact and fuzzy matching. See :h MiniSnippets.default_match().\nSelect from several matched snippets via vim.ui.select(). See :h MiniSnippets.default_select().\nStart specialized in-process LSP server to show loaded snippets inside (auto)completion engines (like mini.completion). See :h MiniSnippets.start_lsp_server().\nInsert, jump, and edit during snippet session in a configurable manner:\n\nConfigurable mappings for jumping and stopping.\nJumping wraps around the tabstops for easier navigation.\nEasy to reason rules for when session automatically stops.\nText synchronization of linked tabstops preserving relative indent.\nDynamic tabstop state visualization (current/visited/unvisited, etc.)\nInline visualization of empty tabstops (requires Neovim&gt;=0.10).\nWorks inside comments by preserving comment leader on new lines.\nSupports nested sessions (expand snippet while there is an active one).\n\nSee :h MiniSnippets.default_insert().\nExported function to parse snippet body into easy-to-reason data structure. See :h MiniSnippets.parse().\n\nNotes:\n\nIt does not set up any snippet collection by default. Explicitly populate config.snippets to have snippets to match from.\nIt does not come with a built-in snippet collection. It is expected from users to add their own snippets, manually or with dedicated plugin(s).\nIt does not support variable/tabstop transformations in default snippet session. This requires ECMAScript Regular Expression parser which can not be implemented concisely.\n\nSources with more details:\n\nOverview\n:h MiniSnippets-glossary\n:h MiniSnippets-examples\n:h MiniSnippets-in-other-plugins (for plugin authors)"
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#dependencies",
    "href": "mini.nvim/readmes/mini-snippets.html#dependencies",
    "title": "mini.snippets",
    "section": "Dependencies",
    "text": "Dependencies\nThis module doesn’t come with snippet collection. Either create it manually or install a dedicated plugin. For example, rafamadriz/friendly-snippets."
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#quickstart",
    "href": "mini.nvim/readmes/mini-snippets.html#quickstart",
    "title": "mini.snippets",
    "section": "Quickstart",
    "text": "Quickstart\n\nUse the following setup:\nlocal gen_loader = require('mini.snippets').gen_loader\nrequire('mini.snippets').setup({\n  snippets = {\n    -- Load custom file with global snippets first (adjust for Windows)\n    gen_loader.from_file('~/.config/nvim/snippets/global.json'),\n\n    -- Load snippets based on current language by reading files from\n    -- \"snippets/\" subdirectories from 'runtimepath' directories.\n    gen_loader.from_lang(),\n  },\n})\nThis setup allows having single file with custom “global” snippets (will be present in every buffer) and snippets which will be loaded based on the local language (see :h MiniSnippets.gen_loader.from_lang()).\nCreate language snippets manually (like by creating and populating ‘$XDG_CONFIG_HOME/nvim/snippets/lua.json’ file) or by installing dedicated snippet collection plugin (like rafamadriz/friendly-snippets).\nNote: all built-in loaders cache their output by default. It means that after a file is first read, changing it won’t have effect during current Neovim session. See :h MiniSnippets.gen_loader about how to reset cache if necessary.\nOpen Neovim in a file with dedicated language (like ‘init.lua’ from your config) and press &lt;C-j&gt;.\n\nThe best way to grasp the design of snippet management and expansion is to try them out yourself. Here are extra steps for a basic demo:\n\nCreate ‘snippets/global.json’ file in the config directory with the content:\n{\n  \"Basic\":        { \"prefix\": \"ba\", \"body\": \"T1=$1 T2=$2 T0=$0\"         },\n  \"Placeholders\": { \"prefix\": \"pl\", \"body\": \"T1=${1:aa}\\nT2=${2:&lt;$1&gt;}\"  },\n  \"Choices\":      { \"prefix\": \"ch\", \"body\": \"T1=${1|a,b|} T2=${2|c,d|}\" },\n  \"Linked\":       { \"prefix\": \"li\", \"body\": \"T1=$1\\n\\tT1=$1\"            },\n  \"Variables\":    { \"prefix\": \"va\", \"body\": \"Runtime: $VIMRUNTIME\\n\"    },\n  \"Complex\":      {\n    \"prefix\": \"co\",\n    \"body\": [ \"T1=${1:$RANDOM}\", \"T3=${3:$1_${2:$1}}\", \"T2=$2\" ]\n  }\n}\nOpen Neovim. Type each snippet prefix and press &lt;C-j&gt; (even if there is still active session). Explore from there."
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#overview",
    "href": "mini.nvim/readmes/mini-snippets.html#overview",
    "title": "mini.snippets",
    "section": "Overview",
    "text": "Overview\nSnippet is a template for a frequently used text. Typical workflow is to type snippet’s (configurable) prefix and expand it into a snippet session: add some pre-defined text and allow user to interactively change/add at certain places.\nThis overview assumes default config for mappings and expand. See :h MiniSnippets.config and :h MiniSnippets-examples for more details.\n\nSnippet structure\nSnippet consists from three parts:\n\nPrefix - identifier used to match against current text.\nBody - actually inserted content with appropriate syntax.\nDesc - description in human readable form.\n\nExample: { prefix = 'tis', body = 'This is snippet', desc = 'Snip' } Typing tis and pressing “expand” mapping (&lt;C-j&gt; by default) will remove “tis”, add “This is snippet”, and place cursor at the end in Insert mode.\n\n\nSyntax\nInserting just text after typing smaller prefix is already powerful enough. For more flexibility, snippet body can be formatted in a special way to provide extra features. This module implements support for syntax defined in LSP specification (with small deviations).\nA quick overview of basic syntax features:\n\nTabstops are snippet parts meant for interactive editing at their location. They are denoted as $1, $2, etc.\nNavigating between them is called “jumping” and is done in numerical order of tabstop identifiers by pressing special keys: &lt;C-l&gt; and &lt;C-h&gt; to jump to next and previous tabstop respectively.\nSpecial tabstop $0 is called “final tabstop”: it is used to decide when snippet session is automatically stopped and is visited last during jumping.\nExample: T1=$1 T2=$2 T0=$0 is expanded as T1= T2= T0= with three tabstops.\nTabstop can have placeholder: a text used if tabstop is not yet edited. Text is preserved if no editing is done. It follows this same syntax, which means it can itself contain tabstops with placeholders (i.e. be nested). Tabstop with placeholder is denoted as ${1:placeholder} ($1 is ${1:}).\nExample: T1=${1:text} T2=${2:&lt;$1&gt;} is expanded as T1=text T2=&lt;text&gt;; typing x at first placeholder results in T1=x T2=&lt;x&gt;; jumping once and typing y results in T1=x T2=y.\nThere can be several tabstops with same identifier. They are linked and updated in sync during text editing. Can also have different placeholders; they are forced to be the same as in the first (from left to right) tabstop.\nExample: T1=${1:text} T1=$1 is expanded as T1=text T1=text; typing x at first placeholder results in T1=x T1=x.\nTabstop can also have choices: suggestions about tabstop text. It is denoted as ${1|a,b,c|}. Choices are shown (with :h ins-completion like interface) after jumping to tabstop. First choice is used as placeholder.\nExample: T1=${1|left,right|} is expanded as T1=left.\nVariables can be used to automatically insert text without user interaction. As tabstops, each one can have a placeholder which is used if variable is not defined. There is a special set of variables describing editor state.\nExample: V1=$TM_FILENAME V2=${NOTDEFINED:placeholder} is expanded as V1=current-file-basename V2=placeholder.\n\nThere are several differences LSP specification: not supporting variable transformations, wider set of supported special variables, and couple more. For more details see :h MiniSnippets-syntax-specification.\nThere is a :h MiniSnippets.parse() function for programmatically parsing snippet body into a comprehensible data structure.\n\n\nExpand\nUsing snippets is done via what is called “expanding”. It goes like this:\n\nType snippet prefix or its recognizable part.\nPress &lt;C-j&gt; to expand. It will perform the following steps:\n\nPrepare available snippets in current context (buffer + local language). This allows snippet setup to have general function loaders which return different snippets in different contexts.\nMatch text to the left of cursor with available prefixes. It first tries to do exact match and falls back to fuzzy matching.\nIf there are several matches, use vim.ui.select() to choose one.\nInsert single matching snippet. If snippet contains tabstops, start snippet session.\n\n\nFor more information see these parts of help:\n\n:h MiniSnippets.default_prepare()\n:h MiniSnippets.default_match()\n:h MiniSnippets.default_select()\n:h MiniSnippets.default_insert()\n\nSnippet session allows interactive editing at tabstop locations:\n\nAll tabstop locations are visualized depending on tabstop “state” (whether it is current/visited/unvisited/final and whether it was already edited).\nEmpty tabstops are visualized with inline virtual text (• / ∎ for regular/final tabstops). It is removed after session is stopped.\nStart session at first tabstop. Type text to replace placeholder. When finished with current tabstop, jump to next with &lt;C-l&gt;. Repeat. If changed mind about some previous tabstop, jump back with &lt;C-h&gt;. Jumping also wraps around the edge (first tabstop is next after final).\nIf tabstop has choices, use &lt;C-n&gt; / &lt;C-p&gt; to select next / previous item.\nStarting another snippet session while there is an active one is allowed. This creates nested sessions: suspend current, start the new one. After newly created is stopped, resume the suspended one.\nStop session manually by pressing &lt;C-c&gt; or make it stop automatically: if final tabstop is current either make a text edit or exit to Normal mode. If snippet doesn’t explicitly define final tabstop, it is added at the end of the snippet.\n\nFor more information about snippet session see :h MiniSnippets-session.\nTo select and insert snippets via completion engine (that supports LSP completion; like mini.completion or :h vim.lsp.completion), call :h MiniSnippets.start_lsp_server() after require('mini.snippets').setup(). This sets up an LSP server that matches and provides snippets loaded with ‘mini.snippets’. To match with completion engine, use start_lsp_server({ match = false }).\n\n\nManagement\nImportant: Out of the box ‘mini.snippets’ doesn’t load any snippets, it should be done explicitly inside :h MiniSnippets.setup() following :h MiniSnippets.config.\nThe suggested approach to snippet management is to create dedicated files with snippet data and load them through function loaders in config.snippets. See Quickstart for basic (yet capable) snippet management config.\nGeneral idea of supported files is to have at least out of the box experience with common snippet collections. Namely rafamadriz/friendly-snippets.\nThe following files are supported:\n\nExtensions:\n\nRead/decoded as JSON object: *.json, *.code-snippets\nExecuted as Lua file and uses returned value: *.lua\n\nContent:\n\nDict-like: object in JSON; returned table in Lua; no order guarantees.\nArray-like: array in JSON; returned array table in Lua; preserves order.\n\n\nExample of file content with a single snippet:\n\nLua dict-like: return { name = { prefix = 't', body = 'Text' } }\nLua array-like: return { { prefix = 't', body = 'Text', desc = 'name' } }\nJSON dict-like: { \"name\": { \"prefix\": \"t\", \"body\": \"Text\" } }\nJSON array-like: [ { \"prefix\": \"t\", \"body\": \"Text\", \"desc\": \"name\" } ]\n\nGeneral advice:\n\nPut files in “snippets” subdirectory of any path in ‘runtimepath’ (like ‘$XDG_CONFIG_HOME/nvim/snippets/global.json’). This is compatible with :h MiniSnippets.gen_loader.from_runtime() and Quickstart.\nPrefer *.json files with dict-like content if you want more cross platform setup. Otherwise use *.lua files with array-like content.\n\nNotes:\n\nThere is no built-in support for VSCode-like “package.json” files. Define structure manually in :h MiniSnippets.setup() via built-in or custom loaders.\nThere is no built-in support for scope field of snippet data. Snippets are expected to be manually separated into smaller files and loaded on demand.\n\nFor supported snippet syntax see :h MiniSnippets-syntax-specification or Syntax."
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#installation",
    "href": "mini.nvim/readmes/mini-snippets.html#installation",
    "title": "mini.snippets",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.snippets’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.snippets’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.snippets', version = false },\n\n\nStable\n{ 'nvim-mini/mini.snippets', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.snippets'\n\n\nStable\nPlug 'nvim-mini/mini.snippets', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.snippets').setup() with non-empty snippets to have snippets to match from.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#default-config",
    "href": "mini.nvim/readmes/mini-snippets.html#default-config",
    "title": "mini.snippets",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Array of snippets and loaders (see |MiniSnippets.config| for details).\n  -- Nothing is defined by default. Add manually to have snippets to match.\n  snippets = {},\n\n  -- Module mappings. Use `''` (empty string) to disable one.\n  mappings = {\n    -- Expand snippet at cursor position. Created globally in Insert mode.\n    expand = '&lt;C-j&gt;',\n\n    -- Interact with default `expand.insert` session.\n    -- Created for the duration of active session(s)\n    jump_next = '&lt;C-l&gt;',\n    jump_prev = '&lt;C-h&gt;',\n    stop = '&lt;C-c&gt;',\n  },\n\n  -- Functions describing snippet expansion. If `nil`, default values\n  -- are `MiniSnippets.default_&lt;field&gt;()`.\n  expand = {\n    -- Resolve raw config snippets at context\n    prepare = nil,\n    -- Match resolved snippets at cursor position\n    match = nil,\n    -- Possibly choose among matched snippets\n    select = nil,\n    -- Insert selected snippet\n    insert = nil,\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-snippets.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-snippets.html#similar-plugins",
    "title": "mini.snippets",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nL3MON4D3/LuaSnip\nBuilt-in snippet expansion in Neovim&gt;=0.10, see :h vim.snippet (doesn’t provide snippet management, only snippet expansion).\nrafamadriz/friendly-snippets (a curated collection of snippet files)\nabeldekat/cmp-mini-snippets (a source for hrsh7th/nvim-cmp that integrates ‘mini.snippets’)"
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html",
    "href": "mini.nvim/readmes/mini-statusline.html",
    "title": "mini.statusline",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html#demo",
    "href": "mini.nvim/readmes/mini-statusline.html#demo",
    "title": "mini.statusline",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html#features",
    "href": "mini.nvim/readmes/mini-statusline.html#features",
    "title": "mini.statusline",
    "section": "Features",
    "text": "Features\n\nDefine own custom statusline structure for active and inactive windows. This is done with a function which should return string appropriate for |statusline|. Its code should be similar to default one with structure:\n\nCompute string data for every section you want to be displayed.\nCombine them in groups with MiniStatusline.combine_groups().\n\nBuilt-in active mode indicator with colors.\nSections can hide information when window is too narrow (specific window width is configurable per section)."
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html#dependencies",
    "href": "mini.nvim/readmes/mini-statusline.html#dependencies",
    "title": "mini.statusline",
    "section": "Dependencies",
    "text": "Dependencies\nFor full experience needs (still works without any of suggestions):\n\nNerd font and enabled ‘mini.icons’ module to show filetype icons. Can fall back to using nvim-tree/nvim-web-devicons plugin.\nEnabled ‘mini.git’ and ‘mini.diff’ modules to show Git and diff related information. Can fall back to using lewis6991/gitsigns.nvim plugin."
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html#installation",
    "href": "mini.nvim/readmes/mini-statusline.html#installation",
    "title": "mini.statusline",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.statusline’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.statusline’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.statusline', version = false },\n\n\nStable\n{ 'nvim-mini/mini.statusline', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.statusline'\n\n\nStable\nPlug 'nvim-mini/mini.statusline', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.statusline').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html#default-config",
    "href": "mini.nvim/readmes/mini-statusline.html#default-config",
    "title": "mini.statusline",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Content of statusline as functions which return statusline string. See\n  -- `:h statusline` and code of default contents (used instead of `nil`).\n  content = {\n    -- Content for active window\n    active = nil,\n    -- Content for inactive window(s)\n    inactive = nil,\n  },\n\n  -- Whether to use icons by default\n  use_icons = true,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-statusline.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-statusline.html#similar-plugins",
    "title": "mini.statusline",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-lualine/lualine.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html",
    "href": "mini.nvim/readmes/mini-hipatterns.html",
    "title": "mini.hipatterns",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html#demo",
    "href": "mini.nvim/readmes/mini-hipatterns.html#demo",
    "title": "mini.hipatterns",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html#features",
    "href": "mini.nvim/readmes/mini-hipatterns.html#features",
    "title": "mini.hipatterns",
    "section": "Features",
    "text": "Features\n\nHighlight text with configurable patterns and highlight groups (can be string or callable).\nHighlighting is updated asynchronously with configurable debounce delay.\nFunction to get matches in a buffer.\n\nSee :h MiniHipatterns-examples for examples of common use cases.\nNotes:\n\nIt does not define any highlighters by default. Add to config.highlighters to have a visible effect."
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html#example-usage",
    "href": "mini.nvim/readmes/mini-hipatterns.html#example-usage",
    "title": "mini.hipatterns",
    "section": "Example usage",
    "text": "Example usage\nlocal hipatterns = require('mini.hipatterns')\nhipatterns.setup({\n  highlighters = {\n    -- Highlight standalone 'FIXME', 'HACK', 'TODO', 'NOTE'\n    fixme = { pattern = '%f[%w]()FIXME()%f[%W]', group = 'MiniHipatternsFixme' },\n    hack  = { pattern = '%f[%w]()HACK()%f[%W]',  group = 'MiniHipatternsHack'  },\n    todo  = { pattern = '%f[%w]()TODO()%f[%W]',  group = 'MiniHipatternsTodo'  },\n    note  = { pattern = '%f[%w]()NOTE()%f[%W]',  group = 'MiniHipatternsNote'  },\n\n    -- Highlight hex color strings (`#rrggbb`) using that color\n    hex_color = hipatterns.gen_highlighter.hex_color(),\n  },\n})"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html#installation",
    "href": "mini.nvim/readmes/mini-hipatterns.html#installation",
    "title": "mini.hipatterns",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.hipatterns’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.hipatterns’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.hipatterns', version = false },\n\n\nStable\n{ 'nvim-mini/mini.hipatterns', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.hipatterns'\n\n\nStable\nPlug 'nvim-mini/mini.hipatterns', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.hipatterns').setup() with non-empty highlighters to auto-enable highlighting in all normal buffers.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html#default-config",
    "href": "mini.nvim/readmes/mini-hipatterns.html#default-config",
    "title": "mini.hipatterns",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Table with highlighters (see |MiniHipatterns.config| for more details).\n  -- Nothing is defined by default. Add manually for visible effect.\n  highlighters = {},\n\n  -- Delays (in ms) defining asynchronous highlighting process\n  delay = {\n    -- How much to wait for update after every text change\n    text_change = 200,\n\n    -- How much to wait for update after window scroll\n    scroll = 50,\n  },\n\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-hipatterns.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-hipatterns.html#similar-plugins",
    "title": "mini.hipatterns",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nfolke/todo-comments.nvim\nfolke/paint.nvim\nNvChad/nvim-colorizer.lua\nuga-rosa/ccc.nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pairs.html",
    "href": "mini.nvim/readmes/mini-pairs.html",
    "title": "mini.pairs",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pairs.html#demo",
    "href": "mini.nvim/readmes/mini-pairs.html#demo",
    "title": "mini.pairs",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pairs.html#features",
    "href": "mini.nvim/readmes/mini-pairs.html#features",
    "title": "mini.pairs",
    "section": "Features",
    "text": "Features\n\nFunctionality to work with two “paired” characters conditional on cursor’s neighborhood (character to its left and character to its right).\nUsage should be through making appropriate mappings using MiniPairs.map() or in MiniPairs.setup() (for global mapping), MiniPairs.map_buf() (for buffer mapping).\nPairs get automatically registered for special &lt;BS&gt; (all configured modes) and &lt;CR&gt; (only Insert mode) mappings. Pressing the key inside pair will delete whole pair and insert extra blank line inside pair respectively. Note: these mappings are autocreated if they do not override existing ones."
  },
  {
    "objectID": "mini.nvim/readmes/mini-pairs.html#installation",
    "href": "mini.nvim/readmes/mini-pairs.html#installation",
    "title": "mini.pairs",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.pairs’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.pairs’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.pairs', version = false },\n\n\nStable\n{ 'nvim-mini/mini.pairs', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.pairs'\n\n\nStable\nPlug 'nvim-mini/mini.pairs', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.pairs').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-pairs.html#default-config",
    "href": "mini.nvim/readmes/mini-pairs.html#default-config",
    "title": "mini.pairs",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- In which modes mappings from this `config` should be created\n  modes = { insert = true, command = false, terminal = false },\n\n  -- Global mappings. Each right hand side should be a pair information, a\n  -- table with at least these fields (see more in |MiniPairs.map|):\n  -- - &lt;action&gt; - one of 'open', 'close', 'closeopen'.\n  -- - &lt;pair&gt; - two character string for pair to be used.\n  -- By default pair is not inserted after `\\`, quotes are not recognized by\n  -- &lt;CR&gt;, `'` does not insert pair after a letter.\n  -- Only parts of tables can be tweaked (others will use these defaults).\n  mappings = {\n    ['('] = { action = 'open', pair = '()', neigh_pattern = '[^\\\\].' },\n    ['['] = { action = 'open', pair = '[]', neigh_pattern = '[^\\\\].' },\n    ['{'] = { action = 'open', pair = '{}', neigh_pattern = '[^\\\\].' },\n\n    [')'] = { action = 'close', pair = '()', neigh_pattern = '[^\\\\].' },\n    [']'] = { action = 'close', pair = '[]', neigh_pattern = '[^\\\\].' },\n    ['}'] = { action = 'close', pair = '{}', neigh_pattern = '[^\\\\].' },\n\n    ['\"'] = { action = 'closeopen', pair = '\"\"', neigh_pattern = '[^\\\\].', register = { cr = false } },\n    [\"'\"] = { action = 'closeopen', pair = \"''\", neigh_pattern = '[^%a\\\\].', register = { cr = false } },\n    ['`'] = { action = 'closeopen', pair = '``', neigh_pattern = '[^\\\\].', register = { cr = false } },\n  },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-pairs.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-pairs.html#similar-plugins",
    "title": "mini.pairs",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nwindwp/nvim-autopairs\njiangmiao/auto-pairs"
  },
  {
    "objectID": "mini.nvim/readmes/mini-doc.html",
    "href": "mini.nvim/readmes/mini-doc.html",
    "title": "mini.doc",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-doc.html#demo",
    "href": "mini.nvim/readmes/mini-doc.html#demo",
    "title": "mini.doc",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-doc.html#features",
    "href": "mini.nvim/readmes/mini-doc.html#features",
    "title": "mini.doc",
    "section": "Features",
    "text": "Features\n\nKeep documentation next to code by writing EmmyLua-like annotation comments. They will be parsed as is, so formatting should follow built-in guide. However, custom hooks are allowed at many generation stages for more granular management of output help file.\nGeneration is done by processing a set of ordered files line by line. Each line can either be considered as a part of documentation block (if it matches certain configurable pattern) or not (considered to be an “afterline” of documentation block). See MiniDoc.generate() help for more details.\nProcessing is done by using nested data structures (section, block, file, doc) describing certain parts of help file. See MiniDoc-data-structures help page for more details.\nAllow flexible customization of output via hook functions.\nProject specific script can be written as plain Lua file with configuratble path. See MiniDoc.generate() help for more details."
  },
  {
    "objectID": "mini.nvim/readmes/mini-doc.html#installation",
    "href": "mini.nvim/readmes/mini-doc.html#installation",
    "title": "mini.doc",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.doc’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.doc’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.doc', version = false },\n\n\nStable\n{ 'nvim-mini/mini.doc', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.doc'\n\n\nStable\nPlug 'nvim-mini/mini.doc', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.doc').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-doc.html#default-config",
    "href": "mini.nvim/readmes/mini-doc.html#default-config",
    "title": "mini.doc",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Lua string pattern to determine if line has documentation annotation.\n  -- First capture group should describe possible section id. Default value\n  -- means that annotation line should:\n  -- - Start with `---` at first column.\n  -- - Any non-whitespace after `---` will be treated as new section id.\n  -- - Single whitespace at the start of main text will be ignored.\n  annotation_pattern = '^%-%-%-(%S*) ?',\n\n  -- Identifier of block annotation lines until first captured identifier\n  default_section_id = '@text',\n\n  -- Hooks to be applied at certain stage of document life cycle. Should\n  -- modify its input in place (and not return new one).\n  hooks = {\n    -- Applied to block before anything else\n    block_pre = --&lt;function: infers header sections (tag and/or signature)&gt;,\n\n    -- Applied to section before anything else\n    section_pre = --&lt;function: replaces current aliases&gt;,\n\n    -- Applied if section has specified captured id\n    sections = {\n      ['@alias'] = --&lt;function: registers alias in MiniDoc.current.aliases&gt;,\n      ['@class'] = --&lt;function&gt;,\n      -- For most typical usage see |MiniDoc.afterlines_to_code|\n      ['@eval'] = --&lt;function: evaluates lines; replaces with their return&gt;,\n      ['@field'] = --&lt;function&gt;,\n      ['@param'] = --&lt;function&gt;,\n      ['@private'] = --&lt;function: registers block for removal&gt;,\n      ['@return'] = --&lt;function&gt;,\n      ['@seealso'] = --&lt;function&gt;,\n      ['@signature'] = --&lt;function: formats signature of documented object&gt;,\n      ['@tag'] = --&lt;function: turns its line in proper tag lines&gt;,\n      ['@text'] = --&lt;function: purposefully does nothing&gt;,\n      ['@type'] = --&lt;function&gt;,\n      ['@usage'] = --&lt;function&gt;,\n    },\n\n    -- Applied to section after all previous steps\n    section_post = --&lt;function: currently does nothing&gt;,\n\n    -- Applied to block after all previous steps\n    block_post = --&lt;function: does many things&gt;,\n\n    -- Applied to file after all previous steps\n    file = --&lt;function: adds separator&gt;,\n\n    -- Applied to doc after all previous steps\n    doc = --&lt;function: adds modeline&gt;,\n\n    -- Applied before output file is written. Takes lines array as argument.\n    write_pre = --&lt;function: removes delimiters at the top&gt;,\n\n    -- Applied after output help file is written. Takes doc as argument.\n    write_post = --&lt;function: various convenience actions&gt;,\n  },\n\n  -- Path (relative to current directory) to script which handles project\n  -- specific help file generation (like custom input files, hooks, etc.).\n  script_path = 'scripts/minidoc.lua',\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-doc.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-doc.html#similar-plugins",
    "title": "mini.doc",
    "section": "Similar plugins",
    "text": "Similar plugins\n\ntjdevries/tree-sitter-lua\nnumToStr/lemmy-help (command line tool)"
  },
  {
    "objectID": "mini.nvim/readmes/mini-starter.html",
    "href": "mini.nvim/readmes/mini-starter.html",
    "title": "mini.starter",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-starter.html#demo",
    "href": "mini.nvim/readmes/mini-starter.html#demo",
    "title": "mini.starter",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-starter.html#features",
    "href": "mini.nvim/readmes/mini-starter.html#features",
    "title": "mini.starter",
    "section": "Features",
    "text": "Features\n\nAll available actions are defined inside items. There are pre-configured whole sections in MiniStarter.sections.\nConfigure what items are displayed by supplying an array which can be normalized to an array of items. Read about how supplied items are normalized in MiniStarter.refresh().\nModify the final look by supplying content hooks. There are pre-configured content hook generators in MiniStarter.gen_hook.\nChoosing an item can be done in two ways:\n\nType prefix query to filter item by matching its name (ignoring case). Displayed information is updated after every typed character. For every item its unique prefix is highlighted.\nUse Down/Up arrows (or &lt;C-n&gt;/&lt;C-p&gt;, or &lt;M-j&gt;/&lt;M-k&gt;) and hit Enter.\n\nAllow multiple simultaneously open Starter buffers."
  },
  {
    "objectID": "mini.nvim/readmes/mini-starter.html#installation",
    "href": "mini.nvim/readmes/mini-starter.html#installation",
    "title": "mini.starter",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.starter’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.starter’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.starter', version = false },\n\n\nStable\n{ 'nvim-mini/mini.starter', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.starter'\n\n\nStable\nPlug 'nvim-mini/mini.starter', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.starter').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-starter.html#default-config",
    "href": "mini.nvim/readmes/mini-starter.html#default-config",
    "title": "mini.starter",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- Whether to open starter buffer on VimEnter. Not opened if Neovim was\n  -- started with intent to show something else.\n  autoopen = true,\n\n  -- Whether to evaluate action of single active item\n  evaluate_single = false,\n\n  -- Items to be displayed. Should be an array with the following elements:\n  -- - Item: table with &lt;action&gt;, &lt;name&gt;, and &lt;section&gt; keys.\n  -- - Function: should return one of these three categories.\n  -- - Array: elements of these three types (i.e. item, array, function).\n  -- If `nil` (default), default items will be used (see |mini.starter|).\n  items = nil,\n\n  -- Header to be displayed before items. Converted to single string via\n  -- `tostring` (use `\\n` to display several lines). If function, it is\n  -- evaluated first. If `nil` (default), polite greeting will be used.\n  header = nil,\n\n  -- Footer to be displayed after items. Converted to single string via\n  -- `tostring` (use `\\n` to display several lines). If function, it is\n  -- evaluated first. If `nil` (default), default usage help will be shown.\n  footer = nil,\n\n  -- Array  of functions to be applied consecutively to initial content.\n  -- Each function should take and return content for 'Starter' buffer (see\n  -- |mini.starter| and |MiniStarter.content| for more details).\n  content_hooks = nil,\n\n  -- Characters to update query. Each character will have special buffer\n  -- mapping overriding your global ones. Be careful to not add `:` as it\n  -- allows you to go into command mode.\n  query_updaters = 'abcdefghijklmnopqrstuvwxyz0123456789_-.',\n\n  -- Whether to disable showing non-error feedback\n  silent = false,\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-starter.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-starter.html#similar-plugins",
    "title": "mini.starter",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nmhinz/vim-startify\nglepnir/dashboard-nvim\ngoolord/alpha-nvim"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bracketed.html",
    "href": "mini.nvim/readmes/mini-bracketed.html",
    "title": "mini.bracketed",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bracketed.html#demo",
    "href": "mini.nvim/readmes/mini-bracketed.html#demo",
    "title": "mini.bracketed",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bracketed.html#features",
    "href": "mini.nvim/readmes/mini-bracketed.html#features",
    "title": "mini.bracketed",
    "section": "Features",
    "text": "Features\n\nConfigurable Lua functions to go forward/backward to a certain target. Each function can be customized with:\n\nDirection. One of “forward”, “backward”, “first” (forward starting from first one), “last” (backward starting from last one).\nNumber of times to go.\nWhether to wrap on edges (going forward on last one goes to first).\nSome other target specific options.\n\nMappings using square brackets. They are created using configurable target suffix and can be selectively disabled.\nEach mapping supports |[count]|. Mappings are created in Normal mode; for targets which move cursor in current buffer also Visual and Operator-pending (with dot-repeat) modes are supported.\nUsing lower-suffix and upper-suffix (lower and upper case suffix) for a single target the following mappings are created:\n\n[ + upper-suffix : go first.\n[ + lower-suffix : go backward.\n] + lower-suffix : go forward.\n] + upper-suffix : go last.\n\nSupported targets (for more information see help for corresponding Lua function):\n\n\n\nTarget\nMappings\nLua function\n\n\n\n\nBuffer\n[B [b ]b ]B\nMiniBracketed.buffer()\n\n\nComment block\n[C [c ]c ]C\nMiniBracketed.comment()\n\n\nConflict marker\n[X [x ]x ]X\nMiniBracketed.conflict()\n\n\nDiagnostic\n[D [d ]d ]D\nMiniBracketed.diagnostic()\n\n\nFile on disk\n[F [f ]f ]F\nMiniBracketed.file()\n\n\nIndent change\n[I [i ]i ]I\nMiniBracketed.indent()\n\n\nJump from jumplist inside current buffer\n[J [j ]j ]J\nMiniBracketed.jump()\n\n\nLocation from location list\n[L [l ]l ]L\nMiniBracketed.location()\n\n\nOld files\n[O [o ]o ]O\nMiniBracketed.oldfile()\n\n\nQuickfix entry from quickfix list\n[Q [q ]q ]Q\nMiniBracketed.quickfix()\n\n\nTree-sitter node and parents\n[T [t ]t ]T\nMiniBracketed.treesitter()\n\n\nUndo states from specially tracked linear history\n[U [u ]u ]U\nMiniBracketed.undo()\n\n\nWindow in current tab\n[W [w ]w ]W\nMiniBracketed.window()\n\n\nYank selection replacing latest put region\n[Y [y ]y ]Y\nMiniBracketed.yank()\n\n\n\n\nNotes:\n\nThe undo target remaps u and &lt;C-R&gt; keys to register undo state after undo and redo respectively. If this conflicts with your setup, either disable undo target or make your remaps after calling MiniBracketed.setup(). To use undo target, remap your undo/redo keys to call MiniBracketed.register_undo_state() after the action."
  },
  {
    "objectID": "mini.nvim/readmes/mini-bracketed.html#installation",
    "href": "mini.nvim/readmes/mini-bracketed.html#installation",
    "title": "mini.bracketed",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.bracketed’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.bracketed’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.bracketed', version = false },\n\n\nStable\n{ 'nvim-mini/mini.bracketed', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.bracketed'\n\n\nStable\nPlug 'nvim-mini/mini.bracketed', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.bracketed').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-bracketed.html#default-config",
    "href": "mini.nvim/readmes/mini-bracketed.html#default-config",
    "title": "mini.bracketed",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{\n  -- First-level elements are tables describing behavior of a target:\n  --\n  -- - &lt;suffix&gt; - single character suffix. Used after `[` / `]` in mappings.\n  --   For example, with `b` creates `[B`, `[b`, `]b`, `]B` mappings.\n  --   Supply empty string `''` to not create mappings.\n  --\n  -- - &lt;options&gt; - table overriding target options.\n  --\n  -- See [`:h MiniBracketed.config`](../doc/mini-bracketed.qmd#minibracketed.config) for more info.\n\n  buffer     = { suffix = 'b', options = {} },\n  comment    = { suffix = 'c', options = {} },\n  conflict   = { suffix = 'x', options = {} },\n  diagnostic = { suffix = 'd', options = {} },\n  file       = { suffix = 'f', options = {} },\n  indent     = { suffix = 'i', options = {} },\n  jump       = { suffix = 'j', options = {} },\n  location   = { suffix = 'l', options = {} },\n  oldfile    = { suffix = 'o', options = {} },\n  quickfix   = { suffix = 'q', options = {} },\n  treesitter = { suffix = 't', options = {} },\n  undo       = { suffix = 'u', options = {} },\n  window     = { suffix = 'w', options = {} },\n  yank       = { suffix = 'y', options = {} },\n}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-bracketed.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-bracketed.html#similar-plugins",
    "title": "mini.bracketed",
    "section": "Similar plugins",
    "text": "Similar plugins\n\ntpope/vim-unimpaired"
  },
  {
    "objectID": "mini.nvim/readmes/mini-extra.html",
    "href": "mini.nvim/readmes/mini-extra.html",
    "title": "mini.extra",
    "section": "",
    "text": "Generated from the main branch of ‘mini.nvim’"
  },
  {
    "objectID": "mini.nvim/readmes/mini-extra.html#demo",
    "href": "mini.nvim/readmes/mini-extra.html#demo",
    "title": "mini.extra",
    "section": "Demo",
    "text": "Demo\nVideo"
  },
  {
    "objectID": "mini.nvim/readmes/mini-extra.html#features",
    "href": "mini.nvim/readmes/mini-extra.html#features",
    "title": "mini.extra",
    "section": "Features",
    "text": "Features\nExtra useful functionality which is not essential enough for other ‘mini.nvim’ modules to include directly.\nFeatures:\n\nVarious pickers for ‘mini.pick’:\n\nBuilt-in diagnostic (MiniExtra.pickers.diagnostic()).\nFile explorer (MiniExtra.pickers.explorer()).\nGit branches/commits/files/hunks (MiniExtra.pickers.git_hunks(), etc.).\nCommand/search/input history (MiniExtra.pickers.history()).\nLSP references/symbols/etc. (MiniExtra.pickers.lsp()).\nTree-sitter nodes (MiniExtra.pickers.treesitter()).\nAnd much more. See :h MiniExtra.pickers for more.\n\nVarious textobject specifications for ‘mini.ai’. See :h MiniExtra.gen_ai_spec.\nVarious highlighters for ‘mini.hipatterns’. See :h MiniExtra.gen_highlighter.\n\nNotes:\n\nThis module requires only those ‘mini.nvim’ modules which are needed for a particular functionality: ‘mini.pick’ for pickers, etc.\n\nFor more information see these parts of help:\n\n:h MiniExtra.pickers\n:h MiniExtra.gen_ai_spec\n:h MiniExtra.gen_highlighter"
  },
  {
    "objectID": "mini.nvim/readmes/mini-extra.html#installation",
    "href": "mini.nvim/readmes/mini-extra.html#installation",
    "title": "mini.extra",
    "section": "Installation",
    "text": "Installation\nThis plugin can be installed as part of ‘mini.nvim’ library (recommended) or as a standalone Git repository.\nThere are two branches to install from:\n\nmain (default, recommended) will have latest development version of plugin. All changes since last stable release should be perceived as being in beta testing phase (meaning they already passed alpha-testing and are moderately settled).\nstable will be updated only upon releases with code tested during public beta-testing phase in main branch.\n\nHere are code snippets for some common installation methods (use only one):\n\n\nWith mini.deps\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nFollow recommended ‘mini.deps’ installation\n\n\nStable\nFollow recommended ‘mini.deps’ installation\n\n\n\nStandalone plugin:\n\n\n\n\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nadd(‘nvim-mini/mini.extra’)\n\n\nStable\nadd({ source = ‘nvim-mini/mini.extra’, checkout = ‘stable’ })\n\n\n\n\n\n\n\nWith folke/lazy.nvim\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.nvim', version = false },\n\n\nStable\n{ 'nvim-mini/mini.nvim', version = '*' },\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\n{ 'nvim-mini/mini.extra', version = false },\n\n\nStable\n{ 'nvim-mini/mini.extra', version = '*' },\n\n\n\n\n\n\n\nWith junegunn/vim-plug\n\n\n‘mini.nvim’ library:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.nvim'\n\n\nStable\nPlug 'nvim-mini/mini.nvim', { 'branch': 'stable' }\n\n\n\nStandalone plugin:\n\n\n\nBranch\nCode snippet\n\n\n\n\nMain\nPlug 'nvim-mini/mini.extra'\n\n\nStable\nPlug 'nvim-mini/mini.extra', { 'branch': 'stable' }\n\n\n\n\n\nImportant: don’t forget to call require('mini.extra').setup() to enable its functionality.\nNote: if you are on Windows, there might be problems with too long file paths (like error: unable to create file &lt;some file name&gt;: Filename too long). Try doing one of the following:\n\nEnable corresponding git global config value: git config --system core.longpaths true. Then try to reinstall.\nInstall plugin in other place with shorter path."
  },
  {
    "objectID": "mini.nvim/readmes/mini-extra.html#default-config",
    "href": "mini.nvim/readmes/mini-extra.html#default-config",
    "title": "mini.extra",
    "section": "Default config",
    "text": "Default config\n-- No need to copy this inside `setup()`. Will be used automatically.\n{}"
  },
  {
    "objectID": "mini.nvim/readmes/mini-extra.html#similar-plugins",
    "href": "mini.nvim/readmes/mini-extra.html#similar-plugins",
    "title": "mini.extra",
    "section": "Similar plugins",
    "text": "Similar plugins\n\nnvim-telescope/telescope.nvim\nibhagwan/fzf-lua"
  },
  {
    "objectID": "blog/2024-03-28-announce-mini-diff.html",
    "href": "blog/2024-03-28-announce-mini-diff.html",
    "title": "Announcing ‘mini.diff’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nPlease join me in cheering the release of mini.diff - new module of mini.nvim for visualizing difference between buffer and reference text which is updated as you type. It can also be installed using separate GitHub repository.\n\nTL;DR: this is mostly similar to ‘lewis6991/gitsigns.nvim’, but with slight differences:\n\nReference text source is configurable and not tied to Git (although it is used by default). This makes ‘mini.diff’ more flexible and future proof.\nThere is a special overlay view that persistently shows more diff details in text area. For me this became a much better way to review diff than preview_hunk() from ‘gitsigns.nvim’.\nThere are built-in reasonable mappings to work with hunks: apply/reset/textobject/navigate.\n\n\nFor a very long time I hesitated writing ‘gitsigns.nvim’ alternative to be included in ‘mini.nvim’. Mostly because it seemed to be almost impossible to squeeze all the diffing and Git functionality into a reasonably small file (which is a design goal for all ‘mini.nvim’ modules).\nBut after looking at how it is done in ‘gitsigns.nvim’, I realized that it utilizes built-in vim.diff() authored by Lewis Russell (a.k.a lewis6991) himself, and suddenly it became feasible. So I am really grateful for Lewis’s work in core, as without it this module would probably never happen.\n\nFeatures:\n\nVisualize difference between buffer text and its configurable reference interactively (updates as you type). This is done per line showing whether it is inside added, changed, or deleted part of difference (called hunk). Visualization can be with customizable colored signs or line numbers.\nSpecial toggleable overlay view with more hunk details inside text area.\nCompletely configurable per buffer source of reference text used to keep it up to date and define interactions with it. By default uses buffer’s file content in Git index.\nConfigurable mappings to manage diff hunks:\n\nApply and reset hunks inside region (selected visually or with a dot-repeatable operator).\n“Hunk range under cursor” textobject to be used as operator target.\nNavigate to first/previous/next/last hunk.\n\n\nWhat it doesn’t do:\n\nProvide functionality to work directly with Git outside of visualizing and staging (applying) hunks with (default) Git source. In particular, unstaging hunks is not supported.\n\nFor slightly more details, see overview in README.\nFor even more information, see these tags in help file:\n\n*MiniDiff-source-specification*\n*MiniDiff-hunk-specification*\n*MiniDiff-diff-summary*\n\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-10-30-announce-dual-distribution.html",
    "href": "blog/2022-10-30-announce-dual-distribution.html",
    "title": "‘mini.nvim’ now has dual distribution model",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nFor more than a year I’ve been developing a mini.nvim plugin - library of 20+ independent Lua modules improving overall Neovim experience with minimal effort. Each one can be used separately without any startup and usage overhead. In this post I am announcing its dual distribution: both as current “bundle” and standalone plugins for each module.\nInitial motivation behind ‘mini.nvim’ was to share with community a set of small-ish modules which I had developed for myself in spare time for fun. As almost each module initially was mediocre compared to analogues, to gain visibility I had come up with the idea of bundling them together in one “traditional” plugin and ship them as a single Git repository. It kind of worked and in slightly more than a year since initial announcement it hit 1000 GitHub stars, for which I am super grateful! This was only possible with your support and contributions. Thank you!\nHowever, although this “bundle” approach fulfilled (and keeps fulfilling) its purposes, it also immediately got criticised with some legitimate arguments (albeit personally sometimes a little far-fetched). So in the back of my head I kept thinking about addressing this in a way that would make me comfortable continuing improving ‘mini.nvim’. And I think the dual distribution model is the solution here.\nIn a nutshell, ‘mini.nvim’ will continue its development as before, but at the same time each module will also be distributed as a standalone plugin. This will be done by running a script (first manually; then, hopefully, automatically) which inside each standalone plugin will duplicate ‘mini.nvim’ Git commits relevant to the plugin. This way history of all incremental changes will be preserved. As a slight bonus, each plugin is super lightweight as they come only with the files necessary for their distribution (no testing infrastructure, etc.).\nConsider standalone plugins only as an alternative distribution of ‘mini.nvim’ modules. All issues, PRs and other user interaction will be done in ‘mini.nvim’ repo (mostly because all testing infrastructure is set up there).\nSo please welcome 22 new standalone plugins:\n\n\n\nPlugin name and link\nShort description\n\n\n\n\nmini.ai\nExtend and create a/i textobjects\n\n\nmini.align\nAlign text interactively\n\n\nmini.base16\nBase16 colorscheme creation\n\n\nmini.bufremove\nRemove buffers\n\n\nmini.comment\nFast and familiar per-line comment\n\n\nmini.completion\nCompletion and signature help\n\n\nmini.cursorword\nAutohighlight word under cursor\n\n\nmini.doc\nGenerate Neovim help files\n\n\nmini.fuzzy\nFuzzy matching\n\n\nmini.indentscope\nVisualize and operate on indent scope\n\n\nmini.jump\nJump forward/backward to a single character\n\n\nmini.jump2d\nJump within visible lines\n\n\nmini.map\nWindow with buffer text overview\n\n\nmini.misc\nMiscellaneous useful functions\n\n\nmini.pairs\nAutopairs\n\n\nmini.sessions\nSession management\n\n\nmini.starter\nFast and flexible start screen\n\n\nmini.statusline\nStatusline\n\n\nmini.surround\nFast and feature-rich surround actions\n\n\nmini.tabline\nTabline\n\n\nmini.test\nTest Neovim plugins\n\n\nmini.trailspace\nWork with trailing whitespace\n\n\n\nIf you are looking where to start, I am particularly proud of ‘mini.ai’, ‘mini.align’, ‘mini.indentscope’, ‘mini.starter’, and ‘mini.surround’. For Neovim plugin authors I can not recommend enough ‘mini.doc’ and ‘mini.test’, they were life changers for my workflow.\nIf you find my work useful, please leave GitHub star for ‘mini.nvim’ itself and/or for its standalone plugins. Or simply share this news so that more people are aware of it. This really motivates my work on ‘mini.nvim’. I am looking forward to implementing some really interesting I have. Thanks!"
  },
  {
    "objectID": "blog/2023-11-17-release-0110.html",
    "href": "blog/2023-11-17-release-0110.html",
    "title": "Release 0.11.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nToday is the day to update mini.nvim to version 0.11.0. It includes two big plugins coming out of beta-testing and many small updates to other modules as a result of backlog cleanup.\nHere is a full release description if you are curious.\n\nTwo new modules are about making a performant picker with minimal UI and a lot of preconfigured pickers:\n\nmini.pick - pick anything. A general picker as alternative to Telescope and Fzf-Lua. Both of these plugins are great, but I wanted to have a slightly different UI and UX: a one window design with on demand preview. I am daily driving it for about two and a half months now and don’t miss anything. Here is a link to the announcement.\nmini.extra - extra functionality for ‘mini.nvim’ modules. Its main goal is mostly to contain 20+ preconfigured pickers for ‘mini.pick’ (like for built-in diagnostic, LSP, Neovim histories, etc.) and several textobject specifications for ‘mini.ai’ (line, buffer, indent, etc.), while still allowing more diverse functionality in the future. Here is a link to the announcement.\n\n\n‘mini.hipatterns’ got a substantial update:\n\nHighlighter can now have an array of patterns to highlight, not just a single one.\nHighlighter can now define more general extmark_opts. This allows highlighting not only with single highlight group over the matched range, but adding virtual text (like covering some sensitive words with x), highlighting whole line of the match, add sign, etc.\nBuilt-in hex color highlighter now can highlight using inline extmarks (so that colored symbols appear to the left of the color and not over it). But only on Neovim&gt;=0.10.\nThere is a new get_matches() function to get current matches with their positions. This powers the pickers.hipatterns picker form ‘mini.extra’.\n\n\nThere are also small-ish feature updates for ‘mini.bufremove’, ‘mini.clue’, ‘mini.comment’, ‘mini.completion’, ‘mini.files’, ‘mini.map’, ‘mini.misc’, ‘mini.starter’, and ‘mini.test’.\n\nOn another note, ‘mini.nvim’ just passed the 3000 GitHub stars mark. Thank you all for continuous support. I love you 3000!\nThanks for reading! Hope to see you in the next module release!"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "Order By\n      Default\n      \n        project\n      \n      \n        website\n      \n      \n        format\n      \n      \n        brand\n      \n      \n        execute\n      \n      \n        language\n      \n      \n        Title\n      \n      \n        Author\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Categories\n      \n      \n        Description\n      \n      \n        path\n      \n      \n        outputHref\n      \n      \n        Modified - Oldest\n      \n      \n        Modified - Newest\n      \n      \n        File Name\n      \n      \n        Modified - Oldest\n      \n      \n        Modified - Newest\n      \n      \n        Reading Time (Low to High)\n      \n      \n        Reading Time (High to Low)\n      \n      \n        Word Count (Low to High)\n      \n      \n        Word Count (High to Low)\n      \n    \n  \n    \n      \n      \n    \n\n\n\n  \n    \n      Release 0.17.0\n    \n    \n      2025-12-18 Evgeni Chasnovski\n      \n        release\n      \n    \n    \n      Command line tweaks, move to a GitHub org, new website, and a ton of module updates\n    \n  \n\n  \n    \n      Announcing 'mini.cmdline'\n    \n    \n      2025-12-07 Evgeni Chasnovski\n      \n        announce\n      \n    \n    \n      Command line tweaks: autocompletion, autocorrection, autopeek range\n    \n  \n\n  \n    \n      MiniMax - Neovim with maximum MINI\n    \n    \n      2025-10-13 Evgeni Chasnovski\n      \n        announce\n      \n    \n    \n      MiniMax is a collection of fully working self-contained Neovim configs. Each uses mostly MINI.\n    \n  \n\n  \n    \n      MINI now has its own site\n    \n    \n      2025-10-03 Evgeni Chasnovski\n      \n        announce\n      \n    \n    \n      Dedicated domain, own blog, generated documentation\n    \n  \n\n  \n    \n      New color schemes\n    \n    \n      2025-07-10 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Four seasons: miniwinter, minispring, minisummer, miniautumn\n    \n  \n\n  \n    \n      Release 0.16.0\n    \n    \n      2025-05-20 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Smart mappings, better autocompletion, and many small improvements\n    \n  \n\n  \n    \n      Announcing 'mini.keymap'\n    \n    \n      2025-05-03 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Make special key mappings: multi-step actions (like \"smart\" tab, shift-tab, enter, backspace) and combos (more general \"better escape\" like behavior)\n    \n  \n\n  \n    \n      Updates of 'mini.completion': snippet support (finally)\n    \n    \n      2025-03-07 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      Plus many small improvements like scrolling and better highlighting in info/signature windows, and more.\n    \n  \n\n  \n    \n      Release 0.15.0\n    \n    \n      2025-01-30 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Snippets plus various features here and there\n    \n  \n\n  \n    \n      Announcing 'mini.snippets'\n    \n    \n      2024-12-23 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Manage and expand snippets. LSP snippet syntax, flexible loaders, fuzzy prefix matching, interactive snippet session with rich visualization, and more\n    \n  \n\n  \n    \n      Release 0.14.0\n    \n    \n      2024-09-26 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Icons... icons everywhere... plus a lot of small features and maintaining\n    \n  \n\n  \n    \n      Updates of 'mini.files': bookmarks\n    \n    \n      2024-09-03 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      Also better file manipulation, prettier confirmation info, and more\n    \n  \n\n  \n    \n      Announcing 'mini.icons'\n    \n    \n      2024-07-03 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      General icon provider. Several categories (file, directory, OS, LSP, etc.) and styles, better blending with color scheme, and more\n    \n  \n\n  \n    \n      Release 0.13.0\n    \n    \n      2024-06-13 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Two new modules, visible updates to 'mini.comment' and 'mini.statusline'\n    \n  \n\n  \n    \n      Announcing 'mini.git'\n    \n    \n      2024-05-21 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Git integration with tracking Git-related data, `:Git` command, and interactive Git history inspection\n    \n  \n\n  \n    \n      Announcing 'mini.diff'\n    \n    \n      2024-03-28 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Work with diff hunks. Interactively visualize difference between current and reference text\n    \n  \n\n  \n    \n      Release 0.12.0\n    \n    \n      2024-02-29 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Three new modules, a few updates to already present ones\n    \n  \n\n  \n    \n      Announcing 'mini.deps'\n    \n    \n      2024-02-11 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Plugin manager with minimal yet sufficient user experience\n    \n  \n\n  \n    \n      Announcing 'mini.notify'\n    \n    \n      2024-01-04 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Show notifications. A `vim.notify()` maker plus automated LSP progress notifications\n    \n  \n\n  \n    \n      Announcing 'mini.visits'\n    \n    \n      2023-11-28 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Track and reuse file system visits. Basically, parts of 'telescope-frecency.nvim' combined with parts of 'harpoon.nvim'\n    \n  \n\n  \n    \n      Release 0.11.0\n    \n    \n      2023-11-17 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      New fuzzy picker in town, major hipatterns update, and many more\n    \n  \n\n  \n    \n      Announcing 'mini.extra'\n    \n    \n      2023-11-02 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Extra 'mini.nvim' functionality. Many pickers for 'mini.pick', textobjects for 'mini.ai', and more\n    \n  \n\n  \n    \n      Announcing 'mini.pick'\n    \n    \n      2023-10-13 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Pick anything. Interactive non-blocking picker with one window design, toggleable preview, fast default matching, built-in pickers, and more\n    \n  \n\n  \n    \n      Release 0.10.0\n    \n    \n      2023-09-05 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Files, clue, operators, and minor updates\n    \n  \n\n  \n    \n      Announcing 'mini.operators'\n    \n    \n      2023-08-15 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Text edit operators: replace, exchange, multiply, sort, evaluate; with count and dot-repeat support\n    \n  \n\n  \n    \n      Announcing 'mini.clue'\n    \n    \n      2023-08-01 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Show next key clues. Basically a 'which-key' + 'hydra' combo with different UI, implementation, and configuration\n    \n  \n\n  \n    \n      Updates of 'mini.files': file preview\n    \n    \n      2023-07-04 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      Also prefix customization, change target window, and more\n    \n  \n\n  \n    \n      Announcing 'mini.files'\n    \n    \n      2023-06-22 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Navigate and manipulate file system (with column view and editing text)\n    \n  \n\n  \n    \n      Release 0.9.0\n    \n    \n      2023-06-08 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Colors, comments, and maintenance\n    \n  \n\n  \n    \n      Announcing 'mini.hipatterns'\n    \n    \n      2023-05-25 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Highlight patterns in text\n    \n  \n\n  \n    \n      Announcing 'mini.hues'\n    \n    \n      2023-05-07 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Generate configurable color scheme (plus 'randomhue' color scheme with random base colors)\n    \n  \n\n  \n    \n      Announcing 'mini.colors'\n    \n    \n      2023-04-16 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Tweak and save any color scheme (plus animate transition and convert between some color spaces)\n    \n  \n\n  \n    \n      Release 0.8.0\n    \n    \n      2023-04-02 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Two new modules, 'mini.comment' and 'mini.jump2d' updates\n    \n  \n\n  \n    \n      Announcing 'mini.splitjoin'\n    \n    \n      2023-03-09 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Split and join arguments\n    \n  \n\n  \n    \n      Announcing 'mini.bracketed'\n    \n    \n      2023-02-21 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Go forward/backward with square brackets (like 'tpope/vim-unimpaired' but in configurable Lua and with *much more targets*)\n    \n  \n\n  \n    \n      Release 0.7.0\n    \n    \n      2023-02-12 Evgeni Chasnovski\n      \n        release\n      \n        reddit\n      \n    \n    \n      Three new modules, some breaking changes, many new features\n    \n  \n\n  \n    \n      Announcing 'mini.basics'\n    \n    \n      2023-01-29 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Common configuration presets for options/mappings/autocommands\n    \n  \n\n  \n    \n      Announcing 'mini.move'\n    \n    \n      2023-01-15 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Move any selection in any direction\n    \n  \n\n  \n    \n      Announcing 'mini.animate'\n    \n    \n      2022-12-22 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Animate common Neovim actions (cursor movement, scroll, resize, window open/close)\n    \n  \n\n  \n    \n      'mini.nvim' now has dual distribution model\n    \n    \n      2022-10-30 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Welcome 22 new standalone plugins!\n    \n  \n\n  \n    \n      Announcing 'mini.map'\n    \n    \n      2022-10-11 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Window with buffer text overview, scrollbar, and highlights\n    \n  \n\n  \n    \n      Announcing 'mini.align'\n    \n    \n      2022-09-22 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Align text interactively (like 'vim-easy-align', but in Lua and slightly different mechanics)\n    \n  \n\n  \n    \n      Updates of 'mini.surround': tree-sitter support and more\n    \n    \n      2022-08-28 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      Tree-sitter support, \"last\"/\"next\" extended mappings, aliases, and more\n    \n  \n\n  \n    \n      Update of 'mini.base16' and a new minicyan color scheme\n    \n    \n      2022-08-19 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      25 new plugin integrations in 'mini.base16' plus 'minicyan' colorscheme\n    \n  \n\n  \n    \n      Update of 'mini.ai'\n    \n    \n      2022-08-07 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      Now supports textobjects based on tree-sitter\n    \n  \n\n  \n    \n      Announcing 'mini.ai'\n    \n    \n      2022-07-28 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Extend and create a/i textobjects (like 'targets.vim', but in Lua and a bit different)\n    \n  \n\n  \n    \n      Announcing 'mini.test'\n    \n    \n      2022-07-01 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Test Neovim plugins with parametrization, screen tests, and more\n    \n  \n\n  \n    \n      Announcing 'mini.jump2d'\n    \n    \n      2022-05-06 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Jump to customizable spots within visible lines\n    \n  \n\n  \n    \n      Updates of 'mini.surround': custom surroundings\n    \n    \n      2022-04-20 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      New features like custom surroundings and search method\n    \n  \n\n  \n    \n      Announcing 'mini.indentscope'\n    \n    \n      2022-02-10 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Visualize and operate on indent scope\n    \n  \n\n  \n    \n      Announcing 'mini.doc'\n    \n    \n      2022-01-20 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Generate help files from EmmyLua-like annotations\n    \n  \n\n  \n    \n      Updates of 'mini.nvim'\n    \n    \n      2021-11-16 Evgeni Chasnovski\n      \n        update\n      \n        reddit\n      \n    \n    \n      Version 0.1.0; call for beta-testing new modules ('sessions', 'starter', 'jump') before 0.2.0\n    \n  \n\n  \n    \n      Announcing 'mini.nvim'\n    \n    \n      2021-10-13 Evgeni Chasnovski\n      \n        announce\n      \n        reddit\n      \n    \n    \n      Collection of minimal, independent, and fast Lua modules\n    \n  \n\n\nNo matching items"
  },
  {
    "objectID": "blog/2023-08-15-announce-mini-operators.html",
    "href": "blog/2023-08-15-announce-mini-operators.html",
    "title": "Announcing ‘mini.operators’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am overjoyed to release mini.operators - new module of mini.nvim with various text edit operators. It can also be installed using separate GitHub repository.\n\nInitially I planned to do a ‘mini.exchange’ module for only “exchange” operator. After exploration of other useful operators, I got a little excited with possibilities. As they all mostly fit into “various text edit operators” category, I decided to upgrade my plans to include more operators.\nAt first, some of them didn’t seem that useful, but continuous practice unveiled interesting minor “quality of life” improvements in frequent mundane tasks:\n\nDot-repeatability of “replace” operator really adds up for several quick replacements.\nHitting grr/gmm to replace/multiply current line feels more ergonomic than VP/yyp. Plus they reuse current indent (which often saves extra keystrokes) and don’t affect \" register.\n“Evaluate” operator is really useful for exploring some big Lua object inside a buffer and is slightly quicker to use than put_text() from ‘mini.misc’.\n\n\nHere are main features of ‘mini.operators’:\n\nOperators:\n\nEvaluate text and replace with output.\nExchange text regions.\nMultiply (duplicate) text.\nReplace text with register.\nSort text.\n\nAutomated configurable mappings to operate on textobject, line, selection. Can be disabled in favor of more control with MiniOperators.make_mappings().\nAll operators support [count] and dot-repeat.\n\nSee MiniOperators-overview and MiniOperators.config for more details.\nFor full documentation see help file.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-08-07-update-mini-ai-tree-sitter.html",
    "href": "blog/2022-08-07-update-mini-ai-tree-sitter.html",
    "title": "Update of ‘mini.ai’",
    "section": "",
    "text": "Originally posted on Reddit\n\n‘mini.ai’ is a module of ‘mini.nvim’ plugin for extending and creating a/i textobjects (like in di( or va\"). You can see more info in the announcement and help file.\nNow it has support for tree-sitter specifications via exported MiniAI.gen_spec.treesitter() function. In order for this to work, user should have ‘textobjects’ query files with specified captures for every target language. Can have them either by just installing ‘nvim-treesitter/nvim-treesitter-textobjects’ (but not enabling textobjects) or creating manually inside ‘after/queries/&lt;language&gt;/textobjects.scm’ files.\nYou can see here a detailed comparison between ‘mini.ai’ and ‘nvim-treesitter-textobjects’. In short: ‘nvim-treesitter-textobjects’ ships with queries while ‘mini.ai’ doesn’t; ‘mini.ai’ supports v:count, different search methods, consecutive application (incremental selection of same textobjects), and next/last textobject variations while ‘nvim-treesitter-textobjects’ doesn’t.\nAlthough the main purpose of ‘mini.ai’ is to create plain text textobjects which are useful most of the times (brackets, quotes, underscores, etc), it was designed to allow extensions via Lua functions. After a bit of beta-testing, Oliver Leete made a great suggestion about a minimal change in API to enable very convenient textobject specifications. Thanks to that, now it is possible.\nEdit: thanks to suggestion, latest main branch now supports array of captures instead of a single capture. So users can define something like MiniAi.gen_spec.treesitter({ a = { '@conditional.outer', '@loop.outer' }, i = { '@conditional.inner', '@loop.inner' } }) (it will pick best region among all supplied matches)."
  },
  {
    "objectID": "blog/2023-05-25-announce-mini-hipatterns.html",
    "href": "blog/2023-05-25-announce-mini-hipatterns.html",
    "title": "Announcing ‘mini.hipatterns’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am excited to announce the release of mini.hipatterns - new module of mini.nvim to highlight patterns in text. It can also be installed using separate GitHub repository.\n\nThis type of module did not have a high priority in my TODO list as I was pretty happy to use both folke/todo-comments.nvim and norcalli/nvim-colorizer.lua. But having just written mini.colors and mini.hues I thought it would be fun to make a future 0.9.0 release mostly about colors. Besides, it will replace in my config two plugins with one module, which I always enjoy.\nI am also extra proud to note that this is a module number 30 of ‘mini.nvim’. I didn’t even imagine when I first started writing functioning Lua modules (around two years ago) that it will go this far. Yet here we are. I really hope more will come (it is definitely planned). Huge thanks to everyone using my work and spreading the word. It means a world to me during these tough times!\n\nHere are the features of ‘mini.hipatterns’:\n\nHighlight text with configurable patterns and highlight groups (can be string or callable).\nHighlighting is updated asynchronously with configurable debounce delay.\n\nFor more information, see help file. See this part for examples of common use cases.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-09-22-announce-mini-align.html",
    "href": "blog/2022-09-22-announce-mini-align.html",
    "title": "Announcing ‘mini.align’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am happy to announce the release of mini.align - module of mini.nvim for aligning text interactively (with or without live preview). This is mostly designed after junegunn/vim-easy-align, but is implemented in Lua and has slightly different alignment specification and user interaction lifecycle.\nFeatures:\n\nAlignment is done in three main steps:\n\nSplit lines into parts based on Lua pattern(s) or user-supplied rule.\nJustify parts for certain side(s) to be same width inside columns.\nMerge parts to be lines, with customizable delimiter(s).\n\nEach main step can be preceded by other steps (pre-steps) to achieve highly customizable outcome.\nUser can control alignment interactively by pressing customizable modifiers (single keys representing how alignment steps and/or options should change). Some of default modifiers:\n\nPress s to enter split Lua pattern.\nPress j to choose justification side from available ones (“left”, “center”, “right”, “none”).\nPress m to enter merge delimiter.\nPress f to enter filter Lua expression to configure which parts will be affected (like “align only first column”).\nPress i to ignore some commonly unwanted split matches.\nPress p to pair neighboring parts so they be aligned together.\nPress t to trim whitespace from parts.\nPress &lt;BS&gt; (backspace) to delete some last pre-step.\n\nAlignment can be done with instant preview (result is updated after each modifier) or without it (result is shown and accepted after non-default split pattern is set).\nEvery user interaction is accompanied with helper status message showing relevant information about current alignment process.\n\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue. Thanks!"
  },
  {
    "objectID": "blog/2021-10-13-announce-mini-nvim.html",
    "href": "blog/2021-10-13-announce-mini-nvim.html",
    "title": "Announcing ‘mini.nvim’",
    "section": "",
    "text": "Originally posted on Reddit\nHello people!\nI would like to introduce you to my Neovim plugin: mini.nvim. Basically, this is a collection of Lua modules each of which can be considered as a separate sub-plugin (meaning you don’t have to use all modules, any number of them will do). This has lived for a very long time in my dotfiles, and I finally decided to share it with the world. Initial idea was to create custom targeted functionality (relatively balanced in terms of number of features and code/support) to fully own my Neovim config. As a side effect, it lead to reducing number of used plugins and to having much fun (when things worked :) ).\nCurrently it has the following modules:\n\nmini.base16 - fast implementation of base16 theme for manually supplied palette. Has unique palette generator which needs only background and foreground colors.\nmini.bufremove - buffer removing (unshow, delete, wipeout) while saving window layout.\nmini.comment - fast and familiar per-line code commenting.\nmini.completion - async (with customizable ‘debounce’ delay) ‘two-stage chain completion’: first builtin LSP, then configurable fallback. Also has functionality for completion item info and function signature (both in floating window appearing after customizable delay).\nmini.cursorword - automatic highlighting of word under cursor (displayed after customizable delay).\nmini.fuzzy - functions for fast and simple fuzzy matching. It has not only functions to perform fuzzy matching of one string to others, but also a sorter for telescope.nvim.\nmini.misc - collection of miscellaneous useful functions. Like put() and put_text() which print Lua objects to command line and current buffer respectively.\nmini.pairs - autopairs plugin which has minimal defaults and functionality to do per-key expression mappings.\nmini.statusline - minimal and fast statusline. Has ability to use custom content supplied with concise function (using module’s provided section functions) along with builtin default. For full experience needs dependencies, but works without any of them.\nmini.surround - fast surround plugin. Add, delete, replace, find, highlight surrounding (like pair of parenthesis, quotes, etc.). Has special “function call”, “tag”, and “interactive” surroundings. Supports dot-repeatability, textobject, motions.\nmini.tabline - minimal tabline which shows listed buffers in case of one tab and falls back to default otherwise. For full experience needs dependencies, but works without any of them.\nmini.trailspace - automatic highlighting of trailing whitespace with functionality to remove it.\n\nThis currently was tested only on Linux inside clean and my full Neovim setup, but I think it should work on other platforms. There might be some period of turbulence after this post (maybe I missed something obvious), but all current functionality looks pretty stable.\nHope you’ll like it :) Any feedback is highly appreciated."
  },
  {
    "objectID": "blog/2023-06-22-announce-mini-files.html",
    "href": "blog/2023-06-22-announce-mini-files.html",
    "title": "Announcing ‘mini.files’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am thrilled to tell you about the release of mini.files - new module of mini.nvim to navigate and manipulate file system. It can also be installed using separate GitHub repository.\n\nWriting a file explorer for Neovim was a dream goal of mine for almost a couple of years now. But I didn’t have any interesting ideas while popular alternatives worked OK. Until about a month ago a thought came to me: how about a combination of a column view for file navigation and a great approach of “manipulate files by editing text” (as in stevearc/oil.nvim)? And thus (after a full bucket of sweat and tears) the ‘mini.files’ module now starts the fourth decade of ‘mini.nvim’ modules.\n\nHere are main features of ‘mini.files’:\n\nNavigate file system using column view (Miller columns) to display nested directories. See *MiniFiles-navigation* tag in help file for overview.\nManipulate files and directories by editing text buffers: create, delete, copy, rename, move. See *MiniFiles-manipulation* tag in help file for overview.\nUse as default file explorer instead of netrw.\nConfigurable:\n\nFilter/sort of file system entries.\nMappings used for common explorer actions.\nUI options: whether to show preview of directory under cursor, etc.\n\n\nSee “Quick start” section of README for some quick start.\nSee *MiniFiles-examples* tag in help file for some common configuration examples.\nNotes:\n\nThis module is written and thoroughly tested on Linux. Support for other platform/OS (like Windows or MacOS) is a goal, but there is no guarantee.\nWorks on all supported versions but using Neovim&gt;=0.9 is recommended.\n\nFor more information, see help file.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-04-20-update-mini-surround-custom-surroundings.html",
    "href": "blog/2022-04-20-update-mini-surround-custom-surroundings.html",
    "title": "Updates of ‘mini.surround’: custom surroundings",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nI would like to share with you two new features of ‘mini.surround’, which is one of the many modules of my ‘mini.nvim’ plugin. It is a module for working with text surrounding (think Lua implementation of ‘tpope/vim-surround’ or ‘machakann/vim-sandwich’ but with additional features). It supports add, delete, replace, find, and highlight surrounding. All of this is dot-repeatable and has extra builtin surroundings: ‘function call’, ‘tag’ and ‘interactive’ (prompts user to enter parts). And now it also has two big new features."
  },
  {
    "objectID": "blog/2022-04-20-update-mini-surround-custom-surroundings.html#custom-surroundings",
    "href": "blog/2022-04-20-update-mini-surround-custom-surroundings.html#custom-surroundings",
    "title": "Updates of ‘mini.surround’: custom surroundings",
    "section": "Custom surroundings",
    "text": "Custom surroundings\nYou can define your own or modify existing surrounding with config.custom_surroundings. This way user can extend setup to meet their needs, like adding brackets with spaces, custom surrounding for Latex command or Lua long brackets ([[...]]), etc. Here is an example:\nrequire('mini.surround').setup({\n  custom_surroundings = {\n    -- Lua long brackets\n    s = {\n      -- Configuration for \"input\" (like for delete) is done with Lua patterns\n      input = { find = '%[%[.-%]%]', extract = '^(..).*(..)$' },\n      -- Configuration for \"output\" (like for add) is done with plain text\n      output = { left = '[[', right = ']]' },\n    },\n    -- Use `(` to insert with spaces, `)` will still add without them\n    ['('] = { output = { left = '( ', right = ' )' } },\n  },\n})\nSo now, for example, typing sds (sd - ‘surround delete’, s - identifier of custom surrounding) will search for Lua’s long bracket and delete it. See documentation for more information."
  },
  {
    "objectID": "blog/2022-04-20-update-mini-surround-custom-surroundings.html#search-method",
    "href": "blog/2022-04-20-update-mini-surround-custom-surroundings.html#search-method",
    "title": "Updates of ‘mini.surround’: custom surroundings",
    "section": "Search method",
    "text": "Search method\nBefore this feature, ‘mini.surround’ searched only for “covering” surrounding: left part is before cursor, right part - after. Now this behavior is customizable with config.search_method option. So, for example, with its value 'cover_or_next' you can type sd) in the beginning of line aaa (bbb) and it will edit like aaa bbb. Available methods are a more or less simplified version of how ‘wellle/targets.vim’ does it. See documentation for more information.\n\nBoth of these features were long overdue, but I didn’t want to interfere with code much as there are many edge cases. Now that I’ve pulled myself together and written automated tests, it feels much safer to do so.\nPlease, try this out and tell me what you think!"
  },
  {
    "objectID": "blog/2023-04-02-release-080.html",
    "href": "blog/2023-04-02-release-080.html",
    "title": "Release 0.8.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nI am here to tell you about version 0.8.0 release of mini.nvim. It is mostly about two new modules and cleaning up issue backlog (both issues and feature requests).\nHere is a full release description if you are curious, while I’ll mention the most prominent ones here.\n\nTwo new modules came out of beta-testing:\n\nmini.bracketed - Go forward/backward with square brackets. It is virtually a ‘tpope/vim-unimpaired’ Lua evolution with much more capabilities. This one feels to me like having the cleanest API design of all ‘mini.nvim’ modules up to date.\nmini.splitjoin - Split and join arguments.\n\n\nThere is a new design principle of silencing module’s non-error feedback. All modules which can do that (like ‘mini.ai’, ‘mini.jump2d’, ‘mini.surround’) now have config.silent option.\n\n‘mini.comment’ got quite substantial update allowing more customization. Users can now control whether to:\n\nRecognize as comment only lines without indent.\nIgnore blank lines.\nEnsure single space pad for comment leaders.\n\n\n‘mini.jump2d’ got also some customization options. User now can control:\n\nHow many label steps ahead to show.\nWhether to dim lines with at least one jump spot.\nHighlighting of spots with unique label for next step.\n\nIt is now visually on par with phaazon/hop.nvim while also having several differences (most are matter of taste, but to me seem more natural). Demo is also updated showing these new capabilities.\n\n‘mini.surround’ now can be configured to respect selection type when adding and deleting surroundings. For example, adding surroundings to linewise visual selection places them on separate lines while indenting selection once.\n\nIf you were waiting for new modules to come out of beta-testing or just curious to try new features, this is the time to do it!\nThanks for reading!"
  },
  {
    "objectID": "blog/2023-11-02-announce-mini-extra.html",
    "href": "blog/2023-11-02-announce-mini-extra.html",
    "title": "Announcing ‘mini.extra’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nToday I would like to tell you about the release of mini.extra - new module of mini.nvim. It can also be installed using separate GitHub repository.\nHere is a link to the video demo.\n\nThis is basically meant as a collection of functionality which is not essential enough for other ‘mini.nvim’ modules to include directly.\nRight now it mostly consists from many (20, to be exact) pre-built pickers for mini.pick plus some ‘mini.ai’ textobjects and ‘mini.hipatterns’ highlighters. But there might be more functionality and for other modules in the future.\n\nFeatures:\n\nVarious pickers for ‘mini.pick’:\n\nBuilt-in diagnostic (*MiniExtra.pickers.diagnostic()*).\nFile explorer (*MiniExtra.pickers.explorer()*).\nGit branches/commits/files/hunks (*MiniExtra.pickers.git_hunks()*, etc.).\nCommand/search/input history (*MiniExtra.pickers.history()*).\nLSP references/symbols/etc. (*MiniExtra.pickers.lsp()*).\nTreesitter nodes (*MiniExtra.pickers.treesitter()*).\nAnd much more.\n\nSee *MiniExtra.pickers* help tag for more.\nVarious textobject specifications for ‘mini.ai’. See *MiniExtra.gen_ai_spec* help tag.\nVarious highlighters for ‘mini.hipatterns’. See *MiniExtra.gen_highlighter* help tag.\n\nNotes: - This module requires only those ‘mini.nvim’ modules which are needed for a particular functionality: ‘mini.pick’ for pickers, etc.\nFor full documentation see help file.\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2025-01-30-release-0150.html",
    "href": "blog/2025-01-30-release-0150.html",
    "title": "Release 0.15.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nThe mini.nvim plugin has released a new 0.15.0 version. It has been a bit more than four months and 168 commits since the latest release, so the new one is long overdue. Here is a full release description if you are curious.\n\nThe main new feature is that one (big and important) module is coming out of beta-testing:\n\nmini.snippets - manage and expand snippets. It is a minimal yet feature-rich way of managing snippets combined with own implementation of LSP snippet parsing/insert. You can read more in this release post.\n\nIt proved to be one of the most tasking module to write, for various reasons. But we’ve overcome this :)\n\nThe rest of release cycle I wanted to dedicate to adding snippet support to ‘mini.completion’ (including ‘mini.snippets’ integration through in-process LSP server) and overall backlog cleaning. The cleaning is taking too long (for again various reasons) and is not even finished yet. So I decided to make a release now (especially with so much time after the previous one) and improve ‘mini.completion’ later.\nA lot of existing plugins got new updates. Here are the highlights:\n\n‘mini.files’ confirm approach was updated:\n\nSynchronization can now be canceled (instead of only skipping applying file system actions). This will return to the explorer’s state as it was prior to sync start.\nClosing explorer now asks for confirmation only if there are pending file system actions (and not just modified buffers).\n\n‘mini.hues’ has two more saturation levels: 'lowmedium' and 'mediumhigh'.\n‘mini.indentscope’ now is:\n\nMore responsive on huge (10K+) scopes via introducing n_lines option that limits the scope computation.\nMore customizable via draw.predicate, which can be used to decide when a scope is drawn.\n\n‘mini.pick’ got substantial updates:\n\ngrep and grep_live pickers now allow globs to limit search in particular globs. There is also a new built-in &lt;C-o&gt; mapping to add a single glob pattern.\nPicker window now sets window-local working directory (the one that is printed with :pwd) to picker’s working directory for a more correct processing when picker’s cwd differs from a Neovim’s one.\nA new MiniPickMatch event allows customizing picker on every query match update (like customizing height to only fit matches).\n\nAnd more.\n\n\nThanks for the continued support of ‘mini.nvim’ project! We are past 6.4K stars now ❤️\nHope to see you soon with new and exciting updates!"
  },
  {
    "objectID": "blog/2023-04-16-announce-mini-colors.html",
    "href": "blog/2023-04-16-announce-mini-colors.html",
    "title": "Announcing ‘mini.colors’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI would like to announce a release of mini.colors - new module of mini.nvim to tweak and save any color scheme. It can also be installed using separate GitHub repository.\nThis module is a combined result of a deep dive into color theory (which lead to a discovery of the beautiful Oklab color space) and my desire to create a tool with which users can tweak any color scheme to fit their taste.\nFor example, have you ever wondered how would warm Tokyonight look? With ‘mini.colors’ you are one chan_invert('temperature') call away. And here is the result, if anyone is curious:\n\n\n\nWarm tokyonight\n\n\nOr have you ever wanted to make animated transition between color schemes? Replace :colorscheme command with :Colorscheme and you are good to go!\nHere are the features of ‘mini.colors’:\n\nCreate colorscheme object: either manually or by querying present color schemes (including currently active one).\nInfer data about color scheme and/or modify based on it:\n\nAdd transparency by removing background color (requires transparency in terminal emulator).\nInfer cterm attributes based on gui colors making it compatible with ‘notermguicolors’.\nResolve highlight group links.\nCompress by removing redundant highlight groups.\nExtract palette of used colors and/or infer terminal colors based on it.\n\nModify colors to better fit your taste and/or goals:\n\nApply any function to color hex string.\nUpdate channels (like lightness, saturation, hue, temperature, red, green, blue, etc.). Use either own function or one of the implemented methods:\n\nAdd value to channel or multiply it by coefficient. Like “add 10 to saturation of every color” or “multiply saturation by 2” to make colors more saturated (less gray).\nInvert. Like “invert lightness” to convert between dark/light theme.\nSet to one or more values (picks closest to current one). Like “set to one or two hues” to make mono- or dichromatic color scheme.\nRepel from certain source(s) with stronger effect for closer values. Like “repel from hue 30” to remove red color from color scheme. Repel hue (how much is removed) is configurable.\n\nSimulate color vision deficiency.\n\nOnce color scheme is ready, either apply it to see effects right away or write it into a Lua file as a fully functioning separate color scheme.\nExperiment interactively with a feedback.\nAnimate transition between color schemes either with MiniColors.animate() or with :Colorscheme user command.\nConvert within supported color spaces (MiniColors.convert()):\n\nHex string.\n8-bit number (terminal colors).\nRGB.\nOklab, Oklch, Okhsl.\n\n\nFor a more hands-on learners there are “Tweak quick start” (essentially reproducing demo) and recipes for some common tasks.\nFor more information, see help file.\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-10-11-announce-mini-map.html",
    "href": "blog/2022-10-11-announce-mini-map.html",
    "title": "Announcing ‘mini.map’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am here to announce a mini.map - new module of mini.nvim for showing buffer text overview with scrollbar and highlights. It is shown in automatically updated full-height floating window stuck to either side (left or right).\nPrior to writing this, I didn’t use any “buffer overview” plugins. I accidentally happened to see a wfxr/minimap.vim plugin, which uses Rust dependency to render text overview. This made me really curious if I could implement similar functionality in Lua with at least comparable speed. Turned out, I could! Benchmarking ‘mini.map’ and ‘wfxr/minimap.vim’ for first map window opening on ‘builtin.txt’ help page (9338 lines) shows around 70-90 milliseconds of computation time. Both are much faster on smaller files, of course.\n‘mini.map’ has the following features:\n\nUpdates are really fast and asynchronous (non-blocking).\nShow scrollbar next to map content. It represents current line and view (top and bottom visible lines). Can be the only thing shown, making map window a “pure scrollbar”.\nHighlight map lines representing certain data in current buffer. This is done via extensible set of callables, called integrations. There are pre-built generators for common integrations:\n\nBuiltin search.\nBuiltin diagnostic.\nGit line status (requires lewis6991/gitsigns.nvim).\n\nFocus on map window to quickly browse current (source) buffer. Moving inside map window updates cursor position in source window enabling fast and targeted buffer exploration. To focus back, hit &lt;CR&gt; to accept current explored position or &lt;Esc&gt; to go back to original position.\nCustomizable:\n\nEncoding symbols used to display binary information of different resolution (default is 3x2). There are pre-built generators for different basic character families and resolutions (block, dot, shade).\nScrollbar symbols, separate for line and view. Can have any width (even zero, which virtually disables scrollbar).\nIntegrations producing map line highlights.\nWindow options: side (left/right), width, ‘winblend’, and more.\n\n\nFor more information, see help file. Here is a comparison to other similar plugins.\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue. Thanks!"
  },
  {
    "objectID": "blog/2023-02-21-announce-mini-bracketed.html",
    "href": "blog/2023-02-21-announce-mini-bracketed.html",
    "title": "Announcing ‘mini.bracketed’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nLet me present you mini.bracketed - new module of mini.nvim for going forward/backward with square brackets. It can also be installed using separate GitHub repository.\nInitially I planned to make a Neovim take on ‘tpope/vim-unimpaired’ as a part of mini.basics module, but got a bit carried away with features. General idea is to have [ / ] mappings (along with Lua functions) which iterate to next/previous/first/last element of certain kind. Judging by experience, mastering this type of mappings leads to a huge productivity boost (or at least feels like it :) ).\nMain features:\n\nConfigurable Lua functions to go forward/backward to a certain target. Each function can be customized with direction, number of times, whether to wrap on edges, etc.\nMappings using square brackets. They are created using configurable target suffix and can be selectively disabled.\nSupported targets (for more information see help for corresponding Lua function):\n\n\n\nTarget\nMappings\nLua function\n\n\n\n\nBuffer\n[B [b ]b ]B\nMiniBracketed.buffer()\n\n\nComment\n[C [c ]c ]C\nMiniBracketed.comment()\n\n\nConflict\n[X [x ]x ]X\nMiniBracketed.conflict()\n\n\nDiagnostic\n[D [d ]d ]D\nMiniBracketed.diagnostic()\n\n\nFile on disk\n[F [f ]f ]F\nMiniBracketed.file()\n\n\nIndent\n[I [i ]i ]I\nMiniBracketed.indent()\n\n\nJump\n[J [j ]j ]J\nMiniBracketed.jump()\n\n\nLocation\n[L [l ]l ]L\nMiniBracketed.location()\n\n\nOld files\n[O [o ]o ]O\nMiniBracketed.oldfile()\n\n\nQuickfix\n[Q [q ]q ]Q\nMiniBracketed.quickfix()\n\n\nTree-sitter\n[T [t ]t ]T\nMiniBracketed.treesitter()\n\n\nUndo states\n[U [u ]u ]U\nMiniBracketed.undo()\n\n\nWindow\n[W [w ]w ]W\nMiniBracketed.window()\n\n\nYank\n[Y [y ]y ]Y\nMiniBracketed.yank()\n\n\n\n\nFor more information, see help file.\nBesides some obvious ones (buffer, location, quickfix, window, etc.), I am especially excited about the following targets:\n\noldfile - old files from previous and current sessions ordered by recency.\ntreesitter - move to start/end of current node and its parents.\nundo - undo to the previous visited undo state; see demo.\nyank - replace previous paste region with yank history, a.k.a. yank-ring targets.\n\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-07-01-announce-mini-test.html",
    "href": "blog/2022-07-01-announce-mini-test.html",
    "title": "Announcing ‘mini.test’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am thrilled to announce mini.test - module of mini.nvim with framework for writing extensive Neovim plugin tests. It is very feature-rich, which makes me both proud and not proud. It took me too long to implement everything I wanted to see in testing framework and the outcome is too big for my taste (it is ~80% larger by line count than the next largest module). But… it is awesome.\nIt has:\n\nHierarchical organization of tests with custom hooks, parametrization, and user data.\nPredefined small yet usable set of expectations (assert-like functions).\nHelper for creating child Neovim process which is designed to be used in tests. It has helpers for using it directly (like child.o.lines returns vim.o.lines executed inside child process, etc.). It can also create a screenshot of current state. Together with dedicated expectation it makes quite easy testing visual effects (like highlighting, extmarks, etc.).\nEmulation of ‘Olivine-Labs/busted’ interface (describe, it, etc.).\nTest case filtering. There are predefined wrappers for testing a file and case at a location like current cursor position.\nCustomizable reporter of output results. There are two predefined ones: for interactive usage and for headless Neovim (like from command line or continuous integration services).\nAnd more.\n\nSources for more information:\n\n‘mini.test’ section of help file.\nTESTING.md for a hands-on introduction based on examples.\nTests of ‘mini.nvim’.\n\nWith release of this module I hope to finally fully pay this plugin’s technical debt. Previously it had no tests which slowed down bug fixes and feature implementations. Now, judging by size, it has three times bigger tests than actual code (granted, most of it is screenshots). Now I hope to work on more tightly focused modules.\nNeovim plugin authors, try it and tell me what you think. Either here, in dedicated issue, or in Discussions. Thanks!"
  },
  {
    "objectID": "blog/2024-09-26-release-0140.html",
    "href": "blog/2024-09-26-release-0140.html",
    "title": "Release 0.14.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nToday is the day for yet another stable release of mini.nvim, now version 0.14.0 (they grow up so fast). Here is a full release description if you are curious.\n\nThis release marks only a single module coming out of beta-testing:\n\nmini.icons - a general icons provider. It is meant to be a more versatile ‘nvim-tree/nvim-web-devicons’ replacement which relies on built-in vim.filetype.match() for a more fine-grained icon detection rules and which implements highlight group design with easier blending for any color scheme. You can also read this release post.\n\nThis module came with a lot of extra burden:\n\nSwitch existing modules which rely on ‘nvim-web-devicons’ to prefer ‘mini.icons’ instead. Those are ‘mini.files’, ‘mini.pick’, ‘mini.statusline’, ‘mini.tabline’.\nUpdate popular color schemes to define ‘mini.icons’ highlight groups for a better “out of the box” experience for most users.\nMake changes to Neovim itself for a faster vim.filetype.match(). Unfortunately, this took a lot of mental effort to both get right and debate with core maintainers that it is even worth merging.\n\n\nThe rest of release cycle I decided to dedicate to clean up feature backlog and do overall maintenance. As a result, a lot of existing plugins got new and exciting features. Here are the highlights:\n\n‘mini.files’ got the most attention: bookmarks, better file manipulation, and more. Here is a separate post about it.\n‘mini.completion’ now also integrates with ‘mini.icons’:\n\nIt can show icons near LSP item kind (like “Function”, “Class”, etc.) after an indirect call to MiniIcons.tweak_lsp_kind().\nIt can highlight LSP item kind. Requires set up ‘mini.icons’ and Neovim&gt;=0.11 (current Nightly).\n\n‘mini.misc’ got new setup_termbg_sync() function which can set up terminal background synchronization to remove possible “frame” around current Neovim instance. Or you can use advice from this post.\n‘mini.pick’ now uses full height character “│” instead of previous “:” to separate file name, line, column, and text. The full change is slightly more complicated, though, so see changelog.\nMany pickers from ‘mini.extra’ now also integrate ‘mini.icons’: both for file and LSP kind.\n‘mini.test’ now can work on Windows. All that was missing was essentially a one line change in how pipe is created. Huge thanks to @cameronr for this PR.\nAnd many more.\n\n\nOverall maintenance also was fruitful:\n\nHelp pages now use Neovim-specific way of highlighting code blocks.\nThanks to ‘mini.test’ PR, I was finally able to set up CI tests for Windows (and also decided to add MacOS). Updating tests themselves required a gruesome amount of tedious effort (as I don’t have local access to any of those OSs), but it was worth it.\nAll modules now uniformly ensure that their highlight groups are defined for any color scheme. It was not the case previously as usually the :colorscheme ... call clears all highlight groups before defining its own and ‘mini.nvim’ did not account for that.\n\n\nThanks for expressing an ever growing interest in ‘mini.nvim’ project!\nHope to see you soon with some exciting updates!"
  },
  {
    "objectID": "blog/2021-11-16-update-mini-nvim-new-modules.html",
    "href": "blog/2021-11-16-update-mini-nvim-new-modules.html",
    "title": "Updates of ‘mini.nvim’",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nThis is a post about updates to my mini.nvim plugin with some changes after previous post.\nI decided to adopt two branch approach with main (default) having latest development version of plugin and stable updating only upon releases after public beta-testing. After reacting to a handful of useful feedback there was a 0.1.0 release. Before making 0.2.0 I need your help in beta-testing some big updates (especially if you use Windows). Their general design is mostly stable, but I would like to hear your feedback about undesired behavior (a.k.a bugs), naming (are configuration and function names intuitive), default values (are they convenient), and documentation (is it clear enough).\nNew modules:\n\nmini.sessions is a module for session management (read, write, delete) which works using builtin mksession. It was heavily inspired by ‘vim-startify’ and should work out of the box with sessions created by it (only provide path to where it stored them). Names of main functions are different from ‘vim-startify’ on purpose as I think they are more appropriate when it comes to managing session files.\nmini.starter is a minimal, fast, and flexible start screen which I am really excited about. Displayed items are fully customizable both in terms of what they do and how they look (with reasonable defaults). Item selection can be done using prefix query with instant visual feedback. Has example configurations similar to ‘vim-startify’ and ‘dashboard-nvim’. I also made some benchmarks testing its effect on overall startup time (along with alternative plugins).\nmini.jump is a module for smarter jumping to a single character (something like clever-f.vim). Initial idea and implementation by Adam Blažek.\n\nExisting modules:\n\nmini.pairs got an update for a more user-friendly custom mappings. Now they can be done inside setup() call and can be automatically registered for &lt;BS&gt; and &lt;CR&gt; keys.\n\nFeel free to drop your feedback in comments here or in dedicated GitHub issues (sessions, starter, jump). If you end up adopting new modules right away, please keep in mind that there might be a slight turbulence as a result of this public beta-testing (which I hope will stop after 0.2.0 release planned in a couple of weeks).\nThanks!"
  },
  {
    "objectID": "blog/2024-12-23-announce-mini-snippets.html",
    "href": "blog/2024-12-23-announce-mini-snippets.html",
    "title": "Announcing ‘mini.snippets’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nLet’s celebrate passed December solstice with the long overdue release of mini.snippets - new module of mini.nvim that can manage and expand snippets. It can also be installed using separate GitHub repository.\n\nSnippets are a vital part of my editing workflow. That’s why I wanted to have ‘mini.snippets’ for about 3 years now. My initial plan was to wait and utilize snippet expansion capabilities in core and implement only snippet management (find/load/match/etc). And indeed, when vim.snippet became a thing in 0.10 back in May I used it together with some small set of commonly used snippets.\nDue to time consuming development of ‘mini.icons’ and cleaning ‘mini.nvim’ feature backlog, I started ‘mini.snippets’ mid-September. It proved to be outstandingly long development period for various reasons: both external and internal. Some of them are:\n\nDesire to make things “right”: robust yet flexible, out-of-the-box yet customizable. There were many iterations of back and forth, which were as late as several days ago. Eventually it converged into something, let’s hope it is enough.\nAlthough very capable already, some decisions about vim.snippet direction proved to not sit well with me (not wanting to add dedicated events and forcing &lt;Tab&gt;/&lt;S-Tab&gt; overrides are the main ones). It resulted in a long internal debate about whether having own snippet parsing and interactive session is worth it. The fact that I needed to interact with LSP specification (which I am not very good at) made own implementation even less compelling.\nIn the end I managed to come up with several distinctive snippet session features that I realized I wanted to have for a long time: no Select mode mappings (extra complexity and visually not adjustable), dynamic highlighting, ability to not stop session immediately at final tabstop, etc. That eventually got me nerd-sniped (by myself, mind you) into deciding to take it on.\nSnippet LSP specification is compact, but at the same time allows a lot of weird cases which need to be accounted for (mostly because of nested placeholders and linked tabstops). Finding and addressing them also took many sleepless nights.\nPlus all the tests and documentation… a lot of tests and documentation.\n\nBut the main thing is that ‘mini.snippets’ is out and it is good. This should take a bit of weight out of my shoulders.\nNext thing (after a bit of backlog cleanup) is to add another long overdue feature: snippet support in ‘mini.completion’. As it also requires LSP related work, it might take a while (again).\n\nFeatures:\n\nManage snippet collection by adding it explicitly or with a flexible set of performant built-in loaders. See MiniSnippets.gen_loader.\nConfigured snippets are efficiently resolved before every expand based on current local context. This, for example, allows using different snippets in different local tree-sitter languages (like in markdown code blocks). See MiniSnippets.default_prepare().\nMatch which snippet to insert based on the currently typed text. Supports both exact and fuzzy matching. See MiniSnippets.default_match().\nSelect from several matched snippets via vim.ui.select(). See MiniSnippets.default_select().\nInsert, jump, and edit during snippet session in a configurable manner:\n\nConfigurable mappings for jumping and stopping.\nJumping wraps around the tabstops for easier navigation.\nEasy to reason rules for when session automatically stops.\nText synchronization of linked tabstops.\nDynamic tabstop state visualization (current/visited/unvisited, etc.)\nInline visualization of empty tabstops (requires Neovim&gt;=0.10).\nWorks inside comments by preserving comment leader on new lines.\nSupports nested sessions (expand snippet while there is an one active).\n\nSee MiniSnippets.default_insert().\nExported function to parse snippet body into easy-to-reason data structure. See MiniSnippets.parse().\n\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2023-11-28-announce-mini-visits.html",
    "href": "blog/2023-11-28-announce-mini-visits.html",
    "title": "Announcing ‘mini.visits’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nIt is my pleasure to bring you mini.visits - new module of mini.nvim which can track and reuse file system visits. It can also be installed using separate GitHub repository.\nNote: This demo uses custom vim.ui.select() from mini.pick.\n\nTL;DR: This is a ‘mini.nvim’ version of a combination of nvim-telescope/telescope-frecency.nvim (persistently track file visits and select from them) and ThePrimeagen/harpoon (persistently add/remove labels to paths and select based on them).\nBut there is no feature parity with any of them (and is not planned), as the overall design and assumed workflows are slightly different. Here is a link to a more detailed comparisons.\n\nFeatures:\n\nPersistently track file system visits (both files and directories) per project directory. Store visit index is human readable and editable.\nVisit index is normalized on every write to contain relevant information. Exact details can be customized.\nBuilt-in ability to persistently use label paths for later use.\nExported functions to reuse visit data:\n\nList visited paths/labels with custom filter and sort (uses “robust frecency” by default). Can be used as source for pickers.\nSelect visited paths/labels using vim.ui.select().\nIterate through visit paths in target direction (“forward”, “backward”, “first”, “last”).\n\nExported functions to manually update visit index allowing persistent track of any user information.\n\nFor more information, see these tags in help file:\n\n*MiniVisits-overview*\n*MiniVisits-index-specification*\n*MiniVisits-examples*\n\nFor full documentation see help file.\n\nThere are also two new ‘mini.pick’ pickers for mini.extra: visit_paths() and visit_labels(). These are essentially a slightly polished alternatives (with file icons, preview, etc.) to built-in pickers which use vim.ui.select().\n\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2023-01-15-announce-mini-move.html",
    "href": "blog/2023-01-15-announce-mini-move.html",
    "title": "Announcing ‘mini.move’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nLet me introduce you to mini.move - new module of mini.nvim which adds ability to move current visual selection or current line in all four directions (left, right, down, up). It can also be installed using separate GitHub repository.\nTo be perfectly honest, I didn’t plan to write this module, as most of its functionality can be replicated using basic Vim actions. But while doing research for another upcoming module, I stumbled upon this kind of functionality in a form of simple mappings. It worked only for vertical movement in Visual mode and had several “quality of life” drawbacks (lack of v:count support, handling of undo, etc.). So of course it got me thinking if I can make it better without much complications (there are plugins with this functionality already, but their implementation feels disproportionally complex). Several couples of days later we got this module and I can appreciate visual feedback of this movement approach :)\nMain features:\n\nWorks in two modes:\n\nVisual mode. Select text (charwise with v, linewise with V, and blockwise with CTRL-V) and press customizable mapping to move in all four directions (left, right, down, up). It keeps Visual mode.\nNormal mode. Press customizable mapping to move current line in all four directions (left, right, down, up).\nVertical linewise movement gets reindented with =. Horizontal linewise movement is same as indent with &gt; and dedent with &lt;.\n\nProvides both mappings and Lua functions for motions.\nRespects v:count. Movement mappings can be preceded by a number which multiplies command effect.\nAll consecutive moves (regardless of direction) can be undone by a single u.\nRespects preferred column for vertical movement. It will vertically move selection as how cursor is moving (not strictly vertically if target column is not present in target line).\n\nFor more information, see help file.\nPlease, check it out and tell me what you think! Either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2025-05-20-release-0160.html",
    "href": "blog/2025-05-20-release-0160.html",
    "title": "Release 0.16.0",
    "section": "",
    "text": "Originally posted on Reddit\nHello, Neovim users!\nThe mini.nvim plugin has released a new 0.16.0 version. The previous release was about 4 months and 250 commits ago, so it felt like the right time. Here is a full release description if you are curious.\n\nThere is only one new module, but it fixes some common issues when it comes to mappings:\n\nmini.keymap - Special key mappings. It has two main features: multi-step actions (like “smart” tab, shift-tab, enter, backspace) and combos (more general “better escape” like behavior). You can read more in this release post.\n\n\nThe main attention in this release cycle went towards revamping ‘mini.completion’ with long overdue features like snippet support (made fully possible after release of ‘mini.snippets’), better highlighting and scroll support in info/signature windows, overall more proper coverage of LSP capabilities, and various quality of life improvements. There was a release post, but full changelog is here (there were new changes after the post).\n\nA lot of effort was put into unifying certain behavior across all modules:\n\nHow floating windows are displayed: better titles, ‘single’ border by default but respecting new ‘winborder’ options, etc.\nNaming scheme for special module-specific buffers, which makes buffer list and some custom actions clearer.\nStop handling general options behind set_vim_settings config value in favor of setting them automatically if they were not already set by the user.\n\n\nVarious plugins got small and not so much updates. Here are some of them:\n\n‘mini.ai’ and ‘mini.surround’ got better support of tree-sitter captures and non-latin textobject/surrounding identifiers.\n‘mini.diff’ got the ability to set array of sources to attempt to attach them one at a time. This allows having setup like “try attach Git source, but fall back to custom Mercurial source” (there might be built-in sources for other VCS in the future).\n‘mini.operators’ now remaps built-in gx (open URL under cursor) to gX if the exchange operator is about to override it.\n‘mini.pairs’ now support multibyte characters in pairs.\n‘mini.pick’ now has more highlighting customizations of prompt and better scripting capabilities for setting current and marked matches.\n‘mini.snippets’ has start_lsp_server() that starts an in-process LSP server that provides completion suggestions from snippets loaded via ‘mini.snippets’. This integrates well with ‘mini.completion’.\n‘mini.tabline’ now shows special truncation symbols on left and/or right if there are more text to the left/right.\n\n\nThanks for the continued support of ‘mini.nvim’ project! We are past 7.2K stars now 🌟❤️ I still have a lot of ideas I want to add to ‘mini.nvim’ to make it even better. I also plan to spend some time implementing several important features in upstream Neovim. So stay tuned!\nHope to see you soon with new and exciting updates!"
  },
  {
    "objectID": "blog/2025-07-10-announce-new-colorschemes.html",
    "href": "blog/2025-07-10-announce-new-colorschemes.html",
    "title": "New color schemes",
    "section": "",
    "text": "Originally posted on Reddit\n\n\n\nminiautumn dark\n\n\n\n\n\nminiautumn light\n\n\n\n\n\nminispring dark\n\n\n\n\n\nminispring light\n\n\n\n\n\nminisummer dark\n\n\n\n\n\nminisummer light\n\n\n\n\n\nminiwinter dark\n\n\n\n\n\nminiwinter light\n\n\nHello, Neovim users!\nFor quite some time I wanted to have more ‘mini.hues’ based color schemes as part of ‘mini.nvim’. There is randomhue (each time randomly generated color scheme), but having something “fixed” is useful for demos and new user experience in general.\nThis coincided with the fact that for even longer time I was curious why there is no “time of year” inspired set of color schemes. So about 9 months ago I started working on it and daily driving each (dark variant) of them.\nAnd I think it is finally time to release them. So please welcome:\n\nminiwinter: “icy winter” palette with azure background.\nminispring: “blooming spring” palette with green background.\nminisummer: “hot summer” palette with brown/yellow background.\nminiautumn: “cooling autumn” palette with purple background.\n\nI personally enjoy miniwinter the most: I generally tend to like azure/blue backgrounds and yellowy/ivory foregrounds. And light variants of either minispring or minisummer look like genuinely usable light color schemes (which is rather rare).\nPlease, check them out and tell me what you think! They now (on latest main) come bundled with ‘mini.nvim’ or standalone ‘mini.hues’ repository.\nObligatory notes:\n\nThe font is a very customized Iosevka build inspired by “Input Mono” font.\n\nThanks!"
  },
  {
    "objectID": "blog/2024-07-03-announce-mini-icons.html",
    "href": "blog/2024-07-03-announce-mini-icons.html",
    "title": "Announcing ‘mini.icons’",
    "section": "",
    "text": "Originally posted on Reddit\n\n\n\nDefault “glyph” style and dark color scheme\n\n\n\n\n\nDefault “glyph” style and light color scheme\n\n\n\n\n\nFallback “ascii” style\n\n\nHello, Neovim users!\nLet us rejoice at the release of mini.icons - new module of mini.nvim intended to be a general icon provider. It can also be installed using separate GitHub repository.\n\nAs recent releases of ‘mini.diff’ and ‘mini.git’ allowed ‘mini.statusline’ to require one less external dependency (‘lewis6991/gitsigns.nvim’), I’ve got curious if ‘nvim-tree/nvim-web-devicons’ replacement can be fit in ‘mini.nvim’ design. Having custom solution for icons would benefit at least four modules (and probably more), so it seemed worth it. In the end, I found the approach that works for me and is based on several ideas:\n\nHave the same “one main function to get icon and its highlight group” idea as ‘nvim-web-devicons’, but be more flexible and future proof. It explicitly requires category (like “file”, “extension”, “directory”, etc.) and icon names (while ‘nvim-web-devicons’ mostly has only “file”, “extension”, and “filetype”).\nFollow an already established route in ‘mini.nvim’ and provide a fixed set of highlight groups which are used in the module. This allows better color scheme integration (both out of the box and inside color scheme) and easier bulk customization.\nProvide fallback for users which can not use Nerd Fonts glyphs but still want their Neovim experience to be as beautiful as possible. This is achieved with config.style = 'ascii' setting (see screenshots).\n\n\nAlthough the actual code logic is comparatively small, the major time consuming hurdles with ‘mini.icons’ were around it:\n\nCompile common cases to explicitly support for various categories. The most effort needed to be put in ‘filetype’ support, as it is used as a fallback for richer Neovim integration. The current count of supported filetypes is a whopping 780!\nGo through each icon to actually assign Nerd Fonts glyph and highlighting. It was monotonous but fun experience.\nMake PRs to popular Neovim color schemes for you to have a better out of the box experience right after ‘mini.icons’ release. Ended up with 16 PRs!\nUpdate relevant modules to prefer ‘mini.icons’ instead of ‘nvim-web-devicons’ (in backwards compatible way, of course). So now all ‘mini.statusline’, ‘mini.tabline’, ‘mini.files’, and ‘mini.pick’ use ‘mini.icons’ (if it is set up).\n\n\nFeatures:\n\nProvide icons with their highlighting via a single MiniIcons.get() for various categories: filetype, file/directory path, extension, operating system, LSP kind values. Icons and category defaults can be overridden.\nConfigurable styles: “glyph” (icon glyphs) or “ascii” (non-glyph fallback).\nFixed set of highlight groups (linked to built-in groups by default) for better blend with color scheme.\nCaching for maximum performance.\nIntegration with vim.filetype.add() and vim.filetype.match().\nMocking methods of ‘nvim-tree/nvim-web-devicons’ for better integrations with plugins outside ‘mini.nvim’. See MiniIcons.mock_nvim_web_devicons().\n\n\nI sincerely hope that you give ‘mini.icons’ a try. With its final result, I think it is a better alternative to ‘nvim-web-devicons’; both for end users and plugin authors. Here are the more detailed comparisons for users and for plugin authors. Besides, as a user you can add MiniIcons.mock_nvim_web_devicons() to your config and it should work with other plugins which support only ‘nvim-web-devicons’ (yet).\nPlease, check it out and tell me what you think! You can leave your suggestions either here in comments or in dedicated beta-testing issue.\nThanks!"
  },
  {
    "objectID": "blog/2022-07-28-announce-mini-ai.html",
    "href": "blog/2022-07-28-announce-mini-ai.html",
    "title": "Announcing ‘mini.ai’",
    "section": "",
    "text": "Originally posted on Reddit\n\nHello, Neovim users!\nI am incredibly happy to announce mini.ai - module #20 of mini.nvim for extending and creating a/i textobjects (like in di( or va\"). It enhances some builtin textobjects (like a(, a), a', and more), creates new ones (like a*, a&lt;Space&gt;, af, a?, and more), and allows user to create their own.\nFeatures:\n\nCustomizable creation of a/i textobjects using Lua patterns and functions. Supports:\n\nDot-repeat.\nv:count.\nDifferent search methods (cover, cover_or_next, cover_or_prev, cover_or_nearest). Edit: now there is also next, prev (power an/in/al/il textobjects), and nearest.\nConsecutive application (update selection without leaving Visual mode).\nAliases for multiple textobjects.\n\nComprehensive builtin textobjects (they are shown in video):\n\nBalanced brackets (with and without whitespace) plus alias.\nBalanced quotes plus alias.\nDerived from user prompt.\nTag.\nFunction call.\nArgument.\nDefault for punctuation, digit, or whitespace single character.\n\nMotions for jumping to left/right edge of textobject.\nAs a part of all ‘mini.nvim’ modules’ functionality, runtime configuration settings can be set locally to a buffer. This leads to ability of defining custom textobjects only for certain conditions (like per filetype).\n\nMore information can be found in help file. Here are some examples of which textobjects can be defined with ‘mini.ai’.\nThis was the first module request I got for ‘mini.nvim’, and I happy to finally implement it. Initially I planned this to have the same “backend” as mini.surround. But then I got an idea about slight change in textobject definition and algorithm, which enabled many more powerful textobjects (like aliases, etc.). After ‘mini.ai’ is publicly beta-tested, I plan to move its logic to ‘mini.surround’ (which will lead to some graceful soft deprecation of current custom textobject definition).\nTry it out and tell me your thoughts! Either here or in dedicated beta-testing issue. I am especially interested in your thoughts about default textobjects (more info in beta-testing issue).\nAlso simply sharing information about ‘mini.nvim’ plugin is a huge help. Thanks!"
  },
  {
    "objectID": "MiniMax/CHANGELOG.html",
    "href": "MiniMax/CHANGELOG.html",
    "title": "MINI",
    "section": "",
    "text": "Generated from the main branch of ‘MiniMax’"
  },
  {
    "objectID": "MiniMax/CHANGELOG.html#2025-12-16",
    "href": "MiniMax/CHANGELOG.html#2025-12-16",
    "title": "MINI",
    "section": "2025-12-16",
    "text": "2025-12-16\n\nUpdate ‘nvim-treesitter/nvim-treesitter’ plugin to not explicitly use main branch as it is now the default.\nUpdate ‘mason-org/mason.nvim’ example to use now_if_args instead of later. Otherwise LSP server installed via Mason will not yet be available if Neovim is started as nvim -- path/to/file."
  },
  {
    "objectID": "MiniMax/CHANGELOG.html#2025-11-22",
    "href": "MiniMax/CHANGELOG.html#2025-11-22",
    "title": "MINI",
    "section": "2025-11-22",
    "text": "2025-11-22\n\nUpdate &lt;Leader&gt;fs mapping to use \"workspace_symbol_live\" scope for :Pick lsp instead of \"workspace_symbol\""
  },
  {
    "objectID": "MiniMax/CHANGELOG.html#2025-10-16",
    "href": "MiniMax/CHANGELOG.html#2025-10-16",
    "title": "MINI",
    "section": "2025-10-16",
    "text": "2025-10-16\n\nMove now_if_args startup helper to ‘init.lua’ as _G.Config.now_if_args to be directly usable from other config files.\nEnable ‘mini.misc’ behind now_if_args instead of now. Otherwise setup_auto_root() and setup_restore_cursor() don’t work on initial file(s) if Neovim is started as nvim -- path/to/file."
  },
  {
    "objectID": "MiniMax/CHANGELOG.html#2025-10-13",
    "href": "MiniMax/CHANGELOG.html#2025-10-13",
    "title": "MINI",
    "section": "2025-10-13",
    "text": "2025-10-13\n\nInitial release."
  },
  {
    "objectID": "MiniMax/configs/index.html",
    "href": "MiniMax/configs/index.html",
    "title": "MiniMax configs",
    "section": "",
    "text": "Generated from the main branch of ‘MiniMax’"
  },
  {
    "objectID": "MiniMax/configs/index.html#minimax-configs",
    "href": "MiniMax/configs/index.html#minimax-configs",
    "title": "MiniMax configs",
    "section": "MiniMax configs",
    "text": "MiniMax configs\nAvailable:\n\nnvim-0.11 - for Neovim&gt;=0.11\n\nPlanned (after small time of ‘nvim-0.11’ public testing):\n\nnvim-0.9 - for Neovim&gt;=0.9\nnvim-0.10 - for Neovim&gt;=0.10\nnvim-0.12 - for Neovim&gt;=0.12\n\n\nStructure\n\ninit.lua\nInitial file executed first during startup.\n\n\nplugin/\nFiles automatically executed in alphabetical order during startup:\n\n10_options.lua - built-in Neovim behavior.\n20_keymaps.lua - custom mappings, mostly for the :h &lt;Leader&gt; key.\n30_mini.lua - MINI configuration.\n40_plugins.lua - plugins outside of MINI.\n\n\n\n\n\n\n\nNote\n\n\n\nMany configurations prefer to use the ‘lua/’ directory with explicit require() calls to modularize their config. It is okay to use, but has a drawback that it occupies ‘lua’ namespace. As it is shared across all plugins, it might lead to conflicts during require(). Usually solved by having config files inside a dedicated “user” directory like ‘lua/username’.\nThe ‘plugin/’ approach doesn’t have this issue. It also doesn’t need explicit require() calls inside ‘init.lua’ for files to be executed.\n\n\n\n\n\n\n\n\nTip\n\n\n\nFor more details about this approach, see :h load-plugins. In particular: - Subdirectories are allowed. Their files are also sourced in alphabetical order. - ‘plugin/’ files still get executed if Neovim is started with nvim -u path/to/file. Make sure to also pass --noplugin or use :h $NVIM_APPNAME approach.\n\n\n\n\nsnippets/\nUser defined snippets. Contains a single ‘global.json’ file as a demo (used in the ‘mini.snippets’ setup).\n\n\nafter/\nFiles for overriding behavior added by plugins. Usually located inside special subdirectories like ‘ftplugin/’ (see :h 'runtimepath'). Files from this directory take effect after similar files provided by plugins.\nFor demonstration purposes, it contains examples of common ways to use ‘after/’.\n\nafter/ftplugin/\nFiletype plugins. Contains files that are sourced when :h 'filetype' option is set.\nFor example, ‘*.txt’ files have text filetype, so ‘ftplugin/text.lua’ is sourced when ‘*.txt’ file is opened. It defines behavior that should exist only in text files.\n\n\nafter/lsp/ (for Neovim&gt;=0.11)\nFiles that configure LSP servers. These are used by Neovim’s built-in :h vim.lsp.config() and :h vim.lsp.enable(). See also :h lsp-quickstart for more details.\nFor example, the ‘lsp/lua_ls.lua’ file defines part of configuration that will be used during vim.lsp.enable({ 'lua_ls' }) (i.e. with the same name).\n\n\nafter/snippets/\nFiles containing snippet definition per language. Used by ‘mini.snippets’. As they are located in ‘after/’, they override any snippets provided by plugins (like ‘rafamadriz/friendly-snippets’).\nFor example, based on ‘snippets/lua.json’, typing l + &lt;C-j&gt; in Insert mode inside Lua files will always insert local $1 = $0 snippet. No matter if any other snippet provider contains this or conflicting snippet."
  }
]